#include "G_Object.h"
#include "M3Da.h"
#include "GLOBAL_VARS.h"
#include <iostream>
#include <sstream>
#include <fstream>
// #include <windows.h>
using namespace std;
// START OF GLOBAL VARIABLES - TRYING THIS OUT 22/09/2023
//**************Symbols table are GLOBAL scope**************
Symbol* pSymTable[MAX_SYMBOLS];
int iNoSymbols = 0;
double dAveW = 1;
double dAveH = 1;
//*********************************************************
bool gDOUBLEBUFF = true;
double gDIM_SCALE = 1.0;
double gZOOM_SCL = 1.0;
double gPT_SIZE = 10;
double gND_SIZE = 10;
double gLM_SIZE = 20;
double gEL_SIZE = 2;
double gED_SIZE = 5;
double gFC_SIZE = 3;
double gWP_SIZE = 12;
double gBM_SIZE = 2;
double gTXT_SIZE = 2;
int gDIM_PREC = 2;
double gDIM_SIZE = 0.5;
double gDRILL_KS = 1.0;
double gRIGID_MULTIPLIER = 10000.0;
double gVSTIFF_KS = 1.0e10; // Big K value for restraints
double gDEF_E = 70.0e9; // defualt material youngs mod
double gDEF_V = 0.33; // Poisson ratio
double gDEF_DEN = 2750.0;
double gDEF_COND = 237.0;
double gSTIFF_BDIA = 0.1; // stiff beam dia used for out psuedo RBE2
double gDEF_CTE = 23.0e-6;
double gDEF_THERM_LNK = 1.0e9;
double gDEF_SOL_TOL = 1e-9;
// Esp_Mod_Labels_4_27_2025_Start: Defined initial
bool gLBL_DSP_TRG = false;
// Esp_Mod_Labels_4_27_2025_End
// END OF GLOBAL VARS
#define D2R 0.01745329251994
#define R2D 57.2957795130931
const double Pi = 3.1415926535;
const double dTol = 0.00000001; // unsed for Surface tolerance
// Constant Related to Auto-Meshing
CONST double PARA_NEAR_ZERO = 0.000001;
CONST double PARA_MAX_ERROR = 0.0001;
const int ISO_TEST_INC = 10;

// #include "math.h"
#include <cmath>

#pragma warning(disable : 4477)
#pragma warning(disable : 4244)
#pragma warning(disable : 4474)

GLubyte BMPX[13] = {0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3};
GLubyte BMPY[13] = {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3};
GLubyte BMPZ[13] = {0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff};
GLubyte BMPT[13] = {0x00, 0x00, 0x18, 0x24, 0x42, 0x42, 0x42, 0x3c, 0x42, 0x42, 0x42, 0x24, 0x18};
GLubyte BMPR[13] = {0x00, 0x00, 0x42, 0x42, 0x44, 0x72, 0x50, 0x7c, 0x42, 0x42, 0x62, 0x58, 0x00};
GLubyte BMPP[13] = {0x00, 0x00, 0x3e, 0x08, 0x08, 0x08, 0x3e, 0x49, 0x49, 0x49, 0x08, 0x08, 0x3e};
GLubyte BMPSP[13] = {0x04, 0x04, 0x04, 0x0a, 0x0a, 0x09, 0x91, 0x90, 0x50, 0x50, 0x20, 0x20, 0x20};
GLubyte BMPU[13] = {0x01, 0x3D, 0x43, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x00};
GLubyte BMPV[13] = {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3};

// Colour bar
float cBarMax = -FLT_MAX;
float cBarMin = FLT_MAX;
float cBarVecMax;
float cBarVecMin;

CString ExtractSubString2(int iP, CString sIn) {
	sIn.Replace(",", " ");
	int i;
	int iS = 0;
	int iLen = sIn.GetLength();
	CString sOut;
	int iOCnt = 0;
	int iCBlock = 0;
	BOOL bF = FALSE;
	for (i = 0; i < iLen; i++) {
		if (sIn[i] != ' ') {
			if (bF == FALSE) {
				bF = TRUE;
				iCBlock++;
			}

			if (iCBlock == iP) {
				sOut += sIn[i];
				iOCnt++;
			}
		} else {
			bF = FALSE;
		}
	}
	return (sOut);
}

void SetColBar(float fMin, float fMax) {
	// if (fMax>cBarMax)
	cBarMax = fMax;
	// if (fMin<cBarMin)
	cBarMin = fMin;
}

void SetColBarVec(float fMin, float fMax) {
	if (fMax > cBarMax)
		cBarVecMax = fMax;
	if (fMin < cBarMin)
		cBarVecMin = fMin;
}

double VecMaxMag() // For normalisation of vector lengths
{
	double dRet = 1.0;
	dRet = abs(cBarVecMax);
	if (abs(cBarVecMin) > dRet)
		dRet = abs(cBarVecMin);
	return (dRet);
}

float GetContourCol(float Val) {
	float fN;
	fN = (Val - cBarMin) / (cBarMax - cBarMin);
	if (fN >= 0.999) {
		fN = (float) 0.999;
	}
	if (fN <= 0.001) {
		fN = (float) 0.001;
	}
	return (fN);
}

float GetContourColVec(float Val) {
	float fN;
	fN = (Val - cBarVecMin) / (cBarVecMax - cBarVecMin);
	if (fN >= 0.999) {
		fN = (float) 0.999;
	}
	if (fN <= 0.001) {
		fN = (float) 0.001;
	}
	return (fN);
}

CString RemTrailingZeros(CString sIn) {
	int iLen;
	int i;
	CString sRet;
	int iLPos;
	iLen = sIn.GetLength();
	iLPos = iLen;
	sRet = sIn;
	CString sC;

	for (i = iLen; i > 0; i--) {
		sC = sRet.Mid(i - 1, 1);
		if (sC == "0") {
		} else {
			iLPos = i;
			break;
		}
	}
	sRet = sRet.Left(iLPos);
	return (sRet);
}

CString ncr(CString sIn) {
	sIn.Replace("\n", "");
	sIn.Replace(" ", "");
	return (sIn);
}

CString f8(double dIn) {
	char s80[80];
	CString s8;
	if (dIn == 0) {
		s8 = "0.0";
	} else {
		sprintf_s(s80, "%-f", dIn);
		s8 = s80;
		s8 = s8.Left(8);
	}
	return (s8);
}

CString f4(double dIn) {
	char s80[80];
	CString s8;

	sprintf_s(s80, "%-f", dIn);
	s8 = s80;
	s8 = s8.Left(5);
	s8 += "   ";
	return (s8);
}

CString e8(double dIn) {
	char s80[80];
	sprintf_s(s80, "%e", dIn);
	CString s8;
	CString sRet;
	CString sExp;
	CString sNum;
	double dExp;
	s8 = s80;
	int iD;
	int iL;
	if (dIn == DBL_MAX) {
		sRet = "        ";
	} else {
		if (dIn == 0) {
			sRet = "0.0";
		} else {
			iD = s8.Find('e');
			iL = s8.GetLength();
			sExp = s8.Right(3);
			dExp = atoi(sExp);
			if ((dExp > 4) || (dExp < -4)) {
				if ((dExp > 99) || (dExp < -99)) {
					sNum = s8.Left(4);
					sNum = RemTrailingZeros(sNum);
					sExp = s8.Right(3);
				} else if ((dExp > 9) || (dExp < -9)) {
					sNum = s8.Left(5);
					sNum = RemTrailingZeros(sNum);
					sExp = s8.Right(2);
				} else {
					sNum = s8.Left(6);
					sNum = RemTrailingZeros(sNum);
					sExp = s8.Right(1);
				}
				if (s8.Find('+') > -1) {
					sRet = sNum + '+' + sExp;
				} else {
					sRet = sNum + '-' + sExp;
				}
			} else {
				sRet = f8(dIn);
				sRet = RemTrailingZeros(sRet);
			}
		}
	}
	return (sRet);
}

void OglString(int iDspFlgs, double x, double y, double z, char* s) {
	////Esp_Mod_Labels_4_27_2025_Start: Redined Label display to use advance font display
	if (iDspFlgs & DSP_BLACK)
		glColor3fv(cols[124]);
	else
		glColor3fv(cols[0]);

	glRasterPos3f((float) x, (float) y, (float) z);
	glListBase(g_arialBase - g_firstChar);

	// Esp_Mod_Offset:The following controls the offset of the label from the entity (easier to see the label)
	int spaces = 2; // number of spaces
	int len = (int) strlen(s);
	char* s2 = (char*) malloc(len + spaces);
	for (int i = 0; i < spaces; ++i)
		s2[i] = ' ';

	memcpy(s2 + spaces, s, len);
	glCallLists(len + spaces, GL_UNSIGNED_BYTE, s2);
	////Esp_Mod_Labels_4_27_2025_End
}

int Factorial(int n) {
	int izp;
	int iRetzVal;
	iRetzVal = 1;
	for (izp = 0; izp < n; izp++) {
		iRetzVal = iRetzVal * (izp + 1);
	}
	return (iRetzVal);
};

CString float8NAS(double d) {
	char s1[80];
	CString sRet;
	sprintf_s(s1, "%8.7f", d);
	sRet = s1;
	sRet = sRet.Left(8);
	return (sRet);
}

int minimum(int a, int b) {
	int irc;
	irc = a;
	if (b < a) {
		irc = b;
	}
	return (irc);
}

// implementation of linked list
// for storing objects derived from G_Object
IMPLEMENT_DYNAMIC(cLinkedListB, CObject)

cLinkedListB::cLinkedListB() {
	iCnt = 0;
	Head = NULL;
	pCur = NULL;
	iLabel = -1;
	iColour = -1;
	sTitle = "";
	iObjType = 201;
}

void cLinkedListB::Info() {
	char S1[200];
	outtext1("**************************************");
	sprintf_s(S1, "%s%i%s%i%s%i", "Type ", iObjType, "; Label ", iLabel, " Col; ", iColour);
	outtext1("BOUNDARY SET");
	outtext1(S1);
	sprintf_s(S1, "ID: %i TITLE: %s", iLabel, sTitle);
	outtext1(S1);
	outtext1("**************************************");
}

IMPLEMENT_DYNAMIC(cLinkedListT, CObject)

cLinkedListT::cLinkedListT() {
	iCnt = 0;
	Head = NULL;
	pCur = NULL;
	iLabel = -1;
	iColour = -1;
	sTitle = "";
	iObjType = 202;
}

void cLinkedListT::Info() {
	char S1[200];
	outtext1("**************************************");
	sprintf_s(S1, "%s%i%s%i%s%i", "Type ", iObjType, "; Label ", iLabel, " Col; ", iColour);
	outtext1("TEMPERATURE SET");
	outtext1(S1);
	sprintf_s(S1, "ID: %i TITLE: %s", iLabel, sTitle);
	outtext1(S1);
	outtext1("**************************************");
}

IMPLEMENT_DYNAMIC(cLinkedList, CObject)

cLinkedList::cLinkedList() {
	iCnt = 0;
	Head = NULL;
	pCur = NULL;
	iLabel = -1;
	iColour = -1;
	sTitle = "";
	iObjType = 200;
}

void cLinkedList::Clear() {
	iCnt = 0;
	Head = NULL;
	pCur = NULL;
	iLabel = -1;
	iColour = -1;
	sTitle = "";
	iObjType = 200;
}

// Results set class
cLinkedList::~cLinkedList() {
	// THIS SHOULD NOT DELETE THE OBJECTS IN THE LIST
	// CALL DELETE ALL TO ACTUALLY DELETE ALL ELEMENTS

	// G_Object* pC;
	// G_Object* pNext = NULL;
	// pC = Head;
	// while (pC != NULL)
	//{
	//	pNext = pC->next;
	//	delete(pC);
	//	pC = pNext;
	// }
	// outtext1("CHECK THE DELETE MTHOD IS BEING USED CORRECTLY IN THIS CONTEXT");
	// outtext1("AS CODE DELETE HAS CHANGED NOT TO DELETE ITEMS IN THE DESRUCTOR");
	iCnt = 0;
	Head = NULL;
}

void cLinkedList::DeleteAll() {
	G_Object* pC;
	G_Object* pNext = NULL;
	pC = Head;
	while (pC != NULL) {
		pNext = pC->next;
		delete (pC);
		pC = pNext;
	}
	iCnt = 0;
	Head = NULL;
}

void cLinkedList::RemNoDelete(G_Object* inItem) {
	if (inItem != NULL) {
		if ((inItem->before != NULL) && (inItem->next != NULL)) // in middle with a befor and after
		{
			inItem->before->next = inItem->next;
			inItem->next->before = inItem->before;
			iCnt--;
		} else if ((inItem->before == NULL) && (inItem->next == NULL)) {
			Head->before = NULL;
			Head->next = NULL;
			Head = NULL;
			iCnt--;
		} else if (inItem->before == NULL) {
			Head = (eEdge*) inItem->next;
			Head->before = NULL;
			iCnt--;
		} else if (inItem->next == NULL) {
			pCur = (eEdge*) inItem->before;
			pCur->next = NULL;
			iCnt--;
		}
	}
}

void cLinkedList::Remove(G_Object* inItem) {
	if ((inItem != NULL) && (inItem->pParent == this)) {
		if ((inItem->before != NULL) && (inItem->next != NULL)) // in middle with a befor and after
		{
			inItem->before->next = inItem->next;
			inItem->next->before = inItem->before;
			delete (inItem);
			iCnt--;
		} else if ((inItem->before == NULL) && (inItem->next == NULL)) {
			Head->before = NULL;
			Head->next = NULL;
			Head = NULL;
			delete (inItem);
			iCnt--;
		} else if (inItem->before == NULL) {
			Head = (eEdge*) inItem->next;
			Head->before = NULL;
			delete (inItem);
			iCnt--;
		} else if (inItem->next == NULL) {
			pCur = (eEdge*) inItem->before;
			pCur->next = NULL;
			delete (inItem);
			iCnt--;
		}
	}
}

void cLinkedList::Remove2(G_Object* inItem) {
	if (inItem != NULL) {
		if ((inItem->before != NULL) && (inItem->next != NULL)) // in middle with a befor and after
		{
			inItem->before->next = inItem->next;
			inItem->next->before = inItem->before;
			delete (inItem);
			iCnt--;
		} else if ((inItem->before == NULL) && (inItem->next == NULL)) {
			Head->before = NULL;
			Head->next = NULL;
			Head = NULL;
			delete (inItem);
			iCnt--;
		} else if (inItem->before == NULL) {
			Head = (eEdge*) inItem->next;
			Head->before = NULL;
			delete (inItem);
			iCnt--;
		} else if (inItem->next == NULL) {
			pCur = (eEdge*) inItem->before;
			pCur->next = NULL;
			delete (inItem);
			iCnt--;
		}
	}
}

G_Object* cLinkedList::IsIn(G_Object* inItem) {
	G_Object* pRet = NULL;
	G_Object* pNext;
	pNext = Head;
	while (pNext != NULL) {
		if (pNext == inItem) {
			pRet = pNext;
			break;
		}
		pNext = (G_Object*) pNext->next;
	}
	return (pRet);
}

void cLinkedList::AddEx(G_Object* inItem) {
	if (!IsIn(inItem))
		Add(inItem);
}

void cLinkedList::Add(G_Object* inItem) {
	if (Head == NULL) {
		Head = inItem;
		Head->before = NULL;
		pCur = Head;
		iCnt++;
	} else {
		inItem->before = pCur;
		pCur->next = inItem;
		pCur = inItem;
		pCur->next = NULL;
		iCnt++;
	}
}

G_Object* cLinkedList::GetByPtr(G_Object* pThis) {
	int i;
	G_Object* pC;
	G_Object* pR = NULL;
	pC = Head;
	for (i = 0; i < iCnt; i++) {
		if (pC == pThis) {
			pR = pC;
			break;
		} else {
			pC = pC->next;
		}
	}
	return (pR);
}

G_Object* cLinkedList::Get(int ID) {
	int i;
	G_Object* pC;
	G_Object* pR = NULL;
	pC = Head;
	for (i = 0; i < iCnt; i++) {
		if (pC->iLabel == ID) {
			pR = pC;
			break;
		} else {
			pC = pC->next;
		}
	}
	return (pR);
}

G_Object* cLinkedList::GetObj(int iType, int iLab) {
	int i;
	G_Object* pC;
	G_Object* pR = NULL;
	pC = Head;
	for (i = 0; i < iCnt; i++) {
		if ((pC->iLabel == iLab) && (pC->iObjType == iType)) {
			pR = pC;
			break;
		} else {
			pC = pC->next;
		}
	}
	return (pR);
}

void cLinkedList::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	G_Object* pNext;
	pNext = Head;
	while (pNext != NULL) {
		pNext->SetToScr(pModMat, pScrTran);
		pNext = (G_Object*) pNext->next;
	}
}

void cLinkedList::GenIDS(int& iS) {
	G_Object* pNext;
	pNext = Head;
	while (pNext != NULL) {
		pNext->iLabel = iS;
		iS++;
		pNext = (G_Object*) pNext->next;
	}
}

void cLinkedList::Draw(CDC* pDC, int iDrawmode) {
	G_Object* pNext;
	pNext = Head;
	while (pNext != NULL) {
		pNext->Draw(pDC, iDrawmode);
		pNext = (G_Object*) pNext->next;
	}
}

void cLinkedList::HighLight(CDC* pDC) {
	G_Object* pNext;
	pNext = Head;
	while (pNext != NULL) {
		pNext->HighLight(pDC);
		pNext = (G_Object*) pNext->next;
	}
}

void cLinkedList::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	G_Object* pNext;
	pNext = Head;
	while (pNext != NULL) {
		pNext->OglDrawW(iDspFlgs, dS1, dS2);
		pNext = (G_Object*) pNext->next;
	}
}

void cLinkedList::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void cLinkedList::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	G_Object* pNext;
	pNext = Head;
	while (pNext != NULL) {
		if (pNext->isSelectable() == 1) {
			pNext->S_Box(P1, P2, pSel);
		}
		pNext = (G_Object*) pNext->next;
	}
}

G_ObjectD cLinkedList::SelDist(CPoint InPT, Filter FIL) {
	G_Object* pSel = NULL;
	G_Object* pMinSel = NULL;
	G_ObjectD Ret;

	double dDist = 1e36;
	Ret.pObj = NULL;
	Ret.Dist = dDist;

	G_Object* pNext;
	pNext = Head;
	while (pNext != NULL) {
		Ret = pNext->SelDist(InPT, FIL);
		if (Ret.Dist < dDist) {
			pMinSel = Ret.pObj;
			dDist = Ret.Dist;
		}
		pNext = (G_Object*) pNext->next;
	}

	if ((FIL.isFilter(321) == TRUE) || (FIL.isFilter(322) == TRUE) || (FIL.isFilter(323) == TRUE) || (FIL.isFilter(324) == TRUE) || (FIL.isFilter(325) == TRUE) || (FIL.isFilter(326) == TRUE) || (FIL.isFilter(327) == TRUE) || (FIL.isFilter(328) == TRUE) || (FIL.isFilter(329) == TRUE)) {
		Ret.pObj = pMinSel;
		Ret.Dist = dDist;
	} else {
		Ret.pObj = this;
		Ret.Dist = dDist;
	}
	return (Ret);
}

// iType is resulatant entity type
// pThis the object that has the association
void cLinkedList::RelTo(G_Object* pThis, ObjList* pList, int iType) {
	pThis->RelTo(pThis, pList, iType);
}

void cLinkedList::Info() {
	char S1[200];
	outtext1("**************************************");
	sprintf_s(S1, "%s%i%s%i%s%i", "Type ", iObjType, "; Label ", iLabel, " Col; ", iColour);
	outtext1("LOAD SET");
	outtext1(S1);
	sprintf_s(S1, "ID: %i TITLE: %s", iLabel, sTitle);
	outtext1(S1);
	outtext1("**************************************");
}

void cLinkedList::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int i;
	int iType;
	BCLD* pNext;
	BCLD* pO = nullptr;
	pNext = (BCLD*) Head;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << iCnt;
		ar << sTitle;
		while (pNext != NULL) {
			ar << pNext->iObjType;
			pNext->Serialize(ar, iV, MESH);
			pNext = (BCLD*) pNext->next;
		}
	} else {
		G_Object::Serialize(ar, iV);
		int iNo;
		ar >> iNo;
		ar >> sTitle;
		for (i = 0; i < iNo; i++) {
			ar >> iType;
			switch (iType) {
				case 321:
					pO = new Force;
					break;
				case 322:
					pO = new Restraint;
					break;
				case 323:
					pO = new Moment;
					break;
				case 324:
					pO = new Pressure;
					break;
				case 325:
					pO = new Temperature;
					break;
				case 326:
					pO = new FluxLoad;
					break;
				case 327:
					pO = new TemperatureBC;
					break;
				case 328:
					pO = new AccelLoad;
					break;
				case 329:
					pO = new RotationLoad;
					break;
				case 331:
					pO = new TEMPD;
					break;
				case 332:
					pO = new GRAV;
					break;
			}
			pO->Serialize(ar, iV, MESH);
			pO->pParent = this;
			this->Add(pO);
		}
	}
}

// End of linked list implementation

// Results set class
ResSet::ResSet() {
	iCnt = 0;
	iNoV = 0;
	Head = NULL;
	pCur = NULL;
	sTitle = "";
	sSubTitle = "";
	sOpName = "None";
	iDefID = 0;
	iSecondaryID = -1;
	int iNoResDef = 0;
}

// Results set class
ResSet::~ResSet() {
	int i;
	Res* pC;
	Res* pR = NULL;
	pC = Head;
	for (i = 0; i < iCnt; i++) {
		pR = pC->next;
		delete (pC);
		pC = pR;
	}

	for (i = 0; i < iNoResDef; i++) {
		delete (ResDefintion[i]);
		ResDefintion[i] = NULL;
	}
}

Res* ResSet::Get(int ID, int iOpt) {
	int i;
	int iSecVar = 0;
	Res* pC;
	Res* pR = NULL;
	pC = Head;

	// iOpt is a sesondary selection ID like layer for composite elements
	for (i = 0; i < iCnt; i++) {
		if (iSecondaryID != -1) // This is layered element also need to select the correct layer
		{
			iSecVar = (int) *pC->GetAddress(iSecondaryID);
		} // Variable 0 is the layer iD
		else {
			iSecVar = 0;
		} // all other datatset read so far have no secondary ID
		if ((pC->ID == ID) && (iSecVar == iOpt)) {
			pR = pC;
			break;
		} else {
			pC = pC->next;
		}
	}
	return pR;
}

int ResSet::getMaxSecondaryID() {
	int i;
	int irc = 0;
	int iSecVar = 0;
	Res* pC;
	pC = Head;
	if (iSecondaryID != -1) {
		for (i = 0; i < iCnt; i++) {
			iSecVar = (int) *pC->GetAddress(iSecondaryID);
			if (iSecVar > irc)
				irc = iSecVar;
			pC = pC->next;
		}
	}
	return (irc);
}

CString ResSet::ToStringDL(Res* pR) {
	char S1[1000];
	CString outT;
	int j;
	if (pR != NULL) {
		outT = "";
		sprintf_s(S1, "%i	", pR->ID);
		outT += S1;
		for (j = 0; j < iNoV; j++) {
			sprintf_s(S1, "%e	", *pR->GetAddress(j));
			outT += S1;
		}
	}
	return (outT);
}

CString ResSet::ToStringHead() {
	char S1[1000];
	CString outT;
	int i;
	outT = "";
	sprintf_s(S1, "%s	", "ID");
	outT += S1;
	for (i = 0; i < iNoV; i++) {
		sprintf_s(S1, "%s	", lab[i]);
		outT += S1;
	}
	return (outT);
}

void ResSet::PrintToFile(FILE* pFile) {
	int i;
	fprintf(pFile, "%s\n", "START OF DATA SET");
	fprintf(pFile, "%s%s\n", "FILE, ", sFile);
	fprintf(pFile, "%s%i%s,%s\n", "LC, ", LC, " ", sName);
	fprintf(pFile, "%s%s\n", "TITLE, ", sTitle);
	fprintf(pFile, "%s%s\n", "SUBTITLE, ", sSubTitle);
	fprintf(pFile, "%s", "ID,");
	for (i = 0; i < iNoV; i++) {
		fprintf(pFile, "%s,", lab[i]);
	}
	fprintf(pFile, "\n");
	int j;
	Res* pC;
	pC = Head;
	for (i = 0; i < iCnt; i++) {
		if (pC != NULL) {
			fprintf(pFile, "%i,", pC->ID);
			for (j = 0; j < iNoV; j++) {
				fprintf(pFile, "%e,", *pC->GetAddress(j));
			}
			fprintf(pFile, "\n");
			pC = pC->next;
		}
	}
	fprintf(pFile, "%s\n", "END OF DATA SET");
	fprintf(pFile, "%s\n", "");
}

ResDef* ResSet::GetResDef(int iN) {
	ResDef* pRD = NULL;
	if ((iN > -1) && (iN < iNoResDef)) {
		pRD = ResDefintion[iN];
	}
	return (pRD);
}

void ResSet::AddResDef(ResDef* rD) {
	// MAX_RES_DEF = 5;
	int iNoRes = -1;
	if (iNoRes < MAX_RES_DEF) {
		ResDefintion[iNoResDef] = rD;
		iNoResDef++;
	} else {
		outtext1("Error Adding Results Definition");
	}
}

void ResSet::Add(Res* inRes) {
	if (Head == NULL) {
		Head = inRes;
		pCur = inRes;
		iCnt++;
	} else {
		pCur->next = inRes;
		pCur = inRes;
		pCur->next = NULL;
		iCnt++;
	}
}

Filter::Filter() {
	iNo = 0;

	iType[0] = (0); // POINT
	iType[1] = (1); // NODE
	iType[2] = (2); // LINE
	iType[3] = (3); // ELEMENT
	iType[4] = (4); // MESH
	iType[5] = (5); // SYMBOL
	iType[6] = (6); // TEXT
	iType[7] = (7); // NURBS CURVE
	iType[8] = (8); // EEDGE
	iType[9] = (9); // EFACE
	iType[10] = (10); // DIM
	iType[11] = (12); // COORDSYS
	iType[12] = (13); // CURVE ON SURFACE
	iType[13] = (14); // SOLID SECTION
	iType[14] = (15); // NURBS SURFACE
	iType[15] = (18); // FACE
	iType[16] = (19); // SHELL
	iType[17] = (20); // PART
	iType[18] = (200); // LSET
	iType[19] = (201); // BSET
	iType[20] = (202); // TSET
	iType[21] = (321); // FORCE
	iType[22] = (323); // MOMENT
	iType[23] = (324); // PRESSURE
	iType[24] = (322); // RESTRAINT
	iType[25] = (325); // TEMPERATURE
	iType[26] = (326); // FLUX LOAD
	iType[27] = (327); // T BC
	iType[28] = (328); // ACCEL LOAD
	iType[29] = (329); // ROTATION ACCEL LOAD
	iType[30] = (330); // RESULTS VECTOR
	iType[31] = (331); // TEMPD
	iType[32] = (332); // GRAV
	sType[0] = "POINT";
	sType[1] = "NODE";
	sType[2] = "LINE NOT USED";
	sType[3] = "ELEMENT";
	sType[4] = "MESH";
	sType[5] = "SYMBOL";
	sType[6] = "TEXT";
	sType[7] = "CURVE";
	sType[8] = "EEDGE";
	sType[9] = "EFACE";
	sType[10] = "DIMENSION";
	sType[11] = "COORDSYS";
	sType[12] = "CURVE ON SURFACE";
	sType[13] = "SECTION";
	sType[14] = "SURFACE";
	sType[15] = "FACE";
	sType[16] = "SHELL";
	sType[17] = "PART";
	sType[18] = "LOAD SET"; // LOAD SET
	sType[19] = "BC SET"; // SET
	sType[20] = "TEMPERATURE SET"; // SET
	sType[21] = "FORCE";
	sType[22] = "MOMENT";
	sType[23] = "PRESSURE";
	sType[24] = "RESTRAINT";
	sType[25] = "TEMP STRUCTURAL";
	sType[26] = "NET FLUX Q";
	sType[27] = "TEMP BC T";
	sType[28] = "ACCEL BODY LOAD";
	sType[29] = "ROTATIONAL BODY LOAD";
	sType[30] = "RESULTS VECTOR";
	sType[31] = "TEMPD CARD";
	sType[32] = "GRAV CARD";
	iNoOfType = 33;

	// USED IN ASTRIUMS QUANTA PROGRAM
	// iType[17] =(500); //WG DEF
	// iType[18] =(600); //PART
	// iType[19] =(601); //ELBOW
	// iType[20] =(602); //BRK
	// iType[21] =(603); //SWEEP
	// iType[22] =(604); //SWEEP
	// iType[23] =(605); //BRK INT
}

void Filter::SetAll() {
	iNo = 0;
	int i;
	for (i = 0; i < iNoOfType; i++) {
		SetFilter(iType[i]);
	}
}

void Filter::Clear() {
	iNo = 0;
}

void Filter::Save() {
	int i;
	iSaveNo = iNo;
	for (i = 0; i < iNo; i++)
		iSave[i] = Filt[i];
}

void Filter::Restore() {
	int i;
	iNo = iSaveNo;
	for (i = 0; i < iNo; i++)
		Filt[i] = iSave[i];
}

int Filter::isIn(int iThisType) {
	int iRC = -1;
	int i;
	for (i = 0; i < iNo; i++) {
		if (Filt[i] == iThisType) {
			iRC = i;
			break;
		}
	}
	return (iRC);
}

void Filter::SetFilter(int iThisType) {
	if (isIn(iThisType) == -1) {
		Filt[iNo] = iThisType;
		iNo++;
	}
}

void Filter::RemFilter(int iThisType) {
	int ind;
	ind = isIn(iThisType);
	if (ind != -1) {
		Filt[ind] = Filt[iNo - 1];
		iNo--;
	}
}

BOOL Filter::isFilter(int iThisType) {
	if (isIn(iThisType) != -1) {
		return (TRUE);
	} else {
		return (FALSE);
	}
}

dList::dList() {
	iNo = 0;
}

void dList::Init() {
	iNo = 0;
}

void dList::Add(double indbl) {
	if (iNo < 1000) {
		d[iNo] = indbl;
		iNo++;
	} else {
		outtext1("ERROR: Max List Items Exceeded.");
	}
}

void dList::AddEx(double indbl) {
	if (iNo < 1000) {
		if (IsIn(indbl) == -1) {
			d[iNo] = indbl;
			iNo++;
		}
	} else {
		outtext1("ERROR: Max List Items Exceeded.");
	}
}

void dList::Sort() {
	int i, j;
	double tD;

	for (i = 0; i < iNo; i++) {
		for (j = i; j < iNo; j++) {
			if (d[j] < d[i]) {
				tD = d[i];
				d[i] = d[j];
				d[j] = tD;
			}
		}
	}
}

int dList::IsIn(double indbl) {
	int iRet = -1;
	int i;
	for (i = 0; i < iNo; i++) {
		if (d[i] == indbl) {
			iRet = i;
			break;
		}
	}
	return (iRet);
}

NEList::NEList() {
	Title = "NULL";
	iNo = 0;
}

int NEList::Get(int iD) {
	int iRet = -1;
	int i;
	for (i = 0; i < iNo; i++) {
		if (ids[i] == iD) {
			iRet = iType[i];
			break;
		}
	}
	return (iRet);
}

BOOL NEList::IsIn(int iD) {
	BOOL bRC = FALSE;
	int i;
	for (i = 0; i < iNo; i++) {
		if (ids[i] == iD) {
			bRC = TRUE;
			break;
		}
	}
	return (bRC);
}

void NEList::Add(int iP, int iT) {
	if (iNo < MAX_LITEMS) {
		ids[iNo] = iP;
		iType[iNo] = iT;
		iNo++;
	} else {
		outtext1("ERROR: Max NEList Items Exceeded.");
	}
}

ObjList::ObjList() {
	iNo = 0;
}

ObjList::~ObjList() {
	// DeleteAll();
}

void ObjList::InsertAt(int iPos, G_Object* inItem) {
	int i;
	for (i = iPos; i < iNo; i++) {
		Objs[iNo - i] = Objs[iNo - i - 1];
	}
	iNo++;
	Objs[iPos] = inItem;
}

void ObjList::Add(G_Object* inItem) {
	if (iNo < MAX_GP_ITEMS) {
		Objs[iNo] = inItem;
		iNo++;
	}
}

void ObjList::AddEx(G_Object* inItem) {
	BOOL bIsIn;
	bIsIn = IsIn(inItem);
	if (bIsIn == FALSE) {
		Objs[iNo] = inItem;
		iNo++;
	}
}

G_Object* ObjList::GetMaxLabItem() {
	G_Object* pRet = NULL;
	int i;
	int iMax = 0;
	for (i = 0; i < iNo; i++) {
		if (Objs[i]->iLabel > iMax) {
			iMax = Objs[i]->iLabel;
			pRet = Objs[i];
		}
	}
	return (pRet);
}

G_Object* ObjList::GetMinLabItem() {
	G_Object* pRet = NULL;
	int i;
	int iMin = 99999999;
	for (i = 0; i < iNo; i++) {
		if (Objs[i]->iLabel < iMin) {
			iMin = Objs[i]->iLabel;
			pRet = Objs[i];
		}
	}
	return (pRet);
}

G_Object* ObjList::GetByLab(int iLab) {
	int i;
	G_Object* pRet = NULL;
	for (i = 0; i < iNo; i++) {
		if (Objs[i]->iLabel == iLab) {
			pRet = Objs[i];
			break;
		}
	}
	return (pRet);
}

BOOL ObjList::IsIn(G_Object* inItem) {
	int i;
	BOOL bRet = FALSE;
	for (i = 0; i < iNo; i++) {
		if (Objs[i] == inItem) {
			bRet = TRUE;
			break;
		}
	}
	return (bRet);
}

int ObjList::IsIn2(G_Object* inItem) {
	int i;
	int iRet = -1;
	for (i = 0; i < iNo; i++) {
		if (Objs[i] == inItem) {
			iRet = i;
			break;
		}
	}
	return (iRet);
}

void ObjList::RemoveGP(ObjList* inRemGp) {
	int i;
	for (i = 0; i < inRemGp->iNo; i++) {
		this->Remove(inRemGp->Objs[i]);
	}
}

void ObjList::Remove(G_Object* inItem) {
	int iO = IsIn2(inItem);
	int i;
	if (iO != -1) {
		for (i = iO + 1; i < iNo; i++) {
			Objs[i - 1] = Objs[i];
		}
		Objs[iNo - 1] = NULL;
		iNo--;
	}
}

// Sort items in list based on min distance of centroid to vPt
void ObjList::MinDistSort(C3dVector vPt) {
	int i;
	int j;
	double dMinDist;
	double dDist;
	G_Object* oT;

	for (i = 0; i < iNo - 1; i++) {
		dMinDist = vPt.Dist(this->Objs[i]->Get_Centroid());
		for (j = i + 1; j < iNo; j++) {
			dDist = vPt.Dist(this->Objs[j]->Get_Centroid());
			if (dDist < dMinDist) {
				dMinDist = dDist;
				oT = Objs[i];
				Objs[i] = Objs[j];
				Objs[j] = oT;
			}
		}
	}
}

void ObjList::MinSizeSort() {
	int i;
	int j;
	double dMinSize;
	double dSize;
	G_Object* oT;

	for (i = 0; i < iNo - 1; i++) {
		dMinSize = this->Objs[i]->GetCharSize();
		for (j = i + 1; j < iNo; j++) {
			dSize = this->Objs[j]->GetCharSize();
			if (dSize < dMinSize) {
				dMinSize = dSize;
				oT = Objs[i];
				Objs[i] = Objs[j];
				Objs[j] = oT;
			}
		}
	}
}

void ObjList::Clear() {
	iNo = 0;
}

void ObjList::DeleteAll() {
	int i;
	for (i = 0; i < iNo; i++) {
		if (Objs[i] != NULL)
			delete (Objs[i]);
		Objs[i] = NULL;
	}
	iNo = 0;
}

void ObjList::GenIDS(int& iS) {
	int i;
	for (i = 0; i < iNo; i++) {
		Objs[i]->iLabel = iS;
		iS++;
	}
}

void ObjList::ReOrder(int iStart) {
	int i;
	for (i = 0; i < iStart; i++) {
		Objs[iNo + i] = Objs[i];
	}
	for (i = 0; i < iNo; i++) {
		Objs[i] = Objs[i + iStart];
	}
	for (i = 0; i < iStart; i++) {
		Objs[iNo + i] = NULL;
	}
}

void ObjList::ListIDs() {
	char S1[200];
	CString outT;
	int i;
	outtext1("LAB");
	for (i = 0; i < iNo; i++) {
		sprintf_s(S1, "%i,", Objs[i]->iLabel);
		// outtext1(S1);
		outT += S1;
	}
	outtext1(outT);
	// outtext1("D");
}

ObjGp::ObjGp() {
	Title = "";
	iNo = 0;
}

ObjGp::ObjGp(CString inTit) {
	Title = inTit;
	iNo = 0;
}

void ObjGp::Clear() {
	iNo = 0;
}

void ObjGp::Add(G_Object* inItem) {
	if (IsIn(inItem) == -1) {
		if (iNo < MAX_GP_ITEMS) {
			Objs[iNo] = inItem;
			iNo++;
		} else {
			outtext1("ERROR: Group Overflow.");
		}
	}
}

void ObjGp::Rem(G_Object* inItem) {
	int i;
	for (i = 0; i < iNo; i++) {
		if (Objs[i] == inItem) {
			Objs[i] = Objs[iNo - 1];
			iNo--;
			break;
		}
	}
}

int ObjGp::IsIn(G_Object* inItem) {
	int i;
	int iRet = -1;
	for (i = 0; i < iNo; i++) {
		if (Objs[i] == inItem) {
			iRet = i;
			break;
		}
	}
	return (iRet);
}

IMPLEMENT_DYNAMIC(BMP, CObject)

BMP::BMP() {
	// Data read from the header of the BMP file
	dataPos = 0;
	width = 0;
	height = 0;
	imageSize = 0;
	data = NULL;
}

BMP::~BMP() {
	free(data);
	dataPos = 0;
	width = 0;
	height = 0;
	imageSize = 0;
	data = NULL;
}

// Create Shade Representation of object

IMPLEMENT_DYNAMIC(G_Object, CCmdTarget)

BEGIN_DISPATCH_MAP(G_Object, CCmdTarget)
DISP_PROPERTY_ID(G_Object, "iColour", 1, iColour, VT_I4)
DISP_FUNCTION_ID(G_Object, "GetTest", 2, GetTest, VT_BSTR, VTS_NONE) // Add this
DISP_PROPERTY_ID(G_Object, "iLabel", 3, iLabel, VT_I4)
DISP_PROPERTY_ID(G_Object, "iObjType", 4, iObjType, VT_I4)
DISP_PROPERTY_ID(G_Object, "iType", 5, iType, VT_I4)
DISP_PROPERTY_ID(G_Object, "iFile", 6, iFile, VT_I4)
DISP_FUNCTION_ID(G_Object, "GetObjectHeaders", 7, API_GetObjectHeaders, VT_EMPTY, VTS_PVARIANT)
DISP_FUNCTION_ID(G_Object, "GetObjectVars", 8, API_GetObjectVars, VT_EMPTY, VTS_PVARIANT)
DISP_FUNCTION_ID(G_Object, "PutObjectVars", 9, API_PutObjectVars, VT_EMPTY, VTS_PVARIANT)
DISP_FUNCTION_ID(G_Object, "GetObjectName", 10, API_GetObjectName, VT_BSTR, VTS_NONE)
END_DISPATCH_MAP()

// this is the GUID
const IID IID_IObject = {0x2EC99D19, 0x8632, 0x44E0, {0xA2, 0x2E, 0x29, 0x4C, 0xFB, 0x4F, 0x5D, 0x61}};

BEGIN_INTERFACE_MAP(G_Object, CCmdTarget)
INTERFACE_PART(G_Object, IID_IObject, Dispatch)
END_INTERFACE_MAP()

// Manually added API function

BSTR G_Object::GetTest() {
	return SysAllocString(L"Test Successful");
}

// Function 1: GetModel - Retrieves the SAFEARRAY of BSTRs
HRESULT __stdcall G_Object::API_GetObjectHeaders(VARIANT* pVariant) {
	// Initialize the VARIANT
	int iNoVars;
	CString sVar[100];
	iNoVars = GetVarHeaders(sVar);

	VariantInit(pVariant);
	pVariant->vt = VT_ARRAY | VT_BSTR;

	// Create a SAFEARRAY to hold BSTRs
	SAFEARRAY* psa;
	SAFEARRAYBOUND bounds[1];
	bounds[0].lLbound = 0;
	bounds[0].cElements = iNoVars; // Fix: Use correct size
	psa = SafeArrayCreate(VT_BSTR, 1, bounds);

	if (!psa)
		return E_OUTOFMEMORY; // Handle memory allocation failure

	// Fill the SAFEARRAY
	LONG index;
	for (int i = 0; i < iNoVars; i++) {
		BSTR bstr = sVar[i].AllocSysString(); // Convert CString to BSTR
		index = i; // Use correct index
		SafeArrayPutElement(psa, &index, bstr);
		// Do NOT free bstr here! SafeArrayPutElement takes ownership
	}

	pVariant->parray = psa;
	return S_OK;
}

HRESULT __stdcall G_Object::API_GetObjectVars(VARIANT* pVariant) {
	// Initialize the VARIANT
	int iNoVars;
	CString sVar[100];
	iNoVars = GetVarValues(sVar);

	VariantInit(pVariant);
	pVariant->vt = VT_ARRAY | VT_BSTR;

	// Create a SAFEARRAY to hold BSTRs
	SAFEARRAY* psa;
	SAFEARRAYBOUND bounds[1];
	bounds[0].lLbound = 0;
	bounds[0].cElements = iNoVars; // Fix: Use correct size
	psa = SafeArrayCreate(VT_BSTR, 1, bounds);

	if (!psa)
		return E_OUTOFMEMORY; // Handle memory allocation failure

	// Fill the SAFEARRAY
	LONG index;
	for (int i = 0; i < iNoVars; i++) {
		BSTR bstr = sVar[i].AllocSysString(); // Convert CString to BSTR
		index = i; // Use correct index
		SafeArrayPutElement(psa, &index, bstr);
		// Do NOT free bstr here! SafeArrayPutElement takes ownership
	}

	pVariant->parray = psa;
	return S_OK;
}

HRESULT __stdcall G_Object::API_PutObjectVars(VARIANT* pVariant) {
	int iNoVars;
	CString sVar[100];
	if (!pVariant)
		return E_POINTER; // Ensure pVariant is valid
	if (pVariant->vt != (VT_ARRAY | VT_BSTR))
		return E_INVALIDARG; // Ensure correct type

	SAFEARRAY* psa = pVariant->parray;
	if (!psa)
		return E_INVALIDARG; // Ensure SAFEARRAY is valid

	LONG lLower, lUpper;
	if (FAILED(SafeArrayGetLBound(psa, 1, &lLower)) ||
	    FAILED(SafeArrayGetUBound(psa, 1, &lUpper))) {
		return E_FAIL;
	}

	iNoVars = lUpper - lLower + 1; // Number of elements

	if (iNoVars > 100) // Ensure it does not exceed array bounds
		return E_FAIL;

	HRESULT hr = S_OK;
	for (LONG i = 0; i < iNoVars; i++) {
		BSTR bstr;
		LONG index = lLower + i;
		if (FAILED(SafeArrayGetElement(psa, &index, &bstr))) {
			hr = E_FAIL;
			break;
		}
		sVar[i] = CString(bstr); // Convert BSTR to CString
		SysFreeString(bstr); // Free BSTR after use
	}
	// G_Object::PutVarValues(PropTable * PT, int iNo, CString sVar[])
	// Problem how to get pointer to propery table
	PutVarValues(PropsT, iNoVars, sVar);
	return hr;
}

BSTR G_Object::API_GetObjectName() {
	CString strObjectName = GetName();
	return strObjectName.AllocSysString(); // Directly return the BSTR
}

//************************************************************
void G_Object::SetVisable(int iOnOff) {
	Visable = iOnOff;
}

void G_Object::SetSelectable(int iOnOff) {
	Selectable = iOnOff;
}

int G_Object::GetCol() {
	int irc;
	if ((iColour >= 0) && (iColour <= 17)) {
		irc = iColour;
	} else {
		irc = 7;
	}
	return (iColour);
}

void G_Object::SetDrawn(int iOnOff) {
	Drawn = iOnOff;
}

G_Object* G_Object::GetObj(int iType, int iLab) {
	return (NULL);
}

int G_Object::isVisable() {
	return (Visable);
}

int G_Object::isDrawn() {
	return (Drawn);
}

int G_Object::isSelectable() {
	return (Selectable);
}

G_Object::G_Object() {
	iFile = -1;
	iType = -1;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	bDrawLab = FALSE;
	pParent = nullptr;
	next = nullptr;
	EnableAutomation();
	// AfxOleLockApp();
}

void G_Object::GetBoundingBox(C3dVector& vll, C3dVector& vur) {
	vll.Set(0, 0, 0);
	vur.Set(0, 0, 0);
}

double G_Object::GetCharSize() {
	return (1.0);
}

void G_Object::ExportDXF(FILE* pFile) {
}

CString G_Object::GetName() {
	return ("Base Object");
}

int G_Object::GetVarHeaders(CString sVar[]) {
	sVar[0] = "NULL";
	return (1);
}

int G_Object::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", -1);
	sVar[0] = S1;
	iNo++;
	return (iNo);
}

void G_Object::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
}

G_Object::~G_Object() {
	// AfxOleUnlockApp();
}

// Create Object

void G_Object::Create() {
	iType = -1;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	pParent = NULL;
	bDrawLab = FALSE;
}

// For Dynamic dragging update
void G_Object::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
}

C3dVector G_Object::MinPt(C3dVector inPt) {
	C3dVector vRet;
	return vRet;
}

G_Object* G_Object::Copy(G_Object* parrent) {
	// G_Object* gret = new G_Object;
	// gret->iObjType=iObjType;
	// gret->iLabel=iLabel;
	// gret->iColour=iColour;
	// gret->Drawn = Drawn;
	// gret->Selectable  = Selectable;
	// gret->Visable  = Visable;
	return (NULL);
}

void G_Object::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
		ar << iObjType;
		ar << iFile;
		ar << iType;
		ar << iLabel;
		ar << iColour;
		ar << Drawn;
		ar << Selectable;
		ar << Visable;
	} else {
		ar >> iObjType;
		// New file number to group include files
		if (iV < -62)
			ar >> iFile;
		else
			iFile = -1;

		if (iV < -52)
			ar >> iType;
		else
			iType = -1;

		ar >> iLabel;
		ar >> iColour;
		ar >> Drawn;
		ar >> Selectable;
		ar >> Visable;
	}
}

CString G_Object::ToString() {
	return ("");
}

void G_Object::Build() {
}

void G_Object::Info() {
	char S1[80];
	CString OutT;
	sprintf_s(S1, "%s %i %s %i %s %i %s %i", "Type", iObjType, "FileNo", iFile, "Label", iLabel, "Col", iColour);
	OutT += S1;
	outtext1(OutT);
}

void G_Object::ModLayNo(int iLay) {
	iFile = iLay;
}

C3dVector G_Object::Get_Centroid() {
	C3dVector vRet;
	vRet.Set(0, 0, 0);
	return (vRet);
}

C3dVector G_Object::Get_Normal() {
	C3dVector vRet;
	vRet.Set(0, 0, 1);
	return (vRet);
}

void G_Object::Draw(CDC* pDC, int iDrawmode) {
}

void G_Object::OglDraw(int iDspFlgs, double dS1, double dS2) {
}

void G_Object::OglDrawW(int DspFlags, double dS1, double dS2) {
}

void G_Object::Transform(C3dMatrix TMat) {
}

void G_Object::Translate(C3dVector vIn) {
}

void G_Object::Move(C3dVector vM) {
}

G_Object* G_Object::OffSet(C3dVector vN, C3dVector vDir, double Dist) {
	return (NULL);
}

C3dVector G_Object::GetPt(double w) {
	C3dVector vR;
	return (vR);
}

C3dVector G_Object::GetInPt() {
	C3dVector vR;
	return (vR);
}

C3dVector G_Object::GetDir(double w) {
	C3dVector vR;
	return (vR);
}

double G_Object::getLen() {
	return (0);
}

void G_Object::HighLight(CDC* pDC) {
	pDC->Ellipse(int(SelPt.x + 8), int(SelPt.y + 8), int(SelPt.x - 8), int(SelPt.y - 8));
}

void G_Object::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	C3dVector vC;
	vC = Get_Centroid();
	vC.SetToScr(pModMat, pScrTran);
	SelPt = vC;
}

G_ObjectD G_Object::SelDist(CPoint InPT, Filter FIL) {
	G_ObjectD Ret;
	double x, y, d;
	x = SelPt.x - InPT.x;
	y = SelPt.y - InPT.y;
	d = (x * x + y * y);
	Ret.Dist = d;
	Ret.pObj = this;
	return (Ret);
}

void G_Object::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	if ((SelPt.x > P1.x) &&
	    (SelPt.x < P2.x) &&
	    (SelPt.y > P1.y) &&
	    (SelPt.y < P2.y)) {
		pSel->AddEx(this);
	}
}

void G_Object::Colour(int iCol) {
	iColour = iCol;
}

void G_Object::RelTo(G_Object* pThis, ObjList* pList, int iType) {
	if (pThis->pParent != NULL) {
		if (pThis->pParent->iObjType == iType) {
			pList->AddEx(pThis->pParent);
		}
	}
}

//**********************************************************************
// Test class for the planet
//**********************************************************************
IMPLEMENT_DYNAMIC(Planet, CObject)

Planet::Planet() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 998;
	pParent = NULL;
	pTexture = nullptr;
}

Planet::~Planet() {
	pTexture = nullptr;
}

// Planet Draw
void Planet::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if ((pTexture != nullptr) && (gDSP_BACK == TRUE)) {
		int width = pTexture->width;
		int height = pTexture->height;
		GLuint textureID;
		glColor3fv(cols[124]);
		glGenTextures(1, &textureID);
		// "Bind" the newly created texture : all future texture functions will modify this texture
		glBindTexture(GL_TEXTURE_2D, textureID);
		// Give the image to OpenGL
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, pTexture->width, pTexture->height, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE,
		             pTexture->data);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glEnable(GL_TEXTURE_2D);
		glEnable(GL_NORMALIZE);
		double dDec;
		double dDec1;
		double dRA;
		double dRA1;
		C3dVector n0;
		C3dVector n1;
		C3dVector n2;
		C3dVector n3;
		float R = 1;
		float x0, y0, z0;
		float x1, y1, z1;
		float x2, y2, z2;
		float x3, y3, z3;
		float tRA, tRA1, tDEC, tDEC1;
		int i, j;
		i = 0, j = 0;
		// glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		glShadeModel(GL_SMOOTH);
		for (i = 0; i < 48; i++) {
			for (j = 0; j < 36; j++) {
				dRA = i * 7.5;
				dRA1 = (i + 1) * 7.5;
				dDec = j * 5 - 90;
				dDec1 = (j + 1) * 5 - 90;
				tRA = dRA / 360;
				tRA1 = dRA1 / 360;
				tDEC = (dDec + 90) / 180;
				tDEC1 = (dDec1 + 90) / 180;
				x0 = R * cos(D2R * dDec) * cos(D2R * dRA);
				y0 = R * cos(D2R * dDec) * sin(D2R * dRA);
				z0 = R * sin(D2R * dDec);
				x1 = R * cos(D2R * dDec) * cos(D2R * dRA1);
				y1 = R * cos(D2R * dDec) * sin(D2R * dRA1);
				z1 = R * sin(D2R * dDec);
				x2 = R * cos(D2R * dDec1) * cos(D2R * dRA1);
				y2 = R * cos(D2R * dDec1) * sin(D2R * dRA1);
				z2 = R * sin(D2R * dDec1);
				x3 = R * cos(D2R * dDec1) * cos(D2R * dRA);
				y3 = R * cos(D2R * dDec1) * sin(D2R * dRA);
				z3 = R * sin(D2R * dDec1);
				n0.Set(x0, y0, z0);
				n1.Set(x1, y1, z1);
				n2.Set(x2, y2, z2);
				n3.Set(x3, y3, z3);
				n0.Normalize();
				n1.Normalize();
				n2.Normalize();
				n3.Normalize();
				glBegin(GL_POLYGON);
				glTexCoord2f(tRA, tDEC);
				glVertex3f(x0, y0, z0);
				glNormal3f((float) n0.x, (float) n0.y, (float) n0.z);
				glTexCoord2f(tRA1, tDEC);
				glVertex3f(x1, y1, z1);
				glNormal3f((float) n1.x, (float) n1.y, (float) n1.z);
				glTexCoord2f(tRA1, tDEC1);
				glVertex3f(x2, y2, z2);
				glNormal3f((float) n2.x, (float) n2.y, (float) n2.z);
				glTexCoord2f(tRA, tDEC1);
				glVertex3f(x3, y3, z3);
				glNormal3f((float) n3.x, (float) n3.y, (float) n3.z);
				glEnd();
			}
		}
		glDeleteTextures(1, &textureID);
	}
}

void Planet::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void Planet::Draw(CDC* pDC, int iDrawmode) {
}

void Planet::AttachTexture(BMP* pT) {
	pTexture = pT;
}

//**********************************************************************
// Test class for the Bitmat BackGround
//**********************************************************************
IMPLEMENT_DYNAMIC(BackGround, CObject)

BackGround::BackGround(double dWPSize) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 999;
	pParent = NULL;
	pTexture = nullptr;
	dS = dWPSize;
}

BackGround::~BackGround() {
	pTexture = nullptr;
}

void BackGround::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if ((pTexture != nullptr) && (gDSP_BACK == TRUE)) {
		int width = pTexture->width;
		int height = pTexture->height;
		double dW = dS;
		double dH = dS;
		double dRatio;
		dRatio = static_cast<double>(height) / width; // Using static_cast to ensure correct division
		dH *= dRatio;

		GLuint textureID;
		glColor3fv(cols[124]);
		glGenTextures(1, &textureID);
		// "Bind" the newly created texture: all future texture functions will modify this texture
		glBindTexture(GL_TEXTURE_2D, textureID);
		// Give the image to OpenGL GL_RGB
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, pTexture->width, pTexture->height, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE,
		             pTexture->data);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glEnable(GL_TEXTURE_2D);
		glEnable(GL_NORMALIZE);
		C3dVector n0;
		C3dVector n1;
		C3dVector n2;
		C3dVector n3;

		// glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		glShadeModel(GL_SMOOTH);

		glBegin(GL_POLYGON);
		glTexCoord2f(0, 0);
		glVertex3f((float) -dW / 2, (float) -dH / 2, (float) -0.1);
		glNormal3f((float) 0.0, (float) 0.0, (float) 1.0);
		glTexCoord2f(1, 0);
		glVertex3f((float) dW / 2, (float) -dH / 2, (float) -0.1);
		glNormal3f((float) 0.0, (float) 0.0, (float) 1.0);
		glTexCoord2f(1, 1);
		glVertex3f((float) dW / 2, (float) dH / 2, (float) -0.1);
		glNormal3f((float) 0.0, (float) 0.0, (float) 1.0);
		glTexCoord2f(0, 1);
		glVertex3f((float) -dW / 2, (float) dH / 2, (float) -0.1);
		glNormal3f((float) 0.0, (float) 0.0, (float) 1.0);
		glEnd();
		glDeleteTextures(1, &textureID);
	}
}

void BackGround::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void BackGround::Draw(CDC* pDC, int iDrawmode) {
}

void BackGround::AttachTexture(BMP* pT) {
	pTexture = pT;
}

//**********************************************
IMPLEMENT_DYNAMIC(Node, CObject)
// Create Object

Node::Node() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 1;
	pResV = NULL;
	pResD = NULL;
	pParent = NULL;
	Pt_Point = NULL;
	DSP_Point = NULL;
	dof[0] = 0;
	dof[1] = 0;
	dof[2] = 0;
	dof[3] = 0;
	dof[4] = 0;
	dof[5] = 0;
	pN = NULL;
}

Node::~Node() {
	delete (Pt_Point);
	delete (DSP_Point);
	Pt_Point = NULL;
	DSP_Point = NULL;
}

void Node::Create(C3dVector InPt, int iLab, int i2, int i3, int iC, int iDef, int iOut, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 1;
	iColour = iC;
	iLabel = iLab;
	Pt_Point = new C3dVector(InPt.x, InPt.y, InPt.z);
	DSP_Point = new C3dVector();
	pParent = Parrent;
	dof[0] = 0;
	dof[1] = 0;
	dof[2] = 0;
	dof[3] = 0;
	dof[4] = 0;
	dof[5] = 0;
	DefSys = iDef;
	OutSys = iOut;
	pResV = NULL;
	pResD = NULL;
	pN = NULL;
}

void Node::Info() {
	char S1[80];
	G_Object::Info();
	sprintf_s(S1, "GRID %8i X %s Y %s Z %s DEFSYS %i OUTSYS %i", iLabel, float8NAS(Pt_Point->x), float8NAS(Pt_Point->y),
	          float8NAS(Pt_Point->z), DefSys, OutSys);
	outtext1(S1);
}

CString Node::ToString() {
	CString sRT;
	char S1[80];
	// New to handle the DEF system eventually
	// ME_Object* ME = (ME_Object*) pParent;
	C3dVector pt(Pt_Point->x, Pt_Point->y, Pt_Point->z);
	int iN = 0;
	int iRID;
	CoordSys* pD;
	ME_Object* ME;

	iRID = this->DefSys;
	if (iRID > 0) {
		ME = (ME_Object*) this->pParent;
		pD = ME->GetSys(iRID);
		if (pD != NULL) {
			C3dMatrix A = pD->mOrientMat;
			A.Transpose();
			if (pD->CysType == 1) {
				pt -= pD->Origin;
				pt = A * pt;
			} else if (pD->CysType == 2) {
				pt -= pD->Origin;
				pt = A * pt;
				C3dVector pCyl;
				pCyl.x = sqrt(pt.x * pt.x + pt.y * pt.y);
				pCyl.y = atan2(pt.y, pt.x) * R2D;
				pCyl.z = pt.z;
				pt = pCyl;
			} else if (pD->CysType == 3) {
				pt -= pD->Origin;
				pt = A * pt;
				C3dVector pCyl;
				pCyl.x = sqrt(pt.x * pt.x + pt.y * pt.y + pt.z * pt.z);
				pCyl.y = acos(pt.z / pCyl.x) * R2D;
				pCyl.z = atan2(pt.y, pt.x) * R2D;
				pt = pCyl;
			}
		}
		//}
	}
	sprintf_s(S1, "%8s%8i%8i%8s%8s%8s%8i\n", "GRID    ", iLabel, DefSys, e8(pt.x).GetString(), e8(pt.y).GetString(),
	          e8(pt.z).GetString(), OutSys);
	sRT = S1;
	return (sRT);
}

C3dVector Node::MinPt(C3dVector inPt) {
	C3dVector vRet;
	vRet.Set(Pt_Point->x, Pt_Point->y, Pt_Point->z);
	return (vRet);
}

void Node::ExportUNV(FILE* pFile) {
	fprintf(pFile, "%10i%10i%10i%10i\n", iLabel, 1, 1, iColour - 150);
	fprintf(pFile, "%25.16E%25.16E%25.16E\n", Pt_Point->x, Pt_Point->y, Pt_Point->z);
}

void Node::ExportNAS(FILE* pFile, CoordSys* pD) {
	// New to handle the DEF system eventually
	// ME_Object* ME = (ME_Object*) pParent;
	C3dVector pt(Pt_Point->x, Pt_Point->y, Pt_Point->z);
	int iN = 0;
	int iRID;
	iRID = this->DefSys;
	if (iRID > 0) {
		if (pD != NULL) {
			C3dMatrix A = pD->mOrientMat;
			A.Transpose();
			if (pD->CysType == 1) {
				pt -= pD->Origin;
				pt = A * pt;
			} else if (pD->CysType == 2) {
				pt -= pD->Origin;
				pt = A * pt;
				C3dVector pCyl;
				pCyl.x = sqrt(pt.x * pt.x + pt.y * pt.y);
				pCyl.y = atan2(pt.y, pt.x) * R2D;
				pCyl.z = pt.z;
				pt = pCyl;
			} else if (pD->CysType == 3) {
				pt -= pD->Origin;
				pt = A * pt;
				C3dVector pCyl;
				pCyl.x = sqrt(pt.x * pt.x + pt.y * pt.y + pt.z * pt.z);
				pCyl.y = acos(pt.z / pCyl.x) * R2D;
				pCyl.z = atan2(pt.y, pt.x) * R2D;
				pt = pCyl;
			}
		}
		//}
	}
	fprintf(pFile, "%8s%8i%8i%8s%8s%8s%8i\n", "GRID    ", iLabel, DefSys, e8(pt.x), e8(pt.y), e8(pt.z), OutSys);
}

G_Object* Node::Copy(G_Object* Parrent) {
	Node* PtRet = new Node;
	PtRet->pParent = Parrent;
	PtRet->Drawn = Drawn;
	PtRet->Selectable = Selectable;
	PtRet->Visable = Visable;
	PtRet->iColour = iColour;
	PtRet->iObjType = iObjType;
	PtRet->iLabel = iLabel;
	PtRet->Pt_Point = new C3dVector(Pt_Point->x, Pt_Point->y, Pt_Point->z);
	PtRet->DSP_Point = new C3dVector();
	PtRet->OutSys = OutSys;
	PtRet->DefSys = DefSys;

	pResV = NULL;
	pResD = NULL;
	return (PtRet);
}

void Node::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << DefSys;
		ar << OutSys;
		ar << Pt_Point->x;
		ar << Pt_Point->y;
		ar << Pt_Point->z;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> DefSys;
		ar >> OutSys;
		Pt_Point = new C3dVector();
		DSP_Point = new C3dVector();
		ar >> Pt_Point->x;
		ar >> Pt_Point->y;
		ar >> Pt_Point->z;
		pResV = NULL;
		pResD = NULL;
	}
}

void Node::Clear() {
}

C3dVector Node::GetCoords() {
	C3dVector vRet;
	vRet.Set(Pt_Point->x, Pt_Point->y, Pt_Point->z);
	return (vRet);
}

C3dVector Node::Get_Centroid() {
	return (GetCoords());
}

// Draw Object line
void Node::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) DSP_Point->x - 4, (int) DSP_Point->y + 4);
	pDC->LineTo((int) DSP_Point->x + 4, (int) DSP_Point->y - 4);
	pDC->MoveTo((int) DSP_Point->x + 4, (int) DSP_Point->y + 4);
	pDC->LineTo((int) DSP_Point->x - 4, (int) DSP_Point->y - 4);
	pDC->MoveTo((int) DSP_Point->x + 4, (int) DSP_Point->y);
	pDC->LineTo((int) DSP_Point->x - 5, (int) DSP_Point->y);
	pDC->MoveTo((int) DSP_Point->x, (int) DSP_Point->y - 4);
	pDC->LineTo((int) DSP_Point->x, (int) DSP_Point->y + 4);
	// pDC->SetPixel(DSP_Point->x, DSP_Point->y+4, 255 );

	// pDC->Ellipse(DSP_Point->x+3,DSP_Point->y+3,DSP_Point->x-3,DSP_Point->y-3);
}

GLubyte BmpND[22] = {
    0x04, 0x00, 0x44, 0x40, 0x24, 0x80, 0x15, 0x00, 0x0e, 0x00, 0xff, 0xe0, 0x0e, 0x00, 0x15, 0x00, 0x24, 0x80, 0x44,
    0x40, 0x04, 0x00};

void Node::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	double x;
	double y;
	double z;
	double dS = 0;
	double dRF = 1.0;
	int ind;
	C3dVector vD;
	ME_Object* ME = (ME_Object*) this->pParent;
	dS = ME->dScale;
	dRF = ME->dResFactor;
	ind = ME->iCVar;
	if ((iDspFlgs & DSP_NODES) > 0) {
		x = Pt_Point->x;
		y = Pt_Point->y;
		z = Pt_Point->z;
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			if (pResD != NULL) {
				vD = pResD->GetVec();
				vD -= ME->vRelDispOff;
				x += vD.x * dS * dRF;
				y += vD.y * dS * dRF;
				z += vD.z * dS * dRF;
			}
		}

		Selectable = 1;
		glColor3fv(cols[GetCol()]);
		glPointSize(gND_SIZE);

		if ((iDspFlgs & DSP_NODES_ASK) > 0) {
			glBegin(GL_POINTS);
			glVertex3f((float) x, (float) y, (float) z);
			glEnd();

		} else {
			glRasterPos3f((float) x, (float) y, (float) z);
			glBitmap(11, 11, 5.0, 5.0, 0.0, 0.0, BmpND);
		}

		// Esp_Mod_Labels_4_27_2025_Start: Added globlal label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "N%i", iLabel);
			OglString(iDspFlgs, (float) x, (float) y, (float) z, &sLab[0]);
		}
		if (((iDspFlgs & DSP_RESLAB) == 0) && (pResV != NULL)) {
			sprintf_s(sLab, "%f", *pResV->GetAddress(ind));
			// Esp_Mod_Label_Old: Offset Labels for Nodes
			// float radius = gND_SIZE / 100;
			// float offset = (radius / 2.0f + 0.15f) * (float)dS1;
			// OglString(iDspFlgs, (float)x + offset, (float)y + offset, (float)z + offset, &sLab[0]);
			// Esp_Mod_Label_Old
		}
	} else {
		Selectable = 0;
	}
}

void Node::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void Node::Move(C3dVector vM) {
	Pt_Point->x += vM.x;
	Pt_Point->y += vM.y;
	Pt_Point->z += vM.z;
}

void Node::Transform(C3dMatrix TMAt) {
	C3dVector R;
	R.x = TMAt.m_00 * Pt_Point->x + TMAt.m_01 * Pt_Point->y + TMAt.m_02 * Pt_Point->z + TMAt.m_30;
	R.y = TMAt.m_10 * Pt_Point->x + TMAt.m_11 * Pt_Point->y + TMAt.m_12 * Pt_Point->z + TMAt.m_31;
	R.z = TMAt.m_20 * Pt_Point->x + TMAt.m_21 * Pt_Point->y + TMAt.m_22 * Pt_Point->z + TMAt.m_32;
	Pt_Point->x = R.x;
	Pt_Point->y = R.y;
	Pt_Point->z = R.z;
}

void Node::Translate(C3dVector vIn) {
	Pt_Point->x += vIn.x;
	Pt_Point->y += vIn.y;
	Pt_Point->z += vIn.z;
}

void Node::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	C3dVector V;
	C3dVector R;
	G_Object::SetToScr(pModMat, pScrTran);

	R.x = Pt_Point->x;
	R.y = Pt_Point->y;
	R.z = Pt_Point->z;
	V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
	V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
	V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;

	R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
	R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
	R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;

	DSP_Point->x = R.x;
	DSP_Point->y = R.y;
	DSP_Point->z = R.z;
}

void Node::SetTo(C3dVector cInVect) {
	Pt_Point->x = cInVect.x;
	Pt_Point->y = cInVect.y;
	Pt_Point->z = cInVect.z;
}

CString Node::GetName() {
	return ("Node (GRID)");
}

int Node::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "Def CYS";
	iNo++;
	sVar[iNo] = "Out CYS";
	iNo++;
	sVar[iNo] = "X";
	iNo++;
	sVar[iNo] = "Y";
	iNo++;
	sVar[iNo] = "Z";
	iNo++;
	return (iNo);
}

int Node::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", DefSys);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", OutSys);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", Pt_Point->x);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", Pt_Point->y);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", Pt_Point->z);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void Node::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	DefSys = atoi(sVar[1]);
	OutSys = atof(sVar[2]);
	;
	Pt_Point->x = atof(sVar[3]);
	;
	;
	Pt_Point->y = atof(sVar[4]);
	;
	;
	Pt_Point->z = atof(sVar[5]);
	;
	;
}

eFace::eFace() {
	iObjType = 9;
	iColour = 1;
	NoVert = 0;
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	pVertex[2] = NULL;
	pVertex[3] = NULL;
	pParent = NULL;
	next = NULL;
}

eFace::~eFace() {
	NoVert = 0;
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	pVertex[2] = NULL;
	pVertex[3] = NULL;
	pParent = NULL;
	next = NULL;
}

BOOL eFace::isSame(eFace* inFace) {
	BOOL brc = FALSE;
	int i, j, iC;
	iC = 0;
	if (NoVert == inFace->NoVert) {
		for (i = 0; i < NoVert; i++) {
			for (j = 0; j < NoVert; j++) {
				if (pVertex[i] == inFace->pVertex[j]) {
					iC++;
				}
			}
		}
		if (iC == NoVert) {
			brc = TRUE;
		}
	}
	return (brc);
}

void eFace::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	C3dVector v1;
	C3dVector v2;
	C3dVector Vn;
	glLineWidth(gFC_SIZE);
	glColor3fv(cols[124]);
	if (NoVert == 3) {
		glBegin(GL_LINES);
		glVertex3f((float) (pVertex[0]->Pt_Point->x), (float) (pVertex[0]->Pt_Point->y),
		           (float) (pVertex[0]->Pt_Point->z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x), (float) (pVertex[1]->Pt_Point->y),
		           (float) (pVertex[1]->Pt_Point->z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x), (float) (pVertex[1]->Pt_Point->y),
		           (float) (pVertex[1]->Pt_Point->z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x), (float) (pVertex[2]->Pt_Point->y),
		           (float) (pVertex[2]->Pt_Point->z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x), (float) (pVertex[2]->Pt_Point->y),
		           (float) (pVertex[2]->Pt_Point->z));
		glVertex3f((float) (pVertex[0]->Pt_Point->x), (float) (pVertex[0]->Pt_Point->y),
		           (float) (pVertex[0]->Pt_Point->z));
		glEnd();
	} else if (NoVert == 4) {
		glBegin(GL_LINES);
		glVertex3f((float) (pVertex[0]->Pt_Point->x), (float) (pVertex[0]->Pt_Point->y),
		           (float) (pVertex[0]->Pt_Point->z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x), (float) (pVertex[1]->Pt_Point->y),
		           (float) (pVertex[1]->Pt_Point->z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x), (float) (pVertex[1]->Pt_Point->y),
		           (float) (pVertex[1]->Pt_Point->z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x), (float) (pVertex[2]->Pt_Point->y),
		           (float) (pVertex[2]->Pt_Point->z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x), (float) (pVertex[2]->Pt_Point->y),
		           (float) (pVertex[2]->Pt_Point->z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x), (float) (pVertex[3]->Pt_Point->y),
		           (float) (pVertex[3]->Pt_Point->z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x), (float) (pVertex[3]->Pt_Point->y),
		           (float) (pVertex[3]->Pt_Point->z));
		glVertex3f((float) (pVertex[0]->Pt_Point->x), (float) (pVertex[0]->Pt_Point->y),
		           (float) (pVertex[0]->Pt_Point->z));
		glEnd();
	}
	glLineWidth(2.0);
}

C3dVector eFace::Get_Centroid() {
	C3dVector vT;
	vT.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < NoVert; j++) {
		vT += pVertex[j]->Get_Centroid();
	}
	vT.x /= NoVert;
	vT.y /= NoVert;
	vT.z /= NoVert;
	return (vT);
}

void eFace::RelTo(G_Object* pThis, ObjList* pList, int iType) {
	int j;
	if (iType == 1) {
		for (j = 0; j < NoVert; j++)
			pList->AddEx(pVertex[j]);
	}
}

void eFace::Serialize(CArchive& ar, int iV) {
}

void eFace::OglDraw(int iDspFlgs, double dS1, double dS2) {
	C3dVector v1;
	C3dVector v2;
	C3dVector Vn;
	if (NoVert == 3) {
		v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
		v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
		v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

		v2.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
		v2.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
		v2.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;
		Vn = v1.Cross(v2);

		Vn.Normalize();
		glBegin(GL_POLYGON);
		glColor3fv(cols[iColour]);
		glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
		glVertex3f((float) pVertex[0]->Pt_Point->x, (float) pVertex[0]->Pt_Point->y, (float) pVertex[0]->Pt_Point->z);
		glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
		glVertex3f((float) pVertex[1]->Pt_Point->x, (float) pVertex[1]->Pt_Point->y, (float) pVertex[1]->Pt_Point->z);
		glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
		glVertex3f((float) pVertex[2]->Pt_Point->x, (float) pVertex[2]->Pt_Point->y, (float) pVertex[2]->Pt_Point->z);
		glEnd();
	} else if (NoVert == 4) {
		v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
		v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
		v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;
		v2.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
		v2.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
		v2.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;
		Vn = v1.Cross(v2);
		Vn.Normalize();
		glBegin(GL_POLYGON);
		glColor3fv(cols[iColour]);
		glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
		glVertex3f((float) pVertex[0]->Pt_Point->x, (float) pVertex[0]->Pt_Point->y, (float) pVertex[0]->Pt_Point->z);
		glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
		glVertex3f((float) pVertex[1]->Pt_Point->x, (float) pVertex[1]->Pt_Point->y, (float) pVertex[1]->Pt_Point->z);
		glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
		glVertex3f((float) pVertex[2]->Pt_Point->x, (float) pVertex[2]->Pt_Point->y, (float) pVertex[2]->Pt_Point->z);
		glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
		glVertex3f((float) pVertex[3]->Pt_Point->x, (float) pVertex[3]->Pt_Point->y, (float) pVertex[3]->Pt_Point->z);
		glEnd();
	}
}

eEdge::eEdge() {
	iObjType = 8;
	iColour = -1;
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	next = NULL;
	before = NULL;
	pParent = NULL;
}

eEdge::~eEdge() {
	iColour = -1;
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	next = NULL;
	before = NULL;
	pParent = NULL;
}

BOOL eEdge::isSame(eEdge* inLink) {
	BOOL brc = FALSE;
	if (inLink != NULL) {
		if ((pVertex[0] == inLink->pVertex[0]) &&
		    (pVertex[1] == inLink->pVertex[1])) {
			brc = TRUE;
		} else if ((pVertex[1] == inLink->pVertex[0]) &&
		           (pVertex[0] == inLink->pVertex[1])) {
			brc = TRUE;
		}
	}
	return (brc);
}

void eEdge::Info() {
	char S1[80];
	G_Object::Info();
	sprintf_s(S1, "LAB: %i X: %f Y: %f Z: %f", pVertex[0]->iLabel, pVertex[0]->Pt_Point->x, pVertex[0]->Pt_Point->y,
	          pVertex[0]->Pt_Point->z);
	outtext1(_T(S1));
	sprintf_s(S1, "LAB: %i X: %f Y: %f Z: %f", pVertex[1]->iLabel, pVertex[1]->Pt_Point->x, pVertex[1]->Pt_Point->y,
	          pVertex[1]->Pt_Point->z);
	outtext1(_T(S1));
}

void eEdge::Reverse() {
	Node* pN;
	pN = pVertex[0];
	pVertex[0] = pVertex[1];
	pVertex[1] = pN;
}

// 0 not the same
// 1 the same
// 2 the same bit wrond direction

int eEdge::isSameWithDir(eEdge* inLink) {
	int irc = 0;
	if ((pVertex[0] == inLink->pVertex[0]) &&
	    (pVertex[1] == inLink->pVertex[1])) {
		irc = 1;
	} else if ((pVertex[1] == inLink->pVertex[0]) &&
	           (pVertex[0] == inLink->pVertex[1])) {
		irc = 2;
	}
	return (irc);
}

void eEdge::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	glLineWidth(gED_SIZE);
	glColor3fv(cols[iColour]);
	glBegin(GL_LINES);
	glVertex3f((float) pVertex[0]->Pt_Point->x, (float) pVertex[0]->Pt_Point->y, (float) pVertex[0]->Pt_Point->z);
	glVertex3f((float) pVertex[1]->Pt_Point->x, (float) pVertex[1]->Pt_Point->y, (float) pVertex[1]->Pt_Point->z);
	glEnd();
	//

	// int i;
	// double X, Y, Z;
	// C3dVector Point[2];
	// C3dVector vDir;
	// C3dVector Pts[7];  //Arrow Head
	// C3dMatrix mT;
	// C3dVector vOff;
	//
	//	Selectable = 1;
	//	Point[0] = pVertex[0]->Pt_Point;
	//	Point[1] = pVertex[1]->Pt_Point;
	//	vOff.Set(AHead[0][0], AHead[0][1], AHead[0][2]);
	//	vDir = Point[1]- Point[0];
	//
	//	vDir.Normalize();
	//	mT = vDir.GetTMat();
	//
	//	for (i = 0; i < 7; i++)
	//	{
	//		Pts[i].Set(AHead[i][0], AHead[i][1], AHead[i][2]);
	//		Pts[i] -= vOff;
	//		Pts[i] = mT.Mult(Pts[i]);
	//		Pts[i] *= 0.2 * dS1;
	//	}
	//	X = Point[1].x; Y = Point[1].y; Z = Point[1].z;
	//
	//	glColor3fv(cols[iColour]);
	//	glBegin(GL_LINES);
	//	glVertex3f((float)Point[0].x, (float)Point[0].y, (float)Point[0].z);
	//	glVertex3f((float)Point[1].x, (float)Point[1].y, (float)Point[1].z);
	//	glEnd();
	//	glPointSize(10.0f);
	//	glBegin(GL_POINTS);
	//	glVertex3f((float)0.5 * (Point[0].x + Point[1].x), (float)0.5 * (Point[0].y + Point[1].y), (float)0.5 * (Point[0].z + Point[1].z));
	//	glEnd();
	//	glBegin(GL_POLYGON);
	//	glVertex3f((float)Pts[0].x + X, (float)Pts[0].y + Y, (float)Pts[0].z + Z);
	//	glVertex3f((float)Pts[2].x + X, (float)Pts[2].y + Y, (float)Pts[2].z + Z);
	//	glVertex3f((float)Pts[1].x + X, (float)Pts[1].y + Y, (float)Pts[1].z + Z);
	//	glEnd();
	//	glBegin(GL_POLYGON);
	//	glVertex3f((float)Pts[0].x + X, (float)Pts[0].y + Y, (float)Pts[0].z + Z);
	//	glVertex3f((float)Pts[3].x + X, (float)Pts[3].y + Y, (float)Pts[3].z + Z);
	//	glVertex3f((float)Pts[2].x + X, (float)Pts[2].y + Y, (float)Pts[2].z + Z);
	//	glEnd();
	//	glBegin(GL_POLYGON);
	//	glVertex3f((float)Pts[0].x + X, (float)Pts[0].y + Y, (float)Pts[0].z + Z);
	//	glVertex3f((float)Pts[4].x + X, (float)Pts[4].y + Y, (float)Pts[4].z + Z);
	//	glVertex3f((float)Pts[3].x + X, (float)Pts[3].y + Y, (float)Pts[3].z + Z);
	//	glEnd();
	//	glBegin(GL_POLYGON);
	//	glVertex3f((float)Pts[0].x + X, (float)Pts[0].y + Y, (float)Pts[0].z + Z);
	//	glVertex3f((float)Pts[5].x + X, (float)Pts[5].y + Y, (float)Pts[5].z + Z);
	//	glVertex3f((float)Pts[4].x + X, (float)Pts[4].y + Y, (float)Pts[4].z + Z);
	//	glEnd();
	//	glBegin(GL_POLYGON);
	//	glVertex3f((float)Pts[0].x + X, (float)Pts[0].y + Y, (float)Pts[0].z + Z);
	//	glVertex3f((float)Pts[6].x + X, (float)Pts[6].y + Y, (float)Pts[6].z + Z);
	//	glVertex3f((float)Pts[5].x + X, (float)Pts[5].y + Y, (float)Pts[5].z + Z);
	//	glEnd();
	//	glBegin(GL_POLYGON);
	//	glVertex3f((float)Pts[0].x + X, (float)Pts[0].y + Y, (float)Pts[0].z + Z);
	//	glVertex3f((float)Pts[1].x + X, (float)Pts[1].y + Y, (float)Pts[1].z + Z);
	//	glVertex3f((float)Pts[6].x + X, (float)Pts[6].y + Y, (float)Pts[6].z + Z);
	//	glEnd();
	glLineWidth(2.0);
}

void eEdge::Serialize(CArchive& ar, int iV) {
}

void eEdge::RelTo(G_Object* pThis, ObjList* pList, int iType) {
	if (iType == 1) {
		pList->AddEx(pVertex[0]);
		pList->AddEx(pVertex[1]);
	}
}

C3dVector eEdge::Get_Centroid() {
	C3dVector vT;
	vT.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < 2; j++) {
		vT += pVertex[j]->Get_Centroid();
	}
	vT.x /= 2;
	vT.y /= 2;
	vT.z /= 2;
	return (vT);
}

void eEdge::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

c2dParPt::c2dParPt() {
	pParent = NULL;
	next = NULL;
	before = NULL;
}

c2dParPt::c2dParPt(double x, double y) {
	pParent = NULL;
	next = NULL;
	before = NULL;
	PP.x = x;
	PP.y = y;
}

c2dParPt::~c2dParPt() {
	next = NULL;
	before = NULL;
	pParent = NULL;
}

// Segment class used for 2d mesh generation
cSeg::cSeg() {
	pParent = NULL;
	pt[0] = NULL;
	pt[1] = NULL;
}

cSeg::cSeg(G_Object* pP) {
	iColour = 4;
	iObjType = 14;
	next = NULL;
	before = NULL;
	pParent = pP;
	pt[0] = NULL;
	pt[1] = NULL;
}

cSeg::cSeg(G_Object* pP, double x1, double y1, double x2, double y2) {
	iColour = 4;
	iObjType = 14;
	next = NULL;
	before = NULL;
	pParent = pP;
	pt[0] = new c2dParPt(x1, y1);
	pt[1] = new c2dParPt(x2, y2);
	CalcMids();
}

cSeg::~cSeg() {
	next = NULL;
	before = NULL;
	pParent = NULL;
	pt[0] = NULL;
	pt[1] = NULL;
}

void cSeg::CalcMids() {
	double x, y;
	MpT.x = 0.5 * (pt[0]->PP.x + pt[1]->PP.x);
	MpT.y = 0.5 * (pt[0]->PP.y + pt[1]->PP.y);
	x = pt[1]->PP.x - pt[0]->PP.x;
	y = pt[1]->PP.y - pt[0]->PP.y;
	dL = pow(x * x + y * y, 0.5);
}

BOOL cSeg::HasCommonVert(c2dParPt* p1, c2dParPt* p2) {
	BOOL bRet = FALSE;
	if ((pt[0] == p1) || (pt[1] == p1) ||
	    (pt[0] == p2) || (pt[1] == p2)) {
		bRet = TRUE;
	}
	return (bRet);
}

void cSeg::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	C3dVector vA, vB, vV;
	C3dMatrix mT;
	int i;
	double X, Y, Z;
	C3dVector p2;
	C3dVector Pts[7];
	if (pParent != NULL) {
		if ((pParent->iObjType == 15) || (pParent->iObjType == 16) || (pParent->iObjType == 17)) {
			NSurf* pS = (NSurf*) pParent;
			if ((pt[0] != NULL) && (pt[1] != NULL)) {
				vA = pS->GetPt(pt[0]->PP.x, pt[0]->PP.y);
				vB = pS->GetPt(pt[1]->PP.x, pt[1]->PP.y);
				p2 = vB;
				vV = vB - vA;
				vV.Normalize();
				mT = vV.GetTMat();
				// Create Arrow Head
				for (i = 0; i < 7; i++) {
					Pts[i].Set(AHead[i][0] - 2.0, AHead[i][1], AHead[i][2]);
					Pts[i] = mT.Mult(Pts[i]);
					Pts[i] *= 0.2;
				}
				X = Pts[0].x;
				Y = Pts[0].y;
				Z = Pts[0].z;
				glLineWidth(5.0);
				glColor3fv(cols[iColour]);
				glBegin(GL_LINES);
				glVertex3f((float) vA.x, (float) vA.y, (float) vA.z);
				glVertex3f((float) vB.x, (float) vB.y, (float) vB.z);
				glEnd();
				glLineWidth(2.0);
				glBegin(GL_POLYGON);
				glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
				glVertex3f((float) Pts[2].x * dS1 + p2.x, (float) Pts[2].y * dS1 + p2.y, (float) Pts[2].z * dS1 + p2.z);
				glVertex3f((float) Pts[1].x * dS1 + p2.x, (float) Pts[1].y * dS1 + p2.y, (float) Pts[1].z * dS1 + p2.z);
				glEnd();
				glBegin(GL_POLYGON);
				glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
				glVertex3f((float) Pts[3].x * dS1 + p2.x, (float) Pts[3].y * dS1 + p2.y, (float) Pts[3].z * dS1 + p2.z);
				glVertex3f((float) Pts[2].x * dS1 + p2.x, (float) Pts[2].y * dS1 + p2.y, (float) Pts[2].z * dS1 + p2.z);
				glEnd();
				glBegin(GL_POLYGON);
				glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
				glVertex3f((float) Pts[4].x * dS1 + p2.x, (float) Pts[4].y * dS1 + p2.y, (float) Pts[4].z * dS1 + p2.z);
				glVertex3f((float) Pts[3].x * dS1 + p2.x, (float) Pts[3].y * dS1 + p2.y, (float) Pts[3].z * dS1 + p2.z);
				glEnd();
				glBegin(GL_POLYGON);
				glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
				glVertex3f((float) Pts[5].x * dS1 + p2.x, (float) Pts[5].y * dS1 + p2.y, (float) Pts[5].z * dS1 + p2.z);
				glVertex3f((float) Pts[4].x * dS1 + p2.x, (float) Pts[4].y * dS1 + p2.y, (float) Pts[4].z * dS1 + p2.z);
				glEnd();
				glBegin(GL_POLYGON);
				glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
				glVertex3f((float) Pts[6].x * dS1 + p2.x, (float) Pts[6].y * dS1 + p2.y, (float) Pts[6].z * dS1 + p2.z);
				glVertex3f((float) Pts[5].x * dS1 + p2.x, (float) Pts[5].y * dS1 + p2.y, (float) Pts[5].z * dS1 + p2.z);
				glEnd();
				glBegin(GL_POLYGON);
				glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
				glVertex3f((float) Pts[1].x * dS1 + p2.x, (float) Pts[1].y * dS1 + p2.y, (float) Pts[1].z * dS1 + p2.z);
				glVertex3f((float) Pts[6].x * dS1 + p2.x, (float) Pts[6].y * dS1 + p2.y, (float) Pts[6].z * dS1 + p2.z);
				glEnd();
			}
		}
	}
}

C2dVector cSeg::Get_Mid() {
	return (MpT);
}

void cSeg::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

c2dFront::c2dFront() {
	pParent = NULL;
	dA = 180;
	iPID = -1;
	fNodes = new cLinkedList();
}

c2dFront::~c2dFront() {
	if (fNodes != NULL) {
		fNodes->DeleteAll();
		fNodes = NULL;
	}
}

Node* c2dFront::isSegBet(int pL, int pH) {
	Node* oRet = NULL;
	Node* pN;
	pN = (Node*) fNodes->Head;
	while (pN != NULL) {
		if (pL == pN->iColour) {
			if (pN->next->iColour != pH) {
				oRet = (Node*) pN->next;
				break;
			}
		}
		pN = (Node*) pN->next;
	}
	return (oRet);
}

Node* c2dFront::GetNodeByGID(int iGID) {
	// node colour has been used to identify the GPLY ID
	Node* oRet = NULL;
	Node* pN;
	pN = (Node*) fNodes->Head;
	while (pN != NULL) {
		if (iGID == pN->iColour) {
			oRet = (Node*) pN;
			break;
		}
		pN = (Node*) pN->next;
	}
	return (oRet);
}

void c2dFront::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	fNodes->SetToScr(pModMat, pScrTran);
}

void c2dFront::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	fNodes->OglDrawW(iDspFlgs, dS1, dS2);
}

void c2dFront::OglDraw(int iDspFlgs, double dS1, double dS2) {
	fNodes->OglDraw(iDspFlgs, dS1, dS2);
}

eFaceList::eFaceList() {
	Head = NULL;
	pCur = NULL;
	iNo = 0;
}

eFaceList::~eFaceList() {
	eFace* pNext;
	eFace* p;
	p = Head;
	while (p != NULL) {
		pNext = (eFace*) p->next;
		delete (p);
		p = pNext;
	}
	Head = NULL;
	pCur = NULL;
}

eFace* eFaceList::IsIn(eFace* inFace) {
	eFace* pRet = NULL;
	eFace* pNext;
	pNext = Head;
	while (pNext != NULL) {
		if (pNext->isSame(inFace) == TRUE) {
			pRet = pNext;
			break;
		}
		pNext = (eFace*) pNext->next;
	}
	return (pRet);
}

void eFaceList::Add(eFace* inFace) {
	eFace* ind;
	ind = IsIn(inFace);
	if (ind == NULL) {
		if (Head == NULL) {
			inFace->before = NULL;
			inFace->next = NULL;
			Head = inFace;
			pCur = inFace;
			iNo++;
		} else {
			inFace->before = pCur;
			pCur->next = inFace;
			pCur = (eFace*) inFace;
			pCur->next = NULL;
			iNo++;
		}
	} else {
		Remove(ind);
	}
}

void eFaceList::Remove(eFace* inFace) {
	if (inFace != NULL) {
		if ((inFace->before != NULL) && (inFace->next != NULL)) // in middle with a befor and after
		{
			inFace->before->next = inFace->next;
			inFace->next->before = inFace->before;
			delete (inFace);
			iNo--;
		} else if (inFace->before == NULL) {
			Head = (eFace*) inFace->next;
			Head->before = NULL;
			delete (inFace);
			iNo--;
		} else if (inFace->next == NULL) {
			pCur = (eFace*) inFace->before;
			pCur->next = NULL;
			delete (inFace);
			iNo--;
		}
	}
}

void eFaceList::OglDraw(int iDspFlgs, double dS1, double dS2) {
	eFace* pNext;
	pNext = Head;
	while (pNext != NULL) {
		pNext->OglDraw(iDspFlgs, dS1, dS2);
		pNext = (eFace*) pNext->next;
	}
}

void eFaceList::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	eFace* pNext;
	pNext = Head;
	while (pNext != NULL) {
		pNext->OglDrawW(iDspFlgs, dS1, dS2);
		pNext = (eFace*) pNext->next;
	}
}

eEdgeList::eEdgeList() {
	Head = NULL;
	pCur = NULL;
	iNo = 0;
}

eEdgeList::~eEdgeList() {
	eEdge* pNext;
	eEdge* p;
	p = Head;
	while (p != NULL) {
		pNext = (eEdge*) p->next;
		delete (p);
		p = pNext;
	}
	Head = NULL;
	pCur = NULL;
}

eEdge* eEdgeList::IsIn(eEdge* inLink) {
	eEdge* pRet = NULL;
	eEdge* pNext;
	pNext = Head;
	while (pNext != NULL) {
		if (pNext->isSame(inLink) == TRUE) {
			pRet = pNext;
			break;
		}
		pNext = (eEdge*) pNext->next;
	}
	return (pRet);
}

void eEdgeList::AddGp(int iN, eEdge* inLink[]) {
	int i;
	for (i = 0; i < iN; i++) {
		Add(inLink[i]);
	}
}

void eEdgeList::Add(eEdge* inLink) {
	eEdge* ind;
	ind = IsIn(inLink);
	if (ind == NULL) {
		if (Head == NULL) {
			inLink->before = NULL;
			inLink->next = NULL;
			Head = inLink;
			pCur = inLink;
			iNo++;
		} else {
			inLink->before = pCur;
			pCur->next = inLink;
			pCur = (eEdge*) inLink;
			pCur->next = NULL;
			iNo++;
		}
	} else {
		Remove(ind);
	}
}

void eEdgeList::AddIncOnly(eEdge* inLink) {
	eEdge* ind;
	ind = IsIn(inLink);
	if (ind == NULL) {
		if (Head == NULL) {
			inLink->before = NULL;
			inLink->next = NULL;
			Head = inLink;
			pCur = inLink;
			iNo++;
		} else {
			inLink->before = pCur;
			pCur->next = inLink;
			pCur = (eEdge*) inLink;
			pCur->next = NULL;
			iNo++;
		}
	} else {
		ind->iColour++;
		;
	}
}

void eEdgeList::Remove(eEdge* inLink) {
	if (inLink != NULL) {
		if ((inLink->before != NULL) && (inLink->next != NULL)) // in middle with a befor and after
		{
			inLink->before->next = inLink->next;
			inLink->next->before = inLink->before;
			delete (inLink);
			iNo--;
		} else if ((inLink->before == NULL) && (inLink->next == NULL)) {
			Head->before = NULL;
			Head->next = NULL;
			Head = NULL;
			delete (inLink);
			iNo--;
		} else if (inLink->before == NULL) {
			Head = (eEdge*) inLink->next;
			Head->before = NULL;
			delete (inLink);
			iNo--;
		} else if (inLink->next == NULL) {
			pCur = (eEdge*) inLink->before;
			pCur->next = NULL;
			delete (inLink);
			iNo--;
		}
	}
}

void eEdgeList::Purge() {
	eEdge* pNext;
	eEdge* pDel;
	pNext = Head;
	while (pNext != NULL) {
		if (pNext->iColour == 1) {
			pDel = pNext;
			pNext = (eEdge*) pNext->next;
			Remove(pDel);
		} else {
			if (pNext->iColour > 1)
				pNext->iColour = 50;
			else
				pNext->iColour = 120;
			pNext = (eEdge*) pNext->next;
		}
	}
}

void eEdgeList::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	eEdge* pNext;
	pNext = Head;
	while (pNext != NULL) {
		pNext->OglDrawW(iDspFlgs, dS1, dS2);
		pNext = (eEdge*) pNext->next;
	}
}

void eEdgeList::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

//****************************************************************************
// 26/09/2016
// Link class simples way of storing lists of lines
// used for symbols
//****************************************************************************

Link::Link() {
	pNext = NULL;
	p1 = NULL;
	p2 = NULL;
}

Link::Link(double x1, double y1, double z1,
           double x2, double y2, double z2) {
	pNext = NULL;
	p1 = new CvPt_Object();
	p2 = new CvPt_Object();

	p1->Pt_Point->x = x1;
	p1->Pt_Point->y = y1;
	p1->Pt_Point->z = z1;
	p2->Pt_Point->x = x2;
	p2->Pt_Point->y = y2;
	p2->Pt_Point->z = z2;
}

Link::~Link() {
	if (p1 != NULL)
		delete (p1);
	if (p2 != NULL)
		delete (p2);
	pNext = NULL;
}

void Link::ExportDXF(FILE* pFile, int iLay) {
	// fprintf(pFile, "%8i", pVertex[0]->iLabel);
	fprintf(pFile, "LINE\n"); // write the LINE entity
	fprintf(pFile, "  8\n"); // write a line with value 8
	fprintf(pFile, "%s\n", "All"); // write the layer number
	fprintf(pFile, " 10\n"); // write a line with value 10
	fprintf(pFile, "%g\n", p1->Pt_Point->x); // write the x-coordinate of the first point
	fprintf(pFile, " 20\n"); // write a line with value 20
	fprintf(pFile, "%g\n", p1->Pt_Point->y); // write the y-coordinate of the first point
	fprintf(pFile, " 30\n"); // write a line with value 30
	fprintf(pFile, "%g\n", p1->Pt_Point->z); // write the z-coordinate of the first point
	fprintf(pFile, " 11\n"); // write a line with value 11
	fprintf(pFile, "%g\n", p2->Pt_Point->x); // write the x-coordinate of the second point
	fprintf(pFile, " 21\n"); // write a line with value 21
	fprintf(pFile, "%g\n", p2->Pt_Point->y); // write the y-coordinate of the second point
	fprintf(pFile, " 31\n"); // write a line with value 31
	fprintf(pFile, "%g\n", p2->Pt_Point->z); // write the z-coordinate of the second point
	fprintf(pFile, "  0\n"); // write a line with value 0
}

IMPLEMENT_DYNAMIC(Line_Object, CObject)

Line_Object::~Line_Object() {
	delete (pVertex1);
	delete (pVertex2);
}

void Line_Object::Create(C3dVector* pInVertex1, C3dVector* pInVertex2, int iLab, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	int i = 0;
	iObjType = 2;
	iLabel = iLab;
	C3dVector InVect;
	InVect.x = pInVertex1->x;
	InVect.y = pInVertex1->y;
	InVect.z = pInVertex1->z;
	pVertex1 = new CvPt_Object;
	pVertex1->Create(InVect, 0, 0, 0, 0, 11, this);
	pVertex1->SetVisable(0);
	InVect.x = pInVertex2->x;
	InVect.y = pInVertex2->y;
	InVect.z = pInVertex2->z;
	pVertex2 = new CvPt_Object;
	pVertex2->Create(InVect, 0, 0, 0, 0, 11, this);
	pVertex2->SetVisable(0);
	pParent = Parrent;
}

void Line_Object::SetP1(double dx, double dy, double dz) {
	pVertex1->Pt_Point->x = dx;
	pVertex1->Pt_Point->y = dy;
	pVertex1->Pt_Point->z = dz;
}

void Line_Object::SetP2(double dx, double dy, double dz) {
	pVertex2->Pt_Point->x = dx;
	pVertex2->Pt_Point->y = dy;
	pVertex2->Pt_Point->z = dz;
}

C3dVector Line_Object::MinPt(C3dVector inPt) {
	C3dVector vRet;
	C3dVector v1;
	C3dVector v2;
	C3dVector P1;
	C3dVector P2;
	double dm;
	double dDot;
	P1.Set(pVertex1->Pt_Point->x,
	       pVertex1->Pt_Point->y,
	       pVertex1->Pt_Point->z);
	P2.Set(pVertex2->Pt_Point->x,
	       pVertex2->Pt_Point->y,
	       pVertex2->Pt_Point->z);
	v1 = P2;
	v1 -= P1;
	v2 = inPt;
	v2 -= P1;
	dm = v2.Mag();
	v1.Normalize();
	v2.Normalize();
	dDot = v2.Dot(v1);
	dm = dm * dDot;
	vRet = P1 + v1 * dm;
	return vRet;
}

void Line_Object::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		pVertex1->Serialize(ar, iV);
		pVertex2->Serialize(ar, iV);
	} else {
		G_Object::Serialize(ar, iV);
		pVertex1 = new CvPt_Object;
		pVertex2 = new CvPt_Object;
		pVertex1->Serialize(ar, iV);
		pVertex2->Serialize(ar, iV);
	}
}

C3dVector Line_Object::Get_Centroid() {
	return (GetPt(0.5));
}

G_Object* Line_Object::Copy(G_Object* parrent) {
	Line_Object* rLn = new Line_Object;
	rLn->Drawn = Drawn;
	rLn->Selectable = Selectable;
	rLn->Visable = Visable;
	rLn->iColour = iColour;
	rLn->iObjType = iObjType;
	rLn->iLabel = iLabel;
	rLn->pVertex1 = (CvPt_Object*) pVertex1->Copy(rLn);
	rLn->pVertex2 = (CvPt_Object*) pVertex2->Copy(rLn);
	pParent = parrent;
	return (rLn);
}

void Line_Object::Info() {
	char S1[80];
	CString OutT;
	sprintf_s(S1, "%s%i%s%i%s%i", "Type ", iObjType, "; Label ", iLabel, " Col; ", iColour);
	OutT += S1;
	outtext1("LINE OBJECT");
	outtext1(OutT);
	outtext1("    ****");
}

CvPt_Object* Line_Object::GetTEnd() {
	if (dUsel < 0.5) {
		return (pVertex1);
	} else {
		return (pVertex2);
	}
}

void Line_Object::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex1->DSP_Point->x, (int) pVertex1->DSP_Point->y);
	pDC->LineTo((int) pVertex2->DSP_Point->x, (int) pVertex2->DSP_Point->y);
}

void Line_Object::OglDraw(int iDspFlgs, double dS1, double dS2) {
	glColor3fv(cols[GetCol()]);
	glBegin(GL_LINES);
	glVertex3f((float) pVertex1->Pt_Point->x, (float) pVertex1->Pt_Point->y, (float) pVertex1->Pt_Point->z);
	glVertex3f((float) pVertex2->Pt_Point->x, (float) pVertex2->Pt_Point->y, (float) pVertex2->Pt_Point->z);
	glEnd();
}

void Line_Object::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	glColor3fv(cols[GetCol()]);
	glBegin(GL_LINES);
	glVertex3f((float) pVertex1->Pt_Point->x, (float) pVertex1->Pt_Point->y, (float) pVertex1->Pt_Point->z);
	glVertex3f((float) pVertex2->Pt_Point->x, (float) pVertex2->Pt_Point->y, (float) pVertex2->Pt_Point->z);
	glEnd();
}

void Line_Object::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	pVertex1->SetToScr(pModMat, pScrTran);
	pVertex2->SetToScr(pModMat, pScrTran);
}

void Line_Object::HighLight(CDC* pDC) {
	pDC->MoveTo((int) pVertex1->DSP_Point->x, (int) pVertex1->DSP_Point->y);
	pDC->LineTo((int) pVertex2->DSP_Point->x, (int) pVertex2->DSP_Point->y);
}

void Line_Object::Transform(C3dMatrix TMat) {
	pVertex1->Transform(TMat);
	pVertex2->Transform(TMat);
}

G_ObjectD Line_Object::SelDist(CPoint InPT, Filter FIL) {
	CPoint cPt;
	G_ObjectD Ret;
	double MinDist = 100000000000000.0;
	double dDist = 0;
	double fred;
	int iCnt1;

	for (iCnt1 = 5; iCnt1 < 16; iCnt1++) {
		fred = iCnt1 * 0.05;
		cPt.x = (long) (fred * (pVertex2->DSP_Point->x - pVertex1->DSP_Point->x) + pVertex1->DSP_Point->x) - InPT.x;
		cPt.y = (long) (fred * (pVertex2->DSP_Point->y - pVertex1->DSP_Point->y) + pVertex1->DSP_Point->y) - InPT.y;
		dDist = cPt.x * cPt.x + cPt.y * cPt.y;

		if (dDist < MinDist) {
			MinDist = dDist;
			dUsel = fred;
		}
		// pDC->Ellipse(ThePoint.DSP_Point->x+5,ThePoint.DSP_Point->y+5,ThePoint.DSP_Point->x-5,ThePoint.DSP_Point->y-5);
	}
	Ret.Dist = MinDist;
	Ret.pObj = this;
	return (Ret);
}

C3dVector Line_Object::GetPt(double dU) {
	C3dVector vRet;
	double dX, dY, dZ;

	dX = (pVertex2->Pt_Point->x - pVertex1->Pt_Point->x) * dU;
	dY = (pVertex2->Pt_Point->y - pVertex1->Pt_Point->y) * dU;
	dZ = (pVertex2->Pt_Point->z - pVertex1->Pt_Point->z) * dU;
	vRet.x = pVertex1->Pt_Point->x + dX;
	vRet.y = pVertex1->Pt_Point->y + dY;
	vRet.z = pVertex1->Pt_Point->z + dZ;
	return (vRet);
}

C3dVector Line_Object::GetDir(double w) {
	C3dVector DirA;
	C3dVector DirB;
	DirA = this->GetPt(0.0);
	DirB = this->GetPt(1.0);
	DirB -= DirA;
	DirB.Normalize();
	return (DirB);
}

double Line_Object::MinDist(C3dVector vInPt) {
	C3dVector vRet;
	double dX, dY, dZ, dU;
	int iCnt1;
	double MinDist = 100000000000000.0;
	double dDist = 0;

	for (iCnt1 = 1; iCnt1 < 1000; iCnt1++) {
		dU = iCnt1 * 0.001;
		dX = (pVertex2->Pt_Point->x - pVertex1->Pt_Point->x) * dU;
		dY = (pVertex2->Pt_Point->y - pVertex1->Pt_Point->y) * dU;
		dZ = (pVertex2->Pt_Point->z - pVertex1->Pt_Point->z) * dU;
		vRet.x = pVertex1->Pt_Point->x + dX;
		vRet.y = pVertex1->Pt_Point->y + dY;
		vRet.z = pVertex1->Pt_Point->z + dZ;
		dDist = pow((pow((vRet.x - vInPt.x), 2) + pow((vRet.y - vInPt.y), 2) + pow((vRet.z - vInPt.z), 2)), 0.5);
		if (dDist < MinDist) {
			MinDist = dDist;
		}
	}
	return (MinDist);
}

double Line_Object::getLen() {
	double dRet = 0;
	int i;
	int iIncs = 1;
	double dStp;
	double w;
	C3dVector p1;
	C3dVector p2;

	dStp = 1 / iIncs;
	w = 0;
	p1 = GetPt(w);
	for (i = 0; i < iIncs; i++) {
		w += dStp;
		p2 = GetPt(w);
		dRet += p2.Dist(p1);
		p1 = p2;
	}
	return (dRet);
}

IMPLEMENT_DYNAMIC(Curve, CObject)

void Curve::Draw(CDC* pDC, int iDrawmode) {
	ContrPolyW::Draw(pDC, iDrawmode, 0, 1);
}

void Curve::OglDraw(int iDspFlgs, double dS1, double dS2) {
	ContrPolyW::OglDraw(0.0, 1.0);
}

void Curve::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	ContrPolyW::OglDrawW(0.0, 1.0);
}

void Curve::HighLight(CDC* pDC) {
	ContrPolyW::Draw(pDC, 4, 0, 1);
}

CString Curve::GetName() {
	return ("Curve");
}

int Curve::GetVarHeaders(CString sVar[]) {
	int iNo = 0;

	sVar[iNo] = "KNOT Vector";
	iNo++;
	return (iNo);
}

int Curve::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", 1);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void Curve::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	// DefSys = atoi(sVar[0]);
}

IMPLEMENT_DYNAMIC(ContrPolyW, CObject)

ContrPolyW::ContrPolyW() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iNoVerts = 0;
	iLabel = -1;
	iObjType = 6;
}

// CvPt_Object* pVertex[20];
void ContrPolyW::Create(int iLab, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iNoVerts = 0;
	iLabel = iLab;
	iObjType = 6;
	pParent = Parrent;
}

C3dVector ContrPolyW::Get_Centroid() {
	return (GetPt(0.5));
}

void ContrPolyW::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << iNoVerts;
		for (i = 0; i < iNoVerts; i++) {
			ar << pCVertex[i]->xw;
			ar << pCVertex[i]->yw;
			ar << pCVertex[i]->zw;
			ar << pCVertex[i]->w;
		}
	} else {
		G_Object::Serialize(ar, iV);
		ar >> iNoVerts;
		for (i = 0; i < iNoVerts; i++) {
			pCVertex[i] = new C4dVector();
			ar >> pCVertex[i]->xw;
			ar >> pCVertex[i]->yw;
			ar >> pCVertex[i]->zw;
			ar >> pCVertex[i]->w;
		}
	}
}

G_Object* ContrPolyW::Copy(G_Object* parrent) {
	int i;
	ContrPolyW* cPoly = new ContrPolyW;
	cPoly->Drawn = Drawn;
	cPoly->Selectable = Selectable;
	cPoly->Visable = Visable;
	cPoly->iColour = iColour;
	cPoly->iObjType = iObjType;
	cPoly->iLabel = iLabel;
	cPoly->iNoVerts = iNoVerts;
	for (i = 0; i < iNoVerts; i++) {
		cPoly->pCVertex[i] = new C4dVector();
		cPoly->pCVertex[i]->xw = pCVertex[i]->xw;
		cPoly->pCVertex[i]->yw = pCVertex[i]->yw;
		cPoly->pCVertex[i]->zw = pCVertex[i]->zw;
		cPoly->pCVertex[i]->w = pCVertex[i]->w;
	}
	cPoly->pParent = parrent;
	return (cPoly);
}

void ContrPolyW::AddVert(C3dVector* pInVertex1, double dWght) {
	if (dWght == 0) {
		dWght = 1;
	}
	if (iNoVerts < 20) {
		pCVertex[iNoVerts] = new C4dVector();
		pCVertex[iNoVerts]->xw = pInVertex1->x * dWght;
		pCVertex[iNoVerts]->yw = pInVertex1->y * dWght;
		pCVertex[iNoVerts]->zw = pInVertex1->z * dWght;
		pCVertex[iNoVerts]->w = dWght;
		iNoVerts++;
	}
}

void ContrPolyW::CPolyRot(double dAng) {
	int i;
	C3dVector vT1, a, b;

	for (i = 0; i < iNoVerts; i++) {
		vT1.x = pCVertex[i]->xw;
		vT1.y = pCVertex[i]->yw;
		vT1.z = pCVertex[i]->zw;
		vT1.Rotate(a, b, dAng);
		pCVertex[i]->xw = vT1.x;
		pCVertex[i]->yw = vT1.y;
		pCVertex[i]->zw = vT1.z;
	}
}

void ContrPolyW::CWeight(double dW) {
	int i;
	C3dVector vT1, a, b;

	for (i = 0; i < iNoVerts; i++) {
		vT1.x = pCVertex[i]->xw / pCVertex[i]->w;
		vT1.y = pCVertex[i]->yw / pCVertex[i]->w;
		vT1.z = pCVertex[i]->zw / pCVertex[i]->w;
		pCVertex[i]->xw = vT1.x * dW;
		pCVertex[i]->yw = vT1.y * dW;
		pCVertex[i]->zw = vT1.z * dW;
		pCVertex[i]->w = dW;
	}
}

void ContrPolyW::AddVertW(C4dVector pInVertex1) {
	if (iNoVerts < 20) {
		pCVertex[iNoVerts] = new C4dVector();
		pCVertex[iNoVerts]->xw = pInVertex1.xw;
		pCVertex[iNoVerts]->yw = pInVertex1.yw;
		pCVertex[iNoVerts]->zw = pInVertex1.zw;
		pCVertex[iNoVerts]->w = pInVertex1.w;
		iNoVerts++;
	}
}

void ContrPolyW::Set2(ContrPolyW* vS4) {
	int i;

	for (i = 0; i < vS4->iNoVerts; i++) {
		AddVert(&vS4->pCVertex[i]->GetPoint(), vS4->pCVertex[i]->GetWght());
	}
}

void ContrPolyW::Translate(C3dVector vTVect) {
	int i;

	for (i = 0; i < iNoVerts; i++) {
		pCVertex[i]->Translate(vTVect);
	}
}

void ContrPolyW::Clear() {
	int i;
	for (i = 0; i < iNoVerts; i++) {
		delete (pCVertex[i]);
	}
	iNoVerts = 0;
}

int ContrPolyW::GetOrder() {
	return (iNoVerts - 2);
}

C4dVector ContrPolyW::deCastelJau1(double u) {
	C4dVector Q[20];
	int i;
	int k;

	for (i = 0; i <= (iNoVerts - 1); i++) {
		Q[i].xw = pCVertex[i]->xw;
		Q[i].yw = pCVertex[i]->yw;
		Q[i].zw = pCVertex[i]->zw;
		Q[i].w = pCVertex[i]->w;
	}
	for (k = 1; k <= (iNoVerts - 1); k++) {
		for (i = 0; i <= ((iNoVerts - 1) - k); i++) {
			Q[i] = Q[i] * (1.0 - u) + Q[i + 1] * u;
			// Q[i].x=(1.0-u)*Q[i].x+u*Q[i+1].x;
			// Q[i].y=(1.0-u)*Q[i].y+u*Q[i+1].y;
			// Q[i].z=(1.0-u)*Q[i].z+u*Q[i+1].z;
		}
	}

	C4dVector vRetVect;
	vRetVect.xw = Q[0].xw;
	vRetVect.yw = Q[0].yw;
	vRetVect.zw = Q[0].zw;
	vRetVect.w = Q[0].w;

	return (vRetVect);
}

void ContrPolyW::Draw(CDC* pDC, int iDrawmode,
                      double sw, double ew) {
	const double dInc = 0.01;
	double w;

	C3dVector pt;
	pt = GetPt(sw);
	Node* ThePoint = new Node;
	ThePoint->Create(pt, 1, 0, 0, 11, 0, 0, NULL);
	ThePoint->Pt_Point->x = pt.x;
	ThePoint->Pt_Point->y = pt.y;
	ThePoint->Pt_Point->z = pt.z;
	ThePoint->SetToScr(pModZ, pScrZ);
	pDC->MoveTo((int) ThePoint->DSP_Point->x, (int) ThePoint->DSP_Point->y);
	w = sw;

	do {
		w = w + dInc;
		if (w > ew) {
			w = ew;
		}
		pt = GetPt(w);
		ThePoint->Pt_Point->x = pt.x;
		ThePoint->Pt_Point->y = pt.y;
		ThePoint->Pt_Point->z = pt.z;
		ThePoint->SetToScr(pModZ, pScrZ);
		pDC->LineTo((int) ThePoint->DSP_Point->x, (int) ThePoint->DSP_Point->y);
	} while (w < ew);
	delete (ThePoint);
}

void ContrPolyW::OglDraw(double sw, double ew) {
	GLfloat* ctrlpts;
	int iu;
	int icu;
	int iInd = 0;
	iu = iNoVerts;

	ctrlpts = (GLfloat*) malloc(iu * 4 * sizeof(GLfloat));
	for (icu = 0; icu < iu; icu++) {
		ctrlpts[iInd] = (float) pCVertex[icu]->xw;
		ctrlpts[iInd + 1] = (float) pCVertex[icu]->yw;
		ctrlpts[iInd + 2] = (float) pCVertex[icu]->zw;
		ctrlpts[iInd + 3] = (float) pCVertex[icu]->w;
		iInd = iInd + 4;
	}

	glEnable(GL_MAP1_VERTEX_4);
	glMap1f(GL_MAP1_VERTEX_4, 0.0f, 1.0f, 4, iu, ctrlpts);
	// glEnable(GL_MAP1_VERTEX_4);
	glMapGrid1f(20, (float) sw, (float) ew);
	glEvalMesh1(GL_LINE, 0, 20);
	// glFlush();
	free(ctrlpts);
}

void ContrPolyW::OglDrawW(double sw, double ew) {
	OglDraw(sw, ew);
}

void ContrPolyW::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	// int iCnt;
	// for (iCnt=0;iCnt<iNoVerts;iCnt++)
	//     {
	//     pVertex[iCnt]->SetToScr(pScrTran);
	//     }
	pModZ = pModMat;
	pScrZ = pScrTran;
}

void ContrPolyW::Transform(C3dMatrix TMat) {
	int i;
	for (i = 0; i < iNoVerts; i++) {
		pCVertex[i]->Transform(TMat);
	}
}

void ContrPolyW::HighLight(CDC* pDC, double sw, double ew) {
	Draw(pDC, 4, sw, ew);
}

G_ObjectD ContrPolyW::SelDist(CPoint InPT, Filter FIL) {
	int iCnt1;
	G_ObjectD Ret;
	double MinDist = 1e36;
	double dDist = 0;
	double fred;
	C3dVector vDrawPt;
	C4dVector vWpt;
	Node ThePoint;
	ThePoint.Create(vDrawPt, 0, 0, 0, 11, 0, 0, NULL);
	for (iCnt1 = 1; iCnt1 < 21; iCnt1++) {
		fred = iCnt1 * 0.05;
		// vDrawPt = GetParaPoint(fred);
		vWpt = deCastelJau1(fred);
		ThePoint.Pt_Point->x = vWpt.xw / vWpt.w;
		ThePoint.Pt_Point->y = vWpt.yw / vWpt.w;
		ThePoint.Pt_Point->z = vWpt.zw / vWpt.w;
		ThePoint.SetToScr(pModZ, pScrZ);
		dDist = pow((ThePoint.DSP_Point->x - InPT.x), 2) + pow((ThePoint.DSP_Point->y - InPT.y), 2);
		if (dDist < MinDist) {
			MinDist = dDist;
		}
		// pDC->Ellipse(ThePoint.DSP_Point->x+5,ThePoint.DSP_Point->y+5,ThePoint.DSP_Point->x-5,ThePoint.DSP_Point->y-5);
	}
	ThePoint.Clear();
	Ret.Dist = MinDist;
	Ret.pObj = this;
	return (Ret);
}

C3dVector ContrPolyW::GetPt(double w) {
	C3dVector vR;
	C4dVector vWpt;
	if (iNoVerts > 2) {
		vWpt = deCastelJau1(w);
		vR.x = vWpt.xw / vWpt.w;
		vR.y = vWpt.yw / vWpt.w;
		vR.z = vWpt.zw / vWpt.w;
	}
	return (vR);
}

C3dVector ContrPolyW::GetDir(double w) {
	C3dVector DirA;
	C3dVector DirB;
	if (w < 0.99999) {
		DirA = this->GetPt(w);
		DirB = this->GetPt(w + 0.00001);
	} else {
		DirA = this->GetPt(w - 0.00001);
		DirB = this->GetPt(w);
	}
	DirB -= DirA;
	DirB.Normalize();
	return (DirB);
}

IMPLEMENT_DYNAMIC(Circ1, CObject)
//	 int iNoVerts;
//   CvPt_Object* pVertex[8]; //control polygon
//	 double dRadius;
//	 C3dMatrix* pScrZ;

void Circ1::Create(C3dVector vN, C3dVector vC, double dRad, int iLab, G_Object* Parrent) {
	dS = 0;
	dE = 1;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iLabel = iLab;
	iObjType = 5;
	dRadius = dRad;
	C3dVector Pt;
	pParent = Parrent;
	vNorm = new C3dVector(0, 0, 1);
	vCent = new C3dVector(0, 0, 0);

	pSegs[0] = new ContrPolyW();
	pSegs[0]->Create(iLab, this);
	Pt.x = dRadius;
	Pt.y = 0;
	Pt.z = 0;
	pSegs[0]->AddVert(&Pt, 1);
	Pt.x = dRadius;
	Pt.y = dRadius;
	Pt.z = 0;
	pSegs[0]->AddVert(&Pt, 1);
	Pt.x = 0;
	Pt.y = dRadius;
	Pt.z = 0;
	pSegs[0]->AddVert(&Pt, 2);

	pSegs[1] = new ContrPolyW();
	pSegs[1]->Create(iLab, this);
	pSegs[1]->AddVert(&Pt, 1);
	Pt.x = -dRadius;
	Pt.y = dRadius;
	Pt.z = 0;
	pSegs[1]->AddVert(&Pt, 1);
	Pt.x = -dRadius;
	Pt.y = 0;
	Pt.z = 0;
	pSegs[1]->AddVert(&Pt, 2);

	pSegs[2] = new ContrPolyW();
	pSegs[2]->Create(iLab, this);
	pSegs[2]->AddVert(&Pt, 1);
	Pt.x = -dRadius;
	Pt.y = -dRadius;
	Pt.z = 0;
	pSegs[2]->AddVert(&Pt, 1);
	Pt.x = 0;
	Pt.y = -dRadius;
	Pt.z = 0;
	pSegs[2]->AddVert(&Pt, 2);

	pSegs[3] = new ContrPolyW();
	pSegs[3]->Create(iLab, this);
	pSegs[3]->AddVert(&Pt, 1);
	Pt.x = dRadius;
	Pt.y = -dRadius;
	Pt.z = 0;
	pSegs[3]->AddVert(&Pt, 1);
	Pt.x = dRadius;
	Pt.y = 0;
	Pt.z = 0;
	pSegs[3]->AddVert(&Pt, 2);
	C3dMatrix RMat;
	RMat = RMat.CalcTran(vN);
	C3dMatrix TMat;
	this->Transform(RMat);
	TMat.Translate(vC.x, vC.y, vC.z);
	this->Transform(TMat);
}

void Circ1::Reverse() {
	C4dVector* p[12];
	vNorm->x = -vNorm->x;
	vNorm->y = -vNorm->y;
	vNorm->z = -vNorm->z;
	p[0] = pSegs[0]->pCVertex[0];
	p[1] = pSegs[0]->pCVertex[1];
	p[2] = pSegs[0]->pCVertex[2];

	p[3] = pSegs[1]->pCVertex[0];
	p[4] = pSegs[1]->pCVertex[1];
	p[5] = pSegs[1]->pCVertex[2];

	p[6] = pSegs[2]->pCVertex[0];
	p[7] = pSegs[2]->pCVertex[1];
	p[8] = pSegs[2]->pCVertex[2];

	p[9] = pSegs[3]->pCVertex[0];
	p[10] = pSegs[3]->pCVertex[1];
	p[11] = pSegs[3]->pCVertex[2];

	pSegs[0]->pCVertex[0] = p[11];
	pSegs[0]->pCVertex[1] = p[10];
	pSegs[0]->pCVertex[2] = p[9];

	pSegs[1]->pCVertex[0] = p[8];
	pSegs[1]->pCVertex[1] = p[7];
	pSegs[1]->pCVertex[2] = p[6];

	pSegs[2]->pCVertex[0] = p[5];
	pSegs[2]->pCVertex[1] = p[4];
	pSegs[2]->pCVertex[2] = p[3];

	pSegs[3]->pCVertex[0] = p[2];
	pSegs[3]->pCVertex[1] = p[1];
	pSegs[3]->pCVertex[2] = p[0];
}

void Circ1::Info() {
	char S1[80];
	sprintf_s(S1, "%s%i%s%i%s%i", "Type ", iObjType, "; Label ", iLabel, " Col; ", iColour);
	outtext1("CIRCLE OBJECT");
	outtext1(S1);
	sprintf_s(S1, "%s%f", "Radius : ", dRadius);
	outtext1(S1);
	sprintf_s(S1, "%s%f%s%f%s%f", "Centre : ", vCent->x, ",", vCent->y, ",", vCent->z);
	outtext1(S1);
	sprintf_s(S1, "%s%f%s%f%s%f", "Normal : ", vNorm->x, ",", vNorm->y, ",", vNorm->z);
	outtext1(S1);
	outtext1("    ****");
}

void Circ1::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << dRadius;
		ar << dS;
		ar << dE;
		ar << vNorm->x;
		ar << vNorm->y;
		ar << vNorm->z;
		ar << vCent->x;
		ar << vCent->y;
		ar << vCent->z;
		pSegs[0]->Serialize(ar, iV);
		pSegs[1]->Serialize(ar, iV);
		pSegs[2]->Serialize(ar, iV);
		pSegs[3]->Serialize(ar, iV);
	} else {
		G_Object::Serialize(ar, iV);
		ar >> dRadius;
		ar >> dS;
		ar >> dE;
		vNorm = new C3dVector(0, 0, 1);
		vCent = new C3dVector(0, 0, 0);
		ar >> vNorm->x;
		ar >> vNorm->y;
		ar >> vNorm->z;
		ar >> vCent->x;
		ar >> vCent->y;
		ar >> vCent->z;
		pSegs[0] = new ContrPolyW();
		pSegs[1] = new ContrPolyW();
		pSegs[2] = new ContrPolyW();
		pSegs[3] = new ContrPolyW();
		pSegs[0]->Serialize(ar, iV);
		pSegs[1]->Serialize(ar, iV);
		pSegs[2]->Serialize(ar, iV);
		pSegs[3]->Serialize(ar, iV);
	}
}

G_Object* Circ1::Copy(G_Object* Parrent) {
	Circ1* rCir = new Circ1;
	rCir->dS = dS;
	rCir->dE = dE;
	rCir->Drawn = Drawn;
	rCir->Selectable = Selectable;
	rCir->Visable = Visable;
	rCir->iColour = iColour;
	rCir->iObjType = iObjType;
	rCir->iLabel = iLabel;
	rCir->pModZ = pModZ;
	rCir->pScrZ = pScrZ;
	rCir->dRadius = dRadius;
	rCir->vNorm = new C3dVector(0, 0, 1);
	rCir->vCent = new C3dVector(0, 0, 0);
	rCir->vNorm->x = vNorm->x;
	rCir->vNorm->y = vNorm->y;
	rCir->vNorm->z = vNorm->z;
	rCir->vCent->x = vCent->x;
	rCir->vCent->y = vCent->y;
	rCir->vCent->z = vCent->z;
	rCir->pSegs[0] = new ContrPolyW();
	rCir->pSegs[1] = new ContrPolyW();
	rCir->pSegs[2] = new ContrPolyW();
	rCir->pSegs[3] = new ContrPolyW();
	rCir->pSegs[0] = (ContrPolyW*) pSegs[0]->Copy(this);
	rCir->pSegs[1] = (ContrPolyW*) pSegs[1]->Copy(this);
	rCir->pSegs[2] = (ContrPolyW*) pSegs[2]->Copy(this);
	rCir->pSegs[3] = (ContrPolyW*) pSegs[3]->Copy(this);
	return (rCir);
}

double Circ1::Bernstein(double dU, int ii, int inn) {
	double dCoeA;
	double dCoeB;
	double dRet;
	dCoeA = Factorial(inn) / (Factorial(ii) * Factorial(inn - ii));
	dCoeB = 1 - dU;
	dRet = dCoeA * pow(dU, ii) * pow(dCoeB, inn - ii);
	return dRet;
}

void Circ1::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	pModZ = pModMat;
	pScrZ = pScrTran;

	pSegs[0]->SetToScr(pModMat, pScrTran);
	pSegs[1]->SetToScr(pModMat, pScrTran);
	pSegs[2]->SetToScr(pModMat, pScrTran);
	pSegs[3]->SetToScr(pModMat, pScrTran);
}

void Circ1::Transform(C3dMatrix TMat) {
	pSegs[0]->Transform(TMat);
	pSegs[1]->Transform(TMat);
	pSegs[2]->Transform(TMat);
	pSegs[3]->Transform(TMat);
	*vCent = TMat.Mult(*vCent);
	TMat.Translate2(0, 0, 0);
	*vNorm = TMat.Mult(*vNorm);
}

C3dVector Circ1::Get_Centroid() {
	C3dVector vT;
	vT.Set(vCent->x, vCent->y, vCent->z);
	return (vT);
}

void Circ1::Draw(CDC* pDC, int iDrawmode) {
	double dLS;
	double dLE;

	if (dS <= 0.25) {
		dLS = 4 * (dS);
		dLE = 4 * (dE);
		if (dLS < 0) {
			dLS = 0;
		}
		if (dLE > 1) {
			dLE = 1;
		}
		pSegs[0]->Draw(pDC, iDrawmode, dLS, dLE);
	}
	if ((dS <= 0.5) && (dE > 0.25)) {
		dLS = 4 * (dS - 0.25);
		dLE = 4 * (dE - 0.25);
		if (dLS < 0) {
			dLS = 0;
		}
		if (dLE > 1) {
			dLE = 1;
		}
		pSegs[1]->Draw(pDC, iDrawmode, dLS, dLE);
	}
	if ((dS <= 0.75) && (dE > 0.5)) {
		dLS = 4 * (dS - 0.5);
		dLE = 4 * (dE - 0.5);
		if (dLS < 0) {
			dLS = 0;
		}
		if (dLE > 1) {
			dLE = 1;
		}
		pSegs[2]->Draw(pDC, iDrawmode, dLS, dLE);
	}
	if ((dS <= 1) && (dE > 0.75)) {
		dLS = 4 * (dS - 0.75);
		dLE = 4 * (dE - 0.75);
		if (dLS < 0) {
			dLS = 0;
		}
		if (dLE > 1) {
			dLE = 1;
		}
		pSegs[3]->Draw(pDC, iDrawmode, dLS, dLE);
	}
}

void Circ1::OglDraw(int iDspFlgs) {
	double dLS;
	double dLE;

	if (dS <= 0.25) {
		dLS = 4 * (dS);
		dLE = 4 * (dE);
		if (dLS < 0) {
			dLS = 0;
		}
		if (dLE > 1) {
			dLE = 1;
		}
		pSegs[0]->OglDraw(dLS, dLE);
	}
	if ((dS <= 0.5) && (dE > 0.25)) {
		dLS = 4 * (dS - 0.25);
		dLE = 4 * (dE - 0.25);
		if (dLS < 0) {
			dLS = 0;
		}
		if (dLE > 1) {
			dLE = 1;
		}
		pSegs[1]->OglDraw(dLS, dLE);
	}
	if ((dS <= 0.75) && (dE > 0.5)) {
		dLS = 4 * (dS - 0.5);
		dLE = 4 * (dE - 0.5);
		if (dLS < 0) {
			dLS = 0;
		}
		if (dLE > 1) {
			dLE = 1;
		}
		pSegs[2]->OglDraw(dLS, dLE);
	}
	if ((dS <= 1) && (dE > 0.75)) {
		dLS = 4 * (dS - 0.75);
		dLE = 4 * (dE - 0.75);
		if (dLS < 0) {
			dLS = 0;
		}
		if (dLE > 1) {
			dLE = 1;
		}
		pSegs[3]->OglDraw(dLS, dLE);
	}
}

void Circ1::OglDrawW(int iDspFlgs) {
	OglDraw(iDspFlgs);
}

void Circ1::HighLight(CDC* pDC) {
	Draw(pDC, 4);
}

G_ObjectD Circ1::SelDist(CPoint InPT, Filter FIL) {
	int iC;
	double dDist = 1e36;
	G_ObjectD Ret;
	for (iC = 0; iC < 4; iC++) {
		if (pSegs[iC]->SelDist(InPT, FIL).Dist < dDist) {
			Ret = pSegs[iC]->SelDist(InPT, FIL);
			dDist = Ret.Dist;
		}
	}
	Ret.pObj = this;
	return (Ret);
}

C3dVector Circ1::MinPt(C3dVector inPt) {
	C3dVector vRet;
	const double dTol = 0.000000001;
	const double dIncs = 36;
	int i;
	double dStp = 1 / dIncs;
	double dlStp;
	double dW = 0;
	double dMinW = 0;
	C3dVector cPt;
	C3dVector tPt;
	C3dVector cNextPt;
	double dWScl;
	double Dist;
	double minDist = 1e36;
	C3dVector v1;
	C3dVector v2;
	double dM;
	double dDot;
	cPt = GetPt(dW);
	tPt = GetPt(dW + dStp);
	dWScl = cPt.Dist(tPt);
	for (i = 0; i < dIncs; i++) {
		dW = i * dStp;
		cPt = GetPt(dW);
		Dist = cPt.Dist(inPt);
		if (Dist < minDist) {
			minDist = Dist;
			dMinW = dW;
		}
	}
	// start of iteration
	dW = dMinW;
	dlStp = dStp;
	i = 0;
	do {
		cPt = GetPt(dW);
		cNextPt = GetPt(dW + 0.000001);
		v1 = cNextPt;
		v1 -= cPt;
		v2 = inPt;
		v2 -= cPt;
		dM = v2.Mag();
		v1.Normalize();
		v2.Normalize();
		dDot = v2.Dot(v1);
		dlStp = (dM * dDot / dWScl) * 1 * dStp;
		dW = dW + dlStp;
		i++;
	} while ((pow((dlStp * dlStp), 0.5) > dTol) & (i < 10000));

	vRet = GetPt(dW);
	return (vRet);
}

double Circ1::MinWPt(C3dVector inPt) {
	C3dVector vRet;
	const double dIncs = 36;
	int i;
	double dStp = 1 / dIncs;
	double dlStp;
	double dW = 0;
	double dMinW = 0;
	C3dVector cPt;
	C3dVector tPt;
	C3dVector cNextPt;
	double dWScl;
	double Dist;
	double minDist = 1e36;
	C3dVector v1;
	C3dVector v2;
	double dM;
	double dDot;
	cPt = GetPt(dW);
	tPt = GetPt(dW + dStp);
	dWScl = cPt.Dist(tPt);
	for (i = 0; i < dIncs; i++) {
		dW = i * dStp;
		cPt = GetPt(dW);
		Dist = cPt.Dist(inPt);
		if (Dist < minDist) {
			minDist = Dist;
			dMinW = dW;
		}
	}
	// start of iteration
	dW = dMinW;
	dlStp = dStp;
	i = 0;
	do {
		cPt = GetPt(dW);
		cNextPt = GetPt(dW + 0.000001);
		v1 = cNextPt;
		v1 -= cPt;
		v2 = inPt;
		v2 -= cPt;
		dM = v2.Mag();
		v1.Normalize();
		v2.Normalize();
		dDot = v2.Dot(v1);
		dlStp = (dM * dDot / dWScl) * 1 * dStp;
		dW = dW + dlStp;
		i++;
	} while ((pow((dlStp * dlStp), 0.5) > dTol) & (i < 10000));
	return (dW);
}

C3dVector Circ1::GetPt(double w) {
	C3dVector vR;
	vR.x = 0;
	vR.y = 0, vR.z = 0;
	;
	int TheSeg = -1;
	double aw;
	if (w > 1) {
		w = w - 1;
	}
	if ((w >= 0) && (w < 0.25)) {
		TheSeg = 0;
		aw = w * 4;
	} else if ((w >= 0.25) && (w < 0.5)) {
		TheSeg = 1;
		aw = (w - 0.25) * 4;
	} else if ((w >= 0.5) && (w < 0.75)) {
		TheSeg = 2;
		aw = (w - 0.5) * 4;
	} else if ((w >= 0.75) && (w <= 1)) {
		TheSeg = 3;
		aw = (w - 0.75) * 4;
	}
	if (TheSeg != -1) {
		vR = pSegs[TheSeg]->GetPt(aw);
	}
	return (vR);
}

C3dVector Circ1::GetDir(double w) {
	C3dVector vR;
	vR.x = 0;
	vR.y = 0, vR.z = 0;
	;
	int TheSeg = -1;
	double aw;
	if (w > 1) {
		w -= 1;
	}
	if ((w >= 0) && (w < 0.25)) {
		TheSeg = 0;
		aw = w * 4;
	} else if ((w >= 0.25) && (w < 0.5)) {
		TheSeg = 1;
		aw = (w - 0.25) * 4;
	} else if ((w >= 0.5) && (w < 0.75)) {
		TheSeg = 2;
		aw = (w - 0.5) * 4;
	} else if ((w >= 0.75) && (w <= 1)) {
		TheSeg = 3;
		aw = (w - 0.75) * 4;
	}
	if (TheSeg != -1) {
		vR = pSegs[TheSeg]->GetDir(aw);
	}
	return (vR);
}

// Extruded Surface
IMPLEMENT_DYNAMIC(Surf_Ex1, CObject)

// ContrPolyW* pWCurve[2];
// C3dVector vTranVec;
// C3dMatrix* pScrZ;

void Surf_Ex1::Create(ContrPolyW* pWCurveIn, C3dVector vTranVecIn, int iLab, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 3;
	iLabel = iLab;
	iObjType = 10;
	pParent = Parrent;
	vTranVec = vTranVecIn;

	pWCurve[0] = pWCurveIn;
	pWCurve[1] = new ContrPolyW;
	pWCurve[1]->Create(1, this);
	pWCurve[1]->Set2(pWCurve[0]);
	pWCurve[1]->Translate(vTranVecIn);

	pWCurve[2] = new ContrPolyW;
	pWCurve[2]->Create(1, this);
	pWCurve[2]->AddVert(&pWCurve[0]->pCVertex[0]->GetPoint(), 1);
	pWCurve[2]->AddVert(&pWCurve[1]->pCVertex[0]->GetPoint(), 1);

	pWCurve[3] = new ContrPolyW;
	pWCurve[3]->Create(1, this);
	pWCurve[3]->AddVert(&pWCurve[0]->pCVertex[pWCurve[0]->iNoVerts - 1]->GetPoint(), 1);
	pWCurve[3]->AddVert(&pWCurve[1]->pCVertex[pWCurve[0]->iNoVerts - 1]->GetPoint(), 1);
}

void Surf_Ex1::Draw(CClientDC* pDC, int iDrawmode) {
	pWCurve[0]->SetToScr(pModZ, pScrZ);
	pWCurve[1]->SetToScr(pModZ, pScrZ);
	pWCurve[2]->SetToScr(pModZ, pScrZ);
	pWCurve[3]->SetToScr(pModZ, pScrZ);
	pWCurve[0]->Draw(pDC, 4, 0, 1);
	pWCurve[1]->Draw(pDC, 4, 0, 1);
	pWCurve[2]->Draw(pDC, 4, 0, 1);
	pWCurve[3]->Draw(pDC, 4, 0, 1);

	int iCnt1;
	double fred;
	C3dVector vDrawPt;
	C4dVector vWpt;
	Node ThePoint;
	ThePoint.Create(vDrawPt, 0, 0, 0, 11, 0, 0, NULL);
	vDrawPt = deCastelJau2(0, 0.5).GetPoint();
	ThePoint.Pt_Point->x = vDrawPt.x;
	ThePoint.Pt_Point->y = vDrawPt.y;
	ThePoint.Pt_Point->z = vDrawPt.z;
	ThePoint.SetToScr(pModZ, pScrZ);
	pDC->MoveTo((int) ThePoint.DSP_Point->x, (int) ThePoint.DSP_Point->y);
	for (iCnt1 = 1; iCnt1 < 21; iCnt1++) {
		fred = iCnt1 * 0.05;
		vDrawPt = deCastelJau2(fred, 0.5).GetPoint();
		ThePoint.Pt_Point->x = vDrawPt.x;
		ThePoint.Pt_Point->y = vDrawPt.y;
		ThePoint.Pt_Point->z = vDrawPt.z;
		ThePoint.SetToScr(pModZ, pScrZ);
		pDC->LineTo((int) ThePoint.DSP_Point->x, (int) ThePoint.DSP_Point->y);
	}
	vDrawPt = deCastelJau2(0.5, 0).GetPoint();
	ThePoint.Pt_Point->x = vDrawPt.x;
	ThePoint.Pt_Point->y = vDrawPt.y;
	ThePoint.Pt_Point->z = vDrawPt.z;
	ThePoint.SetToScr(pModZ, pScrZ);
	pDC->MoveTo((int) ThePoint.DSP_Point->x, (int) ThePoint.DSP_Point->y);
	vDrawPt = deCastelJau2(0.5, 1).GetPoint();
	ThePoint.Pt_Point->x = vDrawPt.x;
	ThePoint.Pt_Point->y = vDrawPt.y;
	ThePoint.Pt_Point->z = vDrawPt.z;
	ThePoint.SetToScr(pModZ, pScrZ);
	pDC->LineTo((int) ThePoint.DSP_Point->x, (int) ThePoint.DSP_Point->y);
}

void Surf_Ex1::OglDraw(int iDspFlgs) {
	GLfloat* ctrlpts;
	int iu;
	int iv;
	int icu, icv;
	int iInd = 0;
	iu = pWCurve[0]->iNoVerts;
	iv = pWCurve[2]->iNoVerts;

	ctrlpts = (GLfloat*) malloc(iv * iu * 4 * sizeof(GLfloat));

	for (icv = 0; icv < iv; icv++) {
		for (icu = 0; icu < iu; icu++) {
			ctrlpts[iInd] = (float) pWCurve[icv]->pCVertex[icu]->xw;
			ctrlpts[iInd + 1] = (float) pWCurve[icv]->pCVertex[icu]->yw;
			ctrlpts[iInd + 2] = (float) pWCurve[icv]->pCVertex[icu]->zw;
			ctrlpts[iInd + 3] = (float) pWCurve[icv]->pCVertex[icu]->w;
			iInd = iInd + 4;
		}
	}

	glColor3fv(cols[iColour]);
	glEnable(GL_MAP2_VERTEX_4);
	// glBegin(GL_POINTS);
	// glVertex4fv(&ctrlpts[0]);
	// glVertex4fv(&ctrlpts[4]);
	// glVertex4fv(&ctrlpts[8]);
	// glVertex4fv(&ctrlpts[12]);
	// glVertex4fv(&ctrlpts[16]);
	// glVertex4fv(&ctrlpts[20]);
	// glEnd();

	glMap2f(GL_MAP2_VERTEX_4, 0.0f, 1.0f, 4, iu, 0.0f, 1.0f, iu * 4, iv, ctrlpts);
	glEnable(GL_MAP2_VERTEX_4);
	glMapGrid2f(20, 0.0f, 1.0f, 20, 0.0f, 1.0f);
	glEvalMesh2(GL_FILL, 0, 20, 0, 20);
	glFlush();
	free(ctrlpts);
	pWCurve[1]->OglDraw(0, 1);
}

void Surf_Ex1::OglDrawW() {
	GLfloat* ctrlpts;
	int iu;
	int iv;
	int icu, icv;
	int iInd = 0;
	iu = pWCurve[0]->iNoVerts;
	iv = pWCurve[2]->iNoVerts;

	ctrlpts = (GLfloat*) malloc(iv * iu * 4 * sizeof(GLfloat));

	for (icv = 0; icv < iv; icv++) {
		for (icu = 0; icu < iu; icu++) {
			ctrlpts[iInd] = (float) pWCurve[icv]->pCVertex[icu]->xw;
			ctrlpts[iInd + 1] = (float) pWCurve[icv]->pCVertex[icu]->yw;
			ctrlpts[iInd + 2] = (float) pWCurve[icv]->pCVertex[icu]->zw;
			ctrlpts[iInd + 3] = (float) pWCurve[icv]->pCVertex[icu]->w;
			iInd = iInd + 4;
		}
	}

	glColor3fv(cols[iColour]);
	glEnable(GL_MAP2_VERTEX_4);

	glMap2f(GL_MAP2_VERTEX_4, 0.0f, 1.0f, 4, iu, 0.0f, 1.0f, iu * 4, iv, ctrlpts);
	glEnable(GL_MAP2_VERTEX_4);
	glMapGrid2f(20, 0.0f, 1.0f, 20, 0.0f, 1.0f);
	glEvalMesh2(GL_LINE, 0, 20, 0, 20);
	glFlush();
	free(ctrlpts);
	pWCurve[1]->OglDraw(0, 1);
}

void Surf_Ex1::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	pModZ = pModMat;
	pScrZ = pScrTran;
}

void Surf_Ex1::HighLight(CClientDC* pDC) {
	Draw(pDC, 4);
}

G_ObjectD Surf_Ex1::SelDist(CPoint InPT, Filter FIL) {
	double dSelD;
	G_ObjectD Ret;
	Node ThePoint;
	C3dVector vDrawPt;
	ThePoint.Create(vDrawPt, 0, 0, 0, 11, 0, 0, NULL);
	vDrawPt = deCastelJau2(0.5, 0.5).GetPoint();
	ThePoint.Pt_Point->x = vDrawPt.x;
	ThePoint.Pt_Point->y = vDrawPt.y;
	ThePoint.Pt_Point->z = vDrawPt.z;
	ThePoint.SetToScr(pModZ, pScrZ);
	dSelD = pow(ThePoint.DSP_Point->x - InPT.x, 2) + pow(ThePoint.DSP_Point->y - InPT.y, 2);
	ThePoint.Clear();
	Ret.Dist = dSelD;
	Ret.pObj = this;
	return (Ret);
}

C4dVector Surf_Ex1::deCastelJau2(double u, double v)

{
	C4dVector vRetPt;

	ContrPolyW cLast;

	cLast.Create(1, NULL);

	cLast.AddVertW(pWCurve[0]->deCastelJau1(u));
	cLast.AddVertW(pWCurve[1]->deCastelJau1(u));
	vRetPt = cLast.deCastelJau1(v);

	cLast.Clear();
	return (vRetPt);
}

// Extruded Surface
IMPLEMENT_DYNAMIC(Surf_R, CObject)

// ContrPolyW* pWCurve[2];
// C3dVector vTranVec;
// C3dMatrix* pScrZ;

void Surf_R::Create(ContrPolyW* pWCurveIn, C3dVector vRotVecIn, int iLab, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 3;
	iLabel = iLab;
	iObjType = 11;
	pParent = Parrent;
	vRotVec = vRotVecIn;

	pWCurve[0] = pWCurveIn;
	pWCurve[1] = new ContrPolyW;
	pWCurve[1]->Create(1, this);
	pWCurve[1]->Set2(pWCurve[0]);
	pWCurve[1]->CPolyRot(45);

	pWCurve[2] = new ContrPolyW;
	pWCurve[2]->Create(1, this);
	pWCurve[2]->Set2(pWCurve[0]);
	pWCurve[2]->CPolyRot(90);
	pWCurve[2]->CWeight(2);

	pWCurve[3] = new ContrPolyW;
	pWCurve[3]->Create(1, this);
	pWCurve[3]->AddVertW(*pWCurve[0]->pCVertex[0]);
	pWCurve[3]->AddVertW(*pWCurve[1]->pCVertex[0]);
	pWCurve[3]->AddVertW(*pWCurve[2]->pCVertex[0]);

	pWCurve[4] = new ContrPolyW;
	pWCurve[4]->Create(1, this);
	pWCurve[4]->AddVertW(*pWCurve[0]->pCVertex[pWCurve[0]->iNoVerts - 1]);
	pWCurve[4]->AddVertW(*pWCurve[1]->pCVertex[pWCurve[0]->iNoVerts - 1]);
	pWCurve[4]->AddVertW(*pWCurve[2]->pCVertex[pWCurve[0]->iNoVerts - 1]);
}

void Surf_R::Draw(CDC* pDC, int iDrawmode) {
	pWCurve[0]->SetToScr(pModZ, pScrZ);
	pWCurve[1]->SetToScr(pModZ, pScrZ);
	pWCurve[2]->SetToScr(pModZ, pScrZ);
	pWCurve[3]->SetToScr(pModZ, pScrZ);
	pWCurve[4]->SetToScr(pModZ, pScrZ);
	pWCurve[0]->Draw(pDC, 4, 0, 1);
	// pWCurve[1]->Draw(pDC,4);
	pWCurve[2]->Draw(pDC, 4, 0, 1);
	pWCurve[3]->Draw(pDC, 4, 0, 1);
	pWCurve[4]->Draw(pDC, 4, 0, 1);

	C3dVector vDrawPt;
	C4dVector vWpt;
	// Pt_Object ThePoint;

	//  ThePoint.Create(vDrawPt,0);
	//  vDrawPt = deCastelJau2(0,0.5).GetPoint();
	//  ThePoint.Pt_Point->x  = vDrawPt.x;
	//  ThePoint.Pt_Point->y  = vDrawPt.y;
	//  ThePoint.Pt_Point->z  = vDrawPt.z;
	//  ThePoint.SetToScr(pScrZ);
	//  pDC->MoveTo(ThePoint.DSP_Point->x,ThePoint.DSP_Point->y);
	//   for (iCnt1 = 1; iCnt1 < 21; iCnt1++)
	//       {
	//	   fred = iCnt1*0.05;
	//	   vDrawPt = deCastelJau2(fred,0.5).GetPoint();
	//	   ThePoint.Pt_Point->x  = vDrawPt.x;
	//       ThePoint.Pt_Point->y  = vDrawPt.y;
	//       ThePoint.Pt_Point->z  = vDrawPt.z;
	//	   ThePoint.SetToScr(pScrZ);
	//       pDC->LineTo(ThePoint.DSP_Point->x,ThePoint.DSP_Point->y);
	//       }
}

void Surf_R::OglDraw(int iDspFlgs) {
	GLfloat* ctrlpts;
	int iu;
	int iv;
	int icu, icv;
	int iInd = 0;
	iu = pWCurve[0]->iNoVerts;
	iv = pWCurve[3]->iNoVerts;

	ctrlpts = (GLfloat*) malloc(iv * iu * 4 * sizeof(GLfloat));

	for (icv = 0; icv < iv; icv++) {
		for (icu = 0; icu < iu; icu++) {
			ctrlpts[iInd] = (float) pWCurve[icv]->pCVertex[icu]->xw;
			ctrlpts[iInd + 1] = (float) pWCurve[icv]->pCVertex[icu]->yw;
			ctrlpts[iInd + 2] = (float) -pWCurve[icv]->pCVertex[icu]->zw;
			ctrlpts[iInd + 3] = (float) pWCurve[icv]->pCVertex[icu]->w;
			iInd = iInd + 4;
		}
	}

	glEnable(GL_MAP2_VERTEX_4);
	// glBegin(GL_POINTS);
	// glVertex4fv(&ctrlpts[0]);
	// glVertex4fv(&ctrlpts[4]);
	// glVertex4fv(&ctrlpts[8]);
	// glVertex4fv(&ctrlpts[12]);
	// glVertex4fv(&ctrlpts[16]);
	// glVertex4fv(&ctrlpts[20]);
	// glEnd();

	glMap2f(GL_MAP2_VERTEX_4, 0.0f, 1.0f, 4, iu, 0.0f, 1.0f, iu * 4, iv, ctrlpts);
	glEnable(GL_MAP2_VERTEX_4);
	glMapGrid2f(20, 0.0f, 1.0f, 20, 0.0f, 1.0f);
	glEvalMesh2(GL_FILL, 0, 20, 0, 20);
	glFlush();
	free(ctrlpts);
}

void Surf_R::OglDrawW(int iDspFlgs) {
	GLfloat* ctrlpts;
	int iu;
	int iv;
	int icu, icv;
	int iInd = 0;
	iu = pWCurve[0]->iNoVerts;
	iv = pWCurve[3]->iNoVerts;

	ctrlpts = (GLfloat*) malloc(iv * iu * 4 * sizeof(GLfloat));

	for (icv = 0; icv < iv; icv++) {
		for (icu = 0; icu < iu; icu++) {
			ctrlpts[iInd] = (float) pWCurve[icv]->pCVertex[icu]->xw;
			ctrlpts[iInd + 1] = (float) pWCurve[icv]->pCVertex[icu]->yw;
			ctrlpts[iInd + 2] = (float) -pWCurve[icv]->pCVertex[icu]->zw;
			ctrlpts[iInd + 3] = (float) pWCurve[icv]->pCVertex[icu]->w;
			iInd = iInd + 4;
		}
	}

	glEnable(GL_MAP2_VERTEX_4);
	// glBegin(GL_POINTS);
	// glVertex4fv(&ctrlpts[0]);
	// glVertex4fv(&ctrlpts[4]);
	// glVertex4fv(&ctrlpts[8]);
	// glVertex4fv(&ctrlpts[12]);
	// glVertex4fv(&ctrlpts[16]);
	// glVertex4fv(&ctrlpts[20]);
	// glEnd();

	glMap2f(GL_MAP2_VERTEX_4, 0.0f, 1.0f, 4, iu, 0.0f, 1.0f, iu * 4, iv, ctrlpts);
	glEnable(GL_MAP2_VERTEX_4);
	glMapGrid2f(20, 0.0f, 1.0f, 20, 0.0f, 1.0f);
	glEvalMesh2(GL_LINE, 0, 20, 0, 20);
	glFlush();
	free(ctrlpts);
}

void Surf_R::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	pModZ = pModMat;
	pScrZ = pScrTran;
}

void Surf_R::HighLight(CDC* pDC) {
	Draw(pDC, 4);
}

G_ObjectD Surf_R::SelDist(CPoint InPT, Filter FIL) {
	double dSelD;
	G_ObjectD Ret;
	Node ThePoint;
	C3dVector vDrawPt;
	ThePoint.Create(vDrawPt, 0, 0, 0, 11, 0, 0, NULL);
	vDrawPt = deCastelJau2(0.5, 0.5).GetPoint();
	ThePoint.Pt_Point->x = vDrawPt.x;
	ThePoint.Pt_Point->y = vDrawPt.y;
	ThePoint.Pt_Point->z = vDrawPt.z;
	ThePoint.SetToScr(pModZ, pScrZ);
	dSelD = pow(ThePoint.DSP_Point->x - InPT.x, 2) + pow(ThePoint.DSP_Point->y - InPT.y, 2);
	ThePoint.Clear();

	Ret.pObj = this;
	Ret.Dist = dSelD;
	return (Ret);
}

C4dVector Surf_R::deCastelJau2(double u, double v)

{
	C4dVector vRetPt;
	ContrPolyW cLast;
	cLast.Create(1, this);
	cLast.AddVertW(pWCurve[0]->deCastelJau1(u));
	cLast.AddVertW(pWCurve[1]->deCastelJau1(u));
	cLast.AddVertW(pWCurve[2]->deCastelJau1(u));
	vRetPt = cLast.deCastelJau1(v);
	cLast.Clear();
	return (vRetPt);
}

//----------------------------------------------------------------------------
//    E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object38, CObject)

E_Object38::E_Object38() {
	G_Object();
}

E_Object38::~E_Object38() {
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	pVertex[2] = NULL;
	pVertex[3] = NULL;
	pVertex[4] = NULL;
	pVertex[5] = NULL;
	pVertex[6] = NULL;
	pVertex[7] = NULL;
}

void E_Object38::Info() {
	char S1[80];
	E_Object::Info();
	sprintf_s(S1, "NODES %i %i %i %i", pVertex[0]->iLabel, pVertex[1]->iLabel, pVertex[2]->iLabel, pVertex[3]->iLabel);
	outtext1(S1);
	sprintf_s(S1, "NODES %i %i %i %i", pVertex[4]->iLabel, pVertex[5]->iLabel, pVertex[6]->iLabel, pVertex[7]->iLabel);
	outtext1(S1);
}

void E_Object38::Create(Node* pInVertex[100], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                        G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	int i = 0;
	for (i = 0; i < 8; i++) {
		pVertex[i] = pInVertex[i];
	}
}

void E_Object38::Reverse() {
	Node* pT[8];
	pT[0] = pVertex[0];
	pT[1] = pVertex[1];
	pT[2] = pVertex[2];
	pT[3] = pVertex[3];
	pT[4] = pVertex[4];
	pT[5] = pVertex[5];
	pT[6] = pVertex[6];
	pT[7] = pVertex[7];
	pVertex[0] = pT[0];
	pVertex[1] = pT[3];
	pVertex[2] = pT[2];
	pVertex[3] = pT[1];
	pVertex[4] = pT[4];
	pVertex[5] = pT[7];
	pVertex[6] = pT[6];
	pVertex[7] = pT[5];
}

G_Object* E_Object38::GetNode(int i) {
	return (pVertex[i]);
}

int E_Object38::GetLinkList(eEdge* Links[12]) {
	Links[0] = new eEdge;
	Links[0]->pParent = this;
	Links[0]->pVertex[0] = pVertex[0];
	Links[0]->pVertex[1] = pVertex[1];
	Links[0]->iColour = iColour;
	Links[1] = new eEdge;
	Links[1]->pParent = this;
	Links[1]->pVertex[0] = pVertex[1];
	Links[1]->pVertex[1] = pVertex[2];
	Links[1]->iColour = iColour;
	Links[2] = new eEdge;
	Links[2]->pParent = this;
	Links[2]->pVertex[0] = pVertex[2];
	Links[2]->pVertex[1] = pVertex[3];
	Links[2]->iColour = iColour;
	Links[3] = new eEdge;
	Links[3]->pParent = this;
	Links[3]->pVertex[0] = pVertex[3];
	Links[3]->pVertex[1] = pVertex[0];
	Links[3]->iColour = iColour;

	Links[4] = new eEdge;
	Links[4]->pParent = this;
	Links[4]->pVertex[0] = pVertex[4];
	Links[4]->pVertex[1] = pVertex[5];
	Links[4]->iColour = iColour;
	Links[5] = new eEdge;
	Links[5]->pParent = this;
	Links[5]->pVertex[0] = pVertex[5];
	Links[5]->pVertex[1] = pVertex[6];
	Links[5]->iColour = iColour;
	Links[6] = new eEdge;
	Links[6]->pParent = this;
	Links[6]->pVertex[0] = pVertex[6];
	Links[6]->pVertex[1] = pVertex[7];
	Links[6]->iColour = iColour;
	Links[7] = new eEdge;
	Links[7]->pParent = this;
	Links[7]->pVertex[0] = pVertex[7];
	Links[7]->pVertex[1] = pVertex[4];
	Links[7]->iColour = iColour;

	Links[8] = new eEdge;
	Links[8]->pParent = this;
	Links[8]->pVertex[0] = pVertex[0];
	Links[8]->pVertex[1] = pVertex[4];
	Links[8]->iColour = iColour;
	Links[9] = new eEdge;
	Links[9]->pParent = this;
	Links[9]->pVertex[0] = pVertex[1];
	Links[9]->pVertex[1] = pVertex[5];
	Links[9]->iColour = iColour;
	Links[10] = new eEdge;
	Links[10]->pParent = this;
	Links[10]->pVertex[0] = pVertex[2];
	Links[10]->pVertex[1] = pVertex[6];
	Links[10]->iColour = iColour;
	Links[11] = new eEdge;
	Links[11]->pParent = this;
	Links[11]->pVertex[0] = pVertex[3];
	Links[11]->pVertex[1] = pVertex[7];
	Links[11]->iColour = iColour;

	return (12);
}

int E_Object38::GetfaceList(eFace* Faces[6]) {
	int ic;
	ic = GetCol();
	Faces[0] = new eFace();
	Faces[0]->pParent = this;
	Faces[0]->pVertex[0] = pVertex[0];
	Faces[0]->pVertex[1] = pVertex[3];
	Faces[0]->pVertex[2] = pVertex[2];
	Faces[0]->pVertex[3] = pVertex[1];
	Faces[0]->NoVert = 4;
	Faces[0]->iColour = ic;

	Faces[1] = new eFace();
	Faces[1]->pParent = this;
	Faces[1]->pVertex[0] = pVertex[4];
	Faces[1]->pVertex[1] = pVertex[5];
	Faces[1]->pVertex[2] = pVertex[6];
	Faces[1]->pVertex[3] = pVertex[7];
	Faces[1]->NoVert = 4;
	Faces[1]->iColour = ic;

	Faces[2] = new eFace();
	Faces[2]->pParent = this;
	Faces[2]->pVertex[0] = pVertex[0];
	Faces[2]->pVertex[1] = pVertex[1];
	Faces[2]->pVertex[2] = pVertex[5];
	Faces[2]->pVertex[3] = pVertex[4];
	Faces[2]->NoVert = 4;
	Faces[2]->iColour = ic;

	Faces[3] = new eFace();
	Faces[3]->pParent = this;
	Faces[3]->pVertex[0] = pVertex[1];
	Faces[3]->pVertex[1] = pVertex[2];
	Faces[3]->pVertex[2] = pVertex[6];
	Faces[3]->pVertex[3] = pVertex[5];
	Faces[3]->NoVert = 4;
	Faces[3]->iColour = ic;

	Faces[4] = new eFace();
	Faces[4]->pParent = this;
	Faces[4]->pVertex[0] = pVertex[2];
	Faces[4]->pVertex[1] = pVertex[3];
	Faces[4]->pVertex[2] = pVertex[7];
	Faces[4]->pVertex[3] = pVertex[6];
	Faces[4]->NoVert = 4;
	Faces[4]->iColour = ic;

	Faces[5] = new eFace();
	Faces[5]->pParent = this;
	Faces[5]->pVertex[0] = pVertex[0];
	Faces[5]->pVertex[1] = pVertex[4];
	Faces[5]->pVertex[2] = pVertex[7];
	Faces[5]->pVertex[3] = pVertex[3];
	Faces[5]->NoVert = 4;
	Faces[5]->iColour = ic;

	return (6);
}

void E_Object38::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

BOOL E_Object38::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_Object38::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		ar << pVertex[0]->iLabel;
		ar << pVertex[1]->iLabel;
		ar << pVertex[2]->iLabel;
		ar << pVertex[3]->iLabel;
		ar << pVertex[4]->iLabel;
		ar << pVertex[5]->iLabel;
		ar << pVertex[6]->iLabel;
		ar << pVertex[7]->iLabel;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		ar >> iNd;
		pVertex[0] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[1] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[2] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[3] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[4] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[5] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[6] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[7] = MESH->GetNode(iNd);
	}
}

G_Object* E_Object38::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object38* gret = new E_Object38;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->pVertex[2] = MESH->GetNode(pVertex[2]->iLabel);
	gret->pVertex[3] = MESH->GetNode(pVertex[3]->iLabel);
	gret->pVertex[4] = MESH->GetNode(pVertex[4]->iLabel);
	gret->pVertex[5] = MESH->GetNode(pVertex[5]->iLabel);
	gret->pVertex[6] = MESH->GetNode(pVertex[6]->iLabel);
	gret->pVertex[7] = MESH->GetNode(pVertex[7]->iLabel);
	gret->pPr = pPr;
	gret->pParent = MESH;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object38::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object38* gret = new E_Object38;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[2]);
	gret->pVertex[2] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[3]);
	gret->pVertex[3] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[4]);
	gret->pVertex[4] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[5]);
	gret->pVertex[5] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[6]);
	gret->pVertex[6] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[7]);
	gret->pVertex[7] = Target->pNodes[EInd + iSInd];
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object38::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object38* gret = new E_Object38;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->pVertex[2] = pInVertex[2];
	gret->pVertex[3] = pInVertex[3];
	gret->pVertex[4] = pInVertex[4];
	gret->pVertex[5] = pInVertex[5];
	gret->pVertex[6] = pInVertex[6];
	gret->pVertex[7] = pInVertex[7];
	gret->pPr = pPr;
	gret->pParent = Parrent;
	gret->pResV = NULL;
	return (gret);
}

// Draw Object line
void E_Object38::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);
	pDC->LineTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);

	pDC->LineTo((int) pVertex[4]->DSP_Point->x, (int) pVertex[4]->DSP_Point->y);
	pDC->LineTo((int) pVertex[5]->DSP_Point->x, (int) pVertex[5]->DSP_Point->y);
	pDC->LineTo((int) pVertex[6]->DSP_Point->x, (int) pVertex[6]->DSP_Point->y);
	pDC->LineTo((int) pVertex[7]->DSP_Point->x, (int) pVertex[7]->DSP_Point->y);
	pDC->LineTo((int) pVertex[4]->DSP_Point->x, (int) pVertex[4]->DSP_Point->y);

	pDC->MoveTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[5]->DSP_Point->x, (int) pVertex[5]->DSP_Point->y);

	pDC->MoveTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[6]->DSP_Point->x, (int) pVertex[6]->DSP_Point->y);

	pDC->MoveTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);
	pDC->LineTo((int) pVertex[7]->DSP_Point->x, (int) pVertex[7]->DSP_Point->y);
}

void E_Object38::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	C3dVector d[8];
	int i;
	int ind;

	for (i = 0; i < 8; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS;
	dFS = ME->dResFactor;
	ind = ME->iCVar;
	glLineWidth(gEL_SIZE);
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 8; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		if ((iDspFlgs & DSP_LINE) > 0) {
			glColor3fv(cols[iColour]);
		} else {
			glColor3fv(cols[0]);
		}
		glBegin(GL_LINES);
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));

		glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
		           (float) (pVertex[4]->Pt_Point->z + d[4].z));
		glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
		           (float) (pVertex[5]->Pt_Point->z + d[5].z));
		glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
		           (float) (pVertex[5]->Pt_Point->z + d[5].z));
		glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
		           (float) (pVertex[6]->Pt_Point->z + d[6].z));
		glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
		           (float) (pVertex[6]->Pt_Point->z + d[6].z));
		glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
		           (float) (pVertex[7]->Pt_Point->z + d[7].z));
		glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
		           (float) (pVertex[7]->Pt_Point->z + d[7].z));
		glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
		           (float) (pVertex[4]->Pt_Point->z + d[4].z));

		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
		           (float) (pVertex[4]->Pt_Point->z + d[4].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
		           (float) (pVertex[5]->Pt_Point->z + d[5].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
		           (float) (pVertex[6]->Pt_Point->z + d[6].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));
		glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
		           (float) (pVertex[7]->Pt_Point->z + d[7].z));
		glEnd();
		C3dVector vCent;
		vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "E%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if (((iDspFlgs & DSP_RESLAB) == 0) && (pResV != NULL)) {
			sprintf_s(sLab, "%f", *pResV->GetAddress(ind));
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if ((iDspFlgs & DSP_ELSYS) == 0) {
			C3dMatrix mS = GetElSys();
			C3dVector vC = Get_Centroid();
			mS.Transpose();
			C3dVector vX = mS.GetColVec(1);
			C3dVector vY = mS.GetColVec(2);
			;
			C3dVector vZ = mS.GetColVec(3);
			;

			vX *= 0.5 * dS1;
			vY *= 0.5 * dS1;
			vZ *= 0.5 * dS1;
			vX += vC;
			vY += vC;
			vZ += vC;

			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vX.x, (float) vX.y, (float) vX.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vY.x, (float) vY.y, (float) vY.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glEnd();
			glRasterPos3f((float) vX.x, (float) vX.y, (float) vX.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPX);
			glRasterPos3f((float) vY.x, (float) vY.y, (float) vY.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPY);
			glRasterPos3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}
	} else {
		Selectable = 0;
	}
}

void E_Object38::OglDraw(int iDspFlgs, double dS1, double dS2) {
	C3dVector d[8];
	int i;
	for (i = 0; i < 8; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS = 1.0;
	dFS = ME->dResFactor;
	glLineWidth(2.0);
	float fCols[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	BOOL bD = FALSE;
	int iVar;
	iVar = ME->iCVar;
	// Nodal data

	if ((pVertex[0]->pResV != NULL) &&
	    (pVertex[1]->pResV != NULL) &&
	    (pVertex[2]->pResV != NULL) &&
	    (pVertex[3]->pResV != NULL) &&
	    (pVertex[4]->pResV != NULL) &&
	    (pVertex[5]->pResV != NULL) &&
	    (pVertex[6]->pResV != NULL) &&
	    (pVertex[7]->pResV != NULL)) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pVertex[0]->pResV->GetAddress(iVar) * dFS);
		fCols[1] = GetContourCol(*pVertex[1]->pResV->GetAddress(iVar) * dFS);
		fCols[2] = GetContourCol(*pVertex[2]->pResV->GetAddress(iVar) * dFS);
		fCols[3] = GetContourCol(*pVertex[3]->pResV->GetAddress(iVar) * dFS);
		fCols[4] = GetContourCol(*pVertex[4]->pResV->GetAddress(iVar) * dFS);
		fCols[5] = GetContourCol(*pVertex[5]->pResV->GetAddress(iVar) * dFS);
		fCols[6] = GetContourCol(*pVertex[6]->pResV->GetAddress(iVar) * dFS);
		fCols[7] = GetContourCol(*pVertex[7]->pResV->GetAddress(iVar) * dFS);
	}
	if (pResV != NULL) {
		bD = TRUE;
		float fC;
		if (iLabel == 106) {
			bD = TRUE;
		}
		fC = GetContourCol(*pResV->GetAddress(iVar) * dFS);
		fCols[0] = fC;
		fCols[1] = fC;
		fCols[2] = fC;
		fCols[3] = fC;
		fCols[4] = fC;
		fCols[5] = fC;
		fCols[6] = fC;
		fCols[7] = fC;
	}

	C3dVector v1;
	C3dVector v2;
	C3dVector Vn;
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 8; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		glColor3fv(cols[iColour]);
		if (((iDspFlgs & DSP_CONT) > 0) || (bD == FALSE)) {
			v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
			v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
			v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

			v2.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
			v2.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
			v2.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();

			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glEnd();

			v1.x = pVertex[5]->Pt_Point->x - pVertex[4]->Pt_Point->x;
			v1.y = pVertex[5]->Pt_Point->y - pVertex[4]->Pt_Point->y;
			v1.z = pVertex[5]->Pt_Point->z - pVertex[4]->Pt_Point->z;

			v2.x = pVertex[6]->Pt_Point->x - pVertex[5]->Pt_Point->x;
			v2.y = pVertex[6]->Pt_Point->y - pVertex[5]->Pt_Point->y;
			v2.z = pVertex[6]->Pt_Point->z - pVertex[5]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
			           (float) (pVertex[6]->Pt_Point->z + d[6].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
			           (float) (pVertex[7]->Pt_Point->z + d[7].z));
			glEnd();

			v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
			v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
			v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

			v2.x = pVertex[5]->Pt_Point->x - pVertex[1]->Pt_Point->x;
			v2.y = pVertex[5]->Pt_Point->y - pVertex[1]->Pt_Point->y;
			v2.z = pVertex[5]->Pt_Point->z - pVertex[1]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glEnd();

			v1.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
			v1.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
			v1.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;

			v2.x = pVertex[5]->Pt_Point->x - pVertex[2]->Pt_Point->x;
			v2.y = pVertex[5]->Pt_Point->y - pVertex[2]->Pt_Point->y;
			v2.z = pVertex[5]->Pt_Point->z - pVertex[2]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
			           (float) (pVertex[6]->Pt_Point->z + d[6].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glEnd();

			v1.x = pVertex[6]->Pt_Point->x - pVertex[2]->Pt_Point->x;
			v1.y = pVertex[6]->Pt_Point->y - pVertex[2]->Pt_Point->y;
			v1.z = pVertex[6]->Pt_Point->z - pVertex[2]->Pt_Point->z;

			v2.x = pVertex[7]->Pt_Point->x - pVertex[6]->Pt_Point->x;
			v2.y = pVertex[7]->Pt_Point->y - pVertex[6]->Pt_Point->y;
			v2.z = pVertex[7]->Pt_Point->z - pVertex[6]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
			           (float) (pVertex[6]->Pt_Point->z + d[6].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
			           (float) (pVertex[7]->Pt_Point->z + d[7].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glEnd();

			v1.x = pVertex[3]->Pt_Point->x - pVertex[0]->Pt_Point->x;
			v1.y = pVertex[3]->Pt_Point->y - pVertex[0]->Pt_Point->y;
			v1.z = pVertex[3]->Pt_Point->z - pVertex[0]->Pt_Point->z;

			v2.x = pVertex[7]->Pt_Point->x - pVertex[3]->Pt_Point->x;
			v2.y = pVertex[7]->Pt_Point->y - pVertex[3]->Pt_Point->y;
			v2.z = pVertex[7]->Pt_Point->z - pVertex[3]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
			           (float) (pVertex[7]->Pt_Point->z + d[7].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glEnd();
		} else {
			if (bD) {
				glColor3fv(cols[124]);
				glEnable(GL_TEXTURE_1D);
				glBegin(GL_POLYGON);
				glTexCoord1f(fCols[0]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glTexCoord1f(fCols[1]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glTexCoord1f(fCols[2]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glTexCoord1f(fCols[3]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glEnd();

				v1.x = pVertex[5]->Pt_Point->x - pVertex[4]->Pt_Point->x;
				v1.y = pVertex[5]->Pt_Point->y - pVertex[4]->Pt_Point->y;
				v1.z = pVertex[5]->Pt_Point->z - pVertex[4]->Pt_Point->z;

				v2.x = pVertex[6]->Pt_Point->x - pVertex[5]->Pt_Point->x;
				v2.y = pVertex[6]->Pt_Point->y - pVertex[5]->Pt_Point->y;
				v2.z = pVertex[6]->Pt_Point->z - pVertex[5]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glTexCoord1f(fCols[4]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glTexCoord1f(fCols[5]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glTexCoord1f(fCols[6]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
				           (float) (pVertex[6]->Pt_Point->z + d[6].z));
				glTexCoord1f(fCols[7]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
				           (float) (pVertex[7]->Pt_Point->z + d[7].z));
				glEnd();

				v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
				v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
				v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

				v2.x = pVertex[5]->Pt_Point->x - pVertex[1]->Pt_Point->x;
				v2.y = pVertex[5]->Pt_Point->y - pVertex[1]->Pt_Point->y;
				v2.z = pVertex[5]->Pt_Point->z - pVertex[1]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glTexCoord1f(fCols[0]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glTexCoord1f(fCols[1]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glTexCoord1f(fCols[5]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glTexCoord1f(fCols[4]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glEnd();

				v1.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
				v1.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
				v1.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;

				v2.x = pVertex[5]->Pt_Point->x - pVertex[2]->Pt_Point->x;
				v2.y = pVertex[5]->Pt_Point->y - pVertex[2]->Pt_Point->y;
				v2.z = pVertex[5]->Pt_Point->z - pVertex[2]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glTexCoord1f(fCols[1]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glTexCoord1f(fCols[2]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glTexCoord1f(fCols[6]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
				           (float) (pVertex[6]->Pt_Point->z + d[6].z));
				glTexCoord1f(fCols[5]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glEnd();

				v1.x = pVertex[6]->Pt_Point->x - pVertex[2]->Pt_Point->x;
				v1.y = pVertex[6]->Pt_Point->y - pVertex[2]->Pt_Point->y;
				v1.z = pVertex[6]->Pt_Point->z - pVertex[2]->Pt_Point->z;

				v2.x = pVertex[7]->Pt_Point->x - pVertex[6]->Pt_Point->x;
				v2.y = pVertex[7]->Pt_Point->y - pVertex[6]->Pt_Point->y;
				v2.z = pVertex[7]->Pt_Point->z - pVertex[6]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glTexCoord1f(fCols[2]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glTexCoord1f(fCols[6]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
				           (float) (pVertex[6]->Pt_Point->z + d[6].z));
				glTexCoord1f(fCols[7]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
				           (float) (pVertex[7]->Pt_Point->z + d[7].z));
				glTexCoord1f(fCols[3]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glEnd();

				v1.x = pVertex[3]->Pt_Point->x - pVertex[0]->Pt_Point->x;
				v1.y = pVertex[3]->Pt_Point->y - pVertex[0]->Pt_Point->y;
				v1.z = pVertex[3]->Pt_Point->z - pVertex[0]->Pt_Point->z;

				v2.x = pVertex[7]->Pt_Point->x - pVertex[3]->Pt_Point->x;
				v2.y = pVertex[7]->Pt_Point->y - pVertex[3]->Pt_Point->y;
				v2.z = pVertex[7]->Pt_Point->z - pVertex[3]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glTexCoord1f(fCols[0]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glTexCoord1f(fCols[3]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glTexCoord1f(fCols[7]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
				           (float) (pVertex[7]->Pt_Point->z + d[7].z));
				glTexCoord1f(fCols[4]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glEnd();
				glDisable(GL_TEXTURE_1D);
			}
		}
	} else {
		Selectable = 0;
	}
}

void E_Object38::ExportUNV(FILE* pFile) {
	int i;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	for (i = 0; i < iNoNodes; i++) {
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
	}
	fprintf(pFile, "\n", "");
}

void E_Object38::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8i", "CHEXA   ", iLabel, PID);
	fprintf(pFile, "%8i", pVertex[0]->iLabel);
	fprintf(pFile, "%8i", pVertex[1]->iLabel);
	fprintf(pFile, "%8i", pVertex[2]->iLabel);
	fprintf(pFile, "%8i", pVertex[3]->iLabel);
	fprintf(pFile, "%8i", pVertex[4]->iLabel);
	fprintf(pFile, "%8i", pVertex[5]->iLabel);
	fprintf(pFile, "\n", "");
	fprintf(pFile, "%8s", "        ");
	fprintf(pFile, "%8i", pVertex[6]->iLabel);
	fprintf(pFile, "%8i", pVertex[7]->iLabel);
	fprintf(pFile, "\n", "");
}

Mat E_Object38::getCoords3d() {
	int i;
	Mat coord(iNoNodes, 3);
	for (i = 0; i < iNoNodes; i++) {
		*coord.mn(i + 1, 1) = pVertex[i]->Pt_Point->x;
		*coord.mn(i + 1, 2) = pVertex[i]->Pt_Point->y;
		*coord.mn(i + 1, 3) = pVertex[i]->Pt_Point->z;
	}
	return (coord);
}

double E_Object38::GetCentriodVal(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	double dTemp = 0;
	double T = 0;
	int iDOFID;
	int j;
	Mat fun;
	Mat FunPnt(1, 3);
	*FunPnt.mn(1, 1) = 0.0;
	*FunPnt.mn(1, 2) = 0.0;
	*FunPnt.mn(1, 3) = 0.0;
	fun = this->ShapeFun(FunPnt, 1);
	for (j = 0; j < this->iNoNodes; j++) {
		T = 0;
		;
		iDOFID = this->pVertex[j]->dof[iDof];
		if (iDOFID > 0) {
			T = *Disp.nn(iDOFID);
		}
		dTemp += T * *fun.mn(1, j + 1);
	}
	fun.clear();
	FunPnt.clear();
	return (dTemp);
}

double E_Object38::GetElCentriodVal() {
	double dTemp = 0;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		dTemp += pVertex[j]->dTemp;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

C3dVector E_Object38::Get_Centroid() {
	Mat fun;
	Mat FunPnt(1, 3);
	*FunPnt.mn(1, 1) = 0.0;
	*FunPnt.mn(1, 2) = 0.0;
	*FunPnt.mn(1, 3) = 0.0;
	fun = ShapeFun(FunPnt, 1);
	C3dVector vT;
	vT.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vT += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
	}

	fun.clear();
	FunPnt.clear();
	return (vT);
}

C3dMatrix E_Object38::GetElSys() {
	C3dVector vX;
	C3dVector vZ;
	C3dVector vY;
	vX = pVertex[1]->GetCoords();
	vX -= pVertex[0]->GetCoords();
	vX.Normalize();
	vZ = pVertex[4]->GetCoords();
	vZ -= pVertex[0]->GetCoords(); // Approx z direction
	vZ.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	vZ = vX.Cross(vY);
	C3dMatrix vR;
	vR.SetColVec(1, vX);
	vR.SetColVec(2, vY);
	vR.SetColVec(3, vZ);
	vR.Transpose();
	return (vR);
}

int E_Object38::MaxBW() {
	int i;
	int j;
	int MaxDof;
	int MinDof;
	MaxDof = 0;
	MinDof = 99999999;
	for (i = 0; i < iNoNodes; i++) {
		for (j = 0; j < 6; j++) {
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] > MaxDof)) {
				MaxDof = pVertex[i]->dof[j];
			}
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] < MinDof)) {
				MinDof = pVertex[i]->dof[j];
			}
		}
	}
	int iRC;
	if (MaxDof - MinDof < 0) {
		iRC = 0;
	} else {
		iRC = MaxDof - MinDof;
	}
	return (iRC);
}

Mat E_Object38::Sample(int iNo) {
	Mat Pts(iNo, 4);

	if (iNo == 8) {
		double r3 = 1.0 / sqrt(3.0);
		double weight = 1.0;
		*Pts.mn(1, 1) = -r3;
		*Pts.mn(1, 2) = -r3;
		*Pts.mn(1, 3) = -r3;
		*Pts.mn(1, 4) = weight;
		*Pts.mn(2, 1) = r3;
		*Pts.mn(2, 2) = -r3;
		*Pts.mn(2, 3) = -r3;
		*Pts.mn(2, 4) = weight;
		*Pts.mn(3, 1) = r3;
		*Pts.mn(3, 2) = r3;
		*Pts.mn(3, 3) = -r3;
		*Pts.mn(3, 4) = weight;
		*Pts.mn(4, 1) = -r3;
		*Pts.mn(4, 2) = r3;
		*Pts.mn(4, 3) = -r3;
		*Pts.mn(4, 4) = weight;
		*Pts.mn(5, 1) = -r3;
		*Pts.mn(5, 2) = -r3;
		*Pts.mn(5, 3) = r3;
		*Pts.mn(5, 4) = weight;
		*Pts.mn(6, 1) = r3;
		*Pts.mn(6, 2) = -r3;
		*Pts.mn(6, 3) = r3;
		*Pts.mn(6, 4) = weight;
		*Pts.mn(7, 1) = r3;
		*Pts.mn(7, 2) = r3;
		*Pts.mn(7, 3) = r3;
		*Pts.mn(7, 4) = weight;
		*Pts.mn(8, 1) = -r3;
		*Pts.mn(8, 2) = r3;
		*Pts.mn(8, 3) = r3;
		*Pts.mn(8, 4) = weight;
	}
	return (Pts);
}

Mat E_Object38::ShapeFun(Mat Points, int i) {
	Mat fun(1, 8);
	double xi, eta, zeta;
	xi = *Points.mn(i, 1);
	eta = *Points.mn(i, 2);
	zeta = *Points.mn(i, 3);

	*fun.mn(1, 1) = 0.125 * (1.0 - xi) * (1.0 - eta) * (1.0 - zeta);
	*fun.mn(1, 2) = 0.125 * (1.0 + xi) * (1.0 - eta) * (1.0 - zeta);
	*fun.mn(1, 3) = 0.125 * (1.0 + xi) * (1.0 + eta) * (1.0 - zeta);
	*fun.mn(1, 4) = 0.125 * (1.0 - xi) * (1.0 + eta) * (1.0 - zeta);
	*fun.mn(1, 5) = 0.125 * (1.0 - xi) * (1.0 - eta) * (1.0 + zeta);
	*fun.mn(1, 6) = 0.125 * (1.0 + xi) * (1.0 - eta) * (1.0 + zeta);
	*fun.mn(1, 7) = 0.125 * (1.0 + xi) * (1.0 + eta) * (1.0 + zeta);
	*fun.mn(1, 8) = 0.125 * (1.0 - xi) * (1.0 + eta) * (1.0 + zeta);

	return (fun);
}

Mat E_Object38::ShapeDer(Mat Points, int i) {
	Mat der(3, 8);

	*der.mn(1, 1) = -0.125 * (1 - *Points.mn(i, 2)) * (1 - *Points.mn(i, 3));
	*der.mn(1, 2) = 0.125 * (1 - *Points.mn(i, 2)) * (1 - *Points.mn(i, 3));
	*der.mn(1, 3) = 0.125 * (1 + *Points.mn(i, 2)) * (1 - *Points.mn(i, 3));
	*der.mn(1, 4) = -0.125 * (1 + *Points.mn(i, 2)) * (1 - *Points.mn(i, 3));
	*der.mn(1, 5) = -0.125 * (1 - *Points.mn(i, 2)) * (1 + *Points.mn(i, 3));
	*der.mn(1, 6) = 0.125 * (1 - *Points.mn(i, 2)) * (1 + *Points.mn(i, 3));
	*der.mn(1, 7) = 0.125 * (1 + *Points.mn(i, 2)) * (1 + *Points.mn(i, 3));
	*der.mn(1, 8) = -0.125 * (1 + *Points.mn(i, 2)) * (1 + *Points.mn(i, 3));

	*der.mn(2, 1) = -0.125 * (1 - *Points.mn(i, 1)) * (1 - *Points.mn(i, 3));
	*der.mn(2, 2) = -0.125 * (1 + *Points.mn(i, 1)) * (1 - *Points.mn(i, 3));
	*der.mn(2, 3) = 0.125 * (1 + *Points.mn(i, 1)) * (1 - *Points.mn(i, 3));
	*der.mn(2, 4) = 0.125 * (1 - *Points.mn(i, 1)) * (1 - *Points.mn(i, 3));
	*der.mn(2, 5) = -0.125 * (1 - *Points.mn(i, 1)) * (1 + *Points.mn(i, 3));
	*der.mn(2, 6) = -0.125 * (1 + *Points.mn(i, 1)) * (1 + *Points.mn(i, 3));
	*der.mn(2, 7) = 0.125 * (1 + *Points.mn(i, 1)) * (1 + *Points.mn(i, 3));
	*der.mn(2, 8) = 0.125 * (1 - *Points.mn(i, 1)) * (1 + *Points.mn(i, 3));

	*der.mn(3, 1) = -0.125 * (1 - *Points.mn(i, 1)) * (1 - *Points.mn(i, 2));
	*der.mn(3, 2) = -0.125 * (1 + *Points.mn(i, 1)) * (1 - *Points.mn(i, 2));
	*der.mn(3, 3) = -0.125 * (1 + *Points.mn(i, 1)) * (1 + *Points.mn(i, 2));
	*der.mn(3, 4) = -0.125 * (1 - *Points.mn(i, 1)) * (1 + *Points.mn(i, 2));
	*der.mn(3, 5) = 0.125 * (1 - *Points.mn(i, 1)) * (1 - *Points.mn(i, 2));
	*der.mn(3, 6) = 0.125 * (1 + *Points.mn(i, 1)) * (1 - *Points.mn(i, 2));
	*der.mn(3, 7) = 0.125 * (1 + *Points.mn(i, 1)) * (1 + *Points.mn(i, 2));
	*der.mn(3, 8) = 0.125 * (1 - *Points.mn(i, 1)) * (1 + *Points.mn(i, 2));
	return (der);
}

Vec<int> E_Object38::GetSteerVec3d() {
	Vec<int> V(8 * 3);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[1]->dof[0];
	*V.nn(5) = pVertex[1]->dof[1];
	*V.nn(6) = pVertex[1]->dof[2];
	*V.nn(7) = pVertex[2]->dof[0];
	*V.nn(8) = pVertex[2]->dof[1];
	*V.nn(9) = pVertex[2]->dof[2];
	*V.nn(10) = pVertex[3]->dof[0];
	*V.nn(11) = pVertex[3]->dof[1];
	*V.nn(12) = pVertex[3]->dof[2];
	*V.nn(13) = pVertex[4]->dof[0];
	*V.nn(14) = pVertex[4]->dof[1];
	*V.nn(15) = pVertex[4]->dof[2];
	*V.nn(16) = pVertex[5]->dof[0];
	*V.nn(17) = pVertex[5]->dof[1];
	*V.nn(18) = pVertex[5]->dof[2];
	*V.nn(19) = pVertex[6]->dof[0];
	*V.nn(20) = pVertex[6]->dof[1];
	*V.nn(21) = pVertex[6]->dof[2];
	*V.nn(22) = pVertex[7]->dof[0];
	*V.nn(23) = pVertex[7]->dof[1];
	*V.nn(24) = pVertex[7]->dof[2];
	return (V);
}

Vec<int> E_Object38::GetSteerVec1d() {
	Vec<int> V(8 * 1);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[1]->dof[0];
	*V.nn(3) = pVertex[2]->dof[0];
	*V.nn(4) = pVertex[3]->dof[0];
	*V.nn(5) = pVertex[4]->dof[0];
	*V.nn(6) = pVertex[5]->dof[0];
	*V.nn(7) = pVertex[6]->dof[0];
	*V.nn(8) = pVertex[7]->dof[0];
	return (V);
}

int E_Object38::noDof() {
	return (3);
}

CString E_Object38::GetName() {
	return ("8 Node BRICK (CHEXA)");
}

int E_Object38::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "PID";
	iNo++;
	sVar[iNo] = "Mat ID";
	iNo++;
	sVar[iNo] = "N1";
	iNo++;
	sVar[iNo] = "N2";
	iNo++;
	sVar[iNo] = "N3";
	iNo++;
	sVar[iNo] = "N4";
	iNo++;
	sVar[iNo] = "N5";
	iNo++;
	sVar[iNo] = "N6";
	iNo++;
	sVar[iNo] = "N7";
	iNo++;
	sVar[iNo] = "N8";
	iNo++;
	return (iNo);
}

int E_Object38::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", PID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMatID);
	sVar[iNo] = S1;
	iNo++;

	sprintf_s(S1, "%i", pVertex[0]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[1]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[2]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[3]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[4]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[5]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[6]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[7]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void E_Object38::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Node* pN;
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	int newPID = atoi(sVar[1]);
	if (newPID != PID) {
		Property* pr = PT->GetItem(newPID);
		if (pr != NULL) {
			BOOL bC = SetProperty(pr);
			if (bC)
				outtext1("Property has Been Changed");
			else
				outtext1("Invalid Property");
		}
		iMatID = atoi(sVar[2]);
		int N1 = atoi(sVar[3]);
		int N2 = atoi(sVar[4]);
		int N3 = atoi(sVar[5]);
		int N4 = atoi(sVar[6]);
		int N5 = atoi(sVar[7]);
		int N6 = atoi(sVar[8]);
		int N7 = atoi(sVar[9]);
		int N8 = atoi(sVar[10]);
		if (pVertex[0]->iLabel != N1) {
			pN = pMe->GetNode(N1);
			if (pN != NULL)
				pVertex[0] = pN;
		}
		if (pVertex[1]->iLabel != N2) {
			pN = pMe->GetNode(N2);
			if (pN != NULL)
				pVertex[1] = pN;
		}
		if (pVertex[2]->iLabel != N3) {
			pN = pMe->GetNode(N3);
			if (pN != NULL)
				pVertex[2] = pN;
		}
		if (pVertex[3]->iLabel != N4) {
			pN = pMe->GetNode(N4);
			if (pN != NULL)
				pVertex[3] = pN;
		}
		if (pVertex[4]->iLabel != N5) {
			pN = pMe->GetNode(N5);
			if (pN != NULL)
				pVertex[4] = pN;
		}
		if (pVertex[5]->iLabel != N6) {
			pN = pMe->GetNode(N6);
			if (pN != NULL)
				pVertex[5] = pN;
		}
		if (pVertex[6]->iLabel != N7) {
			pN = pMe->GetNode(N7);
			if (pN != NULL)
				pVertex[6] = pN;
		}
		if (pVertex[7]->iLabel != N8) {
			pN = pMe->GetNode(N8);
			if (pN != NULL)
				pVertex[7] = pN;
		}
	}
}

//----------------------------------------------------------------------------
//    E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object36, CObject)

E_Object36::E_Object36() {
	G_Object();
}

E_Object36::~E_Object36() {
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	pVertex[2] = NULL;
	pVertex[3] = NULL;
	pVertex[4] = NULL;
	pVertex[5] = NULL;
}

void E_Object36::Create(Node* pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                        G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	int i = 0;
	for (i = 0; i < 6; i++) {
		pVertex[i] = pInVertex[i];
	}
}

void E_Object36::Reverse() {
	Node* pT[8];
	pT[0] = pVertex[0];
	pT[1] = pVertex[1];
	pT[2] = pVertex[2];
	pT[3] = pVertex[3];
	pT[4] = pVertex[4];
	pT[5] = pVertex[5];
	pVertex[0] = pT[0];
	pVertex[1] = pT[2];
	pVertex[2] = pT[1];
	pVertex[3] = pT[3];
	pVertex[4] = pT[5];
	pVertex[5] = pT[4];
}

void E_Object36::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

BOOL E_Object36::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_Object36::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		ar << pVertex[0]->iLabel;
		ar << pVertex[1]->iLabel;
		ar << pVertex[2]->iLabel;
		ar << pVertex[3]->iLabel;
		ar << pVertex[4]->iLabel;
		ar << pVertex[5]->iLabel;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		ar >> iNd;
		pVertex[0] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[1] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[2] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[3] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[4] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[5] = MESH->GetNode(iNd);
	}
}

G_Object* E_Object36::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object36* gret = new E_Object36;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->pVertex[2] = MESH->GetNode(pVertex[2]->iLabel);
	gret->pVertex[3] = MESH->GetNode(pVertex[3]->iLabel);
	gret->pVertex[4] = MESH->GetNode(pVertex[4]->iLabel);
	gret->pVertex[5] = MESH->GetNode(pVertex[5]->iLabel);
	gret->pPr = pPr;
	gret->pParent = MESH;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object36::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object36* gret = new E_Object36;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[2]);
	gret->pVertex[2] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[3]);
	gret->pVertex[3] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[4]);
	gret->pVertex[4] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[5]);
	gret->pVertex[5] = Target->pNodes[EInd + iSInd];
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object36::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object36* gret = new E_Object36;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->pVertex[2] = pInVertex[2];
	gret->pVertex[3] = pInVertex[3];
	gret->pVertex[4] = pInVertex[4];
	gret->pVertex[5] = pInVertex[5];
	gret->pPr = pPr;
	gret->pParent = Parrent;
	gret->pResV = NULL;
	return (gret);
}

// Draw Object line
void E_Object36::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);

	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);
	pDC->LineTo((int) pVertex[4]->DSP_Point->x, (int) pVertex[4]->DSP_Point->y);
	pDC->LineTo((int) pVertex[5]->DSP_Point->x, (int) pVertex[5]->DSP_Point->y);
	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);

	pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);

	pDC->MoveTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[4]->DSP_Point->x, (int) pVertex[4]->DSP_Point->y);

	pDC->MoveTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[5]->DSP_Point->x, (int) pVertex[5]->DSP_Point->y);
}

void E_Object36::OglDraw(int iDspFlgs, double dS1, double dS2) {
	C3dVector d[6];
	int i;
	for (i = 0; i < 6; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS = 1.0;
	dFS = ME->dResFactor;
	glLineWidth(2.0);
	float fCols[6] = {0, 0, 0, 0, 0, 0};
	BOOL bD = FALSE;
	int iVar;
	iVar = ME->iCVar;
	// Nodal data
	if ((pVertex[0]->pResV != NULL) &&
	    (pVertex[1]->pResV != NULL) &&
	    (pVertex[2]->pResV != NULL) &&
	    (pVertex[3]->pResV != NULL) &&
	    (pVertex[4]->pResV != NULL) &&
	    (pVertex[5]->pResV != NULL)) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pVertex[0]->pResV->GetAddress(iVar) * dFS);
		fCols[1] = GetContourCol(*pVertex[1]->pResV->GetAddress(iVar) * dFS);
		fCols[2] = GetContourCol(*pVertex[2]->pResV->GetAddress(iVar) * dFS);
		fCols[3] = GetContourCol(*pVertex[3]->pResV->GetAddress(iVar) * dFS);
		fCols[4] = GetContourCol(*pVertex[4]->pResV->GetAddress(iVar) * dFS);
		fCols[5] = GetContourCol(*pVertex[5]->pResV->GetAddress(iVar) * dFS);
	}
	if (pResV != NULL) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pResV->GetAddress(iVar) * dFS);
		fCols[1] = fCols[0];
		fCols[2] = fCols[0];
		fCols[3] = fCols[0];
		fCols[4] = fCols[0];
		fCols[5] = fCols[0];
	}
	C3dVector v1;
	C3dVector v2;
	C3dVector Vn;
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 6; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}

		Selectable = 1;
		if (((iDspFlgs & DSP_CONT) > 0) || (bD == FALSE)) {
			v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
			v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
			v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

			v2.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
			v2.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
			v2.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glColor3fv(cols[iColour]);
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glEnd();

			v1.x = pVertex[4]->Pt_Point->x - pVertex[3]->Pt_Point->x;
			v1.y = pVertex[4]->Pt_Point->y - pVertex[3]->Pt_Point->y;
			v1.z = pVertex[4]->Pt_Point->z - pVertex[3]->Pt_Point->z;

			v2.x = pVertex[5]->Pt_Point->x - pVertex[4]->Pt_Point->x;
			v2.y = pVertex[5]->Pt_Point->y - pVertex[4]->Pt_Point->y;
			v2.z = pVertex[5]->Pt_Point->z - pVertex[4]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glEnd();

			v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
			v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
			v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

			v2.x = pVertex[4]->Pt_Point->x - pVertex[1]->Pt_Point->x;
			v2.y = pVertex[4]->Pt_Point->y - pVertex[1]->Pt_Point->y;
			v2.z = pVertex[4]->Pt_Point->z - pVertex[1]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glEnd();

			v1.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
			v1.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
			v1.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;

			v2.x = pVertex[5]->Pt_Point->x - pVertex[2]->Pt_Point->x;
			v2.y = pVertex[5]->Pt_Point->y - pVertex[2]->Pt_Point->y;
			v2.z = pVertex[5]->Pt_Point->z - pVertex[2]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glEnd();

			v1.x = pVertex[0]->Pt_Point->x - pVertex[2]->Pt_Point->x;
			v1.y = pVertex[0]->Pt_Point->y - pVertex[2]->Pt_Point->y;
			v1.z = pVertex[0]->Pt_Point->z - pVertex[2]->Pt_Point->z;

			v2.x = pVertex[3]->Pt_Point->x - pVertex[0]->Pt_Point->x;
			v2.y = pVertex[3]->Pt_Point->y - pVertex[0]->Pt_Point->y;
			v2.z = pVertex[3]->Pt_Point->z - pVertex[0]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glEnd();
		} else {
			if (bD) {
				glColor3fv(cols[124]);
				glEnable(GL_TEXTURE_1D);
				v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
				v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
				v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

				v2.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
				v2.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
				v2.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[2]);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glEnd();

				v1.x = pVertex[4]->Pt_Point->x - pVertex[3]->Pt_Point->x;
				v1.y = pVertex[4]->Pt_Point->y - pVertex[3]->Pt_Point->y;
				v1.z = pVertex[4]->Pt_Point->z - pVertex[3]->Pt_Point->z;

				v2.x = pVertex[5]->Pt_Point->x - pVertex[4]->Pt_Point->x;
				v2.y = pVertex[5]->Pt_Point->y - pVertex[4]->Pt_Point->y;
				v2.z = pVertex[5]->Pt_Point->z - pVertex[4]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[3]);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[4]);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glEnd();

				v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
				v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
				v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

				v2.x = pVertex[4]->Pt_Point->x - pVertex[1]->Pt_Point->x;
				v2.y = pVertex[4]->Pt_Point->y - pVertex[1]->Pt_Point->y;
				v2.z = pVertex[4]->Pt_Point->z - pVertex[1]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[4]);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[3]);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glEnd();

				v1.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
				v1.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
				v1.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;

				v2.x = pVertex[5]->Pt_Point->x - pVertex[2]->Pt_Point->x;
				v2.y = pVertex[5]->Pt_Point->y - pVertex[2]->Pt_Point->y;
				v2.z = pVertex[5]->Pt_Point->z - pVertex[2]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[2]);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[4]);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glEnd();

				v1.x = pVertex[0]->Pt_Point->x - pVertex[2]->Pt_Point->x;
				v1.y = pVertex[0]->Pt_Point->y - pVertex[2]->Pt_Point->y;
				v1.z = pVertex[0]->Pt_Point->z - pVertex[2]->Pt_Point->z;

				v2.x = pVertex[3]->Pt_Point->x - pVertex[0]->Pt_Point->x;
				v2.y = pVertex[3]->Pt_Point->y - pVertex[0]->Pt_Point->y;
				v2.z = pVertex[3]->Pt_Point->z - pVertex[0]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[2]);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[3]);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glEnd();
				glDisable(GL_TEXTURE_1D);
			}
		}
	} else {
		Selectable = 0;
	}
}

void E_Object36::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	C3dVector d[6];
	int i;
	int ind;

	for (i = 0; i < 6; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS;
	dFS = ME->dResFactor;
	ind = ME->iCVar;
	glLineWidth(gEL_SIZE);
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 6; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		if ((iDspFlgs & DSP_LINE) > 0) {
			glColor3fv(cols[iColour]);
		} else {
			glColor3fv(cols[0]);
		}
		glBegin(GL_LINES);
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));
		glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
		           (float) (pVertex[4]->Pt_Point->z + d[4].z));
		glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
		           (float) (pVertex[4]->Pt_Point->z + d[4].z));
		glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
		           (float) (pVertex[5]->Pt_Point->z + d[5].z));
		glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
		           (float) (pVertex[5]->Pt_Point->z + d[5].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
		           (float) (pVertex[4]->Pt_Point->z + d[4].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
		           (float) (pVertex[5]->Pt_Point->z + d[5].z));
		glEnd();
		C3dVector vCent;
		vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "E%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if (((iDspFlgs & DSP_RESLAB) == 0) && (pResV != NULL)) {
			sprintf_s(sLab, "%f", *pResV->GetAddress(ind));
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if ((iDspFlgs & DSP_ELSYS) == 0) {
			C3dMatrix mS = GetElSys();
			C3dVector vC = Get_Centroid();
			mS.Transpose();
			C3dVector vX = mS.GetColVec(1);
			C3dVector vY = mS.GetColVec(2);
			;
			C3dVector vZ = mS.GetColVec(3);
			;

			vX *= 0.5 * dS1;
			vY *= 0.5 * dS1;
			vZ *= 0.5 * dS1;
			vX += vC;
			vY += vC;
			vZ += vC;

			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vX.x, (float) vX.y, (float) vX.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vY.x, (float) vY.y, (float) vY.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glEnd();
			glRasterPos3f((float) vX.x, (float) vX.y, (float) vX.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPX);
			glRasterPos3f((float) vY.x, (float) vY.y, (float) vY.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPY);
			glRasterPos3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}
	} else {
		Selectable = 0;
	}
}

void E_Object36::ExportUNV(FILE* pFile) {
	int i;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	for (i = 0; i < iNoNodes; i++) {
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
	}
	fprintf(pFile, "\n", "");
}

void E_Object36::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8i", "CPENTA  ", iLabel, PID);
	fprintf(pFile, "%8i", pVertex[0]->iLabel);
	fprintf(pFile, "%8i", pVertex[1]->iLabel);
	fprintf(pFile, "%8i", pVertex[2]->iLabel);
	fprintf(pFile, "%8i", pVertex[3]->iLabel);
	fprintf(pFile, "%8i", pVertex[4]->iLabel);
	fprintf(pFile, "%8i", pVertex[5]->iLabel);
	fprintf(pFile, "\n", "");
}

double E_Object36::GetCentriodVal(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	double dTemp = 0;
	double T = 0;
	int iDOFID;
	int j;
	Mat fun;
	Mat FunPnt(1, 3);
	*FunPnt.mn(1, 1) = 0.333;
	*FunPnt.mn(1, 2) = 0.333;
	*FunPnt.mn(1, 3) = 0.0;
	fun = this->ShapeFun(FunPnt, 1);
	for (j = 0; j < this->iNoNodes; j++) {
		T = 0;
		;
		iDOFID = this->pVertex[j]->dof[iDof];
		if (iDOFID > 0) {
			T = *Disp.nn(iDOFID);
		}
		dTemp += T * *fun.mn(1, j + 1);
	}
	fun.clear();
	FunPnt.clear();
	return (dTemp);
}

double E_Object36::GetElCentriodVal() {
	double dTemp = 0;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		dTemp += pVertex[j]->dTemp;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

C3dVector E_Object36::Get_Centroid() {
	Mat fun;
	Mat FunPnt(1, 3);
	*FunPnt.mn(1, 1) = 0.333;
	*FunPnt.mn(1, 2) = 0.333;
	*FunPnt.mn(1, 3) = 0.0;
	fun = ShapeFun(FunPnt, 1);
	C3dVector vT;
	vT.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vT += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
	}

	fun.clear();
	FunPnt.clear();
	return (vT);
}

C3dMatrix E_Object36::GetElSys() {
	C3dVector vX;
	C3dVector vZ;
	C3dVector vY;
	vX = pVertex[1]->GetCoords();
	vX -= pVertex[0]->GetCoords();
	vX.Normalize();
	vZ = pVertex[3]->GetCoords();
	vZ -= pVertex[0]->GetCoords(); // Approx z direction
	vZ.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	vZ = vX.Cross(vY);
	C3dMatrix vR;
	vR.SetColVec(1, vX);
	vR.SetColVec(2, vY);
	vR.SetColVec(3, vZ);
	vR.Transpose();
	return (vR);
}

G_Object* E_Object36::GetNode(int i) {
	return (pVertex[i]);
}

int E_Object36::GetLinkList(eEdge* Links[200]) {
	Links[0] = new eEdge;
	Links[0]->pParent = this;
	Links[0]->pVertex[0] = pVertex[0];
	Links[0]->pVertex[1] = pVertex[1];
	Links[0]->iColour = iColour;
	Links[1] = new eEdge;
	Links[1]->pParent = this;
	Links[1]->pVertex[0] = pVertex[1];
	Links[1]->pVertex[1] = pVertex[2];
	Links[1]->iColour = iColour;
	Links[2] = new eEdge;
	Links[2]->pParent = this;
	Links[2]->pVertex[0] = pVertex[2];
	Links[2]->pVertex[1] = pVertex[0];
	Links[2]->iColour = iColour;
	Links[3] = new eEdge;
	Links[3]->pParent = this;
	Links[3]->pVertex[0] = pVertex[3];
	Links[3]->pVertex[1] = pVertex[4];
	Links[3]->iColour = iColour;

	Links[4] = new eEdge;
	Links[4]->pParent = this;
	Links[4]->pVertex[0] = pVertex[4];
	Links[4]->pVertex[1] = pVertex[5];
	Links[4]->iColour = iColour;
	Links[5] = new eEdge;
	Links[5]->pParent = this;
	Links[5]->pVertex[0] = pVertex[5];
	Links[5]->pVertex[1] = pVertex[3];
	Links[5]->iColour = iColour;
	Links[6] = new eEdge;
	Links[6]->pParent = this;
	Links[6]->pVertex[0] = pVertex[0];
	Links[6]->pVertex[1] = pVertex[3];
	Links[6]->iColour = iColour;
	Links[7] = new eEdge;
	Links[7]->pParent = this;
	Links[7]->pVertex[0] = pVertex[1];
	Links[7]->pVertex[1] = pVertex[4];
	Links[7]->iColour = iColour;

	Links[8] = new eEdge;
	Links[8]->pParent = this;
	Links[8]->pVertex[0] = pVertex[2];
	Links[8]->pVertex[1] = pVertex[5];
	Links[8]->iColour = iColour;
	return (9);
}

int E_Object36::GetfaceList(eFace* Faces[6]) {
	int ic;
	ic = GetCol();
	Faces[0] = new eFace();
	Faces[0]->pParent = this;
	Faces[0]->pVertex[0] = pVertex[0];
	Faces[0]->pVertex[1] = pVertex[1];
	Faces[0]->pVertex[2] = pVertex[2];
	Faces[0]->NoVert = 3;
	Faces[0]->iColour = ic;

	Faces[1] = new eFace();
	Faces[1]->pParent = this;
	Faces[1]->pVertex[0] = pVertex[3];
	Faces[1]->pVertex[1] = pVertex[4];
	Faces[1]->pVertex[2] = pVertex[5];
	Faces[1]->NoVert = 3;
	Faces[1]->iColour = ic;

	Faces[2] = new eFace();
	Faces[2]->pParent = this;
	Faces[2]->pVertex[0] = pVertex[1];
	Faces[2]->pVertex[1] = pVertex[2];
	Faces[2]->pVertex[2] = pVertex[5];
	Faces[2]->pVertex[3] = pVertex[4];
	Faces[2]->NoVert = 4;
	Faces[2]->iColour = ic;

	Faces[3] = new eFace();
	Faces[3]->pParent = this;
	Faces[3]->pVertex[0] = pVertex[0];
	Faces[3]->pVertex[1] = pVertex[3];
	Faces[3]->pVertex[2] = pVertex[5];
	Faces[3]->pVertex[3] = pVertex[2];
	Faces[3]->NoVert = 4;
	Faces[3]->iColour = ic;

	Faces[4] = new eFace();
	Faces[4]->pParent = this;
	Faces[4]->pVertex[0] = pVertex[0];
	Faces[4]->pVertex[1] = pVertex[1];
	Faces[4]->pVertex[2] = pVertex[4];
	Faces[4]->pVertex[3] = pVertex[3];
	Faces[4]->NoVert = 4;
	Faces[4]->iColour = ic;
	return (5);
}

int E_Object36::noDof() {
	return (3);
}

Vec<int> E_Object36::GetSteerVec3d() {
	Vec<int> V(6 * 3);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[1]->dof[0];
	*V.nn(5) = pVertex[1]->dof[1];
	*V.nn(6) = pVertex[1]->dof[2];
	*V.nn(7) = pVertex[2]->dof[0];
	*V.nn(8) = pVertex[2]->dof[1];
	*V.nn(9) = pVertex[2]->dof[2];
	*V.nn(10) = pVertex[3]->dof[0];
	*V.nn(11) = pVertex[3]->dof[1];
	*V.nn(12) = pVertex[3]->dof[2];
	*V.nn(13) = pVertex[4]->dof[0];
	*V.nn(14) = pVertex[4]->dof[1];
	*V.nn(15) = pVertex[4]->dof[2];
	*V.nn(16) = pVertex[5]->dof[0];
	*V.nn(17) = pVertex[5]->dof[1];
	*V.nn(18) = pVertex[5]->dof[2];
	return (V);
}

Vec<int> E_Object36::GetSteerVec1d() {
	Vec<int> V(6 * 1);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[1]->dof[0];
	*V.nn(3) = pVertex[2]->dof[0];
	*V.nn(4) = pVertex[3]->dof[0];
	*V.nn(5) = pVertex[4]->dof[0];
	*V.nn(6) = pVertex[5]->dof[0];
	return (V);
}

int E_Object36::MaxBW() {
	int i;
	int j;
	int MaxDof;
	int MinDof;
	MaxDof = 0;
	MinDof = 99999999;
	for (i = 0; i < iNoNodes; i++) {
		for (j = 0; j < 6; j++) {
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] > MaxDof)) {
				MaxDof = pVertex[i]->dof[j];
			}
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] < MinDof)) {
				MinDof = pVertex[i]->dof[j];
			}
		}
	}
	int iRC;
	if (MaxDof - MinDof < 0) {
		iRC = 0;
	} else {
		iRC = MaxDof - MinDof;
	}
	return (iRC);
}

Mat E_Object36::getCoords3d() {
	int i;
	Mat coord(iNoNodes, 3);
	for (i = 0; i < iNoNodes; i++) {
		*coord.mn(i + 1, 1) = pVertex[i]->Pt_Point->x;
		*coord.mn(i + 1, 2) = pVertex[i]->Pt_Point->y;
		*coord.mn(i + 1, 3) = pVertex[i]->Pt_Point->z;
	}
	return (coord);
}

Mat E_Object36::Sample(int iNo) {
	Mat Pts(iNo, 4);
	if (iNo == 6) {
		double r16 = 1.0 / 6.0;
		double r23 = 2.0 / 3.0;
		double weight = 1.0 / 6.0; // unknown at moment
		*Pts.mn(1, 1) = r16;
		*Pts.mn(1, 2) = r16;
		*Pts.mn(1, 3) = -0.5;
		*Pts.mn(1, 4) = weight;
		*Pts.mn(2, 1) = r23;
		*Pts.mn(2, 2) = r16;
		*Pts.mn(2, 3) = -0.5;
		*Pts.mn(2, 4) = weight;
		*Pts.mn(3, 1) = r16;
		*Pts.mn(3, 2) = r23;
		*Pts.mn(3, 3) = -0.5;
		*Pts.mn(3, 4) = weight;
		*Pts.mn(4, 1) = r16;
		*Pts.mn(4, 2) = r16;
		*Pts.mn(4, 3) = 0.5;
		*Pts.mn(4, 4) = weight;
		*Pts.mn(5, 1) = r23;
		*Pts.mn(5, 2) = r16;
		*Pts.mn(5, 3) = 0.5;
		*Pts.mn(5, 4) = weight;
		*Pts.mn(6, 1) = r16;
		*Pts.mn(6, 2) = r23;
		*Pts.mn(6, 3) = 0.5;
		*Pts.mn(6, 4) = weight;
	}
	return (Pts);
}

Mat E_Object36::ShapeFun(Mat Points, int i) {
	Mat fun(1, 6);
	double xi, eta, zeta;
	double r, s, t;
	eta = *Points.mn(i, 2);
	xi = *Points.mn(i, 1);
	zeta = *Points.mn(i, 3);
	r = xi;
	s = eta;
	t = 1 - xi - eta;

	*fun.mn(1, 1) = 0.5 * (1 - zeta) * r;
	*fun.mn(1, 2) = 0.5 * (1 - zeta) * s;
	*fun.mn(1, 3) = 0.5 * (1 - zeta) * t;
	*fun.mn(1, 4) = 0.5 * (1 + zeta) * r;
	*fun.mn(1, 5) = 0.5 * (1 + zeta) * s;
	*fun.mn(1, 6) = 0.5 * (1 + zeta) * t;

	return (fun);
}

Mat E_Object36::ShapeDer(Mat Points, int i) {
	Mat der(3, 6);
	double xi, eta, zeta;
	double r, s, t;
	eta = *Points.mn(i, 2);
	xi = *Points.mn(i, 1);
	zeta = *Points.mn(i, 3);
	r = xi;
	s = eta;
	t = 1 - xi - eta;
	*der.mn(1, 1) = 0.5 * (1 - zeta);
	*der.mn(1, 2) = 0;
	*der.mn(1, 3) = -0.5 * (1 - zeta);
	*der.mn(1, 4) = 0.5 * (1 + zeta);
	*der.mn(1, 5) = 0;
	*der.mn(1, 6) = -0.5 * (1 + zeta);

	*der.mn(2, 1) = 0;
	*der.mn(2, 2) = 0.5 * (1 - zeta);
	*der.mn(2, 3) = -0.5 * (1 - zeta);
	*der.mn(2, 4) = 0;
	*der.mn(2, 5) = 0.5 * (1 + zeta);
	*der.mn(2, 6) = -0.5 * (1 + zeta);

	*der.mn(3, 1) = -0.5 * r;
	*der.mn(3, 2) = -0.5 * s;
	*der.mn(3, 3) = -0.5 * t;
	*der.mn(3, 4) = 0.5 * r;
	*der.mn(3, 5) = 0.5 * s;
	*der.mn(3, 6) = 0.5 * t;

	return (der);
}

CString E_Object36::GetName() {
	return ("6 Node WEDGE (CPENTA)");
}

int E_Object36::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "PID";
	iNo++;
	sVar[iNo] = "Mat ID";
	iNo++;
	sVar[iNo] = "N1";
	iNo++;
	sVar[iNo] = "N2";
	iNo++;
	sVar[iNo] = "N3";
	iNo++;
	sVar[iNo] = "N4";
	iNo++;
	sVar[iNo] = "N5";
	iNo++;
	sVar[iNo] = "N6";
	iNo++;
	return (iNo);
}

int E_Object36::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", PID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMatID);
	sVar[iNo] = S1;
	iNo++;

	sprintf_s(S1, "%i", pVertex[0]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[1]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[2]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[3]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[4]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[5]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void E_Object36::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Node* pN;
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	int newPID = atoi(sVar[1]);
	if (newPID != PID) {
		Property* pr = PT->GetItem(newPID);
		if (pr != NULL) {
			BOOL bC = SetProperty(pr);
			if (bC)
				outtext1("Property has Been Changed");
			else
				outtext1("Invalid Property");
		}
	}
	iMatID = atoi(sVar[2]);
	int N1 = atoi(sVar[3]);
	int N2 = atoi(sVar[4]);
	int N3 = atoi(sVar[5]);
	int N4 = atoi(sVar[6]);
	int N5 = atoi(sVar[7]);
	int N6 = atoi(sVar[8]);
	if (pVertex[0]->iLabel != N1) {
		pN = pMe->GetNode(N1);
		if (pN != NULL)
			pVertex[0] = pN;
	}
	if (pVertex[1]->iLabel != N2) {
		pN = pMe->GetNode(N2);
		if (pN != NULL)
			pVertex[1] = pN;
	}
	if (pVertex[2]->iLabel != N3) {
		pN = pMe->GetNode(N3);
		if (pN != NULL)
			pVertex[2] = pN;
	}
	if (pVertex[3]->iLabel != N4) {
		pN = pMe->GetNode(N4);
		if (pN != NULL)
			pVertex[3] = pN;
	}
	if (pVertex[4]->iLabel != N5) {
		pN = pMe->GetNode(N5);
		if (pN != NULL)
			pVertex[4] = pN;
	}
	if (pVertex[5]->iLabel != N6) {
		pN = pMe->GetNode(N6);
		if (pN != NULL)
			pVertex[5] = pN;
	}
}

//----------------------------------------------------------------------------
//    E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object34, CObject)

E_Object34::E_Object34() {
	G_Object();
}

E_Object34::~E_Object34() {
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	pVertex[2] = NULL;
	pVertex[3] = NULL;
}

void E_Object34::Info() {
	char S1[80];
	E_Object::Info();
	sprintf_s(S1, "NODES %i %i %i %i", pVertex[0]->iLabel, pVertex[1]->iLabel, pVertex[2]->iLabel, pVertex[3]->iLabel);
	outtext1(S1);
}

void E_Object34::Create(Node* pInVertex[100], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                        G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	int i = 0;
	for (i = 0; i < 4; i++) {
		pVertex[i] = pInVertex[i];
	}
}

// Tetrahedron collapse calculation quality check
// min all combiations of (h*1.24/A) altairs definition
// http://www.altairuniversity.com/wp-content/uploads/2014/02/elemquality.pdf
double E_Object34::height(int n1, int n2, int n3, int p) {
	C3dVector v1;
	C3dVector v2;
	C3dVector v3;
	C3dVector v;
	C3dVector w;
	C3dVector n;
	C3dVector vPt;
	double a;
	// Nornal to plain
	v1 = this->pVertex[n1]->Get_Centroid();
	v2 = this->pVertex[n2]->Get_Centroid();
	v3 = this->pVertex[n3]->Get_Centroid();
	vPt = this->pVertex[p]->Get_Centroid();
	v = v2 - v1;
	w = v3 - v1;
	n = v.Cross(w);
	n.Normalize();
	vPt -= v1;
	a = abs(n.Dot(vPt));
	return (a);
}

double E_Object34::longEdge() {
	C3dVector v0;
	C3dVector v1;
	C3dVector v2;
	C3dVector v3;
	C3dVector w;
	double a;
	double dLen;
	v0 = this->pVertex[0]->Get_Centroid();
	v1 = this->pVertex[1]->Get_Centroid();
	v2 = this->pVertex[2]->Get_Centroid();
	v3 = this->pVertex[3]->Get_Centroid();
	a = (v0 - v1).Mag();
	dLen = a;
	a = (v1 - v2).Mag();
	if (a > dLen)
		dLen = a;
	a = (v2 - v0).Mag();
	if (a > dLen)
		dLen = a;

	a = (v1 - v3).Mag();
	if (a > dLen)
		dLen = a;
	a = (v2 - v3).Mag();
	if (a > dLen)
		dLen = a;
	a = (v0 - v3).Mag();
	if (a > dLen)
		dLen = a;

	return (a);
}

double E_Object34::area(int n1, int n2, int n3) {
	C3dVector v1;
	C3dVector v2;
	C3dVector v3;
	C3dVector v;
	C3dVector w;
	double a;
	v1 = this->pVertex[n1]->Get_Centroid();
	v2 = this->pVertex[n2]->Get_Centroid();
	v3 = this->pVertex[n3]->Get_Centroid();
	v = v2 - v1;
	w = v3 - v1;
	a = (v.Cross(w).Mag()) * 0.5;
	return (a);
}

double E_Object34::GetCentriodVal(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	double dTemp = 0;
	double T = 0;
	int iDOFID;
	int j;
	Mat fun;
	Mat FunPnt(1, 4);
	*FunPnt.mn(1, 1) = 0.25;
	*FunPnt.mn(1, 2) = 0.25;
	*FunPnt.mn(1, 3) = 0.25;
	*FunPnt.mn(1, 4) = 0.25; // redundanta
	fun = this->ShapeFun(FunPnt, 1);
	for (j = 0; j < this->iNoNodes; j++) {
		T = 0;
		;
		iDOFID = this->pVertex[j]->dof[iDof];
		if (iDOFID > 0) {
			T = *Disp.nn(iDOFID);
		}
		dTemp += T * *fun.mn(1, j + 1);
	}
	fun.clear();
	FunPnt.clear();
	return (dTemp);
}

double E_Object34::GetElCentriodVal() {
	double dTemp = 0;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		dTemp += pVertex[j]->dTemp;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

double E_Object34::TetCollapse() {
	double c0;
	double c1;
	double c2;
	double c3;
	double dm;

	c0 = height(0, 1, 2, 3);
	c1 = height(1, 2, 3, 0);
	c2 = height(0, 2, 3, 1);
	c3 = height(0, 1, 3, 2);
	dm = c0;
	if (c0 < dm)
		dm = c0;
	if (c1 < dm)
		dm = c1;
	if (c2 < dm)
		dm = c2;
	if (c3 < dm)
		dm = c3;

	dm = (dm * 1.2247) / longEdge();

	return (dm);
}

void E_Object34::GetBoundingBox(C3dVector& vll, C3dVector& vur) {
	int i = 0;
	vll.x = pVertex[i]->Pt_Point->x;
	vll.y = pVertex[i]->Pt_Point->y;
	vll.z = pVertex[i]->Pt_Point->z;
	for (i = 0; i < 4; i++) {
		if (pVertex[i]->Pt_Point->x < vll.x)
			vll.x = pVertex[i]->Pt_Point->x;
		if (pVertex[i]->Pt_Point->x > vur.x)
			vur.x = pVertex[i]->Pt_Point->x;

		if (pVertex[i]->Pt_Point->y < vll.y)
			vll.y = pVertex[i]->Pt_Point->y;
		if (pVertex[i]->Pt_Point->y > vur.y)
			vur.y = pVertex[i]->Pt_Point->y;

		if (pVertex[i]->Pt_Point->z < vll.z)
			vll.z = pVertex[i]->Pt_Point->z;
		if (pVertex[i]->Pt_Point->z > vur.z)
			vur.z = pVertex[i]->Pt_Point->z;
	}
}

double E_Object34::GetTETHeight(C3dVector vFCent) {
	double dS;
	C3dVector v1;
	C3dVector v2;
	C3dVector A;
	C3dVector B;
	C3dVector H;
	A = this->pVertex[1]->Get_Centroid();
	v2 = this->pVertex[0]->Get_Centroid();
	A -= v2;
	A.Normalize();
	B = this->pVertex[1]->Get_Centroid();
	v2 = this->pVertex[2]->Get_Centroid();
	B -= v2;
	B.Normalize();
	H = B.Cross(A);
	H.Normalize();

	B = this->pVertex[3]->Get_Centroid();
	B -= vFCent;
	dS = B.Dot(H);
	return (dS);
}

double E_Object34::GetCharSize() {
	double dS;
	double dMax;

	C3dVector vT;
	C3dVector vT2;
	vT = pVertex[3]->Pt_Point;
	vT2 = pVertex[0]->Pt_Point;
	vT -= vT2;
	dS = vT.Mag();
	dMax = dS;
	vT = pVertex[3]->Pt_Point;
	vT2 = pVertex[1]->Pt_Point;
	vT -= vT2;
	dS = vT.Mag();
	if (dS > dMax)
		dMax = dS;
	vT = pVertex[3]->Pt_Point;
	vT2 = pVertex[2]->Pt_Point;
	vT -= vT2;
	dS = vT.Mag();
	if (dS > dMax)
		dMax = dS;

	// dS=(pVertex[0]->Pt_Point-pVertex[1]->Pt_Point)->Mag();
	return (dMax);
}

void E_Object34::Reverse() {
	Node* pT[8];
	pT[0] = pVertex[0];
	pT[1] = pVertex[1];
	pT[2] = pVertex[2];
	pT[3] = pVertex[3];
	pVertex[0] = pT[0];
	pVertex[1] = pT[2];
	pVertex[2] = pT[1];
	pVertex[3] = pT[3];
}

BOOL E_Object34::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_Object34::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

G_Object* E_Object34::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object34* gret = new E_Object34;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->pVertex[2] = MESH->GetNode(pVertex[2]->iLabel);
	gret->pVertex[3] = MESH->GetNode(pVertex[3]->iLabel);
	gret->pPr = pPr;
	gret->pParent = MESH;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object34::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object34* gret = new E_Object34;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[2]);
	gret->pVertex[2] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[3]);
	gret->pVertex[3] = Target->pNodes[EInd + iSInd];
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object34::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object34* gret = new E_Object34;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->pVertex[2] = pInVertex[2];
	gret->pVertex[3] = pInVertex[3];
	gret->pPr = pPr;
	gret->pParent = Parrent;
	gret->pResV = NULL;
	return (gret);
}

void E_Object34::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		ar << pVertex[0]->iLabel;
		ar << pVertex[1]->iLabel;
		ar << pVertex[2]->iLabel;
		ar << pVertex[3]->iLabel;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		ar >> iNd;
		pVertex[0] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[1] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[2] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[3] = MESH->GetNode(iNd);
	}
}

int E_Object34::GetLinkList(eEdge* Links[200]) {
	Links[0] = new eEdge;
	Links[0]->pParent = this;
	Links[0]->pVertex[0] = pVertex[0];
	Links[0]->pVertex[1] = pVertex[1];
	Links[0]->iColour = iColour;
	Links[1] = new eEdge;
	Links[1]->pParent = this;
	Links[1]->pVertex[0] = pVertex[1];
	Links[1]->pVertex[1] = pVertex[2];
	Links[1]->iColour = iColour;
	Links[2] = new eEdge;
	Links[2]->pParent = this;
	Links[2]->pVertex[0] = pVertex[2];
	Links[2]->pVertex[1] = pVertex[0];
	Links[2]->iColour = iColour;
	Links[3] = new eEdge;
	Links[3]->pParent = this;
	Links[3]->pVertex[0] = pVertex[0];
	Links[3]->pVertex[1] = pVertex[3];
	Links[3]->iColour = iColour;
	Links[4] = new eEdge;
	Links[4]->pParent = this;
	Links[4]->pVertex[0] = pVertex[1];
	Links[4]->pVertex[1] = pVertex[3];
	Links[4]->iColour = iColour;
	Links[5] = new eEdge;
	Links[5]->pParent = this;
	Links[5]->pVertex[0] = pVertex[2];
	Links[5]->pVertex[1] = pVertex[3];
	Links[5]->iColour = iColour;
	return (6);
}

// Draw Object line
void E_Object34::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);

	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);
	pDC->LineTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);

	pDC->MoveTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);
	pDC->MoveTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
}

void E_Object34::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	C3dVector d[4];
	int i;
	int ind;

	for (i = 0; i < 4; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS;
	dFS = ME->dResFactor;
	ind = ME->iCVar;
	glLineWidth(gEL_SIZE);
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 4; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		if ((iDspFlgs & DSP_LINE) > 0) {
			glColor3fv(cols[iColour]);
		} else {
			glColor3fv(cols[0]);
		}
		glBegin(GL_LINES);
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));
		glEnd();
		C3dVector vCent;
		vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "E%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if (((iDspFlgs & DSP_RESLAB) == 0) && (pResV != NULL)) {
			sprintf_s(sLab, "%f", *pResV->GetAddress(ind));
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if ((iDspFlgs & DSP_ELSYS) == 0) {
			C3dMatrix mS = GetElSys();
			C3dVector vC = Get_Centroid();
			mS.Transpose();
			C3dVector vX = mS.GetColVec(1);
			C3dVector vY = mS.GetColVec(2);
			;
			C3dVector vZ = mS.GetColVec(3);
			;

			vX *= 0.5 * dS1;
			vY *= 0.5 * dS1;
			vZ *= 0.5 * dS1;
			vX += vC;
			vY += vC;
			vZ += vC;

			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vX.x, (float) vX.y, (float) vX.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vY.x, (float) vY.y, (float) vY.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glEnd();
			glRasterPos3f((float) vX.x, (float) vX.y, (float) vX.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPX);
			glRasterPos3f((float) vY.x, (float) vY.y, (float) vY.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPY);
			glRasterPos3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}
	} else {
		Selectable = 0;
	}
}

void E_Object34::OglDraw(int iDspFlgs, double dS1, double dS2) {
	C3dVector d[4];
	int i;
	for (i = 0; i < 4; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS;
	dFS = ME->dResFactor;
	glLineWidth(2);
	float fCols[4] = {0, 0, 0, 0};
	BOOL bD = FALSE;
	int iVar;
	iVar = ME->iCVar;
	// Nodal data
	if ((pVertex[0]->pResV != NULL) &&
	    (pVertex[1]->pResV != NULL) &&
	    (pVertex[2]->pResV != NULL) &&
	    (pVertex[3]->pResV != NULL)) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pVertex[0]->pResV->GetAddress(iVar) * dFS);
		fCols[1] = GetContourCol(*pVertex[1]->pResV->GetAddress(iVar) * dFS);
		fCols[2] = GetContourCol(*pVertex[2]->pResV->GetAddress(iVar) * dFS);
		fCols[3] = GetContourCol(*pVertex[3]->pResV->GetAddress(iVar) * dFS);
	}
	if (pResV != NULL) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pResV->GetAddress(iVar) * dFS);
		fCols[1] = fCols[0];
		fCols[2] = fCols[0];
		fCols[3] = fCols[0];
	}

	C3dVector v1;
	C3dVector v2;
	C3dVector Vn;
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 4; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		glColor3fv(cols[iColour]);
		if (((iDspFlgs & DSP_CONT) > 0) || (bD == FALSE)) {
			v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
			v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
			v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

			v2.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
			v2.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
			v2.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glEnd();

			v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
			v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
			v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

			v2.x = pVertex[3]->Pt_Point->x - pVertex[1]->Pt_Point->x;
			v2.y = pVertex[3]->Pt_Point->y - pVertex[1]->Pt_Point->y;
			v2.z = pVertex[3]->Pt_Point->z - pVertex[1]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glEnd();

			v1.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
			v1.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
			v1.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;

			v2.x = pVertex[3]->Pt_Point->x - pVertex[2]->Pt_Point->x;
			v2.y = pVertex[3]->Pt_Point->y - pVertex[2]->Pt_Point->y;
			v2.z = pVertex[3]->Pt_Point->z - pVertex[2]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glEnd();

			v1.x = pVertex[2]->Pt_Point->x - pVertex[0]->Pt_Point->x;
			v1.y = pVertex[2]->Pt_Point->y - pVertex[0]->Pt_Point->y;
			v1.z = pVertex[2]->Pt_Point->z - pVertex[0]->Pt_Point->z;

			v2.x = pVertex[3]->Pt_Point->x - pVertex[2]->Pt_Point->x;
			v2.y = pVertex[3]->Pt_Point->y - pVertex[2]->Pt_Point->y;
			v2.z = pVertex[3]->Pt_Point->z - pVertex[2]->Pt_Point->z;
			Vn = v1.Cross(v2);

			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glEnd();
		} else {
			if (bD) {
				glColor3fv(cols[124]);
				glEnable(GL_TEXTURE_1D);
				v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
				v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
				v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

				v2.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
				v2.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
				v2.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);

				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[2]);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glEnd();

				v1.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
				v1.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
				v1.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

				v2.x = pVertex[3]->Pt_Point->x - pVertex[1]->Pt_Point->x;
				v2.y = pVertex[3]->Pt_Point->y - pVertex[1]->Pt_Point->y;
				v2.z = pVertex[3]->Pt_Point->z - pVertex[1]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[3]);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glEnd();

				v1.x = pVertex[2]->Pt_Point->x - pVertex[1]->Pt_Point->x;
				v1.y = pVertex[2]->Pt_Point->y - pVertex[1]->Pt_Point->y;
				v1.z = pVertex[2]->Pt_Point->z - pVertex[1]->Pt_Point->z;

				v2.x = pVertex[3]->Pt_Point->x - pVertex[2]->Pt_Point->x;
				v2.y = pVertex[3]->Pt_Point->y - pVertex[2]->Pt_Point->y;
				v2.z = pVertex[3]->Pt_Point->z - pVertex[2]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[2]);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[3]);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glEnd();

				v1.x = pVertex[2]->Pt_Point->x - pVertex[0]->Pt_Point->x;
				v1.y = pVertex[2]->Pt_Point->y - pVertex[0]->Pt_Point->y;
				v1.z = pVertex[2]->Pt_Point->z - pVertex[0]->Pt_Point->z;

				v2.x = pVertex[3]->Pt_Point->x - pVertex[2]->Pt_Point->x;
				v2.y = pVertex[3]->Pt_Point->y - pVertex[2]->Pt_Point->y;
				v2.z = pVertex[3]->Pt_Point->z - pVertex[2]->Pt_Point->z;
				Vn = v1.Cross(v2);

				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[2]);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[3]);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glEnd();
				glDisable(GL_TEXTURE_1D);
			}
		}
	} else {
		Selectable = 0;
	}
}

G_Object* E_Object34::GetNode(int i) {
	return (pVertex[i]);
}

C3dVector E_Object34::GetNodalCoords(int i) {
	C3dVector v;
	v.x = pVertex[i]->Pt_Point->x;
	v.y = pVertex[i]->Pt_Point->y;
	v.z = pVertex[i]->Pt_Point->z;
	return (v);
}

int E_Object34::GetfaceList(eFace* Faces[6]) {
	int ic;
	ic = GetCol();
	Faces[0] = new eFace();
	Faces[0]->pParent = this;
	Faces[0]->pVertex[0] = pVertex[0];
	Faces[0]->pVertex[1] = pVertex[2];
	Faces[0]->pVertex[2] = pVertex[1];
	Faces[0]->NoVert = 3;
	Faces[0]->iColour = iColour;

	Faces[1] = new eFace();
	Faces[1]->pParent = this;
	Faces[1]->pVertex[0] = pVertex[0];
	Faces[1]->pVertex[1] = pVertex[1];
	Faces[1]->pVertex[2] = pVertex[3];
	Faces[1]->NoVert = 3;
	Faces[1]->iColour = iColour;

	Faces[2] = new eFace;
	Faces[2]->pParent = this;
	Faces[2]->pVertex[0] = pVertex[1];
	Faces[2]->pVertex[1] = pVertex[2];
	Faces[2]->pVertex[2] = pVertex[3];
	Faces[2]->NoVert = 3;
	Faces[2]->iColour = iColour;

	Faces[3] = new eFace;
	Faces[3]->pParent = this;
	Faces[3]->pVertex[0] = pVertex[0];
	Faces[3]->pVertex[1] = pVertex[3];
	Faces[3]->pVertex[2] = pVertex[2];
	Faces[3]->NoVert = 3;
	Faces[3]->iColour = iColour;
	return (4);
}

void E_Object34::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8i", "CTETRA  ", iLabel, PID);
	fprintf(pFile, "%8i", pVertex[0]->iLabel);
	fprintf(pFile, "%8i", pVertex[1]->iLabel);
	fprintf(pFile, "%8i", pVertex[2]->iLabel);
	fprintf(pFile, "%8i", pVertex[3]->iLabel);
	fprintf(pFile, "\n", "");
}

void E_Object34::ExportUNV(FILE* pFile) {
	int i;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	for (i = 0; i < iNoNodes; i++) {
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
	}
	fprintf(pFile, "\n", "");
}

C3dVector E_Object34::Get_Centroid() {
	Mat fun;
	Mat FunPnt(1, 4);
	*FunPnt.mn(1, 1) = 0.25;
	*FunPnt.mn(1, 2) = 0.25;
	*FunPnt.mn(1, 3) = 0.25;
	fun = ShapeFun(FunPnt, 1);
	C3dVector vT;
	vT.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vT += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
	}
	fun.clear();
	FunPnt.clear();
	return (vT);
}

C3dMatrix E_Object34::GetElSys() {
	C3dVector vX;
	C3dVector vZ;
	C3dVector vY;
	vX = pVertex[1]->GetCoords();
	vX -= pVertex[0]->GetCoords();
	vX.Normalize();
	vZ = pVertex[3]->GetCoords();
	vZ -= pVertex[0]->GetCoords(); // Approx z direction
	vZ.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	vZ = vX.Cross(vY);
	C3dMatrix vR;
	vR.SetColVec(1, vX);
	vR.SetColVec(2, vY);
	vR.SetColVec(3, vZ);
	vR.Transpose();
	return (vR);
}

Mat E_Object34::getCoords3d() {
	int i;
	Mat coord(iNoNodes, 3);
	for (i = 0; i < iNoNodes; i++) {
		*coord.mn(i + 1, 1) = pVertex[i]->Pt_Point->x;
		*coord.mn(i + 1, 2) = pVertex[i]->Pt_Point->y;
		*coord.mn(i + 1, 3) = pVertex[i]->Pt_Point->z;
	}
	return (coord);
}

Mat E_Object34::Sample(int iNo) {
	Mat Pts(iNo, 4);
	if (iNo == 1) {
		*Pts.mn(1, 1) = 0.25;
		*Pts.mn(1, 2) = 0.25;
		*Pts.mn(1, 3) = 0.25;
		*Pts.mn(1, 4) = 1.0 / 6.0;
	} else if (iNo == 4) {
		double coord1 = 0.585410196624968;
		double coord2 = 0.138196601125010;
		// the weight is divided by 6 because the determinant gives the volume of a
		// qube and a tetraedron has a 6 times smaller volume (0.25/6.0 = 0.04166666)
		double weight = 0.0416666666666666;
		*Pts.mn(1, 1) = coord1;
		*Pts.mn(1, 2) = coord2;
		*Pts.mn(1, 3) = coord2;
		*Pts.mn(1, 4) = weight;
		*Pts.mn(2, 1) = coord2;
		*Pts.mn(2, 2) = coord1;
		*Pts.mn(2, 3) = coord2;
		*Pts.mn(2, 4) = weight;
		*Pts.mn(3, 1) = coord2;
		*Pts.mn(3, 2) = coord2;
		*Pts.mn(3, 3) = coord1;
		*Pts.mn(3, 4) = weight;
		*Pts.mn(4, 1) = coord2;
		*Pts.mn(4, 2) = coord2;
		*Pts.mn(4, 3) = coord2;
		*Pts.mn(4, 4) = weight;
	}
	return (Pts);
}

Mat E_Object34::ShapeFun(Mat Points, int i) {
	Mat fun(1, 4);
	double v1, v2, v3, v4;

	v2 = *Points.mn(i, 1);
	v3 = *Points.mn(i, 2);
	v4 = *Points.mn(i, 3);
	v1 = (1 - v2 - v3 - v4);

	// v1=*Points.mn(i,1);  This how it was in reverse to nastran
	// v2=*Points.mn(i,2);
	// v3=*Points.mn(i,3);
	// v4=(1-v1-v2-v3);
	*fun.mn(1, 1) = v1;
	*fun.mn(1, 2) = v2;
	*fun.mn(1, 3) = v3;
	*fun.mn(1, 4) = v4;
	return (fun);
}

int E_Object34::noDof() {
	return (3);
}

Mat E_Object34::ShapeDer(Mat Points, int i) {
	Mat der(3, 4);
	*der.mn(1, 1) = -1;
	*der.mn(1, 2) = 1;
	*der.mn(1, 3) = 0;
	*der.mn(1, 4) = 0;

	*der.mn(2, 1) = -1;
	*der.mn(2, 2) = 0;
	*der.mn(2, 3) = 1;
	*der.mn(2, 4) = 0;

	*der.mn(3, 1) = -1;
	*der.mn(3, 2) = 0;
	*der.mn(3, 3) = 0;
	*der.mn(3, 4) = 1;

	//*der.mn(1,1) = 1;  //WAS this way
	//*der.mn(1,2) = 0;
	//*der.mn(1,3) = 0;
	//*der.mn(1,4) = -1;
	//
	//*der.mn(2,1) = 0;
	//*der.mn(2,2) = 1;
	//*der.mn(2,3) = 0;
	//*der.mn(2,4) = -1;
	//
	//*der.mn(3,1) = 0;
	//*der.mn(3,2) = 0;
	//*der.mn(3,3) = 1;
	//*der.mn(3,4) = -1;
	return (der);
}

int E_Object34::MaxBW() {
	int i;
	int j;
	int MaxDof;
	int MinDof;
	MaxDof = 0;
	MinDof = 99999999;
	for (i = 0; i < iNoNodes; i++) {
		for (j = 0; j < 6; j++) {
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] > MaxDof)) {
				MaxDof = pVertex[i]->dof[j];
			}
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] < MinDof)) {
				MinDof = pVertex[i]->dof[j];
			}
		}
	}
	int iRC;
	if (MaxDof - MinDof < 0) {
		iRC = 0;
	} else {
		iRC = MaxDof - MinDof;
	}
	return (iRC);
}

Vec<int> E_Object34::GetSteerVec3d() {
	Vec<int> V(4 * 3);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[1]->dof[0];
	*V.nn(5) = pVertex[1]->dof[1];
	*V.nn(6) = pVertex[1]->dof[2];
	*V.nn(7) = pVertex[2]->dof[0];
	*V.nn(8) = pVertex[2]->dof[1];
	*V.nn(9) = pVertex[2]->dof[2];
	*V.nn(10) = pVertex[3]->dof[0];
	*V.nn(11) = pVertex[3]->dof[1];
	*V.nn(12) = pVertex[3]->dof[2];
	return (V);
}

Vec<int> E_Object34::GetSteerVec1d() {
	Vec<int> V(4 * 1);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[1]->dof[0];
	*V.nn(3) = pVertex[2]->dof[0];
	*V.nn(4) = pVertex[3]->dof[0];
	return (V);
}

CString E_Object34::GetName() {
	return ("4 Node TET (CTETRA)");
}

int E_Object34::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "PID";
	iNo++;
	sVar[iNo] = "Mat ID";
	iNo++;
	sVar[iNo] = "N1";
	iNo++;
	sVar[iNo] = "N2";
	iNo++;
	sVar[iNo] = "N3";
	iNo++;
	sVar[iNo] = "N4";
	iNo++;
	return (iNo);
}

int E_Object34::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", PID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMatID);
	sVar[iNo] = S1;
	iNo++;

	sprintf_s(S1, "%i", pVertex[0]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[1]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[2]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[3]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void E_Object34::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Node* pN;
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	int newPID = atoi(sVar[1]);
	if (newPID != PID) {
		Property* pr = PT->GetItem(newPID);
		if (pr != NULL) {
			BOOL bC = SetProperty(pr);
			if (bC)
				outtext1("Property has Been Changed");
			else
				outtext1("Invalid Property");
		}
	}
	iMatID = atoi(sVar[2]);
	int N1 = atoi(sVar[3]);
	int N2 = atoi(sVar[4]);
	int N3 = atoi(sVar[5]);
	int N4 = atoi(sVar[6]);
	if (pVertex[0]->iLabel != N1) {
		pN = pMe->GetNode(N1);
		if (pN != NULL)
			pVertex[0] = pN;
	}
	if (pVertex[1]->iLabel != N2) {
		pN = pMe->GetNode(N2);
		if (pN != NULL)
			pVertex[1] = pN;
	}
	if (pVertex[2]->iLabel != N3) {
		pN = pMe->GetNode(N3);
		if (pN != NULL)
			pVertex[2] = pN;
	}
	if (pVertex[3]->iLabel != N4) {
		pN = pMe->GetNode(N4);
		if (pN != NULL)
			pVertex[3] = pN;
	}
}

//----------------------------------------------------------------------------
//    E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object310, CObject)

E_Object310::E_Object310() {
	G_Object();
}

E_Object310::~E_Object310() {
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	pVertex[2] = NULL;
	pVertex[3] = NULL;
	pVertex[4] = NULL;
	pVertex[5] = NULL;
	pVertex[6] = NULL;
	pVertex[7] = NULL;
	pVertex[8] = NULL;
	pVertex[9] = NULL;
}

void E_Object310::Info() {
	char S1[80];
	E_Object::Info();
	sprintf_s(S1, "PRINARY NODES %i %i %i %i", pVertex[0]->iLabel, pVertex[1]->iLabel, pVertex[2]->iLabel,
	          pVertex[3]->iLabel);
	outtext1(S1);
}

void E_Object310::Create(Node* pInVertex[100], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                         G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	int i = 0;
	for (i = 0; i < 10; i++) {
		pVertex[i] = pInVertex[i];
	}
}

// Tetrahedron collapse calculation quality check
// min all combiations of (h*1.24/A) altairs definition
// http://www.altairuniversity.com/wp-content/uploads/2014/02/elemquality.pdf
double E_Object310::height(int n1, int n2, int n3, int p) {
	C3dVector v1;
	C3dVector v2;
	C3dVector v3;
	C3dVector v;
	C3dVector w;
	C3dVector n;
	C3dVector vPt;
	double a;
	// Nornal to plain
	v1 = this->pVertex[n1]->Get_Centroid();
	v2 = this->pVertex[n2]->Get_Centroid();
	v3 = this->pVertex[n3]->Get_Centroid();
	vPt = this->pVertex[p]->Get_Centroid();
	v = v2 - v1;
	w = v3 - v1;
	n = v.Cross(w);
	n.Normalize();
	vPt -= v1;
	a = abs(n.Dot(vPt));
	return (a);
}

double E_Object310::longEdge() {
	C3dVector v0;
	C3dVector v1;
	C3dVector v2;
	C3dVector v3;
	C3dVector w;
	double a;
	double dLen;
	v0 = this->pVertex[0]->Get_Centroid();
	v1 = this->pVertex[1]->Get_Centroid();
	v2 = this->pVertex[2]->Get_Centroid();
	v3 = this->pVertex[3]->Get_Centroid();
	a = (v0 - v1).Mag();
	dLen = a;
	a = (v1 - v2).Mag();
	if (a > dLen)
		dLen = a;
	a = (v2 - v0).Mag();
	if (a > dLen)
		dLen = a;

	a = (v1 - v3).Mag();
	if (a > dLen)
		dLen = a;
	a = (v2 - v3).Mag();
	if (a > dLen)
		dLen = a;
	a = (v0 - v3).Mag();
	if (a > dLen)
		dLen = a;

	return (a);
}

double E_Object310::area(int n1, int n2, int n3) {
	C3dVector v1;
	C3dVector v2;
	C3dVector v3;
	C3dVector v;
	C3dVector w;
	double a;
	v1 = this->pVertex[n1]->Get_Centroid();
	v2 = this->pVertex[n2]->Get_Centroid();
	v3 = this->pVertex[n3]->Get_Centroid();
	v = v2 - v1;
	w = v3 - v1;
	a = (v.Cross(w).Mag()) * 0.5;
	return (a);
}

double E_Object310::GetCentriodVal(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	double dTemp = 0;
	double T = 0;
	int iDOFID;
	int j;
	Mat fun;
	Mat FunPnt(1, 4);
	*FunPnt.mn(1, 1) = 0.25;
	*FunPnt.mn(1, 2) = 0.25;
	*FunPnt.mn(1, 3) = 0.25;
	*FunPnt.mn(1, 4) = 0.25; // redundanta
	fun = this->ShapeFun(FunPnt, 1);
	for (j = 0; j < this->iNoNodes; j++) {
		T = 0;
		;
		iDOFID = this->pVertex[j]->dof[iDof];
		if (iDOFID > 0) {
			T = *Disp.nn(iDOFID);
		}
		dTemp += T * *fun.mn(1, j + 1);
	}
	fun.clear();
	FunPnt.clear();
	return (dTemp);
}

double E_Object310::GetElCentriodVal() {
	double dTemp = 0;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		dTemp += pVertex[j]->dTemp;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

double E_Object310::TetCollapse() {
	double c0;
	double c1;
	double c2;
	double c3;
	double dm;

	c0 = height(0, 1, 2, 3);
	c1 = height(1, 2, 3, 0);
	c2 = height(0, 2, 3, 1);
	c3 = height(0, 1, 3, 2);
	dm = c0;
	if (c0 < dm)
		dm = c0;
	if (c1 < dm)
		dm = c1;
	if (c2 < dm)
		dm = c2;
	if (c3 < dm)
		dm = c3;

	dm = (dm * 1.2247) / longEdge();

	return (dm);
}

void E_Object310::GetBoundingBox(C3dVector& vll, C3dVector& vur) {
	int i = 0;
	vll.x = pVertex[i]->Pt_Point->x;
	vll.y = pVertex[i]->Pt_Point->y;
	vll.z = pVertex[i]->Pt_Point->z;
	for (i = 0; i < 4; i++) {
		if (pVertex[i]->Pt_Point->x < vll.x)
			vll.x = pVertex[i]->Pt_Point->x;
		if (pVertex[i]->Pt_Point->x > vur.x)
			vur.x = pVertex[i]->Pt_Point->x;

		if (pVertex[i]->Pt_Point->y < vll.y)
			vll.y = pVertex[i]->Pt_Point->y;
		if (pVertex[i]->Pt_Point->y > vur.y)
			vur.y = pVertex[i]->Pt_Point->y;

		if (pVertex[i]->Pt_Point->z < vll.z)
			vll.z = pVertex[i]->Pt_Point->z;
		if (pVertex[i]->Pt_Point->z > vur.z)
			vur.z = pVertex[i]->Pt_Point->z;
	}
}

double E_Object310::GetTETHeight(C3dVector vFCent) {
	double dS;
	C3dVector v1;
	C3dVector v2;
	C3dVector A;
	C3dVector B;
	C3dVector H;
	A = this->pVertex[1]->Get_Centroid();
	v2 = this->pVertex[0]->Get_Centroid();
	A -= v2;
	A.Normalize();
	B = this->pVertex[1]->Get_Centroid();
	v2 = this->pVertex[2]->Get_Centroid();
	B -= v2;
	B.Normalize();
	H = B.Cross(A);
	H.Normalize();

	B = this->pVertex[3]->Get_Centroid();
	B -= vFCent;
	dS = B.Dot(H);
	return (dS);
}

double E_Object310::GetCharSize() {
	double dS;
	double dMax;

	C3dVector vT;
	C3dVector vT2;
	vT = pVertex[3]->Pt_Point;
	vT2 = pVertex[0]->Pt_Point;
	vT -= vT2;
	dS = vT.Mag();
	dMax = dS;
	vT = pVertex[3]->Pt_Point;
	vT2 = pVertex[1]->Pt_Point;
	vT -= vT2;
	dS = vT.Mag();
	if (dS > dMax)
		dMax = dS;
	vT = pVertex[3]->Pt_Point;
	vT2 = pVertex[2]->Pt_Point;
	vT -= vT2;
	dS = vT.Mag();
	if (dS > dMax)
		dMax = dS;

	// dS=(pVertex[0]->Pt_Point-pVertex[1]->Pt_Point)->Mag();
	return (dMax);
}

// GHANGE THIS
void E_Object310::Reverse() {
	Node* pT[8];
	pT[0] = pVertex[0];
	pT[1] = pVertex[1];
	pT[2] = pVertex[2];
	pT[3] = pVertex[3];
	pVertex[0] = pT[0];
	pVertex[1] = pT[2];
	pVertex[2] = pT[1];
	pVertex[3] = pT[3];
}

BOOL E_Object310::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_Object310::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

G_Object* E_Object310::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object310* gret = new E_Object310;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->pVertex[2] = MESH->GetNode(pVertex[2]->iLabel);
	gret->pVertex[3] = MESH->GetNode(pVertex[3]->iLabel);
	gret->pVertex[4] = MESH->GetNode(pVertex[4]->iLabel);
	gret->pVertex[5] = MESH->GetNode(pVertex[5]->iLabel);
	gret->pVertex[6] = MESH->GetNode(pVertex[6]->iLabel);
	gret->pVertex[7] = MESH->GetNode(pVertex[7]->iLabel);
	gret->pVertex[8] = MESH->GetNode(pVertex[8]->iLabel);
	gret->pVertex[9] = MESH->GetNode(pVertex[9]->iLabel);
	gret->pPr = pPr;
	gret->pParent = MESH;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object310::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object310* gret = new E_Object310;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[2]);
	gret->pVertex[2] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[3]);
	gret->pVertex[3] = Target->pNodes[EInd + iSInd];

	EInd = Source->GetNodeInd(pVertex[4]);
	gret->pVertex[4] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[5]);
	gret->pVertex[5] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[6]);
	gret->pVertex[6] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[7]);
	gret->pVertex[7] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[8]);
	gret->pVertex[8] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[9]);
	gret->pVertex[9] = Target->pNodes[EInd + iSInd];
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object310::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object310* gret = new E_Object310;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->pVertex[2] = pInVertex[2];
	gret->pVertex[3] = pInVertex[3];
	gret->pVertex[4] = pInVertex[4];
	gret->pVertex[5] = pInVertex[5];
	gret->pVertex[6] = pInVertex[6];
	gret->pVertex[7] = pInVertex[7];
	gret->pVertex[8] = pInVertex[8];
	gret->pVertex[9] = pInVertex[9];
	gret->pPr = pPr;
	gret->pParent = Parrent;
	gret->pResV = NULL;
	return (gret);
}

void E_Object310::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		ar << pVertex[0]->iLabel;
		ar << pVertex[1]->iLabel;
		ar << pVertex[2]->iLabel;
		ar << pVertex[3]->iLabel;
		ar << pVertex[4]->iLabel;
		ar << pVertex[5]->iLabel;
		ar << pVertex[6]->iLabel;
		ar << pVertex[7]->iLabel;
		ar << pVertex[8]->iLabel;
		ar << pVertex[9]->iLabel;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		ar >> iNd;
		pVertex[0] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[1] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[2] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[3] = MESH->GetNode(iNd);

		ar >> iNd;
		pVertex[4] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[5] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[6] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[7] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[8] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[9] = MESH->GetNode(iNd);
	}
}

int E_Object310::GetLinkList(eEdge* Links[200]) {
	Links[0] = new eEdge;
	Links[0]->pParent = this;
	Links[0]->pVertex[0] = pVertex[0];
	Links[0]->pVertex[1] = pVertex[1];
	Links[0]->iColour = iColour;
	Links[1] = new eEdge;
	Links[1]->pParent = this;
	Links[1]->pVertex[0] = pVertex[1];
	Links[1]->pVertex[1] = pVertex[2];
	Links[1]->iColour = iColour;
	Links[2] = new eEdge;
	Links[2]->pParent = this;
	Links[2]->pVertex[0] = pVertex[2];
	Links[2]->pVertex[1] = pVertex[0];
	Links[2]->iColour = iColour;
	Links[3] = new eEdge;
	Links[3]->pParent = this;
	Links[3]->pVertex[0] = pVertex[0];
	Links[3]->pVertex[1] = pVertex[3];
	Links[3]->iColour = iColour;
	Links[4] = new eEdge;
	Links[4]->pParent = this;
	Links[4]->pVertex[0] = pVertex[1];
	Links[4]->pVertex[1] = pVertex[3];
	Links[4]->iColour = iColour;
	Links[5] = new eEdge;
	Links[5]->pParent = this;
	Links[5]->pVertex[0] = pVertex[2];
	Links[5]->pVertex[1] = pVertex[3];
	Links[5]->iColour = iColour;
	return (6);
}

// Draw Object line
void E_Object310::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);

	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);
	pDC->LineTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);

	pDC->MoveTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);
	pDC->MoveTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
}

void E_Object310::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	C3dVector d[10];
	int i;
	int ind;

	for (i = 0; i < 10; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS;
	dFS = ME->dResFactor;
	ind = ME->iCVar;
	glLineWidth(gEL_SIZE);
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 10; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		if ((iDspFlgs & DSP_LINE) > 0) {
			glColor3fv(cols[iColour]);
		} else {
			glColor3fv(cols[0]);
		}
		glBegin(GL_LINES);
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
		           (float) (pVertex[4]->Pt_Point->z + d[4].z));

		glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
		           (float) (pVertex[4]->Pt_Point->z + d[4].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));

		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
		           (float) (pVertex[5]->Pt_Point->z + d[5].z));

		glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
		           (float) (pVertex[5]->Pt_Point->z + d[5].z));
		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));

		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
		           (float) (pVertex[6]->Pt_Point->z + d[6].z));

		glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
		           (float) (pVertex[6]->Pt_Point->z + d[6].z));
		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));

		glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + d[0].z));
		glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
		           (float) (pVertex[7]->Pt_Point->z + d[7].z));

		glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
		           (float) (pVertex[7]->Pt_Point->z + d[7].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));

		glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + d[1].z));
		glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
		           (float) (pVertex[8]->Pt_Point->z + d[8].z));

		glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
		           (float) (pVertex[8]->Pt_Point->z + d[8].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));

		glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
		           (float) (pVertex[2]->Pt_Point->z + d[2].z));
		glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
		           (float) (pVertex[9]->Pt_Point->z + d[9].z));

		glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
		           (float) (pVertex[9]->Pt_Point->z + d[9].z));
		glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
		           (float) (pVertex[3]->Pt_Point->z + d[3].z));

		glEnd();
		C3dVector vCent;
		vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "E%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if (((iDspFlgs & DSP_RESLAB) == 0) && (pResV != NULL)) {
			sprintf_s(sLab, "%f", *pResV->GetAddress(ind));
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if ((iDspFlgs & DSP_ELSYS) == 0) {
			C3dMatrix mS = GetElSys();
			C3dVector vC = Get_Centroid();
			mS.Transpose();
			C3dVector vX = mS.GetColVec(1);
			C3dVector vY = mS.GetColVec(2);
			;
			C3dVector vZ = mS.GetColVec(3);
			;

			vX *= 0.5 * dS1;
			vY *= 0.5 * dS1;
			vZ *= 0.5 * dS1;
			vX += vC;
			vY += vC;
			vZ += vC;

			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vX.x, (float) vX.y, (float) vX.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vY.x, (float) vY.y, (float) vY.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glEnd();
			glRasterPos3f((float) vX.x, (float) vX.y, (float) vX.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPX);
			glRasterPos3f((float) vY.x, (float) vY.y, (float) vY.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPY);
			glRasterPos3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}
	} else {
		Selectable = 0;
	}
}

void E_Object310::OglDraw(int iDspFlgs, double dS1, double dS2) {
	C3dVector d[10];
	int i;
	for (i = 0; i < 10; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS;
	dFS = ME->dResFactor;
	glLineWidth(2);
	float fCols[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	BOOL bD = FALSE;
	int iVar;
	iVar = ME->iCVar;
	// Nodal data
	if ((pVertex[0]->pResV != NULL) &&
	    (pVertex[1]->pResV != NULL) &&
	    (pVertex[2]->pResV != NULL) &&
	    (pVertex[3]->pResV != NULL) &&
	    (pVertex[4]->pResV != NULL) &&
	    (pVertex[5]->pResV != NULL) &&
	    (pVertex[6]->pResV != NULL) &&
	    (pVertex[7]->pResV != NULL) &&
	    (pVertex[8]->pResV != NULL) &&
	    (pVertex[9]->pResV != NULL)) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pVertex[0]->pResV->GetAddress(iVar) * dFS);
		fCols[1] = GetContourCol(*pVertex[1]->pResV->GetAddress(iVar) * dFS);
		fCols[2] = GetContourCol(*pVertex[2]->pResV->GetAddress(iVar) * dFS);
		fCols[3] = GetContourCol(*pVertex[3]->pResV->GetAddress(iVar) * dFS);
		fCols[4] = GetContourCol(*pVertex[4]->pResV->GetAddress(iVar) * dFS);
		fCols[5] = GetContourCol(*pVertex[5]->pResV->GetAddress(iVar) * dFS);
		fCols[6] = GetContourCol(*pVertex[6]->pResV->GetAddress(iVar) * dFS);
		fCols[7] = GetContourCol(*pVertex[7]->pResV->GetAddress(iVar) * dFS);
		fCols[8] = GetContourCol(*pVertex[8]->pResV->GetAddress(iVar) * dFS);
		fCols[9] = GetContourCol(*pVertex[9]->pResV->GetAddress(iVar) * dFS);
	}
	if (pResV != NULL) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pResV->GetAddress(iVar) * dFS);
		fCols[1] = fCols[0];
		fCols[2] = fCols[0];
		fCols[3] = fCols[0];
		fCols[4] = fCols[0];
		fCols[5] = fCols[0];
		fCols[6] = fCols[0];
		fCols[7] = fCols[0];
		fCols[8] = fCols[0];
		fCols[9] = fCols[0];
	}

	C3dVector v1;
	C3dVector v2;
	C3dVector Vn;
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 10; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		glColor3fv(cols[iColour]);
		if (((iDspFlgs & DSP_CONT) > 0) || (bD == FALSE)) {
			v1 = pVertex[1]->Pt_Point - pVertex[0]->Pt_Point;
			v2 = pVertex[2]->Pt_Point - pVertex[1]->Pt_Point;
			Vn = v1.Cross(v2);
			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
			           (float) (pVertex[6]->Pt_Point->z + d[6].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
			           (float) (pVertex[6]->Pt_Point->z + d[6].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
			           (float) (pVertex[6]->Pt_Point->z + d[6].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glEnd();
			v1 = pVertex[1]->Pt_Point - pVertex[0]->Pt_Point;
			v2 = pVertex[3]->Pt_Point - pVertex[1]->Pt_Point;
			Vn = v1.Cross(v2);
			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
			           (float) (pVertex[7]->Pt_Point->z + d[7].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
			           (float) (pVertex[8]->Pt_Point->z + d[8].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
			           (float) (pVertex[7]->Pt_Point->z + d[7].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
			           (float) (pVertex[4]->Pt_Point->z + d[4].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
			           (float) (pVertex[8]->Pt_Point->z + d[8].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
			           (float) (pVertex[7]->Pt_Point->z + d[7].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
			           (float) (pVertex[8]->Pt_Point->z + d[8].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glEnd();
			v1 = pVertex[2]->Pt_Point - pVertex[1]->Pt_Point;
			v2 = pVertex[3]->Pt_Point - pVertex[2]->Pt_Point;
			Vn = v1.Cross(v2);
			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
			           (float) (pVertex[8]->Pt_Point->z + d[8].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
			           (float) (pVertex[9]->Pt_Point->z + d[9].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
			           (float) (pVertex[8]->Pt_Point->z + d[8].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
			           (float) (pVertex[5]->Pt_Point->z + d[5].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
			           (float) (pVertex[9]->Pt_Point->z + d[9].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
			           (float) (pVertex[8]->Pt_Point->z + d[8].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
			           (float) (pVertex[9]->Pt_Point->z + d[9].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glEnd();
			v1 = pVertex[2]->Pt_Point - pVertex[0]->Pt_Point;
			v2 = pVertex[3]->Pt_Point - pVertex[2]->Pt_Point;
			Vn = v1.Cross(v2);
			Vn.Normalize();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
			           (float) (pVertex[6]->Pt_Point->z + d[6].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
			           (float) (pVertex[7]->Pt_Point->z + d[7].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
			           (float) (pVertex[6]->Pt_Point->z + d[6].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
			           (float) (pVertex[9]->Pt_Point->z + d[9].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
			           (float) (pVertex[7]->Pt_Point->z + d[7].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
			           (float) (pVertex[6]->Pt_Point->z + d[6].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
			           (float) (pVertex[2]->Pt_Point->z + d[2].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
			           (float) (pVertex[9]->Pt_Point->z + d[9].z));
			glEnd();
			glBegin(GL_POLYGON);
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
			           (float) (pVertex[7]->Pt_Point->z + d[7].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
			           (float) (pVertex[9]->Pt_Point->z + d[9].z));
			glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
			glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
			           (float) (pVertex[3]->Pt_Point->z + d[3].z));
			glEnd();
		} else {
			if (bD) {
				glColor3fv(cols[124]);
				glEnable(GL_TEXTURE_1D);
				v1 = pVertex[1]->Pt_Point - pVertex[0]->Pt_Point;
				v2 = pVertex[2]->Pt_Point - pVertex[1]->Pt_Point;
				Vn = v1.Cross(v2);
				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[4]);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
				           (float) (pVertex[6]->Pt_Point->z + d[6].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[4]);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[6]);
				glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
				           (float) (pVertex[6]->Pt_Point->z + d[6].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[4]);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[6]);
				glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
				           (float) (pVertex[6]->Pt_Point->z + d[6].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[2]);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glEnd();
				v1 = pVertex[1]->Pt_Point - pVertex[0]->Pt_Point;
				v2 = pVertex[3]->Pt_Point - pVertex[1]->Pt_Point;
				Vn = v1.Cross(v2);
				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[4]);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[7]);
				glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
				           (float) (pVertex[7]->Pt_Point->z + d[7].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[4]);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[8]);
				glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
				           (float) (pVertex[8]->Pt_Point->z + d[8].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[7]);
				glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
				           (float) (pVertex[7]->Pt_Point->z + d[7].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[4]);
				glVertex3f((float) (pVertex[4]->Pt_Point->x + d[4].x), (float) (pVertex[4]->Pt_Point->y + d[4].y),
				           (float) (pVertex[4]->Pt_Point->z + d[4].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[8]);
				glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
				           (float) (pVertex[8]->Pt_Point->z + d[8].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[7]);
				glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
				           (float) (pVertex[7]->Pt_Point->z + d[7].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[8]);
				glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
				           (float) (pVertex[8]->Pt_Point->z + d[8].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[3]);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glEnd();
				v1 = pVertex[2]->Pt_Point - pVertex[1]->Pt_Point;
				v2 = pVertex[3]->Pt_Point - pVertex[2]->Pt_Point;
				Vn = v1.Cross(v2);
				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[8]);
				glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
				           (float) (pVertex[8]->Pt_Point->z + d[8].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[9]);
				glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
				           (float) (pVertex[9]->Pt_Point->z + d[9].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[8]);
				glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
				           (float) (pVertex[8]->Pt_Point->z + d[8].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[5]);
				glVertex3f((float) (pVertex[5]->Pt_Point->x + d[5].x), (float) (pVertex[5]->Pt_Point->y + d[5].y),
				           (float) (pVertex[5]->Pt_Point->z + d[5].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[2]);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[9]);
				glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
				           (float) (pVertex[9]->Pt_Point->z + d[9].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[8]);
				glVertex3f((float) (pVertex[8]->Pt_Point->x + d[8].x), (float) (pVertex[8]->Pt_Point->y + d[8].y),
				           (float) (pVertex[8]->Pt_Point->z + d[8].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[9]);
				glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
				           (float) (pVertex[9]->Pt_Point->z + d[9].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[3]);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glEnd();
				v1 = pVertex[2]->Pt_Point - pVertex[0]->Pt_Point;
				v2 = pVertex[3]->Pt_Point - pVertex[2]->Pt_Point;
				Vn = v1.Cross(v2);
				Vn.Normalize();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[6]);
				glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
				           (float) (pVertex[6]->Pt_Point->z + d[6].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[7]);
				glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
				           (float) (pVertex[7]->Pt_Point->z + d[7].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[6]);
				glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
				           (float) (pVertex[6]->Pt_Point->z + d[6].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[9]);
				glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
				           (float) (pVertex[9]->Pt_Point->z + d[9].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[7]);
				glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
				           (float) (pVertex[7]->Pt_Point->z + d[7].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[6]);
				glVertex3f((float) (pVertex[6]->Pt_Point->x + d[6].x), (float) (pVertex[6]->Pt_Point->y + d[6].y),
				           (float) (pVertex[6]->Pt_Point->z + d[6].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[2]);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + d[2].x), (float) (pVertex[2]->Pt_Point->y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + d[2].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[9]);
				glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
				           (float) (pVertex[9]->Pt_Point->z + d[9].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[7]);
				glVertex3f((float) (pVertex[7]->Pt_Point->x + d[7].x), (float) (pVertex[7]->Pt_Point->y + d[7].y),
				           (float) (pVertex[7]->Pt_Point->z + d[7].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[9]);
				glVertex3f((float) (pVertex[9]->Pt_Point->x + d[9].x), (float) (pVertex[9]->Pt_Point->y + d[9].y),
				           (float) (pVertex[9]->Pt_Point->z + d[9].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glTexCoord1f(fCols[3]);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + d[3].x), (float) (pVertex[3]->Pt_Point->y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + d[3].z));
				glEnd();
				glDisable(GL_TEXTURE_1D);
			}
		}
	} else {
		Selectable = 0;
	}
}

G_Object* E_Object310::GetNode(int i) {
	return (pVertex[i]);
}

C3dVector E_Object310::GetNodalCoords(int i) {
	C3dVector v;
	v.x = pVertex[i]->Pt_Point->x;
	v.y = pVertex[i]->Pt_Point->y;
	v.z = pVertex[i]->Pt_Point->z;
	return (v);
}

int E_Object310::GetfaceList(eFace* Faces[6]) {
	int ic;
	ic = GetCol();
	Faces[0] = new eFace();
	Faces[0]->pParent = this;
	Faces[0]->pVertex[0] = pVertex[0];
	Faces[0]->pVertex[1] = pVertex[2];
	Faces[0]->pVertex[2] = pVertex[1];
	Faces[0]->NoVert = 3;
	Faces[0]->iColour = iColour;

	Faces[1] = new eFace();
	Faces[1]->pParent = this;
	Faces[1]->pVertex[0] = pVertex[0];
	Faces[1]->pVertex[1] = pVertex[1];
	Faces[1]->pVertex[2] = pVertex[3];
	Faces[1]->NoVert = 3;
	Faces[1]->iColour = iColour;

	Faces[2] = new eFace;
	Faces[2]->pParent = this;
	Faces[2]->pVertex[0] = pVertex[1];
	Faces[2]->pVertex[1] = pVertex[2];
	Faces[2]->pVertex[2] = pVertex[3];
	Faces[2]->NoVert = 3;
	Faces[2]->iColour = iColour;

	Faces[3] = new eFace;
	Faces[3]->pParent = this;
	Faces[3]->pVertex[0] = pVertex[0];
	Faces[3]->pVertex[1] = pVertex[3];
	Faces[3]->pVertex[2] = pVertex[2];
	Faces[3]->NoVert = 3;
	Faces[3]->iColour = iColour;
	return (4);
}

void E_Object310::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8i", "CTETRA  ", iLabel, PID);
	fprintf(pFile, "%8i", pVertex[0]->iLabel);
	fprintf(pFile, "%8i", pVertex[1]->iLabel);
	fprintf(pFile, "%8i", pVertex[2]->iLabel);
	fprintf(pFile, "%8i", pVertex[3]->iLabel);
	fprintf(pFile, "%8i", pVertex[4]->iLabel);
	fprintf(pFile, "%8i\n", pVertex[5]->iLabel);
	fprintf(pFile, "        %8i", pVertex[6]->iLabel);
	fprintf(pFile, "%8i", pVertex[7]->iLabel);
	fprintf(pFile, "%8i", pVertex[8]->iLabel);
	fprintf(pFile, "%8i\n", pVertex[9]->iLabel);
}

void E_Object310::ExportUNV(FILE* pFile) {
	int i;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	for (i = 0; i < iNoNodes; i++) {
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
	}
	fprintf(pFile, "\n", "");
}

C3dVector E_Object310::Get_Centroid() {
	Mat fun;
	Mat FunPnt(1, 4);
	*FunPnt.mn(1, 1) = 0.25;
	*FunPnt.mn(1, 2) = 0.25;
	*FunPnt.mn(1, 3) = 0.25;
	fun = ShapeFun(FunPnt, 1);
	C3dVector vT;
	vT.Set(0, 0, 0);
	int j = 0;
	// USING TET4 FOR NOW
	for (j = 0; j < 4; j++) // for (j = 0; j < iNoNodes; j++)
	{
		vT += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
	}
	fun.clear();
	FunPnt.clear();
	return (vT);
}

C3dMatrix E_Object310::GetElSys() {
	C3dVector vX;
	C3dVector vZ;
	C3dVector vY;
	vX = pVertex[1]->GetCoords();
	vX -= pVertex[0]->GetCoords();
	vX.Normalize();
	vZ = pVertex[3]->GetCoords();
	vZ -= pVertex[0]->GetCoords(); // Approx z direction
	vZ.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	vZ = vX.Cross(vY);
	C3dMatrix vR;
	vR.SetColVec(1, vX);
	vR.SetColVec(2, vY);
	vR.SetColVec(3, vZ);
	vR.Transpose();
	return (vR);
}

Mat E_Object310::getCoords3d() {
	int i;
	Mat coord(iNoNodes, 3);
	for (i = 0; i < iNoNodes; i++) {
		*coord.mn(i + 1, 1) = pVertex[i]->Pt_Point->x;
		*coord.mn(i + 1, 2) = pVertex[i]->Pt_Point->y;
		*coord.mn(i + 1, 3) = pVertex[i]->Pt_Point->z;
	}
	return (coord);
}

Mat E_Object310::Sample(int iNo) {
	Mat Pts(iNo, 4);
	if (iNo == 1) {
		*Pts.mn(1, 1) = 0.25;
		*Pts.mn(1, 2) = 0.25;
		*Pts.mn(1, 3) = 0.25;
		*Pts.mn(1, 4) = 1.0 / 6.0;
	} else if (iNo == 4) {
		double coord1 = 0.585410196624968;
		double coord2 = 0.138196601125010;
		// the weight is divided by 6 because the determinant gives the volume of a
		// qube and a tetraedron has a 6 times smaller volume (0.25/6.0 = 0.04166666)
		double weight = 0.0416666666666666;
		*Pts.mn(1, 1) = coord1;
		*Pts.mn(1, 2) = coord2;
		*Pts.mn(1, 3) = coord2;
		*Pts.mn(1, 4) = weight;
		*Pts.mn(2, 1) = coord2;
		*Pts.mn(2, 2) = coord1;
		*Pts.mn(2, 3) = coord2;
		*Pts.mn(2, 4) = weight;
		*Pts.mn(3, 1) = coord2;
		*Pts.mn(3, 2) = coord2;
		*Pts.mn(3, 3) = coord1;
		*Pts.mn(3, 4) = weight;
		*Pts.mn(4, 1) = coord2;
		*Pts.mn(4, 2) = coord2;
		*Pts.mn(4, 3) = coord2;
		*Pts.mn(4, 4) = weight;
	}
	return (Pts);
}

Mat E_Object310::ShapeFun(Mat Points, int i) {
	Mat fun(1, 4);
	double v1, v2, v3, v4;

	v2 = *Points.mn(i, 1);
	v3 = *Points.mn(i, 2);
	v4 = *Points.mn(i, 3);
	v1 = (1 - v2 - v3 - v4);

	// v1=*Points.mn(i,1);  This how it was in reverse to nastran
	// v2=*Points.mn(i,2);
	// v3=*Points.mn(i,3);
	// v4=(1-v1-v2-v3);
	*fun.mn(1, 1) = v1;
	*fun.mn(1, 2) = v2;
	*fun.mn(1, 3) = v3;
	*fun.mn(1, 4) = v4;
	return (fun);
}

int E_Object310::noDof() {
	return (3);
}

Mat E_Object310::ShapeDer(Mat Points, int i) {
	Mat der(3, 4);
	*der.mn(1, 1) = -1;
	*der.mn(1, 2) = 1;
	*der.mn(1, 3) = 0;
	*der.mn(1, 4) = 0;

	*der.mn(2, 1) = -1;
	*der.mn(2, 2) = 0;
	*der.mn(2, 3) = 1;
	*der.mn(2, 4) = 0;

	*der.mn(3, 1) = -1;
	*der.mn(3, 2) = 0;
	*der.mn(3, 3) = 0;
	*der.mn(3, 4) = 1;

	//*der.mn(1,1) = 1;  //WAS this way
	//*der.mn(1,2) = 0;
	//*der.mn(1,3) = 0;
	//*der.mn(1,4) = -1;
	//
	//*der.mn(2,1) = 0;
	//*der.mn(2,2) = 1;
	//*der.mn(2,3) = 0;
	//*der.mn(2,4) = -1;
	//
	//*der.mn(3,1) = 0;
	//*der.mn(3,2) = 0;
	//*der.mn(3,3) = 1;
	//*der.mn(3,4) = -1;
	return (der);
}

int E_Object310::MaxBW() {
	int i;
	int j;
	int MaxDof;
	int MinDof;
	MaxDof = 0;
	MinDof = 99999999;
	for (i = 0; i < iNoNodes; i++) {
		for (j = 0; j < 6; j++) {
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] > MaxDof)) {
				MaxDof = pVertex[i]->dof[j];
			}
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] < MinDof)) {
				MinDof = pVertex[i]->dof[j];
			}
		}
	}
	int iRC;
	if (MaxDof - MinDof < 0) {
		iRC = 0;
	} else {
		iRC = MaxDof - MinDof;
	}
	return (iRC);
}

Vec<int> E_Object310::GetSteerVec3d() {
	Vec<int> V(4 * 3);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[1]->dof[0];
	*V.nn(5) = pVertex[1]->dof[1];
	*V.nn(6) = pVertex[1]->dof[2];
	*V.nn(7) = pVertex[2]->dof[0];
	*V.nn(8) = pVertex[2]->dof[1];
	*V.nn(9) = pVertex[2]->dof[2];
	*V.nn(10) = pVertex[3]->dof[0];
	*V.nn(11) = pVertex[3]->dof[1];
	*V.nn(12) = pVertex[3]->dof[2];
	return (V);
}

Vec<int> E_Object310::GetSteerVec1d() {
	Vec<int> V(4 * 1);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[1]->dof[0];
	*V.nn(3) = pVertex[2]->dof[0];
	*V.nn(4) = pVertex[3]->dof[0];
	return (V);
}

CString E_Object310::GetName() {
	return ("10 Node TET (CTETRA)");
}

int E_Object310::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "PID";
	iNo++;
	sVar[iNo] = "Mat ID";
	iNo++;
	sVar[iNo] = "N1";
	iNo++;
	sVar[iNo] = "N2";
	iNo++;
	sVar[iNo] = "N3";
	iNo++;
	sVar[iNo] = "N4";
	iNo++;
	return (iNo);
}

int E_Object310::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", PID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMatID);
	sVar[iNo] = S1;
	iNo++;

	sprintf_s(S1, "%i", pVertex[0]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[1]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[2]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[3]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void E_Object310::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Node* pN;
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	int newPID = atoi(sVar[1]);
	if (newPID != PID) {
		Property* pr = PT->GetItem(newPID);
		if (pr != NULL) {
			BOOL bC = SetProperty(pr);
			if (bC)
				outtext1("Property has Been Changed");
			else
				outtext1("Invalid Property");
		}
	}
	iMatID = atoi(sVar[2]);
	int N1 = atoi(sVar[3]);
	int N2 = atoi(sVar[4]);
	int N3 = atoi(sVar[5]);
	int N4 = atoi(sVar[6]);
	if (pVertex[0]->iLabel != N1) {
		pN = pMe->GetNode(N1);
		if (pN != NULL)
			pVertex[0] = pN;
	}
	if (pVertex[1]->iLabel != N2) {
		pN = pMe->GetNode(N2);
		if (pN != NULL)
			pVertex[1] = pN;
	}
	if (pVertex[2]->iLabel != N3) {
		pN = pMe->GetNode(N3);
		if (pN != NULL)
			pVertex[2] = pN;
	}
	if (pVertex[3]->iLabel != N4) {
		pN = pMe->GetNode(N4);
		if (pN != NULL)
			pVertex[3] = pN;
	}
}

IMPLEMENT_DYNAMIC(BCLD, CObject)

void BCLD::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
	} else {
		G_Object::Serialize(ar, iV);
	}
}

void BCLD::ExportNAS(FILE* pFile) {
}

void BCLD::RelTo(G_Object* pThis, ObjList* pList, int iType) {
	// return the parent (SET)
	if (pThis->pParent->iObjType == iType) {
		if (pThis->pParent != NULL) {
			pList->AddEx(pThis->pParent);
		}
	}
	// return node related to this force
	if (this->pObj->iObjType == iType) {
		pList->AddEx(this->pObj);
	}
}

BOOL BCLD::NodeIn(Node* pN) {
	BOOL brc = FALSE;
	if (pObj == pN) {
		brc = TRUE;
	}
	return (brc);
}

//----------------------------------------------------------------------------
//    E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object, CObject)

E_Object::E_Object() {
	dTemp = 0;
}

void E_Object::Create(int iLab, int iCol, int iType, int iPID, int iMat, int iNo, G_Object* Parrent, Property* inPr) {
	this->Drawn = 0;
	this->Selectable = 1;
	this->Visable = 1;
	this->iObjType = 3;
	this->iType = iType;
	this->iLabel = iLab;
	this->iColour = iCol;
	this->PID = iPID;
	this->iMatID = iMat;
	this->iNoNodes = iNo;
	this->pParent = Parrent;
	this->pPr = inPr;
	this->PIDunv = PIDunv;
	this->pResV = NULL;
}

Mat E_Object::Sample(int iNo) {
	Mat M(0, 0);
	return (M);
}

BOOL E_Object::NodeInEl(Node* pN) {
	return (FALSE);
}

void E_Object::RepNodeInEl(Node* pThis, Node* pWith) {
}

int E_Object::noDof() {
	return (3);
}

// Transform nodal stiffness values from element local to global
Mat E_Object::KEToKGTransform() {
	Mat t(iNoNodes * 6, iNoNodes * 6);
	int i, j, n;
	C3dMatrix r;
	r = GetElSys();
	Mat mr(3, 3);
	*mr.mn(1, 1) = r.m_00;
	*mr.mn(1, 2) = r.m_01;
	*mr.mn(1, 3) = r.m_02;
	*mr.mn(2, 1) = r.m_10;
	*mr.mn(2, 2) = r.m_11;
	*mr.mn(2, 3) = r.m_12;
	*mr.mn(3, 1) = r.m_20;
	*mr.mn(3, 2) = r.m_21;
	*mr.mn(3, 3) = r.m_22;

	for (n = 0; n < iNoNodes * 2; n++) {
		for (i = 1; i < 4; i++) {
			for (j = 1; j < 4; j++) {
				*t.mn(i + n * 3, j + n * 3) = *mr.mn(i, j);
			}
		}
	}
	mr.clear();
	return (t);
}

// Transform nodal stiffness values from element local to global
// given a specifed definition system
Mat E_Object::KEToKGTransform2(C3dMatrix mEL) {
	Mat t(iNoNodes * 6, iNoNodes * 6);
	int i, j, n;
	C3dMatrix r;
	r = mEL;
	Mat mr(3, 3);
	*mr.mn(1, 1) = r.m_00;
	*mr.mn(1, 2) = r.m_01;
	*mr.mn(1, 3) = r.m_02;
	*mr.mn(2, 1) = r.m_10;
	*mr.mn(2, 2) = r.m_11;
	*mr.mn(2, 3) = r.m_12;
	*mr.mn(3, 1) = r.m_20;
	*mr.mn(3, 2) = r.m_21;
	*mr.mn(3, 3) = r.m_22;

	for (n = 0; n < iNoNodes * 2; n++) {
		for (i = 1; i < 4; i++) {
			for (j = 1; j < 4; j++) {
				*t.mn(i + n * 3, j + n * 3) = *mr.mn(i, j);
			}
		}
	}
	mr.clear();
	return (t);
}

// Check to see if element has offsets and are non zero in mag
BOOL E_Object::HasOffsets() {
	return (FALSE);
}

// Offsets to global KE SYS
// only for 6 dof elements shells and beams
void E_Object::OffsetsToKG(PropTable* PropsT, Mat& off) {
	// CALL OFFSETS vectors OffA OffB are in global
	// A minor loop within the major loop takes care ofMEand KE which gets post - multiplied by the offset matrix and pre - multiplied by
	// it's transpose. The offset matrices for each G.P. are a 6 x 6 matrix which is an identity matrix plus a small 3 x 3 submatrix
	// containing only 3 independent terms, and the processing takes advantage of thisand simplifies the matrix multiplications.
	// The offset matrix is called E for each G.P.but is never written out as a 6 x 6 matrix.

	// The general form of E for one grid point is :

	//| 1  0  0 | 0    DZ - DY |
	//| 0  1  0 | -DZ   0    DX |
	//| 0  0  1 | DY - DX   0 |
	//| -------- - | -------------- - |
	//| 0  0  0 | 1    0    0 |
	//| 0  0  0 | 0    1    0 |
	//| 0  0  0 | 0    0    1 |

	// where DX, DY and DZ are the 3 components of the offset of the element at a grid and are in global coords
	// With this E matrix, the transformed element matrices are(prime indicates matrix transposition) :
	// MEg = E'* MEe * E
	// KEg = E'* KEe * E
	// PTEg = E'* PTEe
	int i;
	int iD;
	BOOL bOff;
	C3dVector Off;
	off.clear();
	off.Create(iNoNodes * 6, iNoNodes * 6);
	off.MakeUnit();
	iD = 0;
	for (i = 0; i < iNoNodes; i++) {
		bOff = GetOffset(PropsT, i, Off);
		*off.mn(1 + iD, 4 + iD) = 0;
		*off.mn(1 + iD, 5 + iD) = Off.z;
		*off.mn(1 + iD, 6 + iD) = -Off.y;
		*off.mn(2 + iD, 4 + iD) = -Off.z;
		*off.mn(2 + iD, 5 + iD) = 0;
		*off.mn(2 + iD, 6 + iD) = Off.x;
		*off.mn(3 + iD, 4 + iD) = Off.y;
		*off.mn(3 + iD, 5 + iD) = -Off.x;
		*off.mn(3 + iD, 6 + iD) = 0;
		iD += 6;
	}
}

// Process the global soloution dispacements fot the offset
void E_Object::DispOffsets(PropTable* PropsT, Mat& disp) {
	int i;
	int iInc = 0;
	BOOL bOff;
	C3dVector vOff;

	for (i = 0; i < iNoNodes; i++) {
		bOff = GetOffset(PropsT, i, vOff);
		*disp.mn(iInc + 1, 1) += +vOff.z * *disp.mn(iInc + 5, 1) - vOff.y * *disp.mn(iInc + 6, 1);
		*disp.mn(iInc + 2, 1) += -vOff.z * *disp.mn(iInc + 4, 1) + vOff.x * *disp.mn(iInc + 6, 1);
		*disp.mn(iInc + 3, 1) += +vOff.y * *disp.mn(iInc + 4, 1) - vOff.x * *disp.mn(iInc + 5, 1);
		iInc += 6;
	}

	//*disp.mn(7, 1) += +vOff2.z * *disp.mn(11, 1) - vOff2.y * *disp.mn(12, 1);
	//*disp.mn(8, 1) += -vOff2.z * *disp.mn(10, 1) + vOff2.x * *disp.mn(12, 1);
	//*disp.mn(9, 1) += +vOff2.y * *disp.mn(10, 1) - vOff2.x * *disp.mn(11, 1);
}

// returns the nodal offset if ther is one for node = iNode
// if no offset for this element type returns FALSE
BOOL E_Object::GetOffset(PropTable* PropsT, int iNode, C3dVector& vOff) {
	return (FALSE);
}

// Offsets to global KE SYS for 1 grid with offset vOff
// off matrix must be 6x6
void E_Object::OffsetsTransform(Mat& off, C3dVector vOff) {
	// CALL OFFSETS vectors OffA OffB are in global
	// A minor loop within the major loop takes care ofMEand KE which gets post - multiplied by the offset matrix and pre - multiplied by
	// it's transpose. The offset matrices for each G.P. are a 6 x 6 matrix which is an identity matrix plus a small 3 x 3 submatrix
	// containing only 3 independent terms, and the processing takes advantage of thisand simplifies the matrix multiplications.
	// The offset matrix is called E for each G.P.but is never written out as a 6 x 6 matrix.

	// The general form of E for one grid point is :

	//| 1  0  0 | 0    DZ - DY |
	//| 0  1  0 | -DZ   0    DX |
	//| 0  0  1 | DY - DX   0 |
	//| -------- - | -------------- - |
	//| 0  0  0 | 1    0    0 |
	//| 0  0  0 | 0    1    0 |
	//| 0  0  0 | 0    0    1 |

	// where DX, DY and DZ are the 3 components of the offset of the element at a grid and are in global coords
	// With this E matrix, the transformed element matrices are(prime indicates matrix transposition) :
	// MEg = E'* MEe * E
	// KEg = E'* KEe * E
	// PTEg = E'* PTEe

	off.MakeUnit();
	*off.mn(1, 4) = 0;
	*off.mn(1, 5) = vOff.z;
	*off.mn(1, 6) = -vOff.y;
	*off.mn(2, 4) = -vOff.z;
	*off.mn(2, 5) = 0;
	*off.mn(2, 6) = vOff.x;
	*off.mn(3, 4) = vOff.y;
	*off.mn(3, 5) = -vOff.x;
	*off.mn(3, 6) = 0;
}

Mat E_Object::ShapeDer(Mat Points, int i) {
	Mat M(0, 0);
	return (M);
}

Mat E_Object::ShapeFun(Mat Points, int i) {
	Mat M(0, 0);
	return (M);
}

Mat E_Object::getCoords3d() {
	Mat M(0, 0);
	return (M);
}

Mat E_Object::getCoords2d() {
	Mat M(0, 0);
	return (M);
}

Mat E_Object::bmat2d(Mat& coord,
                     Mat& deriv) {
	Mat M(0, 0);
	return (M);
}

int E_Object::GetfaceList(eFace* Faces[6]) {
	return (0);
}

int E_Object::GetLinkList(eEdge* Links[200]) {
	return (0);
}

G_Object* E_Object::GetNode(int i) {
	return (NULL);
}

C3dVector E_Object::GetNodalCoords(int i) {
	C3dVector v;
	return (v);
}

void E_Object::Transform(C3dMatrix TMat) {
}

CString E_Object::GetDOFString(int iDOF) {
	char sDOF[8];
	CString sRet;
	sDOF[0] = ' ';
	sDOF[1] = ' ';
	sDOF[2] = ' ';
	sDOF[3] = ' ';
	sDOF[4] = ' ';
	sDOF[5] = ' ';
	int iN = 0;
	if (iDOF & DOF_1) {
		sDOF[iN] = '1';
		iN++;
	}
	if (iDOF & DOF_2) {
		sDOF[iN] = '2';
		iN++;
	}
	if (iDOF & DOF_3) {
		sDOF[iN] = '3';
		iN++;
	}
	if (iDOF & DOF_4) {
		sDOF[iN] = '4';
		iN++;
	}
	if (iDOF & DOF_5) {
		sDOF[iN] = '5';
		iN++;
	}
	if (iDOF & DOF_6) {
		sDOF[iN] = '6';
		iN++;
	}
	sDOF[iN] = NULL;
	sRet = sDOF;
	return (sRet);
}

void E_Object::Reverse() {
}

C3dVector E_Object::GetFirstEdge() {
	C3dVector V(0, 0, 1);
	return (V);
}

double E_Object::QualAspect() {
	return (0.0);
}

double E_Object::GetCentriodVal(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	return (0);
}

double E_Object::GetElCentriodVal() {
	return (0);
}

double E_Object::GetPHI_SQ() {
	return (1.0);
}

void E_Object::GetPinFlags(Vec<int>& PDOFS, int& iNoPINs) {
}

void E_Object::PinFlgsToKE(Mat& KEL) {
	Vec<int> DOFPIN;
	int NUM_PFLAG_DOFS;
	int PDOF;
	// get the DOF to release
	GetPinFlags(DOFPIN, NUM_PFLAG_DOFS);
	int I, J, K;
	int iNDof = iNoNodes * 6;

	//! Check to make sure that the diagonal stiffness for the pin flagged DOF's are not zero

	//	IERROR = 0
	//	DO I = 1, NUM_PFLAG_DOFS
	//	ZERO_STIFF(I) = 'N'
	//	PDOF = DOFPIN(I)
	//	IF(DABS(KE(PDOF, PDOF)) <= EPS1) THEN
	//	IERROR = IERROR + 1
	//	WARN_ERR = WARN_ERR + 1
	//	WRITE(ERR, 1921) PDOF, TYPE, EID
	//	IF(SUPWARN == 'N') THEN
	//	WRITE(F06, 1921) PDOF, TYPE, EID
	//	ENDIF
	//	ZERO_STIFF(I) = 'Y'
	//	ENDIF
	//	ENDDO
	//	IF(IERROR > 0) THEN
	//	RETURN
	//	ENDIF

	//	!Process pin flags in KE
	// DOFPIN.diag();
	for (I = 1; I < NUM_PFLAG_DOFS; I++) {
		//	i_do : DO I = 1, NUM_PFLAG_DOFS
		//	IF(ZERO_STIFF(I) == 'N') THEN
		PDOF = *DOFPIN.nn(I);

		for (J = 1; J <= iNDof; J++) {
			if (J != PDOF) {
				for (K = 1; K <= iNDof; K++) {
					if (K != PDOF) {
						//	IF(DABS(KE(PDOF, PDOF)) > EPS1) THEN
						*KEL.mn(J, K) = *KEL.mn(J, K) - *KEL.mn(PDOF, K) * *KEL.mn(J, PDOF) / *KEL.mn(PDOF, PDOF);
						//	ELSE
						//	WRITE(ERR, 1937) TYPE, EID, PDOF
						//	WRITE(F06, 1937) TYPE, EID, PDOF
						//	NUM_EMG_FATAL_ERRS = NUM_EMG_FATAL_ERRS + 1
						//	FATAL_ERR = FATAL_ERR + 1
						//	CYCLE i_do
						//	ENDIF
					}
				}
			}
		}

		//	!Set row and column PDOF(pin flagged) to zero

		for (J = 1; J <= iNDof; J++) {
			*KEL.mn(PDOF, J) = 0;
			*KEL.mn(J, PDOF) = 0;
		}

		//	ENDIF
	}
}

C3dMatrix E_Object::GetElSys() {
	C3dMatrix vR;
	vR.MakeUnit();
	return (vR);
}

int E_Object::GetDOFInt(CString sDOF) {
	int iDOF = 0;
	if (sDOF.GetLength() > 0) {
		if (sDOF.Find('1') > -1) {
			iDOF = iDOF ^ DOF_1;
		}
		if (sDOF.Find('2') > -1) {
			iDOF = iDOF ^ DOF_2;
		}
		if (sDOF.Find('3') > -1) {
			iDOF = iDOF ^ DOF_3;
		}
		if (sDOF.Find('4') > -1) {
			iDOF = iDOF ^ DOF_4;
		}
		if (sDOF.Find('5', 0) > -1) {
			iDOF = iDOF ^ DOF_5;
		}
		if (sDOF.Find('6', 0) > -1) {
			iDOF = iDOF ^ DOF_6;
		}
	}
	return (iDOF);
}

BOOL E_Object::SetProperty(Property* Pr) {
	BOOL bC = FALSE;
	if (Pr != NULL) {
		if (iType == 115) {
			if (Pr->iType == 3) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 112) {
			if (Pr->iType == 3) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 94) {
			if ((Pr->iType == 1) || (Pr->iType == 2) || (Pr->iType == 222)) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 91) {
			if ((Pr->iType == 1) || (Pr->iType == 2) || (Pr->iType == 222)) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 21) {
			if ((Pr->iType == 4) || (Pr->iType == 5) || (Pr->iType == 222)) // Remove 222 for test
			{
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 22) {
			if (Pr->iType == 6) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 11) {
			if (Pr->iType == 11) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 4) {
			if (Pr->iType == 4) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 161) {
			PID = Pr->iID;
			bC = TRUE;
			pPr = Pr;
		} else if (iType == 136) {
			if (Pr->iType == 136) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 137) {
			if (Pr->iType == 137) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 138) {
			if (Pr->iType == 138) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 121) {
		} else if ((iType == 21) || (iType == 22)) {
		} else if (iType == 111) {
			if (Pr->iType == 3) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 310) {
			if (Pr->iType == 3) {
				PID = Pr->iID;
				bC = TRUE;
				pPr = Pr;
			}
		} else if (iType == 122) {
		}
	}
	return (bC);
}

void E_Object::Info() {
	// sprintf_s(S1,"%s%i%s%i%s%i%s%i%s%i","Type ",iObjType,"; Label ",iLabel," Col; ",iColour," PID; ",PID," ELTYPE; ",iType);
	// outtext1(S1);
	G_Object::Info();
}

Mat E_Object::bmat(Mat& coord,
                   Mat& deriv,
                   int iD,
                   int iDof) {
	int nod, k, l, m;
	double x, y;
	nod = deriv.n;
	Mat bee(iD, iDof * iNoNodes);
	if (iD == 3) {
		for (m = 1; m < nod + 1; m++) {
			k = 2 * m;
			l = k - 1;
			x = *deriv.mn(1, m);
			*bee.mn(1, l) = x;
			*bee.mn(3, k) = x;
			y = *deriv.mn(2, m);
			*bee.mn(2, k) = y;
			*bee.mn(3, l) = y;
		}
	} else if (iD == 6) {
		for (k = 1; k < nod + 1; k++) // was m
		{
			*bee.mn(1, (k) * 3 - 3 + 1) = *deriv.mn(1, k);
			*bee.mn(2, (k) * 3 - 2 + 1) = *deriv.mn(2, k);
			*bee.mn(3, (k) * 3 - 1 + 1) = *deriv.mn(3, k);
			*bee.mn(4, (k) * 3 - 3 + 1) = *deriv.mn(2, k);
			*bee.mn(4, (k) * 3 - 2 + 1) = *deriv.mn(1, k);
			*bee.mn(5, (k) * 3 - 2 + 1) = *deriv.mn(3, k);
			*bee.mn(5, (k) * 3 - 1 + 1) = *deriv.mn(2, k);
			*bee.mn(6, (k) * 3 - 3 + 1) = *deriv.mn(3, k);
			*bee.mn(6, (k) * 3 - 1 + 1) = *deriv.mn(1, k);
		}
	}

	return (bee);
}

BOOL E_Object::ChkNegJac() {
	BOOL brc = FALSE;
	Mat coord;
	Mat deriv;
	Mat Points;
	Mat jac;
	double det;
	int iDof;

	iDof = noDof();
	if ((iType == 111) ||
	    (iType == 112) ||
	    (iType == 115)) {
		if (iDof == 2) {
			coord = getCoords2d();
		} else {
			coord = getCoords3d();
		}

		Points = Sample(1);
		det = 0;
		deriv = ShapeDer(Points, 1);
		jac = deriv * coord;
		jac = jac.InvertJac(det);
		if (det < 0) {
			brc = TRUE;
		}
	} else {
		brc = FALSE;
	}
	return (brc);
}

Mat E_Object::GetThermalStrainMat3d(PropTable* PropsT, MatTable* MatT, double dT) {
	Mat bee; // strain displacement matrix
	Mat dee; // stress strain
	int nip = 0;
	Mat coord;
	Mat coord2;
	Mat deriv;
	Mat deriv2;
	Mat fun;
	Mat Points;
	Mat jac;
	int i;
	double det;
	Mat bT;
	Mat dS;
	Mat bdT;
	int iDof;
	int iS;
	int MID = -1;
	double dCTE = 0;
	double dE = 0;
	double dv = 0;

	double dthk = 0.001;
	Property* pS = NULL;
	Material* pM = NULL;
	// Get Shell Thicknes and thermal coeff
	// ************NEED TO DO BEAMS LATTER************
	if (PropsT != NULL)
		pS = PropsT->GetItem(PID);

	if (pS != NULL) {
		MID = pS->GetDefMatID();
		pM = MatT->GetItem(MID);
		dthk = pS->GetThk();
	} else {
		dCTE = 1; // for debugging
	}
	if (pM != NULL) {
		dCTE = pM->GetCTE();
		dE = pM->GetE();
		dv = pM->GetV();
	}

	if (iType == 91) {
		iDof = 2;
		nip = 1;
		iS = 3;
	} else if (iType == 94) {
		iDof = 2;
		nip = 4;
		iS = 3;
	} else if (iType == 115) {
		iDof = 3;
		nip = 8;
		iS = 6;
	} else if (iType == 111) {
		iDof = 3;
		nip = 1;
		iS = 6;
	} else if (iType == 112) {
		iDof = 3;
		nip = 6;
		iS = 6;
	} else if (iType == 136) // Translational Spring zero vec
	{
		iDof = 3;
		nip = 0;
		iS = 0;
	} else if (iType == 137) // Rotational Spring zero vec
	{
		iDof = 3;
		nip = 0;
		iS = 0;
	} else if (iType == 138) // BUSH Spring zero vec
	{
		iDof = 6;
		nip = 0;
		iS = 0;
	}
	//*********************JUST FOR TEST*******************************
	Mat FS(iDof * iNoNodes, 1);
	Mat S;
	if (iDof == 3) {
		S.Create(6, 1);
		*S.mn(1, 1) = dCTE * dT;
		*S.mn(2, 1) = dCTE * dT;
		*S.mn(3, 1) = dCTE * dT;
		*S.mn(4, 1) = 0;
		*S.mn(5, 1) = 0;
		*S.mn(6, 1) = 0;
	} else if (iDof == 2) {
		S.Create(3, 1);
		*S.mn(1, 1) = dCTE * dT;
		*S.mn(2, 1) = dCTE * dT;
		*S.mn(3, 1) = 0;
	}

	if ((iType == 91) || (iType == 94) || (iType == 115) || (iType == 111) || (iType == 112)) {
		Mat dee = DeeMat(dE, dv, iS); //***********************
		if (iDof == 2) {
			coord = getCoords3d();
		} // was {coord=getCoords3d();} the 3d version includes transform
		else {
			coord = getCoords3d();
		}
		Points = Sample(nip);
		for (i = 1; i < nip + 1; i++) {
			det = 0;
			fun = ShapeFun(Points, i);
			deriv = ShapeDer(Points, i);
			jac = deriv * coord;
			jac = jac.InvertJac(det);
			deriv2 = jac * deriv;
			bee = bmat(coord, deriv2, iS, iDof);
			bT = bee;
			bT.Transpose();
			dS = dee * S;
			bdT = bT * dS;
			if (iDof == 3) {
				det *= *Points.mn(i, 4);
			} else if (iDof == 2) {
				det *= *Points.mn(i, 3);
			}
			bdT *= det;
			FS += bdT;
		}
	}
	// for plain stress problems factor shells KM by dthk
	if ((iType == 91) || (iType == 94)) {
		FS *= dthk;
	}
	// FS.diag();
	dTemp = dCTE * dT;
	return (FS);
}

Mat E_Object::GetElNodalMass(PropTable* PropsT, MatTable* MatT) {
	Mat bee; // strain displacement matrix
	int nip = 0;
	Mat coord;
	Mat deriv;
	Mat fun;
	Mat NT;
	Mat Points;
	Mat jac;
	int i;
	double det;
	Mat bT;
	Mat MM;
	int iDof = -1;
	int iS;
	int MID = -1;
	double dthk = 1.0;
	double dRho = 1;
	char S1[80];
	Property* pS = NULL;
	Material* pM = NULL;

	// Get Shell Thicknes and Density
	// ************NEED TO DO BEAMS LATTER************

	pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
		if (MatT != NULL)
			pM = MatT->GetItem(MID);
	}

	if (pM != NULL)
		dRho = pM->GetDensity();

	if (((iType == 91) || (iType == 94)) && (pS != NULL)) {
		// These are to be over written in E_Oject4 & 3 so we can deal with PCOMPS and NSM
		if (pS != NULL) {
			PSHELL* pSh = (PSHELL*) pS;
			dthk = pSh->dT;
		} else {
			sprintf_s(S1, "ERROR: Property Not Found For EL %i", iLabel);
			outtext1(S1);
		}
	}

	if (iType == 91) {
		iDof = 2;
		nip = 1;
		iS = 3;
	} else if (iType == 94) {
		iDof = 2;
		nip = 4;
		iS = 3;
	} else if (iType == 115) {
		iDof = 3;
		nip = 8;
		iS = 6;
	} else if (iType == 111) {
		iDof = 3;
		nip = 1;
		iS = 6;
	} else if (iType == 112) {
		iDof = 3;
		nip = 6;
		iS = 6;
	}
	//*********************JUST FOR TEST*******************************
	Mat FS(iNoNodes, 1);
	Mat S(1, 1);
	*S.mn(1, 1) = dRho;
	if ((iType == 91) || (iType == 94) || (iType == 115) || (iType == 111) || (iType == 112)) {
		if (iDof == 2) {
			coord = getCoords3d();
		} // WAS {coord=getCoords2d();}
		else {
			coord = getCoords3d();
		}
		Points = Sample(nip);
		for (i = 1; i < nip + 1; i++) {
			det = 0;
			fun = ShapeFun(Points, i);
			deriv = ShapeDer(Points, i);
			jac = deriv * coord;
			jac = jac.InvertJac(det);
			NT = fun;
			NT.Transpose();
			MM = NT * S;
			if (iDof == 3) {
				det *= *Points.mn(i, 4);
			} else if (iDof == 2) {
				det *= *Points.mn(i, 3);
			}
			MM *= det;
			FS += MM;
		}
	}
	// for plain stress problems factor shells KM by dthk
	if ((iType == 91) || (iType == 94)) {
		FS *= dthk;
	}
	// FS.diag();
	return (FS);
}

Mat E_Object::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL& bErr) {
	Mat bee; // strain displacement matrix
	Mat dee; // stress strain
	int nip = 0;
	Mat coord;
	Mat coord2;
	Mat deriv;
	Mat deriv2;
	Mat fun;
	Mat Points;
	Mat jac;
	int i;
	double det;
	Mat bT;
	Mat db;
	Mat bdb;
	int iDof;
	int iS;
	int MID = -1;
	double dE = 210e9;
	double dv = 0.29;
	char S1[80];
	double dthk = 0.001;

	Property* pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
	}
	Material* pM = MatT->GetItem(MID);
	if (pS == NULL) {
		sprintf_s(S1, "PROPERTY NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	if (pM == NULL) {
		sprintf_s(S1, "MATERIAL NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	// Get Shell thickness

	if (((iType == 91) || (iType == 94)) && (pS != NULL)) {
		PSHELL* pSh = (PSHELL*) pS;
		dthk = pSh->dT;
	}

	if ((pM != NULL) && (pM->iType = 1)) {
		MAT1* pIsen = (MAT1*) pM;
		dE = pIsen->dE;
		dv = pIsen->dNU;
	}

	if (iType == 91) {
		iDof = 2;
		nip = 1;
		iS = 3;
	} else if (iType == 94) {
		iDof = 2;
		nip = 4;
		iS = 3;
	} else if (iType == 115) {
		iDof = 3;
		nip = 8;
		iS = 6;
	} else if (iType == 111) {
		iDof = 3;
		nip = 1;
		iS = 6;
	} else if (iType == 112) {
		iDof = 3;
		nip = 6;
		iS = 6;
	}
	Mat KM(iDof * iNoNodes, iDof * iNoNodes);

	if ((iType == 91) || (iType == 94) || (iType == 115) || (iType == 111) || (iType == 112)) {
		Mat dee = DeeMat(dE, dv, iS);
		if (iDof == 2) {
			coord = getCoords2d();
		} else {
			coord = getCoords3d();
		}
		// coord.diag();
		Points = Sample(nip);
		for (i = 1; i < nip + 1; i++) {
			det = 0;
			fun = ShapeFun(Points, i);
			deriv = ShapeDer(Points, i);
			jac = deriv * coord;
			jac = jac.InvertJac(det);
			deriv2 = jac * deriv;
			bee = bmat(coord, deriv2, iS, iDof);
			bT = bee;
			bT.Transpose();
			db = dee * bee;
			bdb = bT * db;
			if (iDof == 3) {
				det *= *Points.mn(i, 4);
			} else if (iDof == 2) {
				det *= *Points.mn(i, 3);
			}
			bdb *= det;
			KM += bdb;
		}
	}
	// for plain stress problems factor shells KM by dthk
	if ((iType == 91) || (iType == 94)) {
		KM *= dthk;
	}
	// KM.diag();
	return (KM);
}

Mat E_Object::GetThermMat(PropTable* PropsT, MatTable* MatT) {
	Mat Kay; // Conductivity
	int nip = 0;
	Mat coord;
	Mat coord2;
	Mat deriv;
	Mat deriv2;
	Mat fun;
	Mat Points;
	Mat jac;
	int i;
	double det;
	Mat bT;
	Mat db;
	Mat bdb;
	int iDof;
	int MID = -1;
	double dK = 200;
	char S1[80];
	double dthk = 0.001;
	BOOL is2dEl = FALSE;
	Property* pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
	}
	Material* pM = MatT->GetItem(MID);
	if (pS == NULL) {
		sprintf_s(S1, "PROPERTY NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	if (pM == NULL) {
		sprintf_s(S1, "MATERIAL NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	// Get Shell thickness

	if (((iType == 91) || (iType == 94)) && (pS != NULL)) {
		PSHELL* pSh = (PSHELL*) pS;
		dthk = pSh->dT;
	}

	if ((pM != NULL) && (pM->iType = 1)) {
		MAT1* pIsen = (MAT1*) pM;
		dK = pIsen->dk;
	}

	if (iType == 91) {
		iDof = 1;
		nip = 1;
		is2dEl = TRUE;
	} else if (iType == 94) {
		iDof = 1;
		nip = 4;
		is2dEl = TRUE;
	} else if (iType == 115) {
		iDof = 1;
		nip = 8;
	} else if (iType == 111) {
		iDof = 1;
		nip = 1;
	} else if (iType == 112) {
		iDof = 1;
		nip = 6;
	}
	Mat KM(iDof * iNoNodes, iDof * iNoNodes);

	if ((iType == 91) || (iType == 94) || (iType == 115) || (iType == 111) || (iType == 112)) {
		Mat Kay;
		if (is2dEl) {
			Kay = KayMat(dK, 2);
			coord = getCoords3d();
		} else {
			Kay = KayMat(dK, 3);
			coord = getCoords3d();
		}
		// coord.diag();
		Points = Sample(nip);
		for (i = 1; i < nip + 1; i++) {
			det = 0;
			fun = ShapeFun(Points, i);
			deriv = ShapeDer(Points, i);
			jac = deriv * coord;
			jac = jac.InvertJac(det);
			deriv2 = jac * deriv;
			bT = deriv2;
			bT.Transpose();
			db = Kay * deriv2;
			bdb = bT * db;
			if (is2dEl)
				det *= *Points.mn(i, 3);
			else
				det *= *Points.mn(i, 4); // ASSUME ITS A 3D PROBLEM FOR NOW
			// if (iDof==3){det*=*Points.mn(i,4);}
			// else if (iDof==2){det*=*Points.mn(i,3);}
			bdb *= det;
			KM += bdb;
		}
	}
	// for plain stress problems factor shells KM by dthk
	if ((iType == 91) || (iType == 94)) {
		KM *= dthk;
	}
	// KM.diag();
	return (KM);
}

Vec<int> E_Object::GetSteerVec3d() {
	Vec<int> V(0);
	return (V);
}

Vec<int> E_Object::GetSteerVec1d() {
	Vec<int> V(0);
	return (V);
}

int E_Object::MaxBW() {
	return (-1);
}

void E_Object::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << PID;
		ar << PIDunv;
		ar << iMatID;
		ar << iNoNodes;
	} else {
		G_Object::Serialize(ar, iV);
		if (iV >= -52)
			ar >> iType;
		ar >> PID;
		ar >> PIDunv;
		ar >> iMatID;
		ar >> iNoNodes;
		pResV = NULL;
		pPr = NULL;
	}
}

G_Object* E_Object::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object* gret = new E_Object;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pPr = NULL;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	E_Object* gret = new E_Object;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	E_Object* gret = new E_Object;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pParent = Parrent;
	gret->pResV = NULL;
	return (gret);
}

void E_Object::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%s %i\n", "$ERROR MISSING ELEMENT DEFINITION - ELEMENT:", iLabel);
}

void E_Object::ExportUNV(FILE* pFile) {
}

Mat E_Object::DeeMat(double E, double v, int iD) {
	double C, v2, vv;
	int i;
	Mat dee(iD, iD);
	if (iD == 3) // Plain Stress
	{
		C = E / (1 - v * v);
		*dee.mn(1, 1) = C;
		*dee.mn(2, 2) = C;
		*dee.mn(3, 3) = 0.5 * (1 - v) * C; // this should be G not sure is correct??
		*dee.mn(1, 2) = v * C;
		*dee.mn(2, 1) = v * C;
	} else if (iD == 6) {
		v2 = v / (1 - v);
		vv = 0.5 * (1 - 2 * v) / (1 - v);
		for (i = 1; i < 4; i++) {
			*dee.mn(i, i) = 1;
		}
		for (i = 4; i < 7; i++) {
			*dee.mn(i, i) = vv;
		}
		*dee.mn(1, 2) = v2;
		*dee.mn(2, 1) = v2;
		*dee.mn(1, 3) = v2;
		*dee.mn(3, 1) = v2;
		*dee.mn(2, 3) = v2;
		*dee.mn(3, 2) = v2;
		dee *= E * (1 - v) / ((1 + v) * (1 - 2 * v));
	}
	return (dee);
}

// SHELL_D matrix for bending coeffients for Dee Matrix
Mat E_Object::DeeBM(double E, double v, int iD) {
	Mat EBM(3, 3);
	double G = 0;
	double DEN1 = 0;
	double E0 = 0;
	G = E / (2 * (1 + v));
	DEN1 = 1 - v * v;
	if (abs(DEN1) < 0.01)
		outtext1("ERROR: Material Property Error 1-v*v very small.");
	EBM.MakeZero();
	E0 = E / DEN1;
	*EBM.mn(1, 1) = E0;
	*EBM.mn(2, 2) = *EBM.mn(1, 1);
	*EBM.mn(3, 3) = G;
	*EBM.mn(1, 2) = E0 * v;
	*EBM.mn(2, 1) = *EBM.mn(1, 2);

	return (EBM);
}

Mat E_Object::DeeSH(double E, double v, int iD) {
	Mat ESH(2, 2);
	double G = 0;
	G = E / (2 * (1 + v));

	ESH.MakeZero();
	*ESH.mn(1, 1) = G;
	*ESH.mn(2, 2) = G;
	return (ESH);
}

Mat E_Object::BEE_BM_Recovery() {
	Mat dum;
	return (dum);
}

Mat E_Object::BEE_BB_Recovery() {
	Mat dum;
	return (dum);
}

Mat E_Object::BEE_TS_Recovery() {
	Mat dum;
	return (dum);
}

//********************************************************************************
// THERMAL CONDUCTIVITY MATRIX K
//********************************************************************************
Mat E_Object::KayMat(double K, int iD) {
	Mat Kay(iD, iD);
	if (iD == 2) {
		*Kay.mn(1, 1) = K;
		*Kay.mn(2, 2) = K;
	}
	if (iD == 3) {
		*Kay.mn(1, 1) = K;
		*Kay.mn(2, 2) = K;
		*Kay.mn(3, 3) = K;
	}
	return (Kay);
}

//----------------------------------------------------------------------------
//    E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object2, CObject)

E_Object2::E_Object2() {
	G_Object();
	iCSYS = -1;
}

E_Object2::~E_Object2() {
	pVertex[0] = NULL;
	pVertex[1] = NULL;
}

void E_Object2::Create(Node* pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                       G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	int i = 0;
	for (i = 0; i < 2; i++) {
		pVertex[i] = pInVertex[i];
	}
	A = 0;
	B = 0;
	C = 0;
	iCSYS = iMat;
}

int E_Object2::noDof() {
	return (3);
}

// this can probably move to E_Object
int E_Object2::MaxBW() {
	int i;
	int j;

	int MaxDof;
	int MinDof;
	MaxDof = 0;
	MinDof = 99999999;
	for (i = 0; i < iNoNodes; i++) {
		for (j = 0; j < noDof(); j++) {
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] > MaxDof)) {
				MaxDof = pVertex[i]->dof[j];
			}
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] < MinDof)) {
				MinDof = pVertex[i]->dof[j];
			}
		}
	}
	int iRC;
	if (MaxDof - MinDof < 0) {
		iRC = 0;
	} else {
		iRC = MaxDof - MinDof;
	}
	return (iRC);
}

double E_Object2::getLen() {
	double dRet = 0;
	C3dVector vL;
	vL = pVertex[1]->Get_Centroid();
	vL -= pVertex[0]->Get_Centroid();
	dRet = vL.Mag();
	return (dRet);
}

void E_Object2::Info() {
	char S1[80];
	G_Object::Info();
	sprintf_s(S1, "%s%i%s%i", "ND1 ", pVertex[0]->iLabel, "ND2 ", pVertex[1]->iLabel);
	outtext1(S1);
}

C3dMatrix E_Object2::GetSpringSys(CoordSys* pC) {
	C3dMatrix mRC;
	C3dMatrix mInvRC;
	C3dVector pt;
	C3dVector pO;
	double ang;

	if (pC != NULL) {
		mRC = pC->GetTMat();
		if (pC->CysType == 2) {
			pt = this->Get_Centroid();
			pO = pC->Get_Centroid();
			pt -= pO;
			mRC.Transpose();
			pt = mRC * pt;
			ang = atan2(pt.y, pt.x) * 180 / Pi;
			mInvRC.MakeUnit();
			mInvRC.Rotate(0, 0, ang);
			mRC.Transpose();
			mRC *= mInvRC;
			mInvRC = mRC;
		} else if (pC->CysType == 1) {
			mInvRC = mRC;
		} else {
			outtext1("ERROR: Spherical Coordinate Sys Not Supported.");
		}
	} else {
		outtext1("ERROR: Coordinateord Sys Not Found.");
	}

	return (mInvRC);
}

Mat E_Object2::GetSpringTMat(CoordSys* pCSYS) {
	int i, j;
	C3dVector K;
	C3dMatrix r;
	Vec<int> V(2 * 3);

	Mat KM(6, 6);
	Mat t(6, 6);
	if (pCSYS != NULL) {
		// This composes the stiffness tranformation matrix
		r = GetSpringSys(pCSYS);
		r.Transpose();
		Mat mr(3, 3);
		*mr.mn(1, 1) = r.m_00;
		*mr.mn(1, 2) = r.m_01;
		*mr.mn(1, 3) = r.m_02;
		*mr.mn(2, 1) = r.m_10;
		*mr.mn(2, 2) = r.m_11;
		*mr.mn(2, 3) = r.m_12;
		*mr.mn(3, 1) = r.m_20;
		*mr.mn(3, 2) = r.m_21;
		*mr.mn(3, 3) = r.m_22;
		for (i = 1; i < 4; i++) {
			for (j = 1; j < 4; j++) {
				*t.mn(i, j) = *mr.mn(i, j);
				*t.mn(i + 3, j + 3) = *mr.mn(i, j);
			}
		}
	}
	return (t);
}

Mat E_Object2::GetThermMat(PropTable* PropsT, MatTable* MatT) {
	char S1[80];
	double K = 0;
	int iDof = 1;
	Property* pS = PropsT->GetItem(this->PID);
	if (pS != nullptr) {
		if (pS->iType == 136) {
			PSPRINGT* pSP = (PSPRINGT*) pS;
			K = pSP->dkcoeff;
		} else if (pS->iType == 138) {
			PBUSH* pSP = (PBUSH*) pS;
			K = pSP->dkcoeff;
		}
	} else {
		sprintf_s(S1, "%s%i", "ERROR: No Property Found for Spring Element ", iLabel);
		outtext1(S1);
	}

	Mat KM(iDof * iNoNodes, iDof * iNoNodes);
	C3dVector p1;
	C3dVector p2;
	double l;
	p1 = pVertex[0]->GetCoords();
	p2 = pVertex[1]->GetCoords();
	p2 -= p1;
	l = p2.Mag();
	*KM.mn(1, 1) = K;
	*KM.mn(2, 1) = -K;
	*KM.mn(1, 2) = -K;
	*KM.mn(2, 2) = K;
	// KM.diag();
	return (KM);
}

Mat E_Object2::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL& bErr) {
	double kx = 1e3;
	double ky = 1e3;
	double kz = 1e3;
	char S1[80];
	C3dMatrix r;
	BOOL bFail = FALSE;
	Mat TMat;
	Mat TTMat(6, 6);
	Mat Kmt;
	Mat tKmt;
	Property* pS = PropsT->GetItem(this->PID);
	if (pS != NULL) {
		if (pS->iType == 136) {
			PSPRINGT* pSP = (PSPRINGT*) pS;
			kx = pSP->dkx;
			ky = pSP->dky;
			kz = pSP->dkz;
		} else if (pS->iType == 137) {
			PSPRINGR* pSP = (PSPRINGR*) pS;
			kx = pSP->dkx;
			ky = pSP->dky;
			kz = pSP->dkz;
		}
	} else {
		sprintf_s(S1, "%s%i", "ERROR: No Property Found for Spring Element ", iLabel);
		outtext1(S1);
	}
	Mat KM(6, 6);
	KM *= 0;
	// DEFUALT MATRIX GLOBAL
	*KM.mn(1, 1) = kx;
	*KM.mn(4, 4) = kx;
	*KM.mn(1, 4) = -kx;
	*KM.mn(4, 1) = -kx;
	*KM.mn(2, 2) = ky;
	*KM.mn(5, 5) = ky;
	*KM.mn(2, 5) = -ky;
	*KM.mn(5, 2) = -ky;
	*KM.mn(3, 3) = kz;
	*KM.mn(6, 6) = kz;
	*KM.mn(3, 6) = -kz;
	*KM.mn(6, 3) = -kz;

	CoordSys* pCSYS = NULL;
	if (this->iCSYS != -1) {
		ME_Object* ME = (ME_Object*) this->pParent;
		if (ME != NULL) {
			pCSYS = ME->GetSys(iCSYS);
			if (pCSYS != NULL) {
				r = GetSpringSys(pCSYS);
				TMat = GetSpringTMat(pCSYS);
				TTMat = TMat;
				TTMat.Transpose();
				Kmt.clear();
				tKmt.clear();
				Kmt = KM * TMat;
				tKmt = TTMat * Kmt;
				KM = tKmt;
				Kmt.clear();
				tKmt.clear();
				TMat.clear();
				TTMat.clear();
			} else {
				sprintf_s(S1, "%s%i", "ERROR: Coordinate System Not Found for Spring Element ", iLabel);
				outtext1(S1);
				bFail = TRUE;
			}
		} else {
			outtext1("ERROR: Orphaned Element.");
			bFail = TRUE;
		}
	}
	return (KM);
}

Vec<int> E_Object2::GetSteerVec3d() {
	Vec<int> V(2 * 3);
	if (iType == 136) {
		*V.nn(1) = pVertex[0]->dof[0];
		*V.nn(2) = pVertex[0]->dof[1];
		*V.nn(3) = pVertex[0]->dof[2];
		*V.nn(4) = pVertex[1]->dof[0];
		*V.nn(5) = pVertex[1]->dof[1];
		*V.nn(6) = pVertex[1]->dof[2];
	} else if (iType == 137) {
		*V.nn(1) = pVertex[0]->dof[3];
		*V.nn(2) = pVertex[0]->dof[4];
		*V.nn(3) = pVertex[0]->dof[5];
		*V.nn(4) = pVertex[1]->dof[3];
		*V.nn(5) = pVertex[1]->dof[4];
		*V.nn(6) = pVertex[1]->dof[5];
	}

	return (V);
}

Vec<int> E_Object2::GetSteerVec1d() {
	Vec<int> V(2 * 1);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[1]->dof[0];
	return (V);
}

BOOL E_Object2::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_Object2::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

void E_Object2::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		vUp.Serialize(ar, iV);
		ar << pVertex[0]->iLabel;
		ar << pVertex[1]->iLabel;
		ar << A;
		ar << B;
		ar << C;
		ar << iCSYS;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		vUp.Serialize(ar, iV);
		ar >> iNd;
		pVertex[0] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[1] = MESH->GetNode(iNd);
		ar >> A;
		ar >> B;
		ar >> C;
		ar >> iCSYS;
	}
}

G_Object* E_Object2::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object2* gret = new E_Object2;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->vUp = vUp;
	gret->A = A;
	gret->B = B;
	gret->C = C;
	gret->pPr = pPr;
	gret->pParent = MESH;
	gret->pResV = NULL;
	gret->iCSYS = iCSYS;
	return (gret);
}

G_Object* E_Object2::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object2* gret = new E_Object2;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iCSYS = iCSYS;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	gret->iCSYS = iCSYS;
	gret->vUp = vUp;
	Node* nA = Source->GetNode(A);
	if (nA != NULL) {
		EInd = Source->GetNodeInd(nA);
		gret->A = Target->pNodes[EInd + iSInd]->iLabel; // Orientation Node
	} else {
		gret->A = A;
	}
	gret->B = B;
	gret->C = C;
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object2::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object2* gret = new E_Object2;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->vUp = vUp;
	gret->A = A;
	gret->B = B;
	gret->C = C;
	gret->pPr = pPr;
	gret->pParent = Parrent;
	gret->pResV = NULL;
	return (gret);
}

// Draw Object line
void E_Object2::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
}

int E_Object2::GetLinkList(eEdge* Links[200]) {
	Links[0] = new eEdge;
	Links[0]->pParent = this;
	Links[0]->iColour = iColour;
	Links[0]->pVertex[0] = pVertex[0];
	Links[0]->pVertex[1] = pVertex[1];
	return (1);
}

G_Object* E_Object2::GetNode(int i) {
	return (pVertex[i]);
}

C3dMatrix E_Object2::GetElSys() {
	C3dMatrix vR;
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;

	vX.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	vX.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	vX.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;
	vY = vUp;
	vX.Normalize();
	vY.Normalize();
	vZ = vX.Cross(vY);
	vZ.Normalize();
	vY = vZ.Cross(vX);
	vR.SetColVec(1, vX);
	vR.SetColVec(2, vY);
	vR.SetColVec(3, vZ);
	vR.Transpose();
	return (vR);
}

void E_Object2::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void E_Object2::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	int ind;
	BOOL bD = FALSE;
	float fCols[2] = {0, 0};
	C3dVector d[2];
	double S;
	double dFS = 1.0;
	int i;

	for (i = 0; i < 2; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	S = ME->dScale;
	dFS = ME->dResFactor;
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 2; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}

		Selectable = 1;
		ind = ME->iCVar;
		if ((pVertex[0]->pResV != NULL) &&
		    (pVertex[1]->pResV != NULL)) {
			bD = TRUE;
			fCols[0] = GetContourCol(*pVertex[0]->pResV->GetAddress(ind) * dFS);
			fCols[1] = GetContourCol(*pVertex[1]->pResV->GetAddress(ind) * dFS);
		}
		if (pResV != NULL) {
			bD = TRUE;
			fCols[0] = GetContourCol(*pResV->GetAddress(ind) * dFS);
			fCols[1] = fCols[0];
		}
		C3dVector vCent;
		char sLab[20];
		vCent = Get_Centroid();
		if (((iDspFlgs & DSP_CONT) == 0) && (bD == TRUE)) {
			glColor3fv(cols[124]);
			glEnable(GL_TEXTURE_1D);
			glLineWidth(gEL_SIZE);
			glBegin(GL_LINES);
			glTexCoord1f(fCols[0]);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glTexCoord1f(fCols[1]);
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glEnd();
			glRasterPos3f((float) vCent.x, (float) vCent.y, (float) vCent.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPSP);
			glDisable(GL_TEXTURE_1D);
		} else {
			glColor3fv(cols[iColour]);
			glLineWidth(gEL_SIZE);
			glBegin(GL_LINES);
			glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
			           (float) (pVertex[0]->Pt_Point->z + d[0].z));
			glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
			           (float) (pVertex[1]->Pt_Point->z + d[1].z));
			glEnd();
			glRasterPos3f((float) vCent.x, (float) vCent.y, (float) vCent.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPSP);
		}

		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_end
		{
			sprintf_s(sLab, "E%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if (((iDspFlgs & DSP_RESLAB) == 0) && (pResV != NULL)) {
			sprintf_s(sLab, "%f", *pResV->GetAddress(ind));
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if ((iDspFlgs & DSP_ELSYS) == 0) {
			// C3dMatrix mS = GetElSys();
			glColor3fv(cols[iColour]);
			C3dMatrix mS; //  For spring its global or assigned
			mS.MakeUnit();
			if (iCSYS > -1) {
				if (this->pParent != NULL) {
					if (this->pParent->iObjType == 4) {
						ME_Object* pM = (ME_Object*) this->pParent;
						CoordSys* pSYS = (CoordSys*) pM->GetSys(iCSYS);
						if (pSYS != NULL) {
							mS = pSYS->GetTMat();
						}
					}
				}
			}
			C3dVector vC = Get_Centroid();
			// mS.Transpose();
			C3dVector vX = mS.GetColVec(1);
			C3dVector vY = mS.GetColVec(2);
			;
			C3dVector vZ = mS.GetColVec(3);
			;
			vX *= 0.5 * dS1;
			vY *= 0.5 * dS1;
			vZ *= 0.5 * dS1;
			vX += vC;
			vY += vC;
			vZ += vC;
			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vX.x, (float) vX.y, (float) vX.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vY.x, (float) vY.y, (float) vY.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glEnd();
			glRasterPos3f((float) vX.x, (float) vX.y, (float) vX.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPX);
			glRasterPos3f((float) vY.x, (float) vY.y, (float) vY.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPY);
			glRasterPos3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}
	} else {
		Selectable = 0;
	}
}

double E_Object2::GetCentriodVal(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	double dTemp = 0;
	int iDOFID;
	double T;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		T = 0;
		;
		iDOFID = this->pVertex[j]->dof[iDof];
		if (iDOFID > 0) {
			T = *Disp.nn(iDOFID);
		}
		dTemp += T;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

double E_Object2::GetElCentriodVal() {
	double dTemp = 0;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		dTemp += pVertex[j]->dTemp;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

C3dVector E_Object2::Get_Centroid() {
	C3dVector vT;
	vT.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vT += pVertex[j]->Get_Centroid();
	}
	vT.x /= iNoNodes;
	vT.y /= iNoNodes;
	vT.z /= iNoNodes;
	return (vT);
}

void E_Object2::SetUpVec(C3dVector vIn) {
	vUp = vIn;
}

void E_Object2::SetSec(int iA, int iB, int iC) {
	A = iA;
	B = iB;
	C = iC;
}

void E_Object2::ExportUNV(FILE* pFile) {
	int i;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	if ((iType == 21) || (iType == 22)) {
		fprintf(pFile, "%10i%10i%10i\n", A, B, C);
	}
	for (i = 0; i < iNoNodes; i++) {
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
	}
	fprintf(pFile, "\n", "");
}

CString E_Object2::ToString() {
	char S[80] = "";
	CString src = "";
	C3dMatrix TMat;
	int iCS;
	if (iCSYS < 0)
		iCS = 0;
	else
		iCS = iCSYS;

	if (iType == 136) {
		sprintf_s(S, "%8s%8i%8i%8i%8i%8s%8s%8s%8i\n", "CBUSH   ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel,
		          "", "", "", iCS);
		src = S;
	}
	return (src);
}

void E_Object2::ExportNAS(FILE* pFile) {
	C3dMatrix TMat;
	int iCS;
	if (iCSYS < 0)
		iCS = 0;
	else
		iCS = iCSYS;

	if (iType == 138) {
		fprintf(pFile, "%8s%8i%8i%8i%8i%8s%8s%8s%8i\n", "CBUSH   ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel,
		        "", "", "", iCS);
	}
}

void E_Object2::ExportUPVecs(FILE* pFile) {
	double dA1;
	C3dVector Vz;
	C3dVector Vy;
	C3dVector Vx;
	C3dVector Vu;
	C3dMatrix M;
	if (A == 0) {
		M.MakeUnit();
		Vu.Set(vUp.x, vUp.y, vUp.z);
		Vz.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
		Vz.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
		Vz.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;
		Vz.Normalize();
		Vy.Set(0, 0, 1);
		double dDot;
		dDot = abs(Vy.Dot(Vz));
		if (dDot == 1) {
			Vx.Set(0, 1, 0);
			Vy = Vz.Cross(Vx);
			Vy.Normalize();
			Vx = Vy.Cross(Vz);
			Vx.Normalize();
		} else {
			Vx = Vy.Cross(Vz);
			Vx.Normalize();
			Vy = Vz.Cross(Vx);
			Vy.Normalize();
		}
		M.SetColVec(1, Vx);
		M.SetColVec(2, Vy);
		M.SetColVec(3, Vz);
		M.Transpose();
		Vu = M.Mult(Vu);
		if (Vu.y != 0) {
			dA1 = atan2(Vu.x, Vu.y);
			dA1 = dA1 * 180 / 3.1415926535897932384626433832795;
		} else {
			dA1 = 0;
		}
		dA1 += 90.0;
		fprintf(pFile, "%10i%10i\n", iLabel, 21);
		fprintf(pFile, "%10i%10i%10i%10i%10i\n", 8, 0, 0, 0, 0);
		fprintf(pFile, "%15.6E%15.6E%15.6E\n", dA1, 0.0, 0.0);
	} else {
		fprintf(pFile, "%10i%10i\n", iLabel, 21);
		fprintf(pFile, "%10i%10i%10i%10i%10i\n", 0, 1, 0, 0, 0);
	}
}

CString E_Object2::GetName() {
	return ("Spring (CBUSH)");
}

int E_Object2::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "PID";
	iNo++;
	sVar[iNo] = "CID";
	iNo++;
	sVar[iNo] = "N1";
	iNo++;
	sVar[iNo] = "N2";
	iNo++;
	return (iNo);
}

int E_Object2::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", PID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iCSYS);
	sVar[iNo] = S1;
	iNo++;

	sprintf_s(S1, "%i", pVertex[0]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[1]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void E_Object2::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Node* pN;
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	PID = atoi(sVar[1]);
	iCSYS = atoi(sVar[2]);
	int N1 = atof(sVar[3]);
	int N2 = atof(sVar[4]);
	if (pVertex[0]->iLabel != N1) {
		pN = pMe->GetNode(N1);
		if (pN != NULL)
			pVertex[0] = pN;
	}
	if (pVertex[1]->iLabel != N2) {
		pN = pMe->GetNode(N2);
		if (pN != NULL)
			pVertex[1] = pN;
	}
}

//----------------------------------------------------------------------------
//    B U S H  E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object2BUSH, CObject)

int E_Object2BUSH::noDof() {
	return (6);
}

Mat E_Object2BUSH::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL& bErr) {
	int i, j;
	double kx = 1e9;
	double ky = 1e9;
	double kz = 1e9;
	double rx = 1e6;
	double ry = 1e6;
	double rz = 1e6;
	char S1[80];
	C3dMatrix r;
	Mat TMat;
	Mat TTMat(6, 6);
	Mat Kmt;
	Mat tKmt;
	Mat t;
	Mat tt;
	Mat KEdum;
	Property* pS = PropsT->GetItem(this->PID);
	if (pS != NULL) {
		if (pS->iType == 138) {
			PBUSH* pSP = (PBUSH*) pS;
			kx = pSP->dK1;
			ky = pSP->dK2;
			kz = pSP->dK3;
			rx = pSP->dK4;
			ry = pSP->dK5;
			rz = pSP->dK6;
		}
	} else {
		sprintf_s(S1, "%s%i", "ERROR: No Property Found for Spring Element ", iLabel);
		outtext1(S1);
	}
	Mat KE(12, 12);
	KE *= 0;
	// DEFUALT MATRIX GLOBAL

	*KE.mn(1, 1) = kx; // NB * **new 09 / 10 / 21. Big change.KE(before offsets) : just EPROP vals
	*KE.mn(2, 2) = ky;
	*KE.mn(3, 3) = kz;
	*KE.mn(4, 4) = rx;
	*KE.mn(5, 5) = ry;
	*KE.mn(6, 6) = rz;

	*KE.mn(7, 7) = *KE.mn(1, 1);
	*KE.mn(8, 8) = *KE.mn(2, 2);
	*KE.mn(9, 9) = *KE.mn(3, 3);
	*KE.mn(10, 10) = *KE.mn(4, 4);
	*KE.mn(11, 11) = *KE.mn(5, 5);
	*KE.mn(12, 12) = *KE.mn(6, 6);

	*KE.mn(1, 7) = -*KE.mn(1, 1);
	*KE.mn(2, 8) = -*KE.mn(2, 2);
	*KE.mn(3, 9) = -*KE.mn(3, 3);
	*KE.mn(4, 10) = -*KE.mn(4, 4);
	*KE.mn(5, 11) = -*KE.mn(5, 5);
	*KE.mn(6, 12) = -*KE.mn(6, 6);
	for (i = 1; i <= 12; i++) {
		for (j = 1; j <= 12; j++) {
			*KE.mn(j, i) = *KE.mn(i, j);
		}
	}

	// TRANSFORM KE TO GLOBAL
	CoordSys* pCSYS = nullptr;
	if (this->iCSYS != -1) {
		ME_Object* ME = (ME_Object*) this->pParent;
		if (ME != NULL) {
			pCSYS = ME->GetSys(iCSYS);
			if (pCSYS != NULL) {
				r = GetSpringSys(pCSYS);
				t = KEToKGTransform2(r);
				tt = t;
				tt.Transpose();
				KEdum = KE * t;
				KE = tt * KEdum;
			} else {
				sprintf_s(S1, "%s%i", "ERROR: Coordinate System Not Found for Spring Element ", iLabel);
				outtext1(S1);
				bErr = TRUE;
			}
		} else {
			outtext1("ERROR: Orphaned Element.");
			bErr = TRUE;
		}
	}

	return (KE);
}

Vec<int> E_Object2BUSH::GetSteerVec3d() {
	Vec<int> V(2 * 6);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[0]->dof[3];
	*V.nn(5) = pVertex[0]->dof[4];
	*V.nn(6) = pVertex[0]->dof[5];

	*V.nn(7) = pVertex[1]->dof[0];
	*V.nn(8) = pVertex[1]->dof[1];
	*V.nn(9) = pVertex[1]->dof[2];
	*V.nn(10) = pVertex[1]->dof[3];
	*V.nn(11) = pVertex[1]->dof[4];
	*V.nn(12) = pVertex[1]->dof[5];

	return (V);
}

//----------------------------------------------------------------------------
//    ROD E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object2R, CObject)

E_Object2R::E_Object2R() {
	G_Object();
	iDOFA = 0;
	iDOFB = 0;
	iONID = -1;
	iType = 11;
	this->iNoNodes = 2;
}

E_Object2R::~E_Object2R() {
	pVertex[0] = NULL;
	pVertex[1] = NULL;
}

void E_Object2R::Create(Node* pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                        G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	int i = 0;
	for (i = 0; i < 2; i++) {
		pVertex[i] = pInVertex[i];
	}
	A = 0;
	B = 0;
	C = 0;
	iONID = -1;
	OffA *= 0;
	OffB *= 0;
}

void E_Object2R::GetPinFlags(Vec<int>& PDOFS, int& iNoPINs) {
	iNoPINs = 1; // 1 indeded
	PDOFS.Size(12);
	if (iDOFA & DOF_1) {
		*PDOFS.nn(iNoPINs) = 1;
		iNoPINs++;
	}
	if (iDOFA & DOF_2) {
		*PDOFS.nn(iNoPINs) = 2;
		iNoPINs++;
	}
	if (iDOFA & DOF_3) {
		*PDOFS.nn(iNoPINs) = 3;
		iNoPINs++;
	}
	if (iDOFA & DOF_4) {
		*PDOFS.nn(iNoPINs) = 4;
		iNoPINs++;
	}
	if (iDOFA & DOF_5) {
		*PDOFS.nn(iNoPINs) = 5;
		iNoPINs++;
	}
	if (iDOFA & DOF_6) {
		*PDOFS.nn(iNoPINs) = 6;
		iNoPINs++;
	}
	// second node or end of bar
	if (iDOFB & DOF_1) {
		*PDOFS.nn(iNoPINs) = 7;
		iNoPINs++;
	}
	if (iDOFB & DOF_2) {
		*PDOFS.nn(iNoPINs) = 8;
		iNoPINs++;
	}
	if (iDOFB & DOF_3) {
		*PDOFS.nn(iNoPINs) = 9;
		iNoPINs++;
	}
	if (iDOFB & DOF_4) {
		*PDOFS.nn(iNoPINs) = 10;
		iNoPINs++;
	}
	if (iDOFB & DOF_5) {
		*PDOFS.nn(iNoPINs) = 11;
		iNoPINs++;
	}
	if (iDOFB & DOF_6) {
		*PDOFS.nn(iNoPINs) = 12;
		iNoPINs++;
	}
}

void E_Object2R::SetDOFStringA(CString sDOF) {
	iDOFA = GetDOFInt(sDOF);
}

void E_Object2R::SetDOFStringB(CString sDOF) {
	iDOFB = GetDOFInt(sDOF);
}

void E_Object2R::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

BOOL E_Object2R::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_Object2R::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		vUp.Serialize(ar, iV);
		OffA.Serialize(ar, iV);
		OffB.Serialize(ar, iV);
		ar << pVertex[0]->iLabel;
		ar << pVertex[1]->iLabel;
		ar << A;
		ar << B;
		ar << C;
		ar << iDOFA;
		ar << iDOFB;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		vUp.Serialize(ar, iV);
		OffA.Serialize(ar, iV);
		OffB.Serialize(ar, iV);
		ar >> iNd;
		pVertex[0] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[1] = MESH->GetNode(iNd);
		ar >> A;
		ar >> B;
		ar >> C;
		ar >> iDOFA;
		ar >> iDOFB;
	}
}

G_Object* E_Object2R::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object2R* gret = new E_Object2R;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->vUp = vUp;
	gret->OffA = OffA;
	gret->OffB = OffB;
	gret->A = A;
	gret->B = B;
	gret->C = C;
	gret->iDOFA = iDOFA;
	gret->iDOFB = iDOFB;
	gret->iONID = iONID;
	gret->pPr = pPr;
	gret->pParent = MESH;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object2R::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object2R* gret = new E_Object2R;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	gret->vUp = vUp;
	gret->OffA = OffA;
	gret->OffB = OffB;
	Node* pT = Source->GetNode(iONID);
	if (pT != NULL) {
		EInd = Source->GetNodeInd(pT);
		gret->iONID = Target->pNodes[iSInd + EInd]->iLabel;
	} else {
		gret->iONID = -1;
	}
	Node* nA = Source->GetNode(A);
	if (nA != NULL) {
		EInd = Source->GetNodeInd(nA);
		gret->A = Target->pNodes[EInd + iSInd]->iLabel; // Orientation Node
	} else {
		gret->A = A;
	}
	gret->B = B;
	gret->C = C;
	gret->iDOFA = iDOFA;
	gret->iDOFB = iDOFB;
	gret->pPr = NULL;
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object2R::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object2R* gret = new E_Object2R;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->vUp = vUp;
	gret->OffA = OffA;
	gret->OffB = OffB;
	gret->A = A;
	gret->B = B;
	gret->C = C;
	gret->iDOFA = iDOFA;
	gret->iDOFB = iDOFB;
	gret->pPr = pPr;
	gret->pParent = Parrent;
	gret->pResV = NULL;
	return (gret);
}

// Draw Object line
void E_Object2R::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
}

void E_Object2R::Info() {
	char S1[80];
	G_Object::Info();
	sprintf_s(S1, "%s%i%s%i%s%i%s%i%s%i%s%i", "Type ", iObjType, "; Label ", iLabel, " Col; ", iColour, " PID; ", PID,
	          " ELTYPE; ", iType, " CSYS; ", iCSYS);
	outtext1(S1);
	sprintf_s(S1, "%s%i%s%i", "ND1 ", pVertex[0]->iLabel, "ND2 ", pVertex[1]->iLabel);
	outtext1(S1);
	sprintf_s(S1, "Beam Up Vector %g %g %g", vUp.x, vUp.y, vUp.z);
	outtext1(S1);
	CString sEndR;
	sEndR = this->GetDOFString(iDOFA);
	sprintf_s(S1, "End A Release %s ", sEndR);
	outtext1(S1);
	sEndR = this->GetDOFString(iDOFB);
	sprintf_s(S1, "End B Release %s ", sEndR);
	outtext1(S1);
	sprintf_s(S1, "Beam End A Offset %g %g %g", OffA.x, OffA.y, OffA.z);
	outtext1(S1);
	sprintf_s(S1, "Beam End B Offset %g %g %g", OffB.x, OffB.y, OffB.z);
	outtext1(S1);
}

int E_Object2R::GetLinkList(eEdge* Links[200]) {
	Links[0] = new eEdge;
	Links[0]->pParent = this;
	Links[0]->iColour = iColour;
	Links[0]->pVertex[0] = pVertex[0];
	Links[0]->pVertex[1] = pVertex[1];
	return (1);
}

G_Object* E_Object2R::GetNode(int i) {
	return (pVertex[i]);
}

void E_Object2R::OglDraw(int iDspFlgs, double dS1, double dS2) {
	glColor3fv(cols[iColour]);
	C3dVector d[3];
	int i;
	for (i = 0; i < 2; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS = 1.0;
	dFS = ME->dResFactor;
	// Contour colours bit
	float fCols[2] = {0, 0};
	BOOL bD = FALSE;
	int iVar;
	iVar = ME->iCVar;
	// Nodal data
	if ((pVertex[0]->pResV != NULL) &&
	    (pVertex[1]->pResV != NULL)) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pVertex[0]->pResV->GetAddress(iVar) * dFS);
		fCols[1] = GetContourCol(*pVertex[1]->pResV->GetAddress(iVar) * dFS);
	}
	if (pResV != NULL) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pResV->GetAddress(iVar) * dFS);
		fCols[1] = GetContourCol(*pResV->GetAddress(iVar) * dFS);
	}

	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 2; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		if ((iDspFlgs & DSP_THK) > 0) {
			if (pPr != NULL) {
				BSec* pS = pPr->GetSec();
				if (pS != NULL) {
					C3dMatrix TA = GetBeamTformA();
					C3dMatrix TB = GetBeamTformB();
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA, GL_SRC_COLOR);
					pS->OglDraw(iDspFlgs, TA, TB, d[0], d[1], fCols[0], fCols[1], bD);
					glDisable(GL_BLEND);
				}
			}

			// fix for line elements not showing color when in wireframe mode
			else {
				glLineWidth(gEL_SIZE);
				glColor3fv(cols[iColour]);
				glBegin(GL_LINES);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + OffA.x + d[0].x), (float) (pVertex[0]->Pt_Point->y + OffA.y + d[0].y), (float) (pVertex[0]->Pt_Point->z + OffA.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + OffB.x + d[1].x), (float) (pVertex[1]->Pt_Point->y + OffB.y + d[1].y), (float) (pVertex[1]->Pt_Point->z + OffB.z + d[1].z));
				glEnd();
			}

		} else {
			if (((iDspFlgs & DSP_CONT) == 0) || (bD == TRUE)) {
				glColor3fv(cols[124]);
				glEnable(GL_TEXTURE_1D);
				glBegin(GL_LINES);
				glTexCoord1f(fCols[0]);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + d[0].x), (float) (pVertex[0]->Pt_Point->y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + d[0].z));
				glTexCoord1f(fCols[1]);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + d[1].x), (float) (pVertex[1]->Pt_Point->y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + d[1].z));
				glEnd();
				glDisable(GL_TEXTURE_1D);
			} else {
				glColor3fv(cols[iColour]);
				glBegin(GL_LINES);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + OffA.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + OffA.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + OffA.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + OffB.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + OffB.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + OffB.z + d[1].z));
				glEnd();
			}
		}
	} else {
		Selectable = 0;
	}
}

void E_Object2R::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	C3dVector d[2];
	int i;
	int ind;
	for (i = 0; i < 2; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	double dFS;
	S = ME->dScale;
	dFS = ME->dResFactor;
	ind = ME->iCVar;

	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 2; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		if ((iDspFlgs & DSP_LINE) > 0) {
			glColor3fv(cols[iColour]);
		} else {
			glColor3fv(cols[0]);
		}
		glLineWidth(gEL_SIZE);
		glBegin(GL_LINES);
		glVertex3f((float) (pVertex[0]->Pt_Point->x + OffA.x + d[0].x),
		           (float) (pVertex[0]->Pt_Point->y + OffA.y + d[0].y),
		           (float) (pVertex[0]->Pt_Point->z + OffA.z + d[0].z));
		glVertex3f((float) (pVertex[1]->Pt_Point->x + OffB.x + d[1].x),
		           (float) (pVertex[1]->Pt_Point->y + OffB.y + d[1].y),
		           (float) (pVertex[1]->Pt_Point->z + OffB.z + d[1].z));
		glEnd();
		C3dVector vCent;
		vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "E%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if (((iDspFlgs & DSP_RESLAB) == 0) && (pResV != NULL)) {
			sprintf_s(sLab, "%f", *pResV->GetAddress(ind));
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
		if ((iDspFlgs & DSP_THK) > 0) {
			if (pPr != NULL) {
				BSec* pS = pPr->GetSec();
				if (pS != NULL) {
					C3dMatrix TMat = GetBeamTform();
					pS->OglDrawW(iDspFlgs, TMat, d[0], d[1]);
				}
			}
		}
		if ((iDspFlgs & DSP_ELSYS) == 0) {
			glColor3fv(cols[iColour]);
			C3dMatrix mS = GetElSys();
			C3dVector vC = Get_Centroid();
			mS.Transpose();
			C3dVector vX = mS.GetColVec(1);
			C3dVector vY = mS.GetColVec(2);
			;
			C3dVector vZ = mS.GetColVec(3);
			;

			vX *= 0.5 * dS1;
			vY *= 0.5 * dS1;
			vZ *= 0.5 * dS1;
			vX += vC;
			vY += vC;
			vZ += vC;

			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vX.x, (float) vX.y, (float) vX.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vY.x, (float) vY.y, (float) vY.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glEnd();
			glRasterPos3f((float) vX.x, (float) vX.y, (float) vX.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPX);
			glRasterPos3f((float) vY.x, (float) vY.y, (float) vY.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPY);
			glRasterPos3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}
	} else {
		Selectable = 0;
	}
}

C3dVector E_Object2R::Get_Centroid() {
	C3dVector v1;
	C3dVector v2;
	C3dVector vC;
	v1 = pVertex[0]->Get_Centroid();
	v2 = pVertex[1]->Get_Centroid();
	v1 += OffA;
	v2 += OffB;
	vC = v2;
	vC += v1;
	vC *= 0.5;

	return (vC);
}

C3dVector E_Object2R::GetDir() {
	C3dVector vRet;
	C3dVector v1;
	C3dVector v2;
	v1 = pVertex[0]->GetCoords();
	v1 += OffA;
	v2 = pVertex[1]->GetCoords();
	v2 += OffB;
	vRet = v2;
	vRet -= v1;
	vRet.Normalize();
	return (vRet);
}

void E_Object2R::SetUpVec(C3dVector vIn) {
	vUp = vIn;
}

C3dMatrix E_Object2R::GetBeamTform() {
	C3dMatrix TRet;
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;

	vX = this->GetDir();
	;
	vY = vUp;
	vY.Normalize();
	vZ = vX.Cross(vY);
	vZ.Normalize();
	vY = vZ.Cross(vX);
	TRet.SetColVec(1, vZ);
	TRet.SetColVec(2, vY);
	TRet.SetColVec(3, vX);
	C3dVector vC = Get_Centroid();
	TRet.Translate2(vC.x, vC.y, vC.z);
	return (TRet);
}

C3dMatrix E_Object2R::GetBeamTformA() {
	C3dMatrix TRet;
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;

	vX = this->GetDir();
	;
	vY = vUp;
	vY.Normalize();
	vZ = vX.Cross(vY);
	vZ.Normalize();
	vY = vZ.Cross(vX);
	TRet.SetColVec(1, vZ);
	TRet.SetColVec(2, vY);
	TRet.SetColVec(3, vX);

	C3dVector vC = pVertex[0]->Get_Centroid();
	vC += OffA;
	TRet.Translate2(vC.x, vC.y, vC.z);
	return (TRet);
}

C3dMatrix E_Object2R::GetBeamTformB() {
	C3dMatrix TRet;
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;

	vX = this->GetDir();
	;
	vY = vUp;
	vY.Normalize();
	vZ = vX.Cross(vY);
	vZ.Normalize();
	vY = vZ.Cross(vX);
	TRet.SetColVec(1, vZ);
	TRet.SetColVec(2, vY);
	TRet.SetColVec(3, vX);
	C3dVector vC = pVertex[1]->Get_Centroid();
	vC += OffB;
	TRet.Translate2(vC.x, vC.y, vC.z);
	return (TRet);
}

C3dMatrix E_Object2R::GetElSys() {
	C3dMatrix vR;
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;

	vX.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	vX.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	vX.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;
	vY = vUp;
	vX.Normalize();
	vY.Normalize();
	vZ = vX.Cross(vY);
	vZ.Normalize();
	vY = vZ.Cross(vX);
	vR.SetColVec(1, vX);
	vR.SetColVec(2, vY);
	vR.SetColVec(3, vZ);
	vR.Transpose();
	return (vR);
}

void E_Object2R::Transform(C3dMatrix TMat) {
	TMat.ClearTranslations();
	vUp = TMat * vUp;
	OffA = TMat * OffA;
	OffB = TMat * OffB;
}

int E_Object2R::noDof() {
	return (6);
}

Mat E_Object2R::GetElNodalMass(PropTable* PropsT, MatTable* MatT) {
	int MID = -1;
	double Rho = 0;
	double A = 0;
	double L = 0;
	char S1[80];
	Property* pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
	}
	Material* pM = MatT->GetItem(MID);
	if (pS == NULL) {
		sprintf_s(S1, "ERROR PROPERTY NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	if (pM == NULL) {
		sprintf_s(S1, "ERROR MATERIAL NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	if ((pS != NULL) && (pM != NULL)) {
		if (pS->iType == 11) {
			PROD* pB = (PROD*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->A;
			Rho = pM1->dRHO;
		} else if (pS->iType == 5) {
			PBARL* pB = (PBARL*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->A;
			Rho = pM1->dRHO;
		} else if (pS->iType == 4) {
			PBAR* pB = (PBAR*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->dA;
			Rho = pM1->dRHO;
		} else {
			sprintf_s(S1, "ERROR INVALID PROPERTY FOR EL %i", iLabel);
			outtext1(S1);
		}
	} else {
		sprintf_s(S1, "ERROR UNABLE TO CALCULATE PROPERTIES FOR EL %i", iLabel);
		outtext1(S1);
	}
	// Lenght

	double dMass;
	C3dVector n1;
	C3dVector n2;
	n1 = this->pVertex[0]->GetCoords();
	n2 = this->pVertex[1]->GetCoords();
	L = n2.Dist(n1);
	dMass = A * L * Rho / 2;
	Mat FS(iNoNodes, 1);
	*FS.mn(1, 1) = dMass;
	*FS.mn(2, 1) = dMass;
	return (FS);
}

Mat E_Object2R::GetThermalStrainMat3d(PropTable* PropsT, MatTable* MatT, double dT) {
	int MID = -1;
	double CTE = 0;
	double A = 0;
	double L = 0;
	double E = 0;
	char S1[80];
	Property* pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
	}
	Material* pM = MatT->GetItem(MID);
	if (pS == NULL) {
		sprintf_s(S1, "ERROR PROPERTY NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	if (pM == NULL) {
		sprintf_s(S1, "ERROR MATERIAL NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	if ((pS != NULL) && (pM != NULL)) {
		if (pS->iType == 11) {
			PROD* pB = (PROD*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->A;
			E = pM1->dE;
			CTE = pM1->GetCTE();
		} else if (pS->iType == 5) {
			PBARL* pB = (PBARL*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->A;
			E = pM1->dE;
			CTE = pM1->GetCTE();
		} else if (pS->iType == 4) {
			PBAR* pB = (PBAR*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->dA;
			E = pM1->dE;
			CTE = pM1->GetCTE();
		} else {
			sprintf_s(S1, "ERROR INVALID PROPERTY FOR EL %i", iLabel);
			outtext1(S1);
		}
	} else {
		sprintf_s(S1, "ERROR UNABLE TO CALCULATE PROPERTIES FOR EL %i", iLabel);
		outtext1(S1);
	}
	double dF;
	C3dVector n1;
	C3dVector n2;
	n1 = this->pVertex[0]->GetCoords();
	n2 = this->pVertex[1]->GetCoords();
	L = n2.Dist(n1);
	dF = A * E * CTE * dT;
	Mat FS(iNoNodes, 1);
	*FS.mn(1, 1) = -dF;
	*FS.mn(2, 1) = dF;
	dTemp = dF;
	return (FS);
}

Mat E_Object2R::GetThermMat(PropTable* PropsT, MatTable* MatT) {
	char S1[80];
	double A;
	double K;
	int MID;
	int iDof = 1;
	Property* pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
	}
	Material* pM = MatT->GetItem(MID);
	if ((pS != NULL) && (pM != NULL)) {
		if (pS->iType == 11) {
			PROD* pB = (PROD*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->A;
			K = pM1->dk;
		} else {
			sprintf_s(S1, "ERROR INVALID PROPERTY FOR EL %i", iLabel);
			outtext1(S1);
		}
	} else {
		sprintf_s(S1, "ERROR UNABLE TO CALCULATE PROPERTIES FOR EL %i", iLabel);
		outtext1(S1);
	}

	Mat KM(iDof * iNoNodes, iDof * iNoNodes);
	C3dVector p1;
	C3dVector p2;
	double l;
	p1 = pVertex[0]->GetCoords();
	p2 = pVertex[1]->GetCoords();
	p2 -= p1;
	l = p2.Mag();
	*KM.mn(1, 1) = K * A / l;
	*KM.mn(2, 1) = -K * A / l;
	*KM.mn(1, 2) = -K * A / l;
	*KM.mn(2, 2) = K * A / l;
	// KM.diag();
	return (KM);
}

Mat E_Object2R::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL& bErr) {
	double ea = 10000;
	double eal = 10000;
	double jg = 10000;
	double jgl = 10000;
	int MID = -1;
	char S1[80];
	Mat KE(12, 12);
	Mat KEdum;
	Mat t;
	Mat tt;
	C3dVector vN1, vN2;
	KE.MakeZero();

	Property* pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
	}
	Material* pM = MatT->GetItem(MID);
	if (pS == NULL) {
		sprintf_s(S1, "ERROR PROPERTY NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	if (pM == NULL) {
		sprintf_s(S1, "ERROR MATERIAL NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	if ((pS != NULL) && (pM != NULL)) {
		if (pS->iType == 11) {
			PROD* pB = (PROD*) pS;
			MAT1* pM1 = (MAT1*) pM;
			ea = pB->A * pM1->dE;
			jg = pB->J * pM1->dG;
		} else {
			sprintf_s(S1, "ERROR INVALID PROPERTY FOR EL %i", iLabel);
			outtext1(S1);
		}
	} else {
		sprintf_s(S1, "ERROR UNABLE TO CALCULATE PROPERTIES FOR EL %i", iLabel);
		outtext1(S1);
	}

	vN1 = pVertex[0]->Get_Centroid();
	vN2 = pVertex[1]->Get_Centroid();
	vN2 -= vN1;
	double ell = vN2.Mag(); // Element length

	if (ell > 0) {
		eal = ea / ell;
		jgl = jg / ell;
	}
	*KE.mn(1, 1) = eal;
	*KE.mn(1, 7) = -eal;
	*KE.mn(7, 1) = *KE.mn(1, 7);
	*KE.mn(4, 4) = jgl;
	*KE.mn(4, 10) = -jgl;
	*KE.mn(10, 4) = *KE.mn(4, 10);
	*KE.mn(7, 7) = eal;
	*KE.mn(10, 10) = jgl;
	// TRANSFORM KE TO GLOBAL
	CoordSys* pCSYS = nullptr;

	C3dMatrix r = this->GetElSys();
	t = KEToKGTransform2(r);
	tt = t;
	tt.Transpose();
	KEdum = KE * t;
	KE = tt * KEdum;

	return (KE);
}

Vec<int> E_Object2R::GetSteerVec3d() {
	Vec<int> V(2 * 6);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[0]->dof[3];
	*V.nn(5) = pVertex[0]->dof[4];
	*V.nn(6) = pVertex[0]->dof[5];
	*V.nn(7) = pVertex[1]->dof[0];
	*V.nn(8) = pVertex[1]->dof[1];
	*V.nn(9) = pVertex[1]->dof[2];
	*V.nn(10) = pVertex[1]->dof[3];
	*V.nn(11) = pVertex[1]->dof[4];
	*V.nn(12) = pVertex[1]->dof[5];
	return (V);
}

Vec<int> E_Object2R::GetSteerVec1d() {
	Vec<int> V(2 * 1);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[1]->dof[0];
	return (V);
}

void E_Object2R::SetSec(int iA, int iB, int iC) {
	A = iA;
	B = iB;
	C = iC;
}

void E_Object2R::ExportNAS(FILE* pFile) {
	C3dMatrix TMat;
	if (iType == 11) {
		fprintf(pFile, "%8s%8i%8i%8i%8i\n", "CROD    ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel);
	}
}

CString E_Object2R::ToString() {
	CString sRT = "";
	char S1[80] = "";
	if (iType == 11) {
		sprintf_s(S1, "%8s%8i%8i%8i%8i\n", "CROD    ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel);
	}
	sRT = S1;
	return (sRT);
}

void E_Object2R::ExportUNV(FILE* pFile) {
	int i;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	if ((iType == 21) || (iType == 22)) {
		fprintf(pFile, "%10i%10i%10i\n", A, B, C);
	}
	for (i = 0; i < iNoNodes; i++) {
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
	}
	fprintf(pFile, "\n", "");
}

void E_Object2R::ExportUPVecs(FILE* pFile) {
	double dA1;
	C3dVector Vz;
	C3dVector Vy;
	C3dVector Vx;
	C3dVector Vu;
	C3dMatrix M;
	if (A == 0) {
		M.MakeUnit();
		Vu.Set(vUp.x, vUp.y, vUp.z);
		Vz.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
		Vz.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
		Vz.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;
		Vz.Normalize();
		Vy.Set(0, 0, 1);
		double dDot;
		dDot = abs(Vy.Dot(Vz));
		if (dDot == 1) {
			Vx.Set(0, 1, 0);
			Vy = Vz.Cross(Vx);
			Vy.Normalize();
			Vx = Vy.Cross(Vz);
			Vx.Normalize();
		} else {
			Vx = Vy.Cross(Vz);
			Vx.Normalize();
			Vy = Vz.Cross(Vx);
			Vy.Normalize();
		}
		M.SetColVec(1, Vx);
		M.SetColVec(2, Vy);
		M.SetColVec(3, Vz);
		M.Transpose();
		Vu = M.Mult(Vu);
		if (Vu.y != 0) {
			dA1 = atan2(Vu.x, Vu.y);
			dA1 = dA1 * 180 / 3.1415926535897932384626433832795;
		} else {
			dA1 = 0;
		}
		dA1 += 90.0;
		fprintf(pFile, "%10i%10i\n", iLabel, 21);
		fprintf(pFile, "%10i%10i%10i%10i%10i\n", 8, 0, 0, 0, 0);
		fprintf(pFile, "%15.6E%15.6E%15.6E\n", dA1, 0.0, 0.0);
	} else {
		fprintf(pFile, "%10i%10i\n", iLabel, 21);
		fprintf(pFile, "%10i%10i%10i%10i%10i\n", 0, 1, 0, 0, 0);
	}
}

CString E_Object2R::GetName() {
	return ("Rod (CROD)");
}

//----------------------------------------------------------------------------
//    CBEAM E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object2B, CObject)

E_Object2B::E_Object2B() {
	G_Object();
	iDOFA = 0;
	iDOFB = 0;
	iONID = -1;
	iType = 21;
	this->iNoNodes = 2;
}

G_Object* E_Object2B::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object2B* gret = new E_Object2B;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->vUp = vUp;
	gret->OffA = OffA;
	gret->OffB = OffB;
	gret->A = A;
	gret->B = B;
	gret->C = C;
	gret->iDOFA = iDOFA;
	gret->iDOFB = iDOFB;
	gret->iONID = iONID;
	gret->pPr = pPr;
	gret->pParent = MESH;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object2B::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object2B* gret = new E_Object2B;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	gret->vUp = vUp;
	gret->OffA = OffA;
	gret->OffB = OffB;
	Node* pT = Source->GetNode(iONID);
	if (pT != NULL) {
		EInd = Source->GetNodeInd(pT);
		gret->iONID = Target->pNodes[iSInd + EInd]->iLabel;
	} else {
		gret->iONID = -1;
	}
	Node* nA = Source->GetNode(A);
	if (nA != NULL) {
		EInd = Source->GetNodeInd(nA);
		gret->A = Target->pNodes[EInd + iSInd]->iLabel; // Orientation Node
	} else {
		gret->A = A;
	}
	gret->B = B;
	gret->C = C;
	gret->iDOFA = iDOFA;
	gret->iDOFB = iDOFB;
	gret->pPr = NULL;
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object2B::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object2B* gret = new E_Object2B;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->vUp = vUp;
	gret->OffA = OffA;
	gret->OffB = OffB;
	gret->A = A;
	gret->B = B;
	gret->C = C;
	gret->iDOFA = iDOFA;
	gret->iDOFB = iDOFB;
	gret->pPr = pPr;
	gret->pParent = Parrent;
	gret->pResV = NULL;
	return (gret);
}

CString E_Object2B::ToString() {
	char S[80] = "";
	CString src = "";
	C3dMatrix TMat;

	if (iType == 21) {
		sprintf_s(S, "%8s%8i%8i%8i%8i", "CBAR    ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel);
		src = S;
	} else if (iType == 22) {
		sprintf_s(S, "%8s%8i%8i%8i%8i", "CBEAM   ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel);
		src = S;
	}
	if (iONID > 0) {
		sprintf_s(S, "%8i\n", iONID);
		src += S;
	} else {
		TMat.MakeUnit();
		if (pVertex[0]->OutSys > 0) {
			ME_Object* pM = (ME_Object*) this->pParent;
			CoordSys* pSys = pM->GetSys(pVertex[0]->OutSys);
			if (pSys != NULL) {
				TMat = pSys->GetTMat();
				TMat.Transpose();
			}
		}
		C3dVector vU;
		vU = TMat * vUp;
		sprintf_s(S, "%8s%8s%8s\n", e8(vU.x), e8(vU.y), e8(vU.z));
		src += S;
	}
	sprintf_s(S, "%8s%8s%8s", "        ", GetDOFString(iDOFA), GetDOFString(iDOFB));
	src += S;
	TMat.MakeUnit();
	if (pVertex[0]->OutSys > 0) {
		ME_Object* pM = (ME_Object*) this->pParent;
		CoordSys* pSys = pM->GetSys(pVertex[0]->OutSys);
		if (pSys != NULL) {
			TMat = pSys->GetTMat();
			TMat.Transpose();
		}
	}
	C3dVector vD1;
	vD1 = TMat * OffA;
	sprintf_s(S, "%8s%8s%8s", e8(vD1.x), e8(vD1.y), e8(vD1.z));
	src += S;
	TMat.MakeUnit();
	if (pVertex[0]->OutSys > 0) {
		ME_Object* pM = (ME_Object*) this->pParent;
		CoordSys* pSys = pM->GetSys(pVertex[1]->OutSys);
		if (pSys != NULL) {
			TMat = pSys->GetTMat();
			TMat.Transpose();
		}
	}
	C3dVector vD2;
	vD2 = TMat * OffB;
	sprintf_s(S, "%8s%8s%8s\n", e8(vD2.x), e8(vD2.y), e8(vD2.z));
	src += S;
	return (src);
}

void E_Object2B::ExportNAS(FILE* pFile) {
	C3dMatrix TMat;
	if (iLabel == 29007)
		iLabel = iLabel;
	if (iType == 21) {
		fprintf(pFile, "%8s%8i%8i%8i%8i", "CBAR    ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel);
	} else if (iType == 22) {
		fprintf(pFile, "%8s%8i%8i%8i%8i", "CBEAM   ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel);
	}
	if (iONID > 0) {
		fprintf(pFile, "%8i\n", iONID);
	} else {
		TMat.MakeUnit();
		if (pVertex[0]->OutSys > 0) {
			ME_Object* pM = (ME_Object*) this->pParent;
			CoordSys* pSys = pM->GetSys(pVertex[0]->OutSys);
			if (pSys != NULL) {
				TMat = pSys->GetTMat();
				TMat.Transpose();
			}
		}
		C3dVector vU;
		vU = TMat * vUp;
		fprintf(pFile, "%8s%8s%8s\n", e8(vU.x), e8(vU.y), e8(vU.z));
	}
	fprintf(pFile, "%8s%8s%8s", "        ", GetDOFString(iDOFA), GetDOFString(iDOFB));

	TMat.MakeUnit();
	if (pVertex[0]->OutSys > 0) {
		ME_Object* pM = (ME_Object*) this->pParent;
		CoordSys* pSys = pM->GetSys(pVertex[0]->OutSys);
		if (pSys != NULL) {
			TMat = pSys->GetTMat();
			TMat.Transpose();
		}
	}
	C3dVector vD1;
	vD1 = TMat * OffA;
	fprintf(pFile, "%8s%8s%8s", e8(vD1.x), e8(vD1.y), e8(vD1.z));
	TMat.MakeUnit();
	if (pVertex[0]->OutSys > 0) {
		ME_Object* pM = (ME_Object*) this->pParent;
		CoordSys* pSys = pM->GetSys(pVertex[1]->OutSys);
		if (pSys != NULL) {
			TMat = pSys->GetTMat();
			TMat.Transpose();
		}
	}
	C3dVector vD2;
	vD2 = TMat * OffB;
	fprintf(pFile, "%8s%8s%8s\n", e8(vD2.x), e8(vD2.y), e8(vD2.z));
}

int E_Object2B::noDof() {
	return (6);
}

BOOL E_Object2B::HasOffsets() {
	BOOL brc = FALSE;
	if ((OffA.Mag() > 0) || (OffB.Mag() > 0))
		brc = true;
	return (brc);
}

// to be superceeded
BOOL E_Object2B::GetOffset(PropTable* PropsT, int iNode, C3dVector& vOff) {
	C3dVector vO;
	BOOL brc = FALSE;
	if (iNode == 0) // OffA
		vOff = OffA;
	else if (iNode == 1)
		vOff = OffB;
	if (vOff.Mag() > 0)
		brc = TRUE;
	return (brc);
}

Mat E_Object2B::GetThermMat(PropTable* PropsT, MatTable* MatT) {
	char S1[80];
	double A;
	double K;
	int MID;
	int iDof = 1;
	Property* pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
	}
	Material* pM = MatT->GetItem(MID);
	if ((pS != NULL) && (pM != NULL)) {
		if (pS->iType == 11) {
			PROD* pB = (PROD*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->A;
			K = pM1->dk;
		} else if (pS->iType == 5) {
			PBARL* pB = (PBARL*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->A;
			K = pM1->dk;
		} else if (pS->iType == 4) {
			PBAR* pB = (PBAR*) pS;
			MAT1* pM1 = (MAT1*) pM;
			A = pB->dA;
			K = pM1->dk;
		} else {
			sprintf_s(S1, "ERROR INVALID PROPERTY FOR EL %i", iLabel);
			outtext1(S1);
		}
	} else {
		sprintf_s(S1, "ERROR UNABLE TO CALCULATE PROPERTIES FOR EL %i", iLabel);
		outtext1(S1);
	}

	Mat KM(iDof * iNoNodes, iDof * iNoNodes);
	C3dVector p1;
	C3dVector p2;
	double l;
	p1 = pVertex[0]->GetCoords();
	p2 = pVertex[1]->GetCoords();
	p2 -= p1;
	l = p2.Mag();
	*KM.mn(1, 1) = K * A / l;
	*KM.mn(2, 1) = -K * A / l;
	*KM.mn(1, 2) = -K * A / l;
	*KM.mn(2, 2) = K * A / l;
	// KM.diag();
	return (KM);
}

Mat E_Object2B::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL& bErr) {
	BOOL AX = FALSE;
	BOOL BX = FALSE;
	Mat KM(12, 12);
	Mat t;
	Mat tt;
	KM.MakeZero();
	t.MakeZero();
	tt.MakeZero();
	double ea = 50000;
	double eiy = 10000;
	double eiz = 10000;
	double gj = 10000;
	C3dVector vN1, vN2;
	double a1, a2, a3, a4, a5, a6, a7, a8;
	double ell;
	int MID = -1;
	char S1[80];
	Property* pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
	}
	Material* pM = MatT->GetItem(MID);
	if (bOpt == 2) {
		// for psuedo rigid element
		CalcDefStiffProps(ea, eiy, eiz, gj);
	} else {
		if (pS == NULL) {
			sprintf_s(S1, "ERROR: PROPERTY NOT FOUND FOR EL %i", iLabel);
			outtext1(S1);
		}
		if (pM == NULL) {
			sprintf_s(S1, "ERROR: MATERIAL NOT FOUND FOR EL %i", iLabel);
			outtext1(S1);
		}
		if ((pS != NULL) && (pM != NULL)) {
			if (pS->iType == 5) {
				PBARL* pB = (PBARL*) pS;
				MAT1* pM1 = (MAT1*) pM;
				ea = pB->A * pM1->dE;
				eiy = pB->Iyy * pM1->dE;
				eiz = pB->Izz * pM1->dE;
				double g;
				g = pM1->dE / (2 * (1 + pM1->dNU));
				gj = g * pB->J;
			} else if (pS->iType == 4) {
				PBAR* pB = (PBAR*) pS;
				MAT1* pM1 = (MAT1*) pM;
				ea = pB->dA * pM1->dE;
				eiy = pB->dI1 * pM1->dE;
				eiz = pB->dI2 * pM1->dE;
				double g;
				g = pM1->dE / (2 * (1 + pM1->dNU));
				gj = g * pB->dJ;
			} else {
				sprintf_s(S1, "ERROR: INVALID PROPERTY FOR EL %i", iLabel);
				outtext1(S1);
			}
		} else {
			sprintf_s(S1, "ERROR: UNABLE TO CALCULATE PROPERTIES FOR EL %i", iLabel);
			outtext1(S1);
		}
	}
	// Get nodal coords
	vN1 = pVertex[0]->Get_Centroid();
	vN2 = pVertex[1]->Get_Centroid();
	vN2 -= vN1;
	ell = vN2.Mag(); // Element length

	a1 = ea / ell;
	a2 = 12.0 * eiz / (ell * ell * ell);
	a3 = 12.0 * eiy / (ell * ell * ell);
	a4 = 6.0 * eiz / (ell * ell);
	a5 = 6.0 * eiy / (ell * ell);
	a6 = 4.0 * eiz / ell;
	a7 = 4.0 * eiy / ell;
	a8 = gj / ell;

	*KM.mn(1, 1) = a1;
	*KM.mn(7, 7) = a1;
	*KM.mn(1, 7) = -a1;
	*KM.mn(7, 1) = -a1;

	*KM.mn(2, 2) = a2;
	*KM.mn(8, 8) = a2;
	*KM.mn(2, 8) = -a2;
	*KM.mn(8, 2) = -a2;

	*KM.mn(3, 3) = a3;
	*KM.mn(9, 9) = a3;
	*KM.mn(3, 9) = -a3;
	*KM.mn(9, 3) = -a3;

	*KM.mn(4, 4) = a8;
	*KM.mn(10, 10) = a8;
	*KM.mn(4, 10) = -a8;
	*KM.mn(10, 4) = -a8;

	*KM.mn(5, 5) = a7;
	*KM.mn(11, 11) = a7;
	*KM.mn(5, 11) = 0.5 * a7;
	*KM.mn(11, 5) = 0.5 * a7;

	*KM.mn(6, 6) = a6;
	*KM.mn(12, 12) = a6;
	*KM.mn(6, 12) = 0.5 * a6;
	*KM.mn(12, 6) = 0.5 * a6;

	*KM.mn(2, 6) = a4;
	*KM.mn(6, 2) = a4;
	*KM.mn(2, 12) = a4;
	*KM.mn(12, 2) = a4;

	*KM.mn(6, 8) = -a4;
	*KM.mn(8, 6) = -a4;
	*KM.mn(8, 12) = -a4;
	*KM.mn(12, 8) = -a4;

	*KM.mn(5, 9) = a5;
	*KM.mn(9, 5) = a5;
	*KM.mn(9, 11) = a5;
	*KM.mn(11, 9) = a5;

	*KM.mn(3, 5) = -a5;
	*KM.mn(5, 3) = -a5;
	*KM.mn(3, 11) = -a5;
	*KM.mn(11, 3) = -a5;
	//***************************************************************
	//                    PROCESS PIN FLAGS
	//***************************************************************
	if ((iDOFA > 0) || (iDOFB > 0))
		PinFlgsToKE(KM);
	//***************************************************************
	//                  TRANSFORM KE TO GLOBAL
	//***************************************************************
	t = KEToKGTransform();
	tt = t;
	tt.Transpose();
	Mat Kmt;
	Mat tKmt;
	Kmt = KM * t;
	tKmt = tt * Kmt;
	KM = tKmt;
	//***************************************************************
	//                   OFFSETS TO GLOBAL MAT
	//***************************************************************
	if (bOpt == FALSE) {
		if (HasOffsets()) {
			Mat off;
			Mat offT;
			Mat dum1;
			OffsetsToKG(PropsT, off);
			offT = off;
			offT.Transpose();
			dum1 = KM * off;
			KM.clear();
			KM = offT * dum1;
			dum1.clear();
			off.clear();
			offT.clear();
		}
	}

	t.clear();
	tt.clear();
	Kmt.clear();
	tKmt.clear();

	return (KM);
}

Vec<int> E_Object2B::GetSteerVec3d() {
	Vec<int> V(2 * 6);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[0]->dof[3];
	*V.nn(5) = pVertex[0]->dof[4];
	*V.nn(6) = pVertex[0]->dof[5];
	*V.nn(7) = pVertex[1]->dof[0];
	*V.nn(8) = pVertex[1]->dof[1];
	*V.nn(9) = pVertex[1]->dof[2];
	*V.nn(10) = pVertex[1]->dof[3];
	*V.nn(11) = pVertex[1]->dof[4];
	*V.nn(12) = pVertex[1]->dof[5];
	return (V);
}

Vec<int> E_Object2B::GetSteerVec1d() {
	Vec<int> V(2 * 1);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[1]->dof[0];
	return (V);
}

CString E_Object2B::GetName() {
	return ("Beam (CBAR)");
}

int E_Object2B::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "PID";
	iNo++;
	sVar[iNo] = "CID";
	iNo++;
	sVar[iNo] = "N1";
	iNo++;
	sVar[iNo] = "N2";
	iNo++;
	sVar[iNo] = "RELEASE END A";
	iNo++;
	sVar[iNo] = "RELEASE END B";
	iNo++;
	return (iNo);
}

int E_Object2B::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", PID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iCSYS);
	sVar[iNo] = S1;
	iNo++;

	sprintf_s(S1, "%i", pVertex[0]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[1]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sVar[iNo] = GetDOFString(iDOFA);
	iNo++;
	sVar[iNo] = GetDOFString(iDOFB);
	iNo++;
	return (iNo);
}

void E_Object2B::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Node* pN;
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	PID = atoi(sVar[1]);
	iCSYS = atoi(sVar[2]);
	int N1 = atof(sVar[3]);
	int N2 = atof(sVar[4]);
	if (pVertex[0]->iLabel != N1) {
		pN = pMe->GetNode(N1);
		if (pN != NULL)
			pVertex[0] = pN;
	}
	if (pVertex[1]->iLabel != N2) {
		pN = pMe->GetNode(N2);
		if (pN != NULL)
			pVertex[1] = pN;
	}
	iDOFA = GetDOFInt(sVar[5]);
	iDOFB = GetDOFInt(sVar[6]);
}

void E_Object2B::CalcDefStiffProps(double& ea, double& eiy, double& eiz, double& gj) {
	double DEF_G;
	double Area = 1;
	double R = gSTIFF_BDIA / 2;
	double Izz, Iyy, J;
	DEF_G = gDEF_E / (2 * (1 + gDEF_V));
	Area = Pi * R * R;

	Izz = Pi * R * R * R * R / 4;
	Iyy = Izz;
	J = Pi * R * R * R * R / 2;
	ea = gDEF_E * Area * gRIGID_MULTIPLIER;
	eiz = gDEF_E * Izz * gRIGID_MULTIPLIER;
	eiy = gDEF_E * Iyy * gRIGID_MULTIPLIER;
	gj = DEF_G * J * gRIGID_MULTIPLIER;
}

IMPLEMENT_DYNAMIC(E_Object3, CObject)
//----------------------------------------------------------------------------
//    E L E M E N T   O B J E C T
//-
E_Object3::~E_Object3() {
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	pVertex[2] = NULL;
}

E_Object3::E_Object3() {
	G_Object();
	this->iNoNodes = 3;
	this->iType = 91;
	this->pParent = NULL;
	iNoRemesh = 0; // tempoary for tet mesh gen debug.
}

void E_Object3::Create(Node* pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                       int inMCys, double inMAng, G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	iMCys = inMCys;
	MAng = inMAng;
	int i = 0;
	for (i = 0; i < 3; i++) {
		pVertex[i] = pInVertex[i];
	}
	dZOFFS = 0;
}

void E_Object3::Reverse() {
	Node* pT[8];
	pT[0] = pVertex[0];
	pT[1] = pVertex[1];
	pT[2] = pVertex[2];
	pVertex[0] = pT[0];
	pVertex[1] = pT[2];
	pVertex[2] = pT[1];
}

void E_Object3::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

BOOL E_Object3::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_Object3::GetKMat() {
	// No integeration needed for
	// this element as constant strain

	// Bmem[0][0] = Y2 - Y3;
	// Bmem[0][1] = 0;
	// Bmem[0][2] = Y3 - Y1;
	// Bmem[0][3] = 0;
	// Bmem[0][4] = Y1 - Y2;
	// Bmem[0][5] = 0;

	// Bmem[1][0] = 0;
	// Bmem[1][1] = X3 - X2;
	// Bmem[1][2] = 0;
	// Bmem[1][3] = X1 - X3;
	// Bmem[1][4] = 0;
	// Bmem[1][5] = X2 - X1;

	// Bmem[2][0] = X3 - X2;
	// Bmem[2][1] = Y2 - Y3;
	// Bmem[2][2] = X1 - X3;
	// Bmem[2][3] = Y3 - Y1;
	// Bmem[2][4] = X2 - X1;
	// Bmem[2][5] = Y1 - Y2;
}

void E_Object3::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		ar << iMCys;
		ar << MAng;
		ar << dZOFFS;
		ar << pVertex[0]->iLabel;
		ar << pVertex[1]->iLabel;
		ar << pVertex[2]->iLabel;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		ar >> iMCys;
		ar >> MAng;
		ar >> dZOFFS;
		ar >> iNd;
		pVertex[0] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[1] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[2] = MESH->GetNode(iNd);
		pPr = NULL;
	}
}

void E_Object3::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s", ToString());
}

void E_Object3::ExportUNV(FILE* pFile) {
	int i;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	for (i = 0; i < iNoNodes; i++) {
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
	}
	fprintf(pFile, "\n", "");
}

G_Object* E_Object3::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object3* gret = new E_Object3;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->pVertex[2] = MESH->GetNode(pVertex[2]->iLabel);
	gret->pParent = MESH;
	gret->iMCys = iMCys;
	gret->MAng = MAng;
	gret->dZOFFS = dZOFFS;
	gret->pPr = pPr;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object3::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object3* gret = new E_Object3;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;

	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[2]);
	gret->pVertex[2] = Target->pNodes[EInd + iSInd];

	gret->pParent = Target;
	gret->iMCys = iMCys;
	gret->MAng = MAng;
	gret->dZOFFS = dZOFFS;
	gret->pPr = NULL;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object3::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object3* gret = new E_Object3;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->pVertex[2] = pInVertex[2];
	gret->pParent = Parrent;
	gret->iMCys = iMCys;
	gret->MAng = MAng;
	gret->dZOFFS = dZOFFS;
	gret->pPr = pPr;
	gret->pResV = NULL;
	return (gret);
}

// Draw Object line
void E_Object3::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
}

int E_Object3::GetLinkList(eEdge* Links[200]) {
	Links[0] = new eEdge;
	Links[0]->pParent = this;
	Links[0]->pVertex[0] = pVertex[0];
	Links[0]->pVertex[1] = pVertex[1];
	Links[0]->iColour = iColour;
	Links[1] = new eEdge;
	Links[1]->pParent = this;
	Links[1]->pVertex[0] = pVertex[1];
	Links[1]->pVertex[1] = pVertex[2];
	Links[1]->iColour = iColour;
	Links[2] = new eEdge;
	Links[2]->pParent = this;
	Links[2]->pVertex[0] = pVertex[2];
	Links[2]->pVertex[1] = pVertex[0];
	Links[2]->iColour = iColour;
	return (3);
}

G_Object* E_Object3::GetNode(int i) {
	return (pVertex[i]);
}

void E_Object3::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	C3dVector d[3];
	int i;
	int ind;
	for (i = 0; i < 3; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;

	S = ME->dScale;
	double dFS;
	dFS = ME->dResFactor;
	ind = ME->iCVar;
	glLineWidth(gEL_SIZE);
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 3; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		if ((iDspFlgs & DSP_ELEMENTS) > 0) {
			if ((iDspFlgs & DSP_LINE) > 0) {
				glColor3fv(cols[iColour]);
			} else {
				glColor3fv(cols[0]);
			}
			C3dVector vN;
			C3dVector vOff;
			vN = Get_Normal();
			// Need to calculate the offsets here
			double dt = 0;
			double dPCompOff = 0;
			if (pPr != NULL) {
				dt = pPr->GetThk();
				dt *= 0.5;
				if (pPr->iType == 2) {
					PCOMP* pPCOMP = (PCOMP*) pPr;
					dPCompOff = pPCOMP->dZ0 + dt;
				} else if (pPr->iType == 222) {
					PCOMPG* pPCOMP = (PCOMPG*) pPr;
					dPCompOff = pPCOMP->dZ0 + dt;
				}
			}
			if (((iDspFlgs & DSP_OFF) > 0) && (dZOFFS != DBL_MAX)) {
				vOff = vN;
				vOff *= dZOFFS + dPCompOff;
			} else {
				vOff *= 0;
			}
			vN *= dt;
			if ((iDspFlgs & DSP_THK) > 0) {
				glBegin(GL_LINES);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));

				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));

				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glEnd();
			} else {
				vN *= 0;
				glBegin(GL_LINES);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glEnd();
			}
			C3dVector vCent;
			vCent = Get_Centroid();
			// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
			if (gLBL_DSP_TRG)
				bDrawLab = FALSE;
			if (bDrawLab == TRUE)
			// Esp_Mod_Labels_4_27_2025_End
			{
				sprintf_s(sLab, "E%i", iLabel);
				OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
			}
			if (((iDspFlgs & DSP_RESLAB) == 0) && (pResV != NULL)) {
				sprintf_s(sLab, "%f", *pResV->GetAddress(ind));
				OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
			}
		}
		if ((iDspFlgs & DSP_ELSYS) == 0) {
			glColor3fv(cols[iColour]);
			C3dMatrix mS = GetElSys();
			C3dVector vC = Get_Centroid();
			mS.Transpose();
			C3dVector vX = mS.GetColVec(1);
			C3dVector vY = mS.GetColVec(2);
			;
			C3dVector vZ = mS.GetColVec(3);
			;

			vX *= 0.5 * dS1;
			vY *= 0.5 * dS1;
			vZ *= 0.5 * dS1;
			vX += vC;
			vY += vC;
			vZ += vC;

			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vX.x, (float) vX.y, (float) vX.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vY.x, (float) vY.y, (float) vY.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glEnd();
			glRasterPos3f((float) vX.x, (float) vX.y, (float) vX.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPX);
			glRasterPos3f((float) vY.x, (float) vY.y, (float) vY.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPY);
			glRasterPos3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}
		if ((iDspFlgs & DSP_MATL) == 0) {
			C3dMatrix mS = GetElSys();
			C3dMatrix mR;
			C3dVector vD;
			C3dVector vC;
			vC = Get_Centroid();
			vD = GetFirstEdge();
			if (this->iMCys == -1) {
				vD = mS * vD;
				mR.Rotate(0, 0, MAng);
				vD = mR * vD;
				mS.Transpose();
				vD = mS * vD;
				vD.Normalize();
				vD *= 0.5 * dS1;
				vD += vC;
			} else {
				C3dVector vSys;
				if (this->pParent != NULL) {
					ME_Object* ME = (ME_Object*) pParent;
					CoordSys* pS = ME->GetSys(this->iMCys);
					if (pS != NULL) {
						vSys = pS->mOrientMat.GetColVec(1);
						vD = mS * vSys;
						vD.z = 0;
						mS.Transpose();
						vD = mS * vD;
						vD.Normalize();
						vD *= 0.5 * dS1;
						vD += vC;
					}
				}
			}
			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vD.x, (float) vD.y, (float) vD.z);
			glEnd();
		}
	} else {
		Selectable = 0;
	}
}

void E_Object3::OglDraw(int iDspFlgs, double dS1, double dS2) {
	C3dVector d[3];
	int i;
	for (i = 0; i < 3; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS;
	dFS = ME->dResFactor;
	glLineWidth(gEL_SIZE);
	BOOL bD = FALSE;
	float fCols[3] = {0, 0, 0};
	int iVar;
	iVar = ME->iCVar;
	// Nodal data
	if ((pVertex[0]->pResV != NULL) &&
	    (pVertex[1]->pResV != NULL) &&
	    (pVertex[2]->pResV != NULL)) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pVertex[0]->pResV->GetAddress(iVar) * dFS);
		fCols[1] = GetContourCol(*pVertex[1]->pResV->GetAddress(iVar) * dFS);
		fCols[2] = GetContourCol(*pVertex[2]->pResV->GetAddress(iVar) * dFS);
	}
	if (pResV != NULL) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pResV->GetAddress(iVar) * dFS);
		fCols[1] = fCols[0];
		fCols[2] = fCols[0];
	}

	C3dVector v1;
	C3dVector v2;
	C3dVector Vn;

	C3dVector vN;
	C3dVector vOff;
	vN = Get_Normal();
	double dt = 0;
	double dPCompOff = 0;
	if (pPr != NULL) {
		dt = pPr->GetThk();
		dt *= 0.5;
		if (pPr->iType == 2) {
			PCOMP* pPCOMP = (PCOMP*) pPr;
			dPCompOff = pPCOMP->dZ0 + dt;
		} else if (pPr->iType == 222) {
			PCOMPG* pPCOMP = (PCOMPG*) pPr;
			dPCompOff = pPCOMP->dZ0 + dt;
		}
	}
	if (((iDspFlgs & DSP_OFF) > 0) && (dZOFFS != DBL_MAX)) {
		vOff = vN;
		vOff *= dZOFFS + dPCompOff;
	} else {
		vOff *= 0;
	}

	vN *= dt;
	Vn = Get_Normal();
	Vn.Normalize();

	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 3; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		glColor3fv(cols[iColour]);
		if (((iDspFlgs & DSP_CONT) > 0) || (bD == FALSE)) {
			if ((iDspFlgs & DSP_THK) > 0) {
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glEnd();

				glBegin(GL_POLYGON);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glEnd();

				glBegin(GL_POLYGON);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glEnd();

				glBegin(GL_POLYGON);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glEnd();
			} else {
				vN *= 0;
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glEnd();
			}
		} else {
			vN *= 0;

			if (bD) {
				glColor3fv(cols[124]);
				glEnable(GL_TEXTURE_1D);
				glBegin(GL_POLYGON);
				glTexCoord1f(fCols[0]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glTexCoord1f(fCols[1]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glTexCoord1f(fCols[2]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glEnd();
				glDisable(GL_TEXTURE_1D);
			}
		}
	} else {
		Selectable = 0;
	}
}

int E_Object3::GetfaceList(eFace* Faces[6]) {
	Faces[0] = new eFace();
	Faces[0]->pParent = this;
	Faces[0]->pVertex[0] = pVertex[0];
	Faces[0]->pVertex[1] = pVertex[1];
	Faces[0]->pVertex[2] = pVertex[2];
	Faces[0]->NoVert = 3;
	Faces[0]->iColour = GetCol();
	return (1);
}

// void E_Object3::SetToScr(C3dMatrix* pModMat,C3dMatrix* pScrTran)
//{
////int j=0;
////for (j=0;j<iNoNodes;j++)
////{
////   pVertex[j]->SetToScr(pModMat,pScrTran);
////}
// C3dVector vC;
// vC=Get_Centroid();
// vC.SetToScr(pModMat,pScrTran);
// SelPt=vC;
//
// }

double E_Object3::GetCentriodVal(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	double dTemp = 0;
	double T = 0;
	int iDOFID;
	int j;
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 0.333;
	*FunPnt.mn(1, 2) = 0.333;
	fun = this->ShapeFun(FunPnt, 1);
	for (j = 0; j < this->iNoNodes; j++) {
		T = 0;
		;
		iDOFID = this->pVertex[j]->dof[iDof];
		if (iDOFID > 0) {
			T = *Disp.nn(iDOFID);
		}
		dTemp += T * *fun.mn(1, j + 1);
	}
	fun.clear();
	FunPnt.clear();
	return (dTemp);
}

double E_Object3::GetElCentriodVal() {
	double dTemp = 0;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		dTemp += pVertex[j]->dTemp;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

C3dVector E_Object3::Get_Centroid() {
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 0.333;
	*FunPnt.mn(1, 2) = 0.333;
	fun = ShapeFun(FunPnt, 1);
	C3dVector vT;
	vT.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vT += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
	}
	fun.clear();
	FunPnt.clear();
	return (vT);
}

C3dMatrix E_Object3::GetElSys() {
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 0.33;
	*FunPnt.mn(1, 2) = 0.33;
	fun = ShapeDer(FunPnt, 1);
	C3dVector vX, vY, vT;
	vX.Set(0, 0, 0);
	vY.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vX += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
		vY += pVertex[j]->Get_Centroid() * *fun.mn(2, j + 1);
	}
	vT = vX.Cross(vY);
	vT.Normalize();
	vX = pVertex[1]->GetCoords();
	vX -= pVertex[0]->GetCoords();
	vX.Normalize();
	vY = vT.Cross(vX);
	fun.clear();
	FunPnt.clear();
	C3dMatrix vR;
	vR.SetColVec(1, vX);
	vR.SetColVec(2, vY);
	vR.SetColVec(3, vT);
	vR.Transpose();
	return (vR);
}

C3dVector E_Object3::GetFirstEdge() {
	C3dVector vD;
	vD.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	vD.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	vD.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

	return (vD);
}

void E_Object3::GetBoundingBox(C3dVector& vll, C3dVector& vur) {
	int i;
	vll.x = pVertex[0]->Pt_Point->x;
	vll.y = pVertex[0]->Pt_Point->y;
	vll.z = pVertex[0]->Pt_Point->z;
	vur.x = pVertex[0]->Pt_Point->x;
	vur.y = pVertex[0]->Pt_Point->y;
	vur.z = pVertex[0]->Pt_Point->z;

	for (i = 0; i < 3; i++) {
		if (pVertex[i]->Pt_Point->x < vll.x)
			vll.x = pVertex[i]->Pt_Point->x;
		if (pVertex[i]->Pt_Point->x > vur.x)
			vur.x = pVertex[i]->Pt_Point->x;

		if (pVertex[i]->Pt_Point->y < vll.y)
			vll.y = pVertex[i]->Pt_Point->y;
		if (pVertex[i]->Pt_Point->y > vur.y)
			vur.y = pVertex[i]->Pt_Point->y;

		if (pVertex[i]->Pt_Point->z < vll.z)
			vll.z = pVertex[i]->Pt_Point->z;
		if (pVertex[i]->Pt_Point->z > vur.z)
			vur.z = pVertex[i]->Pt_Point->z;
	}
}

double E_Object3::QualAspect() {
	double drc = 1;
	C3dVector v1;
	C3dVector v2;
	double de1;
	double de2;
	double de3;
	double deMax;
	double deMin;
	v1 = pVertex[0]->Get_Centroid();
	v2 = pVertex[1]->Get_Centroid();
	de1 = (v1 - v2).Mag();
	v1 = pVertex[1]->Get_Centroid();
	v2 = pVertex[2]->Get_Centroid();
	de2 = (v1 - v2).Mag();
	v1 = pVertex[2]->Get_Centroid();
	v2 = pVertex[0]->Get_Centroid();
	de3 = (v1 - v2).Mag();
	// Find Maximum value
	deMax = de1;
	if (de2 > deMax)
		deMax = de2;
	if (de3 > deMax)
		deMax = de3;
	// Minimum
	deMin = de1;
	if (de2 < deMin)
		deMin = de2;
	if (de3 < deMin)
		deMin = de3;

	if (deMin != 0)
		drc = deMax / deMin;
	else
		drc = 100000;
	return (drc);
}

double E_Object3::GetCharSize() {
	double dS;
	C3dVector vT;
	C3dVector vT2;
	vT = pVertex[0]->Pt_Point;
	vT2 = pVertex[1]->Pt_Point;
	vT -= vT2;
	dS = vT.Mag();
	vT = pVertex[1]->Pt_Point;
	vT2 = pVertex[2]->Pt_Point;
	vT -= vT2;
	dS += vT.Mag();
	vT = pVertex[2]->Pt_Point;
	vT2 = pVertex[0]->Pt_Point;
	vT -= vT2;
	dS += vT.Mag();
	dS /= 3;
	// dS=(pVertex[0]->Pt_Point-pVertex[1]->Pt_Point)->Mag();
	return (dS);
}

C3dVector E_Object3::GetTestPt() {
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 1;
	*FunPnt.mn(1, 2) = 0;
	fun = ShapeFun(FunPnt, 1);
	C3dVector vX;
	vX.Set(0, 0, 0);

	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vX += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
	}
	return (vX);
}

void E_Object3::Info() {
	char S1[80];
	G_Object::Info();
	sprintf_s(S1, "LAB: %i COL: %i PID: %i ELTP: %i MCID: %i ANG: %f ", iLabel, iColour, PID, iType, iMCys, MAng);
	outtext1(S1);
	sprintf_s(S1, "NODES %i %i %i", pVertex[0]->iLabel, pVertex[1]->iLabel, pVertex[2]->iLabel);
	outtext1(S1);
}

CString E_Object3::ToString() {
	CString sRT;
	char S1[80];
	CString sDir;
	if ((iMCys == -1) && (MAng != 0.0)) {
		sDir = e8(MAng);
	} else if (iMCys == -1) {
		sDir = "        ";
	} else {
		sprintf_s(S1, "%8i", iMCys);
		sDir = S1;
	}
	sprintf_s(S1, "%8s%8i%8i%8i%8i%8i%8s%8s\n", "CTRIA3  ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel,
	          pVertex[2]->iLabel, sDir, e8(dZOFFS));
	sRT = S1;
	return (sRT);
}

C3dVector E_Object3::Get_Normal() {
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 0.333;
	*FunPnt.mn(1, 2) = 0.333;
	fun = ShapeDer(FunPnt, 1);
	C3dVector vX, vY, vT;
	vX.Set(0, 0, 0);
	vY.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vX += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
		vY += pVertex[j]->Get_Centroid() * *fun.mn(2, j + 1);
	}
	vT = vX.Cross(vY);
	fun.clear();
	FunPnt.clear();
	vT.Normalize();
	return (vT);
}

// void E_Object3::HighLight(CDC* pDC)
//{
////CPoint cPt1;
////CPoint cPt2;
////cPt1.x = (long) 0.5*((long) pVertex[2]->DSP_Point->x-(long) pVertex[0]->DSP_Point->x)+(long) pVertex[0]->DSP_Point->x;
////cPt1.y = (long) 0.5*((long) pVertex[2]->DSP_Point->y-(long) pVertex[0]->DSP_Point->y)+(long) pVertex[0]->DSP_Point->y;
////cPt2.x = (long) (0.3*((long) pVertex[1]->DSP_Point->x-cPt1.x)+cPt1.x);
////cPt2.y = (long) (0.3*((long) pVertex[1]->DSP_Point->y-cPt1.y)+cPt1.y);
// pDC->Ellipse(SelPt.x+5,SelPt.y+5,SelPt.x-5,SelPt.y-5);
// }

// G_ObjectD E_Object3::SelDist(CPoint InPT,Filter FIL)
//{
// G_ObjectD Ret;
// double x,y,d;
// x =  SelPt.x-InPT.x;
// y =  SelPt.y-InPT.y;
// d=(x*x+y*y);
// Ret.Dist=d;
// Ret.pObj=this;
// return (Ret);
// }

Mat E_Object3::Sample(int iNo) {
	Mat Pts(iNo, 3);
	if (iNo == 1) {
		*Pts.mn(1, 1) = (double) 1 / 3;
		*Pts.mn(1, 2) = (double) 1 / 3;
		*Pts.mn(1, 3) = (double) 0.5;
	} else if (iNo == 3) {
		*Pts.mn(1, 1) = (double) 0;
		*Pts.mn(1, 2) = (double) 0.5;
		*Pts.mn(1, 3) = (double) 1 / 6;

		*Pts.mn(2, 1) = (double) 0.5;
		*Pts.mn(2, 2) = (double) 0;
		*Pts.mn(2, 3) = (double) 1 / 6;

		*Pts.mn(3, 1) = (double) 0.5;
		*Pts.mn(3, 2) = (double) 0.5;
		*Pts.mn(3, 3) = (double) 1 / 6;
	}
	return (Pts);
}

int E_Object3::MaxBW() {
	int i;
	int j;
	int MaxDof;
	int MinDof;
	MaxDof = 0;
	MinDof = 99999999;
	for (i = 0; i < iNoNodes; i++) {
		for (j = 0; j < 6; j++) {
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] > MaxDof)) {
				MaxDof = pVertex[i]->dof[j];
			}
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] < MinDof)) {
				MinDof = pVertex[i]->dof[j];
			}
		}
	}
	int iRC;
	if (MaxDof - MinDof < 0) {
		iRC = 0;
	} else {
		iRC = MaxDof - MinDof;
	}
	return (iRC);
}

// Used for MPM example for particle position in element
Mat E_Object3::GetParticlePos() {
	Mat Cent(2, 1);
	C3dVector vC = this->Get_Centroid();
	*Cent.mn(1, 1) = vC.x;
	*Cent.mn(2, 1) = vC.y;
	return (Cent);
}

// Used for MPM example for area calc
Mat E_Object3::DetCoords2d() {
	Mat DetCoord(iNoNodes, 3);

	*DetCoord.mn(1, 1) = 1.0;
	*DetCoord.mn(1, 2) = 1.0;
	*DetCoord.mn(1, 3) = 1.0;

	*DetCoord.mn(2, 1) = pVertex[0]->Pt_Point->x;
	*DetCoord.mn(2, 2) = pVertex[1]->Pt_Point->x;
	*DetCoord.mn(2, 3) = pVertex[2]->Pt_Point->x;

	*DetCoord.mn(3, 1) = pVertex[0]->Pt_Point->y;
	*DetCoord.mn(3, 2) = pVertex[1]->Pt_Point->y;
	*DetCoord.mn(3, 3) = pVertex[2]->Pt_Point->y;

	return (DetCoord);
}

Mat E_Object3::getCoords2d() {
	int i;
	Mat coord(iNoNodes, 2);
	for (i = 0; i < iNoNodes; i++) {
		*coord.mn(i + 1, 1) = pVertex[i]->Pt_Point->x;
		*coord.mn(i + 1, 2) = pVertex[i]->Pt_Point->y;
	}
	return (coord);
}

//*******************************************************************
// Get The coordinates after transforming the element to the XY plain
//********************************************************************
Mat E_Object3::getCoords3d() {
	int i;
	C3dVector p;
	Mat coord(iNoNodes, 2);
	C3dMatrix M3 = this->GetElSys();
	// M3.Transpose();
	for (i = 0; i < iNoNodes; i++) {
		C3dVector p, v;
		p.x = pVertex[i]->Pt_Point->x;
		p.y = pVertex[i]->Pt_Point->y;
		p.z = pVertex[i]->Pt_Point->z;
		v = M3.Mult(p);
		*coord.mn(i + 1, 1) = v.x;
		*coord.mn(i + 1, 2) = v.y;
	}
	return (coord);
}

//*******************************************************************
// Get The coordinates after transforming the element to the XY plain
// For MIN3 element point are relative to first node
//********************************************************************
Mat E_Object3::getCoords_XEL() {
	int i;
	double dx, dy, dz;

	C3dVector p;
	Mat coord(iNoNodes, 3);
	C3dMatrix M3 = this->GetElSys();
	// M3.Transpose();
	for (i = 0; i < iNoNodes; i++) {
		C3dVector p, v;
		p.x = pVertex[i]->Pt_Point->x - pVertex[0]->Pt_Point->x;
		p.y = pVertex[i]->Pt_Point->y - pVertex[0]->Pt_Point->y;
		p.z = pVertex[i]->Pt_Point->z - pVertex[0]->Pt_Point->z;
		v = M3.Mult(p);
		*coord.mn(i + 1, 1) = v.x;
		*coord.mn(i + 1, 2) = v.y;
		*coord.mn(i + 1, 3) = v.z;
		dx = *coord.mn(i + 1, 1);
		dy = *coord.mn(i + 1, 2);
		dz = *coord.mn(i + 1, 3);
	}

	return (coord);
}

Mat E_Object3::ShapeDer(Mat Points, int i) {
	Mat der(2, 3);
	*der.mn(1, 1) = 1;
	*der.mn(1, 2) = 0;
	*der.mn(1, 3) = -1;
	*der.mn(2, 1) = 0;
	*der.mn(2, 2) = 1;
	*der.mn(2, 3) = -1;
	return (der);
}

Vec<int> E_Object3::GetSteerVec3d() {
	Vec<int> V(18);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[0]->dof[3];
	*V.nn(5) = pVertex[0]->dof[4];
	*V.nn(6) = pVertex[0]->dof[5];

	*V.nn(7) = pVertex[1]->dof[0];
	*V.nn(8) = pVertex[1]->dof[1];
	*V.nn(9) = pVertex[1]->dof[2];
	*V.nn(10) = pVertex[1]->dof[3];
	*V.nn(11) = pVertex[1]->dof[4];
	*V.nn(12) = pVertex[1]->dof[5];

	*V.nn(13) = pVertex[2]->dof[0];
	*V.nn(14) = pVertex[2]->dof[1];
	*V.nn(15) = pVertex[2]->dof[2];
	*V.nn(16) = pVertex[2]->dof[3];
	*V.nn(17) = pVertex[2]->dof[4];
	*V.nn(18) = pVertex[2]->dof[5];

	return (V);
}

Vec<int> E_Object3::GetSteerVec1d() {
	Vec<int> V(3 * 1);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[1]->dof[0];
	*V.nn(3) = pVertex[2]->dof[0];
	return (V);
}

Mat E_Object3::ShapeFun(Mat Points, int i) {
	Mat fun(1, 3);
	double xi, eta;
	double c1, c2, c3;
	eta = *Points.mn(i, 2);
	xi = *Points.mn(i, 1);
	c1 = xi;
	c2 = eta;
	c3 = 1 - xi - eta;

	*fun.mn(1, 1) = c1;
	*fun.mn(1, 2) = c2;
	*fun.mn(1, 3) = c3;
	return (fun);
}

int E_Object3::noDof() {
	return (6);
}

// 07/01/2024 MIN3 IMPLEMENTATION
Mat E_Object3::TMEM1_BEE(int OPT) {
	// Membrane strain / displacement for 1 point CTRIA element
	Mat BM(3, 18);
	BM.MakeZero();
	double C01 = 0;
	double C02 = 0;
	double C03 = 0;
	double C04 = 0;
	Mat XEL = getCoords_XEL(); // Local element coordinates
	// Calculate element geometry parameters from data block XEL
	// XEL is local element coods
	double X2E = *XEL.mn(2, 1);
	double X3E = *XEL.mn(3, 1);
	double Y3E = *XEL.mn(3, 2);
	double AREA = X2E * Y3E / 2.0;

	C01 = 1 / X2E;
	C02 = 1 / Y3E;
	C03 = (X3E - X2E) * C01 * C02;
	C04 = X3E * C01 * C02;

	*BM.mn(1, 1) = -C01;
	*BM.mn(1, 7) = C01;
	*BM.mn(2, 2) = C03;
	*BM.mn(2, 8) = -C04;
	*BM.mn(2, 14) = C02;
	*BM.mn(3, 1) = C03;
	*BM.mn(3, 2) = -C01;
	*BM.mn(3, 7) = -C04;
	*BM.mn(3, 8) = C01;
	*BM.mn(3, 13) = C02;
	XEL.clear();
	return (BM);
}

// BEE Matrix for transverse shear (strain / displacement matrix)
// one integration point befined by XI;
Mat E_Object3::TPLT2_BEE_TS(int OPT, Vec<double>& XI) {
	int j;
	Mat BS(2, 9);

	BS.MakeZero();
	Vec<double> A(3);
	Vec<double> B(3);
	Mat XEL = getCoords_XEL(); // Local element coordinates
	// Calculate element geometry parameters from data block XEL
	// XEL is local element coods

	double X2E = *XEL.mn(2, 1);
	double X3E = *XEL.mn(3, 1);
	double Y3E = *XEL.mn(3, 2);
	double AREA = X2E * Y3E / 2.0;
	*A.nn(1) = X3E - X2E;
	*A.nn(2) = -X3E;
	*A.nn(3) = X2E;
	*B.nn(1) = -Y3E;
	*B.nn(2) = Y3E;
	*B.nn(3) = 0;
	double A4 = 4 * AREA;
	for (j = 1; j <= 3; j++) {
		*BS.mn(1, j) = *B.nn(j) / (2 * AREA);
		*BS.mn(2, j) = *A.nn(j) / (2 * AREA);
	}

	*BS.mn(1, 4) = -(*B.nn(1) * (*XI.nn(2) * *B.nn(3) - *XI.nn(3) * *B.nn(2)) / A4);
	*BS.mn(1, 5) = -(*B.nn(2) * (-*XI.nn(1) * *B.nn(3) + *XI.nn(3) * *B.nn(1)) / A4);
	*BS.mn(1, 6) = -(*B.nn(3) * (*XI.nn(1) * *B.nn(2) - *XI.nn(2) * *B.nn(1)) / A4);

	*BS.mn(1, 7) = (*XI.nn(1) * (A4 - *B.nn(2) * *A.nn(3) + *B.nn(3) * *A.nn(2)) + *B.nn(1) * (-*XI.nn(2) * *A.nn(3) + *XI.nn(3) * *A.nn(2))) / A4;
	*BS.mn(1, 8) = (*XI.nn(2) * (A4 + *B.nn(1) * *A.nn(3) - *B.nn(3) * *A.nn(1)) + *B.nn(2) * (*XI.nn(1) * *A.nn(3) - *XI.nn(3) * *A.nn(1))) / A4;
	*BS.mn(1, 9) = (*XI.nn(3) * (A4 + *B.nn(2) * *A.nn(1) - *B.nn(1) * *A.nn(2)) + *B.nn(3) * (-*XI.nn(1) * *A.nn(2) + *XI.nn(2) * *A.nn(1))) / A4;

	*BS.mn(2, 4) = -(*XI.nn(1) * (A4 + *A.nn(2) * *B.nn(3) - *A.nn(3) * *B.nn(2)) + *A.nn(1) * (*XI.nn(2) * *B.nn(3) - *XI.nn(3) * *B.nn(2))) / A4;
	*BS.mn(2, 5) = -(*XI.nn(2) * (A4 - *A.nn(1) * *B.nn(3) + *A.nn(3) * *B.nn(1)) + *A.nn(2) * (-*XI.nn(1) * *B.nn(3) +
	                                                                                            *XI.nn(3) * *B.nn(1))) /
	               A4;
	*BS.mn(2, 6) = -(*XI.nn(3) * (A4 - *A.nn(2) * *B.nn(1) + *A.nn(1) * *B.nn(2)) + *A.nn(3) * (*XI.nn(1) * *B.nn(2) - *XI.nn(2) * *B.nn(1))) / A4;

	*BS.mn(2, 7) = *A.nn(1) * (-*XI.nn(2) * *A.nn(3) + *XI.nn(3) * *A.nn(2)) / A4;
	*BS.mn(2, 8) = *A.nn(2) * (*XI.nn(1) * *A.nn(3) - *XI.nn(3) * *A.nn(1)) / A4;
	*BS.mn(2, 9) = *A.nn(3) * (-*XI.nn(1) * *A.nn(2) + *XI.nn(2) * *A.nn(1)) / A4;
	A.clear();
	B.clear();
	XEL.clear();
	// reorder

	return (BS);
}

Mat E_Object3::BEE_BM_Recovery() {
	Mat BEE;
	BEE = TMEM1_BEE(3);
	return (BEE);
}

Mat E_Object3::BEE_BB_Recovery() {
	int i;

	Mat BB(3, 3 * iNoNodes);
	Mat BB2(3, 6 * iNoNodes);
	Vec<int> IDS(18);
	BB.MakeZero();
	BB2.MakeZero();

	//****************************************************************************
	//                            M Y   C A L C U L A T I O N
	//****************************************************************************

	Mat coord; // Nodal Coordinates
	Mat deriv; // shape function derivatives
	Mat Points; // sample points
	Mat deriv2; // derivative of shape functions
	Mat jac;
	double det = 0;
	coord = getCoords3d(); // Coords in element CSYS this case actually 2d
	Points = Sample(1);
	deriv = ShapeDer(Points, 1); // 2x4 shape fuction derivatives
	jac = deriv * coord;
	jac = jac.InvertJac(det);
	deriv2 = jac * deriv;

	// Bending Strain Components curvatures k11,k22,k12
	// 1 pt at el centre

	BB.MakeZero();
	C3dMatrix Bb;
	int k;
	// BENDING TERMS Bb is BENDING B MATRIX
	int inc = 0;
	double tmp;
	for (k = 1; k < iNoNodes + 1; k++) {
		Bb.m_00 = 0;
		Bb.m_01 = 0;
		Bb.m_02 = -*deriv2.mn(1, k);
		Bb.m_10 = 0;
		Bb.m_11 = *deriv2.mn(2, k);
		Bb.m_12 = 0;
		Bb.m_20 = 0;
		Bb.m_21 = *deriv2.mn(1, k);
		Bb.m_22 = -*deriv2.mn(2, k);

		*BB.mn(1, inc + 1) = 0;
		*BB.mn(1, inc + 2) = 0;
		*BB.mn(1, inc + 3) = -*deriv2.mn(1, k);
		tmp = -*deriv2.mn(1, k);
		*BB.mn(2, inc + 1) = 0;
		*BB.mn(2, inc + 2) = *deriv2.mn(2, k);
		tmp = *deriv2.mn(2, k);
		*BB.mn(2, inc + 3) = 0;
		*BB.mn(3, inc + 1) = 0;
		*BB.mn(3, inc + 2) = *deriv2.mn(1, k);
		tmp = *deriv2.mn(1, k);
		*BB.mn(3, inc + 3) = -*deriv2.mn(2, k);
		tmp = -*deriv2.mn(2, k);
		inc += 3;
	}

	*IDS.nn(1) = 3;
	*IDS.nn(2) = 4;
	*IDS.nn(3) = 5;
	*IDS.nn(4) = 9;
	*IDS.nn(5) = 10;
	*IDS.nn(6) = 11;
	*IDS.nn(7) = 15;
	*IDS.nn(8) = 16;
	*IDS.nn(9) = 17;
	for (i = 1; i <= 9; i++) {
		*BB2.mn(1, *IDS.nn(i)) = *BB.mn(1, i);
		*BB2.mn(2, *IDS.nn(i)) = *BB.mn(2, i);
		*BB2.mn(3, *IDS.nn(i)) = *BB.mn(3, i);
	}

	BB.clear();
	coord.clear();
	;
	deriv.clear();
	;
	Points.clear();
	;
	deriv2.clear();
	;
	jac.clear();
	;
	//**********************************************************

	BB.clear();
	IDS.clear();
	return (BB2);
}

Mat E_Object3::BEE_TS_Recovery() {
	int i;
	Mat BS;
	Mat BS2(2, 18);
	Vec<int> IDS(18);
	Vec<double> XI(3);
	*XI.nn(1) = 0.3333333;
	*XI.nn(2) = 0.3333333;
	*XI.nn(3) = 0.3333333;
	BS = TPLT2_BEE_TS(3, XI);
	// INTEGER(LONG), PARAMETER::ID(9) = (/ 3, &!ID(1) = 3 means virgin 9x9 elem DOF 1 is MYSTRAN 18x18 elem DOF  3
	//	9, &!ID(2) = 9 means virgin 9x9 elem DOF 2 is MYSTRAN 18x18 elem DOF  9
	//	15, &!ID(3) = 15 means virgin 9x9 elem DOF 3 is MYSTRAN 18x18 elem DOF 15
	//	4, &!ID(4) = 4 means virgin 9x9 elem DOF 4 is MYSTRAN 18x18 elem DOF  4
	//	10, &!ID(5) = 10 means virgin 9x9 elem DOF 5 is MYSTRAN 18x18 elem DOF 10
	//	16, &!ID(6) = 16 means virgin 9x9 elem DOF 6 is MYSTRAN 18x18 elem DOF 16
	//	5, &!ID(7) = 5 means virgin 9x9 elem DOF 7 is MYSTRAN 18x18 elem DOF  5
	//	11, &!ID(8) = 11 means virgin 9x9 elem DOF 8 is MYSTRAN 18x18 elem DOF 11
	//	17 / ) !ID(9) = 17 mea
	*IDS.nn(1) = 3;
	*IDS.nn(2) = 9;
	*IDS.nn(3) = 15;
	*IDS.nn(4) = 4;
	*IDS.nn(5) = 10;
	*IDS.nn(6) = 16;
	*IDS.nn(7) = 5;
	*IDS.nn(8) = 11;
	*IDS.nn(9) = 17;
	for (i = 1; i <= 9; i++) {
		*BS2.mn(1, *IDS.nn(i)) = *BS.mn(1, i);
		*BS2.mn(2, *IDS.nn(i)) = *BS.mn(2, i);
	}
	BS.clear();
	return (BS2);
}

Mat E_Object3::TMEM1_KE(int OPT, double AREA, double X2E, double X3E, double Y3E, Mat SHELL_A) {
	// Membrane strain Stiffness Matrix
	//  BMt * DEE * BM
	Mat KE;
	Mat BMT;
	Mat db;
	Mat BM = TMEM1_BEE(3);
	BMT = BM;
	BMT.Transpose();
	db = SHELL_A * BM;
	KE = BMT * db;
	KE *= AREA;
	// Also need to *by area
	// KE.diag();

	return (KE);
}

Mat E_Object3::TPLT2_KE(int OPT, double AREA, double X2E, double X3E, double Y3E, Mat SHELL_D, Mat SHELL_T) {
	int I, J;
	// Bending and Shear stiffness matrix
	double BENSUM = 0;
	double SHRSUM = 0;
	Mat KE(18, 18);
	Mat KB(9, 9); // w,thetaX,thetaY squared NOT the full matrix of 18*18
	Mat KS(9, 9);
	Mat KV(9, 9);
	Mat A(3, 1);
	Mat B(3, 1);
	Mat FXX(3, 3);
	Mat FYY(3, 3);
	Mat FXY(3, 3);

	*A.mn(1, 1) = X3E - X2E;
	*A.mn(2, 1) = -X3E;
	*A.mn(3, 1) = X2E;
	*B.mn(1, 1) = -Y3E;
	*B.mn(2, 1) = Y3E;
	*B.mn(3, 1) = 0;
	double A4 = 4 * AREA;
	double A42 = A4 * AREA;
	//********************************************************************
	// Calculate element stiffness matrix KE. Note that we need to calc KE
	// if the stress recovery matrices(for OPT(3)) are to be cal'd
	// since the BE strain recovery matrices use PHI_SQ
	KB.MakeZero();
	// Bending stiffness terms(KB)

	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*FXX.mn(I, J) = *B.mn(I, 1) * *B.mn(J, 1) / A42;
			*FYY.mn(I, J) = *A.mn(I, 1) * *A.mn(J, 1) / A42;
			*FXY.mn(I, J) = *B.mn(I, 1) * *A.mn(J, 1) / A42;
		}
	}

	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*KB.mn(I + 3, J + 3) = AREA * (*SHELL_D.mn(2, 2) * *FYY.mn(I, J) + *SHELL_D.mn(2, 3) * (*FXY.mn(I, J) + *FXY.mn(J, I)) + *SHELL_D.mn(3, 3) * *FXX.mn(I, J));
		}
	}
	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*KB.mn(I + 3, J + 6) = -AREA * (*SHELL_D.mn(1, 2) * *FXY.mn(J, I) + *SHELL_D.mn(2, 3) * *FYY.mn(I, J) + *SHELL_D.mn(1, 3) * *FXX.mn(I, J) + *SHELL_D.mn(3, 3) * *FXY.mn(I, J));
			*KB.mn(J + 6, I + 3) = *KB.mn(I + 3, J + 6);
		}
	}
	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*KB.mn(I + 6, J + 6) = AREA * (*SHELL_D.mn(1, 1) * *FXX.mn(I, J) + *SHELL_D.mn(1, 3) * (*FXY.mn(I, J) + *FXY.mn(J, I)) + *SHELL_D.mn(3, 3) * *FYY.mn(I, J));
		}
	}
	BENSUM = 0;
	for (I = 4; I < 9 + 1; I++) {
		BENSUM = BENSUM + *KB.mn(I, I);
	}
	// Start of shear stiffness calc
	// Shear stress terms(KS)

	KS.MakeZero();
	Mat B2(3, 3); // NEEDS CLEARING AT END
	*B2.mn(1, 1) = 0;
	*B2.mn(2, 2) = 0;
	*B2.mn(3, 3) = 0;
	*B2.mn(1, 2) = -*B.mn(2, 1) * *B.mn(3, 1) / A4;
	*B2.mn(1, 3) = -*B2.mn(1, 2);
	*B2.mn(2, 1) = *B.mn(1, 1) * *B.mn(3, 1) / A4;
	*B2.mn(2, 3) = -*B2.mn(2, 1);
	*B2.mn(3, 1) = -*B.mn(1, 1) * *B.mn(2, 1) / A4;
	*B2.mn(3, 2) = -*B2.mn(3, 1);
	Mat A2(3, 3); // NEEDS CLEARING AT END
	*A2.mn(1, 1) = (*A.mn(2, 1) * *B.mn(3, 1) - *A.mn(3, 1) * *B.mn(2, 1)) / A4;
	*A2.mn(2, 2) = (-*A.mn(1, 1) * *B.mn(3, 1) + *A.mn(3, 1) * *B.mn(1, 1)) / A4;
	*A2.mn(3, 3) = (-*A.mn(2, 1) * *B.mn(1, 1) + *A.mn(1, 1) * *B.mn(2, 1)) / A4;
	*A2.mn(1, 2) = -*A.mn(2, 1) * *B.mn(3, 1) / A4;
	*A2.mn(1, 3) = *A.mn(3, 1) * *B.mn(2, 1) / A4;
	*A2.mn(2, 1) = *A.mn(1, 1) * *B.mn(3, 1) / A4;
	*A2.mn(2, 3) = -*A.mn(3, 1) * *B.mn(1, 1) / A4;
	*A2.mn(3, 1) = -*A.mn(1, 1) * *B.mn(2, 1) / A4;
	*A2.mn(3, 2) = *A.mn(2, 1) * *B.mn(1, 1) / A4;
	Mat B1(3, 3); // NEEDS CLEARING AT END
	*B1.mn(1, 1) = (-*B.mn(2, 1) * *A.mn(3, 1) + *B.mn(3, 1) * *A.mn(2, 1)) / A4;
	*B1.mn(2, 2) = (*B.mn(1, 1) * *A.mn(3, 1) - *B.mn(3, 1) * *A.mn(1, 1)) / A4;
	*B1.mn(3, 3) = (*B.mn(2, 1) * *A.mn(1, 1) - *B.mn(1, 1) * *A.mn(2, 1)) / A4;
	*B1.mn(1, 2) = *B.mn(2, 1) * *A.mn(3, 1) / A4;
	*B1.mn(1, 3) = -*B.mn(3, 1) * *A.mn(2, 1) / A4;
	*B1.mn(2, 1) = -*B.mn(1, 1) * *A.mn(3, 1) / A4;
	*B1.mn(2, 3) = *B.mn(3, 1) * *A.mn(1, 1) / A4;
	*B1.mn(3, 1) = *B.mn(1, 1) * *A.mn(2, 1) / A4;
	*B1.mn(3, 2) = -*B.mn(2, 1) * *A.mn(1, 1) / A4;
	Mat A1(3, 3); // NEEDS CLEARING AT END
	*A1.mn(1, 1) = 0;
	*A1.mn(2, 2) = 0;
	*A1.mn(3, 3) = 0;
	*A1.mn(1, 2) = *A.mn(2, 1) * *A.mn(3, 1) / A4;
	*A1.mn(1, 3) = -*A1.mn(1, 2);
	*A1.mn(2, 1) = -*A.mn(1, 1) * *A.mn(3, 1) / A4;
	*A1.mn(2, 3) = -*A1.mn(2, 1);
	*A1.mn(3, 1) = *A.mn(1, 1) * *A.mn(2, 1) / A4;
	*A1.mn(3, 2) = -*A1.mn(3, 1);
	Mat I00(3, 3); // NEEDS CLEARING AT END
	*I00.mn(1, 2) = AREA / 12;
	*I00.mn(1, 3) = *I00.mn(1, 2);
	*I00.mn(2, 1) = *I00.mn(1, 2);
	*I00.mn(2, 3) = *I00.mn(1, 2);
	*I00.mn(3, 1) = *I00.mn(1, 2);
	*I00.mn(3, 2) = *I00.mn(1, 2);
	*I00.mn(1, 1) = 2 * *I00.mn(1, 2);
	*I00.mn(2, 2) = *I00.mn(1, 1);
	*I00.mn(3, 3) = *I00.mn(1, 1);
	Mat IX0(3, 3); // NEEDS CLEARING AT END
	*IX0.mn(1, 1) = *B.mn(1, 1) / 6;
	*IX0.mn(1, 2) = *IX0.mn(1, 1);
	*IX0.mn(1, 3) = *IX0.mn(1, 1);
	*IX0.mn(2, 1) = *B.mn(2, 1) / 6;
	*IX0.mn(2, 2) = *IX0.mn(2, 1);
	*IX0.mn(2, 3) = *IX0.mn(2, 1);
	*IX0.mn(3, 1) = *B.mn(3, 1) / 6;
	*IX0.mn(3, 2) = *IX0.mn(3, 1);
	*IX0.mn(3, 3) = *IX0.mn(3, 1);
	Mat IY0(3, 3); // NEEDS CLEARING AT END
	*IY0.mn(1, 1) = *A.mn(1, 1) / 6;
	*IY0.mn(1, 2) = *IY0.mn(1, 1);
	*IY0.mn(1, 3) = *IY0.mn(1, 1);
	*IY0.mn(2, 1) = *A.mn(2, 1) / 6;
	*IY0.mn(2, 2) = *IY0.mn(2, 1);
	*IY0.mn(2, 3) = *IY0.mn(2, 1);
	*IY0.mn(3, 1) = *A.mn(3, 1) / 6;
	*IY0.mn(3, 2) = *IY0.mn(3, 1);
	*IY0.mn(3, 3) = *IY0.mn(3, 1);
	// SHELL_T.diag();
	Mat S1(3, 3); // NEEDS CLEARING AT END
	Mat S2(3, 3); // NEEDS CLEARING AT END
	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			if (I == J) {
				*S1.mn(I, J) = *A2.mn(I, J) + 1;
				*S2.mn(I, J) = *B1.mn(I, J) + 1;
			} else {
				*S1.mn(I, J) = *A2.mn(I, J);
				*S2.mn(I, J) = *B1.mn(I, J);
			}
		}
	}
	Mat T1(3, 3); // NEEDS CLEARING AT END
	Mat T2(3, 3); // NEEDS CLEARING AT END
	Mat T3(3, 3); // NEEDS CLEARING AT END
	Mat T4(3, 3); // NEEDS CLEARING AT END
	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*T1.mn(I, J) = (*SHELL_T.mn(1, 1) * *B2.mn(I, J) + *SHELL_T.mn(1, 2) * *S1.mn(I, J));
			*T2.mn(I, J) = (*SHELL_T.mn(1, 2) * *B2.mn(I, J) + *SHELL_T.mn(2, 2) * *S1.mn(I, J));
			*T3.mn(I, J) = (*SHELL_T.mn(1, 1) * *S2.mn(I, J) + *SHELL_T.mn(1, 2) * *A1.mn(I, J));
			*T4.mn(I, J) = (*SHELL_T.mn(1, 2) * *S2.mn(I, J) + *SHELL_T.mn(2, 2) * *A1.mn(I, J));
		}
	}

	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*KS.mn(I, J) = AREA * (*SHELL_T.mn(1, 1) * *FXX.mn(I, J) + *SHELL_T.mn(1, 2) * (*FXY.mn(I, J) + *FXY.mn(J, I)) + *SHELL_T.mn(2, 2) * *FYY.mn(I, J));
		}
	}
	// 3x3 KS - 12, 21 Partition
	Mat DUM1; // NEEDS CLEARING AT END
	Mat DUM2; // NEEDS CLEARING AT END

	DUM1 = IX0 * T1;
	DUM2 = IY0 * T2;
	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*KS.mn(I, J + 3) = -*DUM1.mn(I, J) - *DUM2.mn(I, J);
			*KS.mn(J + 3, I) = *KS.mn(I, J + 3);
		}
	}
	DUM1.clear();
	DUM2.clear();
	// 3x3 KS - 13, 31 Partition
	DUM1 = IX0 * T3;
	DUM2 = IY0 * T4;
	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*KS.mn(I, J + 6) = *DUM1.mn(I, J) + *DUM2.mn(I, J);
			*KS.mn(J + 6, I) = *KS.mn(I, J + 6);
		}
	}
	DUM1.clear();
	DUM2.clear();
	Mat DUM3; // NEEDS CLEARING AT END
	Mat DUM4; // NEEDS CLEARING AT END
	Mat TT;
	// 3x3 KS - 22 Partition
	DUM3 = I00 * T1;
	TT = B2;
	TT.Transpose();
	DUM1 = TT * DUM3;
	DUM4 = I00 * T2;
	TT = S1;
	TT.Transpose();
	DUM2 = TT * DUM4;
	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*KS.mn(I + 3, J + 3) = *DUM1.mn(I, J) + *DUM2.mn(I, J);
		}
	}
	DUM1.clear();
	DUM2.clear();
	DUM3.clear();
	DUM4.clear();
	// 3x3 KS - 23, 32 Partition
	DUM3 = I00 * T3;
	TT = B2;
	TT.Transpose();
	DUM1 = TT * DUM3;
	DUM4 = I00 * T4;
	TT = S1;
	TT.Transpose();
	DUM2 = TT * DUM4;
	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*KS.mn(I + 3, J + 6) = -*DUM1.mn(I, J) - *DUM2.mn(I, J);
			*KS.mn(J + 6, I + 3) = *KS.mn(I + 3, J + 6);
		}
	}
	DUM1.clear();
	DUM2.clear();
	DUM3.clear();
	DUM4.clear();
	// 3x3 KS - 33 Partition
	DUM3 = I00 * T3;
	TT = S2;
	TT.Transpose();
	DUM1 = TT * DUM3;
	DUM4 = I00 * T4;
	TT = A1;
	TT.Transpose();
	DUM2 = TT * DUM4;
	for (I = 1; I < 3 + 1; I++) {
		for (J = 1; J < 3 + 1; J++) {
			*KS.mn(I + 6, J + 6) = *DUM1.mn(I, J) + *DUM2.mn(I, J);
		}
	}
	DUM1.clear();
	DUM2.clear();
	DUM3.clear();
	DUM4.clear();
	SHRSUM = 0;
	for (I = 4; I < 9 + 1; I++) {
		SHRSUM = SHRSUM + *KS.mn(I, I);
	}

	Vec<int> ID(9);
	*ID.nn(1) = 3;
	*ID.nn(2) = 9;
	*ID.nn(3) = 15;
	*ID.nn(4) = 4;
	*ID.nn(5) = 10;
	*ID.nn(6) = 16;
	*ID.nn(7) = 5;
	*ID.nn(8) = 11;
	*ID.nn(9) = 17;
	// double PHI_SQ = 0.318704E-03;  //Need to call function for this
	//******** Shear Correction factor  **********
	double CBMIN = 2.0; // for tri element - emprirical value??
	double PSI_HAT = BENSUM / SHRSUM;
	double DEN = 1 + CBMIN * PSI_HAT;
	PHI_SQ = CBMIN * PSI_HAT / DEN;
	//********************************************
	for (I = 1; I < 9 + 1; I++) {
		for (J = 1; J < 9 + 1; J++) {
			*KV.mn(I, J) = *KB.mn(I, J) + PHI_SQ * *KS.mn(I, J);
			*KE.mn(*ID.nn(I), *ID.nn(J)) = *KE.mn(*ID.nn(I), *ID.nn(J)) + *KV.mn(I, J);
		}
	}

	FXX.clear();
	FYY.clear();
	FXY.clear();
	A.clear();
	B.clear();
	B2.clear();
	A2.clear();
	B1.clear();
	A1.clear();
	I00.clear();
	IX0.clear();
	IY0.clear();
	S1.clear();
	S2.clear();
	T1.clear();
	T2.clear();
	T3.clear();
	T4.clear();
	TT.clear();
	DUM1.clear();
	DUM2.clear();
	DUM3.clear();
	DUM4.clear();
	KV.clear();
	KB.clear();
	KS.clear();
	ID.clear();

	return (KE);
}

// Trying out the min3 from mystran to see it any better that what I had
// may revert
// by William Case see www.mystran.com
// 06/01/2024 MIN3 IMPLEMENTATION
Mat E_Object3::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL& bErr) {
	char S1[80];
	Mat KE;
	Mat KEP;
	int iMID1 = -1; // Membrane
	int iMID2 = -1; // bending
	int iMID3 = -1; // shear
	int iMID4 = -1; // Mem / Bend coupling
	Material* pM1 = nullptr;
	Material* pM2 = nullptr;
	Material* pM3 = nullptr;
	Material* pM4 = nullptr;
	double dthk = 0;
	double dBRatio = 1;
	double dSHRatio = 1;

	//**********************************************************************************************************************************
	//! Initialize - these may need moving to higher scope
	double BENSUM = 0;
	double SHRSUM = 0;
	double PSI_HAT = 0;
	double PHI_SQ = 0;
	double X2E = 0;
	double X3E = 0;
	double Y3E = 0;
	double AREA = 0;

	Mat SHELL_A;
	Mat SHELL_D;
	Mat SHELL_T;
	int i;
	Property* pS = PropsT->GetItem(PID);
	if (pS == NULL) {
		sprintf_s(S1, "ERROR: PROPERTY NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}

	// Get Shell Stuff
	if (((iType == 91) || (iType == 94)) && (pS != NULL)) {
		PSHELL* pSh = (PSHELL*) pS;
		dthk = pSh->dT;
		dBRatio = pSh->d12IT3;
		dSHRatio = pSh->dTST;
		iMID1 = pSh->iMID1;
		iMID2 = pSh->iMID2;
		iMID3 = pSh->iMID3;
		pM1 = MatT->GetItem(iMID1);
		if (iMID2 == -1)
			pM2 = pM1; // defualt
		else
			pM2 = MatT->GetItem(iMID2);
		if (iMID3 == -1)
			pM3 = pM1; // defualt
		else
			pM3 = MatT->GetItem(iMID3);
	}

	if ((pM1 != nullptr) && (pM2 != nullptr) && (pM3 != nullptr)) {
		SHELL_A = pM1->DeeMEM();
		SHELL_D = pM2->DeeBM();
		SHELL_T = pM3->DeeSH();
	} else {
		sprintf_s(S1, "ERROR: MATERIAL NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
		bErr = TRUE;
		return (KE);
	}

	Mat XEL = getCoords_XEL(); // Local element coordinates
	C3dMatrix TE = this->GetElSys(); // TE Element coord system
	// Calculate element geometry parameters from data block XEL
	// XEL is local element coods
	X2E = *XEL.mn(2, 1);
	X3E = *XEL.mn(3, 1);
	Y3E = *XEL.mn(3, 2);
	AREA = X2E * Y3E / 2.0;
	//**********************************************************************************************************************************
	// For TRIA3 generate the membrane stiffness
	// Mat BM; //Membrane strain / disp matrix 3*24
	// BM = TMEM1_BEE(3, AREA, X2E, X3E, Y3E); //OPT 3 = K mat
	//******************************************************
	// NOTE BOTH SHELL_A & SHELL_D need transforming to material direction
	Mat SHELL_D_TRIA = SHELL_D;
	Mat SHELL_T_TRIA = SHELL_T;
	SHELL_D_TRIA *= dBRatio * dthk * dthk * dthk / 12;

	SHELL_A *= dthk; // Shell_A need to multiplied by thk
	*SHELL_T_TRIA.mn(1, 1) *= dSHRatio * dthk;
	*SHELL_T_TRIA.mn(2, 2) *= dSHRatio * dthk;

	KE = TMEM1_KE(3, AREA, X2E, X3E, Y3E, SHELL_A);
	// Bending and Shear KE
	KEP = TPLT2_KE(3, AREA, X2E, X3E, Y3E, SHELL_D_TRIA, SHELL_T_TRIA);
	KE += KEP;
	for (i = 6; i <= 18; i += 6) {
		*KE.mn(i, i) = gDRILL_KS; // DRILLING STIFFNES
	}

	Mat TMAT(18, 18);

	for (i = 1; i < 18; i += 3) {
		*TMAT.mn(i, i) = TE.m_00;
		*TMAT.mn(i + 1, i) = TE.m_10;
		*TMAT.mn(i + 2, i) = TE.m_20;

		*TMAT.mn(i, i + 1) = TE.m_01;
		*TMAT.mn(i + 1, i + 1) = TE.m_11;
		*TMAT.mn(i + 2, i + 1) = TE.m_21;

		*TMAT.mn(i, i + 2) = TE.m_02;
		*TMAT.mn(i + 1, i + 2) = TE.m_12;
		*TMAT.mn(i + 2, i + 2) = TE.m_22;
	}
	// TMAT.diag();
	Mat TMATT = TMAT;
	TMATT.Transpose();
	Mat T;
	Mat TT;
	T = KE * TMAT;
	TT = TMATT * T;
	// OFFSETS
	if (HasOffsets()) {
		Mat off;
		Mat offT;
		Mat dum1;
		OffsetsToKG(PropsT, off);
		offT = off;
		offT.Transpose();
		dum1 = TT * off;
		TT.clear();
		TT = offT * dum1;
		dum1.clear();
		off.clear();
		offT.clear();
	}
	return (TT);
}

// 06/01/2024 old implementation of K mat which does not
// work
// Mat E_Object3::GetStiffMat(PropTable* PropsT, MatTable* MatT)
//{
//	Mat bee;   //strain displacement matrix
//	int nip = 0;
//
//	Mat coord2;
//	Mat deriv;
//	Mat deriv2;
//	Mat fun;
//	Mat Points;
//	Mat jac;
//	int i;
//	double det;
//	Mat bT;
//	Mat db;
//	Mat bdb;
//	int iDof;
//	int iS;
//	int MID = -1;
//	double dE = 210e9;
//	double dv = 0.29;
//	char S1[80];
//	double dthk = 0.001;
//
//	Property* pS = PropsT->GetItem(PID);
//	if (pS != NULL)
//	{
//		MID = pS->GetDefMatID();
//	}
//	Material* pM = MatT->GetItem(MID);
//	if (pS == NULL)
//	{
//		sprintf_s(S1, "ERROR: PROPERTY NOT FOUND FOR EL %i", iLabel);
//		outtext1(S1);
//	}
//	if (pM == NULL)
//	{
//		sprintf_s(S1, "ERROR: MATERIAL NOT FOUND FOR EL %i", iLabel);
//		outtext1(S1);
//	}
//	//Get Shell thick ness
//
//	if (((iType == 91) || (iType == 94)) && (pS != NULL))
//	{
//		PSHELL* pSh = (PSHELL*)pS;
//		dthk = pSh->dT;
//	}
//
//	if ((pM != NULL) && (pM->iType = 1))
//	{
//		MAT1* pIsen = (MAT1*)pM;
//		dE = pIsen->dE;
//		dv = pIsen->dNU;
//	}
//	//This part calculates the 2d membraine stiffness
//	iDof = 2;   //2 dof X,Y per node
//	nip = 1;    //1 intergration points
//	iS = 3;
//
//	Mat KM(iDof * iNoNodes, iDof * iNoNodes);
//	Mat dee = DeeMat(dE, dv, iS);
//	Mat coord = getCoords3d();
//	C3dMatrix M3 = this->GetElSys();
//	Points = Sample(nip);
//	//Membraine stiffness calculation
//	//for dof 12
//	for (i = 1; i < nip + 1; i++)
//	{
//		det = 0;
//		fun.clear(); deriv.clear(); jac.clear(), deriv2.clear();
//		bT.clear(); db.clear(); bdb.clear(); bee.clear();
//		fun = ShapeFun(Points, i);
//		deriv = ShapeDer(Points, i);
//		jac = deriv * coord;
//		jac = jac.InvertJac(det);
//		deriv2 = jac * deriv;
//		bee = bmat(coord, deriv2, iS, iDof);
//		bT = bee;
//		bT.Transpose();
//		db = dee * bee;
//		bdb = bT * db;
//		det *= *Points.mn(i, 3);
//		bdb *= det;
//		KM += bdb;
//	}
//	KM *= dthk;
//	fun.clear(); deriv.clear(); jac.clear(), deriv2.clear();
//	bT.clear(); db.clear(); bdb.clear(); bee.clear();
//	//Mindlin Formulation
//	//Sheer Stifness Calculation
//	//I think need to be reduced integration 1 sample point
//	double G, kk;
//	int k;
//	dee.clear();
//	dee.Create(2, 2);
//	G = 0.5 * dE / (1 + dv);
//	kk = 5.0 / 6.0;
//	*dee.mn(1, 1) = kk * G * dthk;
//	*dee.mn(2, 2) = kk * G * dthk;
//	*dee.mn(1, 2) = 0;
//	*dee.mn(2, 1) = 0;
//	Mat KM2(12, 12);
//	nip = 1;
//	Points = Sample(nip);
//	for (i = 1; i < nip + 1; i++)
//	{
//		det = 0;
//		fun.clear(); deriv.clear(); jac.clear(), deriv2.clear();
//		bT.clear(); db.clear(); bdb.clear(); bee.clear();
//		fun = ShapeFun(Points, i);
//		deriv = ShapeDer(Points, i);
//		jac = deriv * coord;
//		jac = jac.InvertJac(det);
//		deriv2 = jac * deriv;
//		bee.clear();
//		bee.Create(2, 12);
//		for (k = 1; k < iNoNodes + 1; k++)//was m
//		{
//			*bee.mn(1, (k) * 3 - 2) = *deriv2.mn(1, k);
//			*bee.mn(1, (k) * 3 - 1) = 0;
//			*bee.mn(1, (k) * 3 - 0) = *fun.mn(1, k);
//			*bee.mn(2, (k) * 3 - 2) = *deriv2.mn(2, k);
//			*bee.mn(2, (k) * 3 - 1) = -*fun.mn(1, k);
//			*bee.mn(2, (k) * 3 - 0) = 0;
//		}
//		bT = bee;
//		bT.Transpose();
//		db = dee * bee;
//		bdb = bT * db;
//		det *= *Points.mn(i, 3);
//		bdb *= det;
//		KM2 += bdb;
//	}
//	fun.clear(); deriv.clear(); jac.clear(), deriv2.clear();
//	bT.clear(); db.clear(); bdb.clear(); bee.clear();
//	//The bending part
//	dee.clear();
//	dee.Create(3, 3);
//	double Cf;
//	Cf = dE * dthk * dthk * dthk / (12 * (1 - dv * dv));
//	//nip should be 3 set to 1 for debugging
//	nip = 1;
//	//*******************************************************************
//	Points = Sample(nip);
//	*dee.mn(1, 1) = 1;
//	*dee.mn(1, 2) = dv;
//	*dee.mn(1, 3) = 0;
//	*dee.mn(2, 1) = dv;
//	*dee.mn(2, 2) = 1;
//	*dee.mn(2, 3) = 0;
//	*dee.mn(3, 1) = 0;
//	*dee.mn(3, 2) = 0;
//	*dee.mn(3, 3) = (1 - dv);
//	dee *= Cf;
//	Mat KM3(12, 12);
//	for (i = 1; i < nip + 1; i++)
//	{
//		fun.clear(); deriv.clear(); jac.clear(), deriv2.clear();
//		bT.clear(); db.clear(); bdb.clear(); bee.clear();
//		det = 0;
//		fun = ShapeFun(Points, i);
//		deriv = ShapeDer(Points, i);
//		jac = deriv * coord;
//		jac = jac.InvertJac(det);
//		deriv2 = jac * deriv;
//		bee.clear();
//		bee.Create(3, 12);
//		for (k = 1; k < iNoNodes + 1; k++)//was m
//		{
//			*bee.mn(1, (k) * 3 - 2) = 0;
//			*bee.mn(1, (k) * 3 - 1) = 0;
//			*bee.mn(1, (k) * 3 - 0) = -*deriv2.mn(1, k);
//			*bee.mn(2, (k) * 3 - 2) = 0;
//			*bee.mn(2, (k) * 3 - 1) = *deriv2.mn(2, k);
//			*bee.mn(2, (k) * 3 - 0) = 0;
//			*bee.mn(3, (k) * 3 - 2) = 0;
//			*bee.mn(3, (k) * 3 - 1) = *deriv2.mn(1, k);
//			*bee.mn(3, (k) * 3 - 0) = -*deriv2.mn(2, k);
//		}
//		bT = bee;
//		bT.Transpose();
//		db = dee * bee;
//		bdb = bT * db;
//		det *= *Points.mn(i, 3);
//		bdb *= det;
//		KM3 += bdb;
//	}
//	KM2 += KM3;
//	//KM2 = KM3;
//	fun.clear(); deriv.clear(); jac.clear(), deriv2.clear();
//	bT.clear(); db.clear(); bdb.clear(); bee.clear();
//	//Assemble all the components inplain,shear and bending in KMf
//	Mat KMf(6 * iNoNodes, 6 * iNoNodes);
//	Vec<int> V(6);
//	*V.nn(1) = 1;
//	*V.nn(2) = 2;
//	*V.nn(3) = 7;
//	*V.nn(4) = 8;
//	*V.nn(5) = 13;
//	*V.nn(6) = 14;
//
//	int j;
//	for (i = 1; i <= 6; i++)
//	{
//		for (j = 1; j <= 6; j++)
//		{
//			*KMf.mn(V[i - 1], V[j - 1]) = *KM.mn(i, j);
//		}
//	}
//	Vec<int> V1(9);
//	*V1.nn(1) = 3;
//	*V1.nn(2) = 4;
//	*V1.nn(3) = 5;
//	*V1.nn(4) = 9;
//	*V1.nn(5) = 10;
//	*V1.nn(6) = 11;
//	*V1.nn(7) = 15;
//	*V1.nn(8) = 16;
//	*V1.nn(9) = 17;
//
//	for (i = 1; i <= 9; i++)
//	{
//		for (j = 1; j <= 9; j++)
//		{
//			*KMf.mn(V1[i - 1], V1[j - 1]) = *KM2.mn(i, j);
//		}
//	}
//
//	for (i = 6; i <= 18; i += 6)
//	{
//		*KMf.mn(i, i) = 0.01;  //DRILLING STIFFNES
//	}
//	//Transform to global
//	//M3.Transpose();
//	Mat TMAT(18, 18);
//
//	for (i = 1; i < 18; i += 3)
//	{
//		*TMAT.mn(i, i) = M3.m_00;
//		*TMAT.mn(i + 1, i) = M3.m_10;
//		*TMAT.mn(i + 2, i) = M3.m_20;
//
//		*TMAT.mn(i, i + 1) = M3.m_01;
//		*TMAT.mn(i + 1, i + 1) = M3.m_11;
//		*TMAT.mn(i + 2, i + 1) = M3.m_21;
//
//		*TMAT.mn(i, i + 2) = M3.m_02;
//		*TMAT.mn(i + 1, i + 2) = M3.m_12;
//		*TMAT.mn(i + 2, i + 2) = M3.m_22;
//	}
//	//TMAT.diag();
//	Mat TMATT = TMAT;
//	TMATT.Transpose();
//	Mat T;
//	Mat TT;
//	T = KMf * TMAT;
//	TT = TMATT * T;
//	KM.clear();
//	KM2.clear();
//	TMATT.clear();
//	TMAT.clear();
//	T.clear();
//	return (TT);
// }

void E_Object3::TranslateAVF(C3dVector vIn) {
	pVertex[0]->Translate(vIn);
	pVertex[1]->Translate(vIn);
	pVertex[2]->Translate(vIn);
}

void E_Object3::TransformAVF(C3dMatrix TMat) {
	pVertex[0]->Transform(TMat);
	pVertex[1]->Transform(TMat);
	pVertex[2]->Transform(TMat);
}

CString E_Object3::GetName() {
	return ("Tri Shell (CTRIA3)");
}

int E_Object3::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "PID";
	iNo++;
	sVar[iNo] = "Mat CYS";
	iNo++;
	sVar[iNo] = "Mat Angle";
	iNo++;
	sVar[iNo] = "Z Offset";
	iNo++;
	sVar[iNo] = "N1";
	iNo++;
	sVar[iNo] = "N2";
	iNo++;
	sVar[iNo] = "N3";
	iNo++;
	return (iNo);
}

int E_Object3::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", PID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMCys);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", MAng);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dZOFFS);
	sVar[iNo] = S1;
	iNo++;

	sprintf_s(S1, "%i", pVertex[0]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[1]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[2]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void E_Object3::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Node* pN;
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	int newPID = atoi(sVar[1]);
	if (newPID != PID) {
		Property* pr = PT->GetItem(newPID);
		if (pr != NULL) {
			BOOL bC = SetProperty(pr);
			if (bC)
				outtext1("Property has Been Changed");
			else
				outtext1("Invalid Property");
		}
	}
	iMCys = atoi(sVar[2]);
	MAng = atof(sVar[3]);
	;
	dZOFFS = atof(sVar[4]);
	;
	;
	int N1 = atoi(sVar[5]);
	int N2 = atoi(sVar[6]);
	int N3 = atoi(sVar[7]);
	if (pVertex[0]->iLabel != N1) {
		pN = pMe->GetNode(N1);
		if (pN != NULL)
			pVertex[0] = pN;
	}
	if (pVertex[1]->iLabel != N2) {
		pN = pMe->GetNode(N2);
		if (pN != NULL)
			pVertex[1] = pN;
	}
	if (pVertex[2]->iLabel != N3) {
		pN = pMe->GetNode(N3);
		if (pN != NULL)
			pVertex[2] = pN;
	}
}

//*************************************************************************************
// Pre: TRUE
// Post: returns area in Y & Y plain only for 2d analysis
//*************************************************************************************
double E_Object3::GetArea2d() {
	C2dVector v, w;
	double dA;
	v.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	v.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	w.x = pVertex[2]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	w.y = pVertex[2]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	dA = 0.5 * abs(v.Cross(w));
	return (dA);
}

//*************************************************************************************
// Pre: Property Table and Material Table
// Post: Nodal masses in col vector
// This is an override for the general method in E_Object so we can
// deal with PCOMPs and NSM
//*************************************************************************************
Mat E_Object3::GetElNodalMass(PropTable* PropsT, MatTable* MatT) {
	int nip = 0;
	Mat coord;
	Mat deriv;
	Mat fun;
	Mat NT;
	Mat NS;
	Mat NM;
	Mat Points;
	Mat jac;
	int i;
	double det;
	Mat bT;
	int iDof = -1;
	int iS;
	int MID = -1;
	double dthk = 0.0;
	double dTotthk = 0.0;
	double dRho = 0;
	double dNSM = 0;
	char S1[80];
	Property* pS = NULL;
	Material* pM = NULL;

	// Get Shell Thicknes and Density
	// ************NEED TO DO BEAMS LATTER************

	pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		if (pS->iType == 1) // pShell
		{
			PSHELL* pSh = (PSHELL*) pS;
			dthk = pSh->dT;
			dNSM = pSh->dNSM;
			MID = pS->GetDefMatID();
			if (MatT != NULL)
				pM = MatT->GetItem(MID);
			if (pM != NULL)
				dRho = pM->GetDensity();
		} else if (pS->iType == 2) {
			PCOMP* pSh = (PCOMP*) pS;
			dNSM = pSh->dNSM;
			dTotthk = 0.0;
			dRho = 0.0;
			for (i = 0; i < pSh->iNoLays; i++) {
				dthk = pSh->T[i];
				dTotthk += dthk;
				dNSM = pSh->dNSM;
				MID = pS->GetDefMatID();
				if (MatT != NULL)
					pM = MatT->GetItem(pSh->MID[i]);
				if (pM != NULL) {
					dRho += pM->GetDensity() * dthk;
					// effective density
				}
			}
			if (dTotthk > 0) {
				dRho /= dTotthk;
				dthk = dTotthk;
			} else {
				dRho = 0;
				dthk = 0;
			}
		} else if (pS->iType == 222) {
			PCOMPG* pSh = (PCOMPG*) pS;
			dNSM = pSh->dNSM;
			dTotthk = 0.0;
			dRho = 0.0;
			for (i = 0; i < pSh->iNoLays; i++) {
				dthk = pSh->T[i];
				dTotthk += dthk;
				dNSM = pSh->dNSM;
				MID = pS->GetDefMatID();
				if (MatT != NULL)
					pM = MatT->GetItem(pSh->MID[i]);
				if (pM != NULL) {
					dRho += pM->GetDensity() * dthk;
					// effective density
				}
			}
			if (dTotthk > 0) {
				dRho /= dTotthk;
				dthk = dTotthk;
			} else {
				dRho = 0;
				dthk = 0;
			}
		} else {
			sprintf_s(S1, "ERROR: Invalid Property EL %i", iLabel);
			outtext1(S1);
		}
	} else {
		sprintf_s(S1, "ERROR: Property Not Found For EL %i", iLabel);
		outtext1(S1);
	}

	iDof = 2;
	nip = 1;
	iS = 3;
	//*********************JUST FOR TEST*******************************
	Mat AA(iNoNodes, 1);
	coord = getCoords3d();
	Points = Sample(nip);
	for (i = 1; i < nip + 1; i++) {
		det = 0;
		fun = ShapeFun(Points, i);
		deriv = ShapeDer(Points, i);
		jac = deriv * coord;
		jac = jac.InvertJac(det);
		NT = fun;
		NT.Transpose();
		// MM = NT * S;
		det *= *Points.mn(i, 3);
		NT *= det;
		AA += NT; // FS The shell nodal areas
		// Clean up
		fun.clear();
		deriv.clear();
		jac.clear();
		NT.clear();
	}

	// Mass Area*dRho*dThk+Area*NSM
	NM = AA;
	NS = AA;
	NM *= dthk * dRho; // Element nodal volume mass
	NS *= dNSM; // Element NSM per Area
	NM += NS;
	// FS.diag();
	coord.clear();
	Points.clear();
	AA.clear();
	NS.clear();
	return (NM);
}

double E_Object3::GetPHI_SQ() {
	return (PHI_SQ);
}

BOOL E_Object3::HasOffsets() {
	BOOL brc = FALSE;
	if (dZOFFS != 0)
		brc = TRUE;
	return (brc);
}

BOOL E_Object3::GetOffset(PropTable* PropsT, int iNode, C3dVector& vOff) {
	BOOL brc = FALSE;
	C3dVector vN;
	vOff = Get_Normal();
	// if its a pocmp wll have to include below
	// vOff *= dZOFFS + dPCompOff;
	// assuming its a PSHELL for now
	vOff *= dZOFFS;
	if (vOff.Mag() > 0)
		brc = TRUE;
	return (brc);
}

//*********************************
IMPLEMENT_DYNAMIC(E_Object1, CObject)

E_Object1::E_Object1() {
	G_Object();
}

E_Object1::~E_Object1() {
	pVertex = NULL;
}

void E_Object1::Create(Node* pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                       G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	pVertex = pInVertex[0];
	iCID = 0;
	dM = 0;
	dX1 = 0;
	dX2 = 0;
	dX3 = 0;
	dI11 = 0;
	dI21 = 0;
	dI22 = 0;
	dI31 = 0;
	dI32 = 0;
	dI33 = 0;
}

G_Object* E_Object1::GetNode(int i) {
	return (pVertex);
}

BOOL E_Object1::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	if (pVertex == pN) {
		brc = TRUE;
	}
	return (brc);
}

// needs replacing with mass property
Mat E_Object1::GetElNodalMass(PropTable* PropsT, MatTable* MatT) {
	double M = 0;
	char S1[80];
	if (PID == -1) {
		M = dM;
	} else {
		Property* pS = PropsT->GetItem(PID);
		if (pS != NULL) {
			if (pS->iType == 161) {
				PMASS* pM = (PMASS*) pS;
				M = pM->dM;
			} else {
				sprintf_s(S1, "ERROR INVALID PROPERTY FOR EL %i", iLabel);
				outtext1(S1);
			}
		} else {
			sprintf_s(S1, "ERROR INVALID NO VALID PROPERTY FOR EL %i", iLabel);
			outtext1(S1);
		}
	}

	Mat FS(iNoNodes, 1);
	*FS.mn(1, 1) = M;
	return (FS);
}

Vec<int> E_Object1::GetSteerVec3d() {
	Vec<int> V(1 * 3);
	*V.nn(1) = pVertex->dof[0];
	*V.nn(2) = pVertex->dof[1];
	*V.nn(3) = pVertex->dof[2];
	return (V);
}

Mat E_Object1::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL& bErr) {
	Mat KM(3, 3);
	KM.MakeZero();
	return (KM);
}

void E_Object1::RepNodeInEl(Node* pThis, Node* pWith) {
	if (pVertex == pThis) {
		pVertex = pWith;
	}
}

void E_Object1::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		ar << pVertex->iLabel;
		ar << sLab;
		ar << iCID;
		ar << dM;
		ar << dX1;
		ar << dX2;
		ar << dX3;
		ar << dI11;
		ar << dI21;
		ar << dI22;
		ar << dI31;
		ar << dI32;
		ar << dI33;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		ar >> iNd;
		pVertex = MESH->GetNode(iNd);
		if (iV < -55)
			ar >> sLab;
		ar >> iCID;
		ar >> dM;
		ar >> dX1;
		ar >> dX2;
		ar >> dX3;
		ar >> dI11;
		ar >> dI21;
		ar >> dI22;
		ar >> dI31;
		ar >> dI32;
		ar >> dI33;
	}
}

void E_Object1::ExportUNV(FILE* pFile) {
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	fprintf(pFile, "%10i\n", pVertex->iLabel);
}

void E_Object1::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%s", ToString().GetString());
}

CString E_Object1::ToString() {
	char S[80] = "";
	CString src = "";
	sprintf_s(S, "$%s\n", sLab.GetString());
	src = S;
	sprintf_s(S, "%8s%8i%8i%8i%8s%8s%8s%8s\n", "CONM2   ", iLabel, pVertex->iLabel, iCID, e8(dM).GetString(),
	          e8(dX1).GetString(), e8(dX2).GetString(), e8(dX3).GetString());
	src += S;
	sprintf_s(S, "%8s%8s%8s%8s%8s%8s%8s\n", "        ", e8(dI11).GetString(), e8(dI21).GetString(),
	          e8(dI22).GetString(), e8(dI31).GetString(), e8(dI32).GetString(), e8(dI33).GetString());
	src += S;
	return (src);
}

void E_Object1::Transform(C3dMatrix TMat) {
	TMat.ClearTranslations();
	C3dVector vOff;
	vOff.Set(dX1, dX2, dX3);
	vOff = TMat * vOff;
	C3dMatrix mI;
	mI.MakeUnit();

	mI.m_00 = dI11;
	mI.m_10 = dI21;
	mI.m_20 = dI31;

	mI.m_01 = dI21;
	mI.m_11 = dI22;
	mI.m_21 = dI32;

	mI.m_02 = dI31;
	mI.m_12 = dI32;
	mI.m_22 = dI33;
	mI *= TMat;
	dI11 = mI.m_00;
	dI21 = mI.m_10;
	dI31 = mI.m_20;

	dI21 = mI.m_01;
	dI22 = mI.m_11;
	dI32 = mI.m_21;

	dI31 = mI.m_02;
	dI32 = mI.m_12;
	dI33 = mI.m_22;
}

G_Object* E_Object1::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object1* gret = new E_Object1;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex = MESH->GetNode(this->pVertex->iLabel);

	gret->iCID = iCID;
	gret->dM = dM;
	gret->dX1 = dX1;
	gret->dX2 = dX2;
	gret->dX3 = dX3;
	gret->dI11 = dI11;
	gret->dI21 = dI21;
	gret->dI22 = dI22;
	gret->dI31 = dI31;
	gret->dI32 = dI32;
	gret->dI33 = dI33;
	gret->pPr = pPr;
	gret->pParent = MESH;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object1::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object1* gret = new E_Object1;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex);
	EInd += iSInd;
	gret->pVertex = Target->pNodes[EInd];
	gret->iCID = iCID;
	gret->dM = dM;
	gret->dX1 = dX1;
	gret->dX2 = dX2;
	gret->dX3 = dX3;
	gret->dI11 = dI11;
	gret->dI21 = dI21;
	gret->dI22 = dI22;
	gret->dI31 = dI31;
	gret->dI32 = dI32;
	gret->dI33 = dI33;
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object1::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object1* gret = new E_Object1;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex = pInVertex[0];
	gret->iCID = iCID;
	gret->dM = dM;
	gret->dX1 = dX1;
	gret->dX2 = dX2;
	gret->dX3 = dX3;
	gret->dI11 = dI11;
	gret->dI21 = dI21;
	gret->dI22 = dI22;
	gret->dI31 = dI31;
	gret->dI32 = dI32;
	gret->dI33 = dI33;
	gret->pPr = pPr;
	gret->pParent = Parrent;
	gret->pResV = NULL;
	return (gret);
}

// Draw Object line
void E_Object1::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex->DSP_Point->x - 5, (int) pVertex->DSP_Point->y - 5);
	pDC->LineTo((int) pVertex->DSP_Point->x + 5, (int) pVertex->DSP_Point->y - 5);
	pDC->LineTo((int) pVertex->DSP_Point->x + 5, (int) pVertex->DSP_Point->y + 5);
	pDC->LineTo((int) pVertex->DSP_Point->x - 5, (int) pVertex->DSP_Point->y + 5);
	pDC->LineTo((int) pVertex->DSP_Point->x - 5, (int) pVertex->DSP_Point->y - 5);
}

void E_Object1::OglDraw(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	C3dVector d;
	C3dVector vCent;
	double dS = 0;
	double dFS = 0.0;
	double S = 0;
	d.x = 0;
	d.y = 0;
	d.z = 0;
	vCent = this->Get_Centroid();
	ME_Object* ME = (ME_Object*) this->pParent;

	S = ME->dScale;
	dFS = ME->dResFactor;
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			if (pVertex->pResD != NULL) {
				d = pVertex->pResD->GetVec();
				d -= ME->vRelDispOff;
				d *= S * dFS;
			}
		}
		Selectable = 1;
		glColor3fv(cols[GetCol()]);
		glPointSize(gLM_SIZE);
		glBegin(GL_POINTS);
		glVertex3f((float) vCent.x + d.x, (float) vCent.y + d.y, (float) vCent.z + d.z);
		glEnd();
	} else {
		Selectable = 0;
	}

	// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
	if (gLBL_DSP_TRG)
		bDrawLab = FALSE;
	if (bDrawLab == TRUE)
	// Esp_Mod_Labels_4_27_2025_End
	{
		sprintf_s(sLab, "N%i", iLabel);
		OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
	}
}

void E_Object1::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	OglDraw(iDspFlgs, dS1, dS2);
}

C3dVector E_Object1::Get_Centroid() {
	C3dVector vT;
	vT.x = pVertex->Pt_Point->x;
	vT.y = pVertex->Pt_Point->y;
	vT.z = pVertex->Pt_Point->z;
	return (vT);
}

int E_Object1::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "COMMENT";
	iNo++;
	sVar[iNo] = "PID";
	iNo++;
	sVar[iNo] = "CID";
	iNo++;
	sVar[iNo] = "Mass";
	iNo++;
	sVar[iNo] = "MX1";
	iNo++;
	sVar[iNo] = "MX2";
	iNo++;
	sVar[iNo] = "MX3";
	iNo++;
	sVar[iNo] = "MI11";
	iNo++;
	sVar[iNo] = "MI21";
	iNo++;
	sVar[iNo] = "MI22";
	iNo++;
	sVar[iNo] = "MI31";
	iNo++;
	sVar[iNo] = "MI32";
	iNo++;
	sVar[iNo] = "MI33";
	iNo++;
	sVar[iNo] = "N1";
	iNo++;
	return (iNo);
}

//"CONM2   "
CString E_Object1::GetName() {
	return ("Mass (CONM2)");
}

int E_Object1::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	iNo++;
	sVar[iNo] = sLab;
	iNo++;
	sprintf_s(S1, "%i", PID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iCID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dM);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dX1);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dX2);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dX3);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dI11);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dI21);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dI22);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dI31);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dI32);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dI33);
	sVar[iNo] = S1;
	iNo++;

	sprintf_s(S1, "%i", pVertex->iLabel);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void E_Object1::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Node* pN;
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	sLab = sVar[1];
	PID = atoi(sVar[2]);
	iCID = atoi(sVar[3]);
	dM = atof(sVar[4]);
	;
	dX1 = atof(sVar[5]);
	;
	dX2 = atof(sVar[6]);
	;
	dX3 = atof(sVar[7]);
	;
	dI11 = atof(sVar[8]);
	;
	dI21 = atof(sVar[9]);
	;
	dI22 = atof(sVar[10]);
	;
	dI31 = atof(sVar[11]);
	;
	dI32 = atof(sVar[12]);
	;
	dI33 = atof(sVar[13]);
	;
	int N1 = atof(sVar[14]);
	;
	if (pVertex->iLabel != N1) {
		pN = pMe->GetNode(N1);
		if (pN != NULL)
			pVertex = pN;
	}
}

void E_Object1::Info() {
	char S1[200];
	G_Object::Info();
	sprintf_s(S1, "%sEID,%i,COL,%i,GRID,%i,MASS,%f,XYZ, %f,%f,%f ", sLab.GetString(), iLabel, iColour, pVertex->iLabel,
	          dM, pVertex->Pt_Point->x, pVertex->Pt_Point->y, pVertex->Pt_Point->z);
	outtext1(S1);
}

IMPLEMENT_DYNAMIC(E_CellS, CObject)

E_CellS::~E_CellS() {
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	pVertex[2] = NULL;
	pVertex[3] = NULL;
	pVertex[4] = NULL;
}

void E_CellS::Create(Node* pInVertex[100], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                     G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);

	int i = 0;
	for (i = 0; i < 5; i++) {
		pVertex[i] = pInVertex[i];
	}
}

void E_CellS::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		ar << pVertex[0]->iLabel;
		ar << pVertex[1]->iLabel;
		ar << pVertex[2]->iLabel;
		ar << pVertex[3]->iLabel;
		ar << pVertex[4]->iLabel;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		ar >> iNd;
		pVertex[0] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[1] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[2] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[3] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[4] = MESH->GetNode(iNd);
	}
	pPr = NULL;
}

G_Object* E_CellS::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_CellS* gret = new E_CellS;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->pVertex[2] = MESH->GetNode(pVertex[2]->iLabel);
	gret->pVertex[3] = MESH->GetNode(pVertex[3]->iLabel);
	gret->pVertex[4] = MESH->GetNode(pVertex[4]->iLabel);
	gret->pParent = MESH;
	gret->pPr = pPr;

	return (gret);
}

G_Object* E_CellS::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_CellS* gret = new E_CellS;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[2]);
	gret->pVertex[2] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[3]);
	gret->pVertex[3] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[4]);
	gret->pVertex[4] = Target->pNodes[EInd + iSInd];
	gret->pParent = Target;
	gret->pPr = NULL;
	return (gret);
}

G_Object* E_CellS::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_CellS* gret = new E_CellS;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->pVertex[2] = pInVertex[2];
	gret->pVertex[3] = pInVertex[3];
	gret->pVertex[4] = pInVertex[4];
	gret->pParent = Parrent;
	gret->pPr = pPr;
	return (gret);
}

// Draw Object line
void E_CellS::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);
	pDC->MoveTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[4]->DSP_Point->x, (int) pVertex[4]->DSP_Point->y);
}

BOOL E_CellS::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_CellS::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

G_Object* E_CellS::GetNode(int i) {
	return (pVertex[i]);
}

C3dVector E_CellS::Get_Centroid() {
	return (pVertex[0]->Get_Centroid());
}

void E_CellS::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		Selectable = 1;
		glEnable(GL_LINE_STIPPLE);
		glLineStipple(1, 0x0101);
		glColor3fv(cols[iColour]);
		glBegin(GL_LINES);
		glVertex3f((float) pVertex[1]->Pt_Point->x, (float) pVertex[1]->Pt_Point->y, (float) pVertex[1]->Pt_Point->z);
		glVertex3f((float) pVertex[3]->Pt_Point->x, (float) pVertex[3]->Pt_Point->y, (float) pVertex[3]->Pt_Point->z);
		glVertex3f((float) pVertex[2]->Pt_Point->x, (float) pVertex[2]->Pt_Point->y, (float) pVertex[2]->Pt_Point->z);
		glVertex3f((float) pVertex[0]->Pt_Point->x, (float) pVertex[0]->Pt_Point->y, (float) pVertex[0]->Pt_Point->z);
		glEnd();
		glDisable(GL_LINE_STIPPLE);
		glBegin(GL_LINES);
		glVertex3f((float) pVertex[0]->Pt_Point->x, (float) pVertex[0]->Pt_Point->y, (float) pVertex[0]->Pt_Point->z);
		glVertex3f((float) pVertex[4]->Pt_Point->x, (float) pVertex[4]->Pt_Point->y, (float) pVertex[4]->Pt_Point->z);
		glEnd();
		C3dVector vCent;
		vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "E%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
	} else {
		Selectable = 0;
	}
}

void E_CellS::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

//----------------------------------------------------------------------------
//    E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_Object4, CObject)

E_Object4::E_Object4() {
	G_Object();
}

E_Object4::~E_Object4() {
	pVertex[0] = NULL;
	pVertex[1] = NULL;
	pVertex[2] = NULL;
	pVertex[3] = NULL;
}

int E_Object4::MaxBW() {
	int i;
	int j;
	int MaxDof;
	int MinDof;
	MaxDof = 0;
	MinDof = 99999999;
	for (i = 0; i < iNoNodes; i++) {
		for (j = 0; j < 6; j++) {
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] > MaxDof)) {
				MaxDof = pVertex[i]->dof[j];
			}
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] < MinDof)) {
				MinDof = pVertex[i]->dof[j];
			}
		}
	}
	int iRC;
	if (MaxDof - MinDof < 0) {
		iRC = 0;
	} else {
		iRC = MaxDof - MinDof;
	}
	return (iRC);
}

Mat E_Object4::Sample(int iNo) {
	Mat Pts(iNo, 3);
	if (iNo == 1) {
		*Pts.mn(1, 1) = 0;
		*Pts.mn(1, 2) = 0;
		*Pts.mn(1, 3) = 4;
	} else if (iNo == 4) {
		double r3 = 0.577350269189626;
		;
		*Pts.mn(1, 1) = -r3;
		*Pts.mn(2, 1) = r3;
		*Pts.mn(3, 1) = r3;
		*Pts.mn(4, 1) = -r3;

		*Pts.mn(1, 2) = -r3;
		*Pts.mn(2, 2) = -r3;
		*Pts.mn(3, 2) = +r3;
		*Pts.mn(4, 2) = +r3;

		// below as in mystran not the same??
		//*Pts.mn(1,1) = -r3;
		//*Pts.mn(2,1) = -r3;
		//*Pts.mn(3,1) = r3;
		//*Pts.mn(4,1) = r3;

		//*Pts.mn(1,2) = -r3;
		//*Pts.mn(2,2) = r3;
		//*Pts.mn(3,2) = -r3;
		//*Pts.mn(4,2) = +r3;

		*Pts.mn(1, 3) = 1;
		*Pts.mn(2, 3) = 1;
		*Pts.mn(3, 3) = 1;
		*Pts.mn(4, 3) = 1;
	}

	else if (iNo == 9) // Used for the shell transverse shear terms
	{
		*Pts.mn(1, 1) = -0.774597E+00;
		*Pts.mn(1, 2) = -0.774597E+00;
		*Pts.mn(1, 3) = 0.308642E+00;
		*Pts.mn(2, 1) = -0.774597E+00;
		*Pts.mn(2, 2) = 0.000000E+00;
		*Pts.mn(2, 3) = 0.493827E+00;
		*Pts.mn(3, 1) = -0.774597E+00;
		*Pts.mn(3, 2) = 0.774597E+00;
		*Pts.mn(3, 3) = 0.308642E+00;
		*Pts.mn(4, 1) = 0.000000E+00;
		*Pts.mn(4, 2) = -0.774597E+00;
		*Pts.mn(4, 3) = 0.493827E+00;
		*Pts.mn(5, 1) = 0.000000E+00;
		*Pts.mn(5, 2) = 0.000000E+00;
		*Pts.mn(5, 3) = 0.790123E+00;
		*Pts.mn(6, 1) = 0.000000E+00;
		*Pts.mn(6, 2) = 0.774597E+00;
		*Pts.mn(6, 3) = 0.493827E+00;
		*Pts.mn(7, 1) = 0.774597E+00;
		*Pts.mn(7, 2) = -0.774597E+00;
		*Pts.mn(7, 3) = 0.308642E+00;
		*Pts.mn(8, 1) = 0.774597E+00;
		*Pts.mn(8, 2) = 0.000000E+00;
		*Pts.mn(8, 3) = 0.493827E+00;
		*Pts.mn(9, 1) = 0.774597E+00;
		*Pts.mn(9, 2) = 0.774597E+00;
		*Pts.mn(9, 3) = 0.308642E+00;
	}
	return (Pts);
}

Mat E_Object4::ShapeDer(Mat Points, int i) {
	Mat der(2, 4);
	double xi, eta;
	xi = *Points.mn(i, 1);
	eta = *Points.mn(i, 2);

	*der.mn(1, 1) = 0.25 * (-1 + eta);
	*der.mn(1, 2) = 0.25 * (1 - eta);
	*der.mn(1, 3) = 0.25 * (1 + eta);
	*der.mn(1, 4) = 0.25 * (-1 - eta);

	*der.mn(2, 1) = 0.25 * (-1 + xi);
	*der.mn(2, 2) = 0.25 * (-1 - xi);
	*der.mn(2, 3) = 0.25 * (1 + xi);
	*der.mn(2, 4) = 0.25 * (1 - xi);

	return (der);
}

Mat E_Object4::ShapeFun(Mat Points, int i) {
	Mat fun(1, 4);
	double xi, eta;
	xi = *Points.mn(i, 1);
	eta = *Points.mn(i, 2);

	*fun.mn(1, 1) = 0.25 * (1 - xi) * (1 - eta);
	*fun.mn(1, 2) = 0.25 * (1 + xi) * (1 - eta);
	*fun.mn(1, 3) = 0.25 * (1 + xi) * (1 + eta);
	*fun.mn(1, 4) = 0.25 * (1 - xi) * (1 + eta);
	return (fun);
}

Mat E_Object4::getCoords2d() {
	int i;
	Mat coord(iNoNodes, 2);
	for (i = 0; i < iNoNodes; i++) {
		*coord.mn(i + 1, 1) = pVertex[i]->Pt_Point->x;
		*coord.mn(i + 1, 2) = pVertex[i]->Pt_Point->y;
	}
	return (coord);
}

//*******************************************************************
// Get The coordinates after transforming the element to the XY plain
//********************************************************************
Mat E_Object4::getCoords3d() {
	int i;
	C3dVector p;
	Mat coord(iNoNodes, 2);
	C3dMatrix M3 = this->GetElSys();
	// M3.Transpose();
	for (i = 0; i < iNoNodes; i++) {
		C3dVector p, v;
		p.x = pVertex[i]->Pt_Point->x;
		p.y = pVertex[i]->Pt_Point->y;
		p.z = pVertex[i]->Pt_Point->z;
		// M3.MakeUnit();
		v = M3.Mult(p);
		*coord.mn(i + 1, 1) = v.x;
		*coord.mn(i + 1, 2) = v.y;
	}
	return (coord);
}

Vec<int> E_Object4::GetSteerVec3d() {
	Vec<int> V(24);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[0]->dof[3];
	*V.nn(5) = pVertex[0]->dof[4];
	*V.nn(6) = pVertex[0]->dof[5];

	*V.nn(7) = pVertex[1]->dof[0];
	*V.nn(8) = pVertex[1]->dof[1];
	*V.nn(9) = pVertex[1]->dof[2];
	*V.nn(10) = pVertex[1]->dof[3];
	*V.nn(11) = pVertex[1]->dof[4];
	*V.nn(12) = pVertex[1]->dof[5];

	*V.nn(13) = pVertex[2]->dof[0];
	*V.nn(14) = pVertex[2]->dof[1];
	*V.nn(15) = pVertex[2]->dof[2];
	*V.nn(16) = pVertex[2]->dof[3];
	*V.nn(17) = pVertex[2]->dof[4];
	*V.nn(18) = pVertex[2]->dof[5];

	*V.nn(19) = pVertex[3]->dof[0];
	*V.nn(20) = pVertex[3]->dof[1];
	*V.nn(21) = pVertex[3]->dof[2];
	*V.nn(22) = pVertex[3]->dof[3];
	*V.nn(23) = pVertex[3]->dof[4];
	*V.nn(24) = pVertex[3]->dof[5];
	return (V);
}

Vec<int> E_Object4::GetSteerVec3d_E() {
	Vec<int> V(12);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[0]->dof[1];
	*V.nn(3) = pVertex[0]->dof[2];
	*V.nn(4) = pVertex[1]->dof[0];
	*V.nn(5) = pVertex[1]->dof[1];
	*V.nn(6) = pVertex[1]->dof[2];
	*V.nn(7) = pVertex[2]->dof[0];
	*V.nn(8) = pVertex[2]->dof[1];
	*V.nn(9) = pVertex[2]->dof[2];
	*V.nn(10) = pVertex[3]->dof[0];
	*V.nn(11) = pVertex[3]->dof[1];
	*V.nn(12) = pVertex[3]->dof[2];
	return (V);
}

Vec<int> E_Object4::GetSteerVec1d() {
	Vec<int> V(4 * 1);
	*V.nn(1) = pVertex[0]->dof[0];
	*V.nn(2) = pVertex[1]->dof[0];
	*V.nn(3) = pVertex[2]->dof[0];
	*V.nn(4) = pVertex[3]->dof[0];
	return (V);
}

Mat E_Object4::bmatAxi(double& radius,
                       Mat& coord,
                       Mat& deriv,
                       Mat& fun) {
	int nod, i, k, l, m;
	double x, y;
	nod = deriv.n;
	Mat bee(4, 8);
	radius = 0;
	for (i = 1; i < 4 + 1; i++) {
		radius = radius + *fun.mn(1, i) * *coord.mn(i, 1);
	}
	for (m = 1; m < nod + 1; m++) {
		k = 2 * m;
		l = k - 1;
		x = *deriv.mn(1, m);
		*bee.mn(1, l) = x;
		*bee.mn(3, k) = x;
		y = *deriv.mn(2, m);
		*bee.mn(2, k) = y;
		*bee.mn(3, l) = y;
		*bee.mn(4, l) = *fun.mn(1, m) / radius;
	}
	return (bee);
}

// strain displacement matrix 1 pt integration for explicit
// Analysis

Mat E_Object4::GetB_1pt(double& det) {
	Mat bee;
	Mat deriv;
	Mat deriv2;
	Mat fun;
	Mat Points;
	Mat jac;
	Mat coord;
	// This part calculates the 2d membraine stiffness
	int iDof = 2; // 2 dof X,Y per node
	int nip = 1; // 1 intergration points
	int iS = 3;
	Points = this->Sample(nip);
	det = 0;

	C3dMatrix M3 = this->GetElSys();
	coord = this->getCoords3d();
	fun = this->ShapeFun(Points, 1);
	deriv = this->ShapeDer(Points, 1);
	jac = deriv * coord;
	jac = jac.InvertJac(det);
	det *= *Points.mn(1, 3); //*det by the weight
	deriv2 = jac * deriv;
	bee = this->bmat(coord, deriv2, iS, iDof);
	coord.clear();
	fun.clear();
	jac.clear();
	deriv.clear();
	deriv2.clear();
	return (bee);
}

// For explicit membraine shell analysis
Mat E_Object4::GetStiffMat_Ex(PropTable* PropsT, MatTable* MatT) {
	Mat bee; // strain displacement matrix
	int nip = 0;

	Mat coord2;
	Mat deriv;
	Mat deriv2;
	Mat fun;
	Mat Points;
	Mat jac;
	int i;
	double det;
	Mat bT;
	Mat db;
	Mat bdb;
	int iDof;
	int iS;
	int MID = -1;
	double dE = 210e9;
	double dv = 0.29;
	char S1[80];
	double dthk = 0.001;

	Property* pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		MID = pS->GetDefMatID();
	}
	Material* pM = MatT->GetItem(MID);
	if (pS == NULL) {
		sprintf_s(S1, "ERROR: PROPERTY NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	if (pM == NULL) {
		sprintf_s(S1, "ERROR: MATERIAL NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	// Get Shell thickness

	if (((iType == 91) || (iType == 94)) && (pS != NULL)) {
		PSHELL* pSh = (PSHELL*) pS;
		dthk = pSh->dT;
	}

	if ((pM != NULL) && (pM->iType = 1)) {
		MAT1* pIsen = (MAT1*) pM;
		dE = pIsen->dE;
		dv = pIsen->dNU;
	}
	// This part calculates the 2d membraine stiffness
	iDof = 2; // 2 dof X,Y per node
	nip = 4; // 4 intergration points
	iS = 3;

	Mat KM(iDof * iNoNodes, iDof * iNoNodes);
	Mat dee = DeeMat(dE, dv, iS); // plain stress material matrix
	Mat coord = getCoords3d(); // Nodal Coordinates
	C3dMatrix M3 = this->GetElSys(); // Element Coordinate system
	// M3.MakeUnit();
	Points = Sample(nip); // sample points for integration
	// Membraine stiffness calculation
	// for dof 12
	for (i = 1; i < nip + 1; i++) // for all integration points
	{
		det = 0;
		fun.clear();
		deriv.clear();
		jac.clear(), deriv2.clear();
		bT.clear();
		db.clear();
		bdb.clear();
		bee.clear();
		fun = ShapeFun(Points, i);
		deriv = ShapeDer(Points, i);
		jac = deriv * coord;
		jac = jac.InvertJac(det);
		deriv2 = jac * deriv;
		bee = bmat(coord, deriv2, iS, iDof);
		bT = bee;
		bT.Transpose();
		db = dee * bee;
		bdb = bT * db;
		det *= *Points.mn(i, 3);
		bdb *= det;
		KM += bdb;
	}
	KM *= dthk;
	fun.clear();
	deriv.clear();
	jac.clear(), deriv2.clear();
	bT.clear();
	db.clear();
	bdb.clear();
	bee.clear();
	return (KM);
}

Mat E_Object4::getCoords_XEL() {
	int i;
	double dx, dy, dz;

	C3dVector p;
	Mat coord(iNoNodes, 3);
	C3dMatrix M3 = this->GetElSys();
	// M3.Transpose();
	for (i = 0; i < iNoNodes; i++) {
		C3dVector p, v;
		p.x = pVertex[i]->Pt_Point->x - pVertex[0]->Pt_Point->x;
		p.y = pVertex[i]->Pt_Point->y - pVertex[0]->Pt_Point->y;
		p.z = pVertex[i]->Pt_Point->z - pVertex[0]->Pt_Point->z;
		v = M3.Mult(p);
		*coord.mn(i + 1, 1) = v.x;
		*coord.mn(i + 1, 2) = v.y;
		*coord.mn(i + 1, 3) = v.z;
		dx = *coord.mn(i + 1, 1);
		dy = *coord.mn(i + 1, 2);
		dz = *coord.mn(i + 1, 3);
	}
	return (coord);
}

const double MXWARP = 0.0000001;
// Calculate KE for membrane
Mat E_Object4::QMEM1_KE(int OPT, double AREA, Vec<double> X2E, Vec<double> X3E, Mat SHELL_A) {
	// NOTE THIS IS NOT USING REDUCED INTEGRATION AS IN MYSTRAN
	int i, j, k;
	double det;
	Mat bee; // strain displacement matrix
	Mat coord2;
	Mat deriv;
	Mat deriv2;
	Mat fun;
	Mat Points;
	Mat jac;
	Mat bT;
	Mat db;
	Mat bdb;
	int iDof = 2; // 2 dof X,Y per node
	int nip = 4; // 4 intergration points
	int iS = 3;
	Vec<int> ID(8);
	*ID.nn(1) = 1;
	*ID.nn(2) = 2;
	*ID.nn(3) = 7;
	*ID.nn(4) = 8;
	*ID.nn(5) = 13;
	*ID.nn(6) = 14;
	*ID.nn(7) = 19;
	*ID.nn(8) = 20;
	Vec<int> ID2(12);
	*ID2.nn(1) = 1;
	*ID2.nn(2) = 2;
	*ID2.nn(3) = 3;
	*ID2.nn(4) = 7;
	*ID2.nn(5) = 8;
	*ID2.nn(6) = 9;
	*ID2.nn(7) = 13;
	*ID2.nn(8) = 14;
	*ID2.nn(9) = 15;
	*ID2.nn(10) = 19;
	*ID2.nn(11) = 20;
	*ID2.nn(12) = 21;
	Mat KM(iDof * iNoNodes, iDof * iNoNodes);
	Mat KMf(6 * iNoNodes, 6 * iNoNodes); // Full stiffness matrix
	Mat coord = getCoords3d(); // Nodal Coordinates
	C3dMatrix M3 = this->GetElSys(); // Element Coordinate system
	Points = Sample(nip); // sample points for integration
	// Membraine stiffness calculation
	Vec<double> DetJ(4);
	Mat BEE[4];
	int GAUSS_PT = 0;
	// Points.diag();
	for (i = 1; i < nip + 1; i++) // for all integration points
	{
		GAUSS_PT = GAUSS_PT + 1;
		det = 0;
		fun = ShapeFun(Points, i);
		deriv = ShapeDer(Points, i);
		jac = deriv * coord;
		jac = jac.InvertJac(det);
		*DetJ.nn(GAUSS_PT) = det;
		deriv2 = jac * deriv;
		bee = bmat(coord, deriv2, iS, iDof); // 3*8 for 1 gauss pt
		BEE[GAUSS_PT - 1] = bee;
		// BEE[GAUSS_PT - 1].diag();
		fun.clear();
		deriv.clear();
		jac.clear(), deriv2.clear();
	}
	// reducing the shear terms??
	double SUMB, SUMD;
	for (j = 1; j < 2 * iNoNodes + 1; j++) {
		SUMB = 0;
		SUMD = 0;
		for (k = 1; k < nip + 1; k++) {
			SUMB = SUMB + *DetJ.nn(k) * *BEE[k - 1].mn(3, j);
			SUMD = SUMD + *DetJ.nn(k);
		}
		SUMB = SUMB;
		for (k = 1; k < nip + 1; k++) {
			*BEE[k - 1].mn(3, j) = SUMB / SUMD;
		}
	}

	for (i = 1; i < nip + 1; i++) // for all integration points
	{
		bee = BEE[i - 1];
		bT = bee;
		bT.Transpose();
		db = SHELL_A * bee;
		bdb = bT * db;
		det *= *Points.mn(i, 3);
		bdb *= *DetJ.nn(i);
		;
		KM += bdb;
		fun.clear();
		deriv.clear();
		jac.clear(), deriv2.clear();
		bT.clear();
		db.clear();
		bdb.clear();
		bee.clear();
		jac.clear();
	}
	double dWarp;
	Mat BMEAN = WARP_BMEAN(dWarp);
	Mat BMEANT;
	BMEANT = BMEAN; // transform to accout for warp
	BMEANT.Transpose();
	Mat KMWp;
	if (dWarp > MXWARP) // It slightly warped need to mod K terms
	{
		KMWp = BMEAN * KM; // my function returns BMEAN not BMEANT
		KM.clear();
		KM = KMWp * BMEANT;
		for (i = 1; i <= 12; i++) {
			for (j = 1; j <= 12; j++) {
				*KMf.mn(ID2[i - 1], ID2[j - 1]) = *KM.mn(i, j);
			}
		}
	} else {
		for (i = 1; i <= 8; i++) {
			for (j = 1; j <= 8; j++) {
				*KMf.mn(ID[i - 1], ID[j - 1]) = *KM.mn(i, j);
			}
		}
	}
	for (i = 0; i < 4; i++)
		BEE[i].clear();
	KM.clear();
	KMWp.clear();
	Points.clear();
	BMEANT.clear();
	BMEAN.clear();
	ID.clear();
	ID2.clear();
	// KMf.diag();
	return (KMf);
}

Mat E_Object4::QPLT2_BEE_DD(Mat deriv) {
	Mat BB(3, 8);
	int JJ = 0;
	int j = 0;
	for (j = 1; j < 4 + 1; j++) {
		JJ = JJ + 1;
		*BB.mn(1, JJ) = 0;
		*BB.mn(2, JJ) = -*deriv.mn(2, j);
		*BB.mn(3, JJ) = -*deriv.mn(1, j);

		JJ = JJ + 1;
		*BB.mn(1, JJ) = *deriv.mn(1, j);
		*BB.mn(2, JJ) = 0;
		*BB.mn(3, JJ) = *deriv.mn(2, j);
	}
	return (BB);
}

// Calcs and checks elem geometry for quad elemsand provides a transformation matrix(TE) to transfer the elem stiffness matrix
//! in the elem system to the basic coordinate system.Calculates grid point coords in local coord system.
//! To define the elem coordinate system, a mean plane is defined which lies midway between the grid points(HBAR is mean dist).
//! The elem z direction is in the direction of the cross product of the diagonals(V13 x V24).Initially, the x axis is along
//! side 1 - 2 of the elem projection onto the mean plane.For elems thet are not rectangular, the x, y axes are rotated such that x
//! splits the angle between the diagonals.
Mat E_Object4::WARP_BMEAN(double& dWarped) {
	Mat BMEAN(12, 8);
	C3dVector V13B;
	C3dVector V24B;
	C3dVector V12B;
	C3dVector KVEC;
	C3dVector IVEC;
	C3dVector JVEC;
	C3dVector tmp;
	double HBAR = 0;
	double X12 = 0;
	double X13 = 0;
	double X24 = 0;
	double X14 = 0;
	double X23 = 0;
	double X34 = 0;
	double Y3 = 0;
	double Y4 = 0;
	double Y34 = 0;
	double L12 = 0;
	double L23 = 0;
	double L34 = 0;
	double L41 = 0;
	double X3 = 0;
	double X4 = 0;

	double SIN_TH1 = 0;
	double COS_TH1 = 0;
	double SIN_TH2 = 0;
	double COS_TH2 = 0;
	double SIN_GAM = 0;
	double COS_GAM = 0;
	double CTN_TH1 = 0;
	double CTN_TH2 = 0;
	double DELTA1 = 0;
	double DELTA2 = 0;

	// Note the checks are done with element aligned GP 1-2
	// Generate vectors from G.P 1 to G.P 3 and from G.P. 2 to G.P. 4 (diagonals)
	V13B = pVertex[3 - 1]->Get_Centroid() - pVertex[1 - 1]->Get_Centroid();
	V24B = pVertex[4 - 1]->Get_Centroid() - pVertex[2 - 1]->Get_Centroid();
	KVEC = V13B.Cross(V24B);
	KVEC.Normalize();
	// Calc initial elem x dir along side 1 - 2 of the elem projection onto the mean plane.
	V12B = pVertex[2 - 1]->Get_Centroid() - pVertex[1 - 1]->Get_Centroid();
	// HBAR is one half of the projection of V12B in z direction
	HBAR = 0.5 * V12B.Dot(KVEC); // measure of warping
	dWarped = abs(HBAR);
	// Now calculate initial x direction along side 1 - 2 of the elem projection onto the mean plane.
	tmp = KVEC;
	tmp *= 2 * HBAR;
	IVEC = V12B;
	IVEC -= tmp;
	IVEC.Normalize();
	// Calculate unit vector in initial elem.y direction(from KVEC x IVEC) :
	JVEC = KVEC.Cross(IVEC);
	JVEC.Normalize();
	// Variables used in checking geometry
	X12 = -V12B.Dot(IVEC); //-(V12B(1) * IVEC(1) + V12B(2) * IVEC(2) + V12B(3) * IVEC(3))
	X13 = -V13B.Dot(IVEC); //-(V13B(1) * IVEC(1) + V13B(2) * IVEC(2) + V13B(3) * IVEC(3))
	X24 = -V24B.Dot(IVEC); //-(V24B(1) * IVEC(1) + V24B(2) * IVEC(2) + V24B(3) * IVEC(3))
	X14 = X12 + X24;
	X23 = X13 - X12;
	X34 = X14 - X13;
	Y3 = V13B.Dot(JVEC); //(V13B(1) * JVEC(1) + V13B(2) * JVEC(2) + V13B(3) * JVEC(3))
	Y4 = V24B.Dot(JVEC); //(V24B(1) * JVEC(1) + V24B(2) * JVEC(2) + V24B(3) * JVEC(3))
	Y34 = Y3 - Y4;
	L12 = abs(X12);
	L23 = sqrt(X23 * X23 + Y3 * Y3);
	L34 = sqrt(X34 * X34 + Y34 * Y34);
	L41 = sqrt(X14 * X14 + Y4 * Y4);
	X3 = -X13;
	X4 = -X14;
	//*********************************************
	SIN_TH1 = Y4 / L41;
	COS_TH1 = -X14 / L41;
	SIN_TH2 = Y3 / L23;
	COS_TH2 = X23 / L23;
	SIN_GAM = (Y4 - Y3) / L34;
	COS_GAM = (X3 - X4) / L34;
	CTN_TH1 = COS_TH1 / SIN_TH1;
	CTN_TH2 = COS_TH2 / SIN_TH2;
	DELTA1 = SIN_TH2 * COS_GAM - COS_TH2 * SIN_GAM;
	DELTA2 = SIN_TH1 * COS_GAM + COS_TH1 * SIN_GAM;

	*BMEAN.mn(1, 1) = 1;
	*BMEAN.mn(2, 2) = 1;
	*BMEAN.mn(4, 3) = 1;
	*BMEAN.mn(5, 4) = 1;
	*BMEAN.mn(7, 5) = 1;
	*BMEAN.mn(8, 6) = 1;
	*BMEAN.mn(10, 7) = 1;
	*BMEAN.mn(11, 8) = 1;
	*BMEAN.mn(3, 1) = HBAR / L12;
	*BMEAN.mn(3, 2) = -HBAR * (CTN_TH1 / L12 - 1 / (L41 * SIN_TH1));
	*BMEAN.mn(3, 3) = -*BMEAN.mn(3, 1);
	*BMEAN.mn(3, 4) = -HBAR * CTN_TH2 / L12;
	*BMEAN.mn(3, 7) = -HBAR * SIN_GAM / (L41 * DELTA2);
	*BMEAN.mn(3, 8) = -HBAR * COS_GAM / (L41 * DELTA2);

	*BMEAN.mn(6, 1) = -*BMEAN.mn(3, 1);
	*BMEAN.mn(6, 2) = HBAR * CTN_TH1 / L12;
	*BMEAN.mn(6, 3) = *BMEAN.mn(3, 1);
	*BMEAN.mn(6, 4) = HBAR * (CTN_TH2 / L12 - 1 / (L23 * SIN_TH2));
	*BMEAN.mn(6, 5) = HBAR * SIN_GAM / (L23 * DELTA1);
	*BMEAN.mn(6, 6) = HBAR * COS_GAM / (L23 * DELTA1);

	*BMEAN.mn(9, 4) = HBAR / (L23 * SIN_TH2);
	*BMEAN.mn(9, 5) = -HBAR * (SIN_GAM / L23 + SIN_TH2 / L34) / DELTA1;
	*BMEAN.mn(9, 6) = -HBAR * (COS_GAM / L23 + COS_TH2 / L34) / DELTA1;
	*BMEAN.mn(9, 7) = HBAR * SIN_TH1 / (L34 * DELTA2);
	*BMEAN.mn(9, 8) = -HBAR * COS_TH1 / (L34 * DELTA2);

	*BMEAN.mn(12, 2) = -HBAR / (L41 * SIN_TH1);
	*BMEAN.mn(12, 5) = HBAR * SIN_TH2 / (L34 * DELTA1);
	*BMEAN.mn(12, 6) = HBAR * COS_TH2 / (L34 * DELTA1);
	*BMEAN.mn(12, 7) = -HBAR * (SIN_TH1 / L34 - SIN_GAM / L41) / DELTA2;
	*BMEAN.mn(12, 8) = HBAR * (COS_TH1 / L34 + COS_GAM / L41) / DELTA2;

	// BMEAN.diag();
	return (BMEAN);
}

void E_Object4::MIN4_SHPF(double SSI, double SSJ, Vec<double> XSD, Vec<double> YSD,
                          Vec<double>& NXSH, Vec<double>& NYSH, Mat& DNXSHG, Mat& DNYSHG) {
	// XSD(4)            !1 - D arrays of differences in x side dimensions(local)
	// YSD(4)            !1 - D arrays of differences in y side dimensions(local)
	// NXSH(4)           !Constrained Nx shape functions for the MIN4 quad element
	// NYSH(4)           !Constrained Ny shape functions for the MIN4 quad element
	// DNXSHG(2, 4)       !Derivatives of NXSH wrt xi, eta.
	// DNYSHG(2, 4)       !Derivatives of NYSH wrt xi, eta.
	NXSH.Zero();
	NYSH.Zero();
	DNXSHG.MakeZero();
	DNYSHG.MakeZero();

	// Get constants needed from local G.P.geometry.Xij = Xi - Xj and Yij = Yi - Yj where Xi, Yi, etc., are element
	// node coords in local element coord system

	double X12 = *XSD.nn(1);
	double X23 = *XSD.nn(2);
	double X34 = *XSD.nn(3);
	double X41 = *XSD.nn(4);

	double Y12 = *YSD.nn(1);
	double Y23 = *YSD.nn(2);
	double Y34 = *YSD.nn(3);
	double Y41 = *YSD.nn(4);

	double XM = 1 - SSI;
	double XP = 1 + SSI;
	double YM = 1 - SSJ;
	double YP = 1 + SSJ;
	double X2M = 1 - SSI * SSI;
	double Y2M = 1 - SSJ * SSJ;
	// N5 thru N8 are the virgin shape functions used in finding the  constrained shape functions(NXSH, NYSH)

	double N5 = X2M * YM / 2;
	double N6 = Y2M * XP / 2;
	double N7 = X2M * YP / 2;
	double N8 = Y2M * XM / 2;
	// N5X thru N8Y are derivatives of N5 thru N8 wrt xi, eta

	double N5X = -SSI * YM;
	double N6X = Y2M / 2;
	double N7X = -SSI * YP;
	double N8X = -Y2M / 2;

	double N5Y = -X2M / 2;
	double N6Y = -SSJ * XP;
	double N7Y = X2M / 2;
	double N8Y = -SSJ * XM;

	// Constrained shapes :
	*NXSH.nn(1) = (-Y41 * N8 + Y12 * N5) / 8;
	*NXSH.nn(2) = (-Y12 * N5 + Y23 * N6) / 8;
	*NXSH.nn(3) = (-Y23 * N6 + Y34 * N7) / 8;
	*NXSH.nn(4) = (-Y34 * N7 + Y41 * N8) / 8;
	*NYSH.nn(1) = (-X41 * N8 + X12 * N5) / 8;
	*NYSH.nn(2) = (-X12 * N5 + X23 * N6) / 8;
	*NYSH.nn(3) = (-X23 * N6 + X34 * N7) / 8;
	*NYSH.nn(4) = (-X34 * N7 + X41 * N8) / 8;

	// Derivatives of NXSH wrt xi, eta:
	*DNXSHG.mn(1, 1) = (-Y41 * N8X + Y12 * N5X) / 8;
	*DNXSHG.mn(1, 2) = (-Y12 * N5X + Y23 * N6X) / 8;
	*DNXSHG.mn(1, 3) = (-Y23 * N6X + Y34 * N7X) / 8;
	*DNXSHG.mn(1, 4) = (-Y34 * N7X + Y41 * N8X) / 8;
	*DNXSHG.mn(2, 1) = (-Y41 * N8Y + Y12 * N5Y) / 8;
	*DNXSHG.mn(2, 2) = (-Y12 * N5Y + Y23 * N6Y) / 8;
	*DNXSHG.mn(2, 3) = (-Y23 * N6Y + Y34 * N7Y) / 8;
	*DNXSHG.mn(2, 4) = (-Y34 * N7Y + Y41 * N8Y) / 8;

	// Derivatives of NYSH wrt xi, eta:
	*DNYSHG.mn(1, 1) = (-X41 * N8X + X12 * N5X) / 8;
	*DNYSHG.mn(1, 2) = (-X12 * N5X + X23 * N6X) / 8;
	*DNYSHG.mn(1, 3) = (-X23 * N6X + X34 * N7X) / 8;
	*DNYSHG.mn(1, 4) = (-X34 * N7X + X41 * N8X) / 8;
	*DNYSHG.mn(2, 1) = (-X41 * N8Y + X12 * N5Y) / 8;
	*DNYSHG.mn(2, 2) = (-X12 * N5Y + X23 * N6Y) / 8;
	*DNYSHG.mn(2, 3) = (-X23 * N6Y + X34 * N7Y) / 8;
	*DNYSHG.mn(2, 4) = (-X34 * N7Y + X41 * N8Y) / 8;
}

// Think this is B matix for transverse shear
Mat E_Object4::QPLT2_BEE_TS(Mat PSH, Mat DPSHX, Mat DNXSHX, Mat DNYSHX) {
	Mat BS(2, 12);
	int J, JJ;
	JJ = 0;

	for (J = 1; J < 4 + 1; J++) {
		JJ = JJ + 1;
		*BS.mn(1, JJ) = *DPSHX.mn(1, J);
		*BS.mn(2, JJ) = *DPSHX.mn(2, J);

		JJ = JJ + 1;
		*BS.mn(1, JJ) = -*DNXSHX.mn(1, J);
		*BS.mn(2, JJ) = -*DNXSHX.mn(2, J) - *PSH.mn(1, J);

		JJ = JJ + 1;
		*BS.mn(1, JJ) = *DNYSHX.mn(1, J) + *PSH.mn(1, J);
		*BS.mn(2, JJ) = *DNYSHX.mn(2, J);
	}
	return (BS);
}

Mat E_Object4::BEE_BM_Recovery() {
	int i;
	Vec<int> IDS(18);
	Mat BM;
	Mat BM2(3, 6 * iNoNodes);
	Mat coord; // Nodal Coordinates
	Mat deriv; // shape function derivatives
	Mat Points; // sample points
	Mat deriv2; // derivative of shape functions
	Mat jac;
	double det = 0;
	coord = getCoords3d(); // Coords in element CSYS this case actually 2d
	Points = Sample(1); // Only 1 integration point at centre of element
	det = 0;
	deriv = ShapeDer(Points, 1); // 2x4 shape fuction derivatives
	jac = deriv * coord;
	jac = jac.InvertJac(det);
	deriv2 = jac * deriv;
	BM = bmat(coord, deriv2, 3, 2);
	*IDS.nn(1) = 1;
	*IDS.nn(2) = 2;
	*IDS.nn(3) = 7;
	*IDS.nn(4) = 8;
	*IDS.nn(5) = 13;
	*IDS.nn(6) = 14;
	*IDS.nn(7) = 19;
	*IDS.nn(8) = 20;
	for (i = 1; i <= 8; i++) {
		*BM2.mn(1, *IDS.nn(i)) = *BM.mn(1, i);
		*BM2.mn(2, *IDS.nn(i)) = *BM.mn(2, i);
		*BM2.mn(3, *IDS.nn(i)) = *BM.mn(3, i);
	}

	return (BM2);
}

Mat E_Object4::BEE_BB_Recovery() {
	int i;

	Mat BB(3, 3 * iNoNodes);
	Mat BB2(3, 6 * iNoNodes);
	Vec<int> IDS(12);
	BB.MakeZero();
	BB2.MakeZero();

	//****************************************************************************
	//                            M Y   C A L C U L A T I O N
	//****************************************************************************

	Mat coord; // Nodal Coordinates
	Mat deriv; // shape function derivatives
	Mat Points; // sample points
	Mat deriv2; // derivative of shape functions
	Mat jac;
	double det = 0;
	coord = getCoords3d(); // Coords in element CSYS this case actually 2d
	Points = Sample(1);
	deriv = ShapeDer(Points, 1); // 2x4 shape fuction derivatives
	jac = deriv * coord;
	jac = jac.InvertJac(det);
	deriv2 = jac * deriv;

	// Bending Strain Components curvatures k11,k22,k12
	// 1 pt at el centre

	BB.MakeZero();
	C3dMatrix Bb;
	int k;
	// BENDING TERMS Bb is BENDING B MATRIX
	int inc = 0;
	double tmp;
	for (k = 1; k < iNoNodes + 1; k++) {
		Bb.m_00 = 0;
		Bb.m_01 = 0;
		Bb.m_02 = -*deriv2.mn(1, k);
		Bb.m_10 = 0;
		Bb.m_11 = *deriv2.mn(2, k);
		Bb.m_12 = 0;
		Bb.m_20 = 0;
		Bb.m_21 = *deriv2.mn(1, k);
		Bb.m_22 = -*deriv2.mn(2, k);

		*BB.mn(1, inc + 1) = 0;
		*BB.mn(1, inc + 2) = 0;
		*BB.mn(1, inc + 3) = -*deriv2.mn(1, k);
		tmp = -*deriv2.mn(1, k);
		*BB.mn(2, inc + 1) = 0;
		*BB.mn(2, inc + 2) = *deriv2.mn(2, k);
		tmp = *deriv2.mn(2, k);
		*BB.mn(2, inc + 3) = 0;
		*BB.mn(3, inc + 1) = 0;
		*BB.mn(3, inc + 2) = *deriv2.mn(1, k);
		tmp = *deriv2.mn(1, k);
		*BB.mn(3, inc + 3) = -*deriv2.mn(2, k);
		tmp = -*deriv2.mn(2, k);
		inc += 3;
	}

	*IDS.nn(1) = 3;
	*IDS.nn(2) = 4;
	*IDS.nn(3) = 5;
	*IDS.nn(4) = 9;
	*IDS.nn(5) = 10;
	*IDS.nn(6) = 11;
	*IDS.nn(7) = 15;
	*IDS.nn(8) = 16;
	*IDS.nn(9) = 17;
	*IDS.nn(10) = 21;
	*IDS.nn(11) = 22;
	*IDS.nn(12) = 23;
	for (i = 1; i <= 12; i++) {
		*BB2.mn(1, *IDS.nn(i)) = *BB.mn(1, i);
		*BB2.mn(2, *IDS.nn(i)) = *BB.mn(2, i);
		*BB2.mn(3, *IDS.nn(i)) = *BB.mn(3, i);
	}

	BB.clear();
	coord.clear();
	;
	deriv.clear();
	;
	Points.clear();
	;
	deriv2.clear();
	;
	jac.clear();
	;
	//**********************************************************

	BB.clear();
	IDS.clear();
	return (BB2);
}

// Bee matrix for recovering transverse shear results
// average of 4 guass points
// will also need PGI_SQ to calc results so will need
// to save id on call to GetStiffMat
Mat E_Object4::BEE_TS_Recovery() {
	Vec<int> IDS(12);
	int i;
	double det;
	Mat BS;
	Mat BS2(2, 12);
	Mat BST(2, 24);
	Mat Points;
	Mat fun;
	Mat jac;
	Mat deriv;
	double SSI, SSJ;
	Vec<double> NXSH(4);
	Vec<double> NYSH(4);
	Mat DPSHX;
	Mat DNXSHX;
	Mat DNYSHX;
	Mat DNXSHG(2, 4);
	Mat DNYSHG(2, 4);
	Points.clear();
	Vec<double> XSD(4);
	Vec<double> YSD(4);
	Mat XEL = getCoords_XEL(); // Local element coordinates
	// WARNING TE is not nastran diagonal bisector trying as I have it
	C3dMatrix TE = this->GetElSys(); // TE Element coord system
	*XSD.nn(1) = *XEL.mn(1, 1) - *XEL.mn(2, 1); // x coord diffs(in local elem coords)
	*XSD.nn(2) = *XEL.mn(2, 1) - *XEL.mn(3, 1);
	*XSD.nn(3) = *XEL.mn(3, 1) - *XEL.mn(4, 1);
	*XSD.nn(4) = *XEL.mn(4, 1) - *XEL.mn(1, 1);
	*YSD.nn(1) = *XEL.mn(1, 2) - *XEL.mn(2, 2); // y coord diffs(in local elem coords)
	*YSD.nn(2) = *XEL.mn(2, 2) - *XEL.mn(3, 2);
	*YSD.nn(3) = *XEL.mn(3, 2) - *XEL.mn(4, 2);
	*YSD.nn(4) = *XEL.mn(4, 2) - *XEL.mn(1, 2);
	// Note my area is not calculated by numerial integration

	// Transverse Shear average of 4 points
	int nip = 4; // 4 INTEGRATION POINTS
	Points = Sample(nip);
	Mat coord = getCoords3d();
	BS2.MakeZero();
	for (i = 1; i < nip + 1; i++) {
		SSI = *Points.mn(i, 1);
		SSJ = *Points.mn(i, 2);
		det = 0;
		fun.clear();
		fun = ShapeFun(Points, i);
		deriv.clear();
		deriv = ShapeDer(Points, i);
		MIN4_SHPF(SSI, SSJ, XSD, YSD, NXSH, NYSH, DNXSHG, DNYSHG);
		jac = deriv * coord;
		jac = jac.InvertJac(det);
		DPSHX.clear();
		DPSHX = jac * deriv;
		DNXSHX.clear();
		DNXSHX = jac * DNXSHG;
		DNYSHX.clear();
		DNYSHX = jac * DNYSHG;
		BS.clear();
		BS = QPLT2_BEE_TS(fun, DPSHX, DNXSHX, DNYSHX); // B MAT for Transverse SHEAR
		BS *= 0.25;
		BS2 += BS;
	}
	BS.clear();
	Points.clear();
	coord.clear();
	fun.clear();
	deriv.clear();
	XEL.clear();
	XSD.clear();
	YSD.clear();
	DPSHX.clear();
	DNXSHX.clear();
	DNYSHX.clear();
	// THESE MAY BE WRONG ORDER???
	*IDS.nn(1) = 3;
	*IDS.nn(2) = 4;
	*IDS.nn(3) = 5;
	*IDS.nn(4) = 9;
	*IDS.nn(5) = 10;
	*IDS.nn(6) = 11;
	*IDS.nn(7) = 15;
	*IDS.nn(8) = 16;
	*IDS.nn(9) = 17;
	*IDS.nn(10) = 21;
	*IDS.nn(11) = 22;
	*IDS.nn(12) = 23;
	for (i = 1; i <= 12; i++) {
		*BST.mn(1, *IDS.nn(i)) = *BS2.mn(1, i);
		*BST.mn(2, *IDS.nn(i)) = *BS2.mn(2, i);
	}
	IDS.clear();
	BS.clear();
	BS2.clear();
	return (BST);
}

Mat E_Object4::QPLT2_KE(int OPT, double AREA, Vec<double> XSD, Vec<double> YSD, Mat SHELL_D, Mat SHELL_T) {
	char S1[80];
	double BENSUM = 0;
	double SHRSUM = 0;
	Mat bee; // strain displacement matrix
	int nip = 0;
	Mat coord2;
	Mat deriv;
	Mat deriv2;
	Mat DPSHX; // Same as deriv2
	Mat DNXSHX;
	Mat DNYSHX;
	Mat BS;
	Mat fun;
	Mat Points;
	Mat jac;
	Mat bT;
	Mat db;
	Mat bdb;
	Mat KB(8, 8);
	Mat KS(12, 12);
	Mat KE(24, 24);
	KE.MakeZero();
	int i, j;
	double det;
	nip = 4;
	Points = Sample(nip);
	Mat coord = getCoords3d();
	// bending
	for (i = 1; i < nip + 1; i++) {
		det = 0;
		fun = ShapeFun(Points, i);
		deriv = ShapeDer(Points, i);
		jac = deriv * coord;
		jac = jac.InvertJac(det);
		deriv2 = jac * deriv;
		bee = QPLT2_BEE_DD(deriv2); // B MAT for bending
		bT = bee;
		bT.Transpose();
		db = SHELL_D * bee;
		bdb = bT * db;
		det *= *Points.mn(i, 3); // DET * weight
		bdb *= det;
		KB += bdb;
	}
	BENSUM = 0; // Add all diag terms from KB
	for (i = 1; i < 8 + 1; i++) {
		BENSUM = BENSUM + *KB.mn(i, i);
	}
	// SHEAR TERMS
	// CALL ORDER_GAUSS(IORDXX, SSS, HHH)
	double SSI, SSJ;
	Vec<double> NXSH(4);
	Vec<double> NYSH(4);
	Mat DNXSHG(2, 4);
	Mat DNYSHG(2, 4);
	Points.clear();
	// Transverse Shear
	nip = 9; // NINE INTEGRATION POINTS
	Points = Sample(nip);
	for (i = 1; i < nip + 1; i++) {
		SSI = *Points.mn(i, 1);
		SSJ = *Points.mn(i, 2);
		det = 0;
		fun = ShapeFun(Points, i);
		deriv = ShapeDer(Points, i);
		MIN4_SHPF(SSI, SSJ, XSD, YSD, NXSH, NYSH, DNXSHG, DNYSHG);
		jac = deriv * coord;
		jac = jac.InvertJac(det);
		DPSHX.clear();
		DPSHX = jac * deriv;
		DNXSHX.clear();
		DNXSHX = jac * DNXSHG;
		DNYSHX.clear();
		DNYSHX = jac * DNYSHG;
		BS.clear();
		BS = QPLT2_BEE_TS(fun, DPSHX, DNXSHX, DNYSHX); // B MAT for Transverse SHEAR
		bT = BS;
		bT.Transpose();
		db = SHELL_T * BS;
		bdb = bT * db;
		det *= *Points.mn(i, 3); // DET * weight
		bdb *= det;
		KS += bdb;
	}

	// Add all diagonal terms from KS for rotational DOF's to get SHRSUM
	SHRSUM = *KS.mn(2, 2) + *KS.mn(3, 3) + *KS.mn(5, 5) + *KS.mn(6, 6) + *KS.mn(8, 8) + *KS.mn(9, 9) + *KS.mn(11, 11) +
	         *KS.mn(12, 12);
	if (abs(SHRSUM) < 0.00001) {
		sprintf_s(S1, "ERROR: SHRSUM TOO SMALL %g", SHRSUM);
		outtext1(S1);
	}

	//******** Shear Correction factor  **********
	double CBMIN = 3.6; // for quad element - emprirical value??
	double PSI_HAT = BENSUM / SHRSUM;
	double DEN = 1 + CBMIN * PSI_HAT;
	PHI_SQ = CBMIN * PSI_HAT / DEN;

	//******** End Shear Correction factor  **********
	// populate the stiffness matrix
	Vec<int> IDB(8);
	*IDB.nn(1) = 4;
	*IDB.nn(2) = 5;
	*IDB.nn(3) = 10;
	*IDB.nn(4) = 11;
	*IDB.nn(5) = 16;
	*IDB.nn(6) = 17;
	*IDB.nn(7) = 22;
	*IDB.nn(8) = 23;
	// KB.diag();
	for (i = 1; i < 8 + 1; i++) {
		for (j = 1; j < 8 + 1; j++) {
			*KE.mn(*IDB.nn(i), *IDB.nn(j)) = *KE.mn(*IDB.nn(i), *IDB.nn(j)) + *KB.mn(i, j);
		}
	}

	Vec<int> IDS(12);
	*IDS.nn(1) = 3;
	*IDS.nn(2) = 4;
	*IDS.nn(3) = 5;
	*IDS.nn(4) = 9;
	*IDS.nn(5) = 10;
	*IDS.nn(6) = 11;
	*IDS.nn(7) = 15;
	*IDS.nn(8) = 16;
	*IDS.nn(9) = 17;
	*IDS.nn(10) = 21;
	*IDS.nn(11) = 22;
	*IDS.nn(12) = 23;
	for (i = 1; i < 12 + 1; i++) {
		for (j = 1; j < 12 + 1; j++) {
			*KE.mn(*IDS.nn(i), *IDS.nn(j)) = *KE.mn(*IDS.nn(i), *IDS.nn(j)) + PHI_SQ * *KS.mn(i, j);
		}
	}
	// KS.diag();

	return (KE);
}

Mat E_Object4::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL& bErr) {
	//******************************************************************************************************************************
	// MIN4 quadrilateral thick(Mindlin) plate bending plate element.This element is based on the following work :
	//"An Improved Treatment Of Transverse Shear In The Mindlin-Type Four-Node Quadrilateral Element", by Alexander Tessler and
	// Thomas J.R.Hughes, Computer Methods In Applied Mechanics And Engineering 39 (1983) pp 311 - 335
	//******************************************************************************************************************************
	int i;
	int iMID1 = -1; // Membrane
	int iMID2 = -1; // bending
	int iMID3 = -1; // shear
	int iMID4 = -1; // Mem / Bend coupling
	Material* pM1 = nullptr;
	Material* pM2 = nullptr;
	Material* pM3 = nullptr;
	Material* pM4 = nullptr;
	char S1[80];
	double dthk = 0.001;
	double dBRatio = 1;
	double dSHRatio = 1;
	double AREA = 1;
	Mat SHELL_A;
	Mat SHELL_D;
	Mat SHELL_T;
	Property* pS = PropsT->GetItem(PID);
	if (pS == NULL) {
		sprintf_s(S1, "ERROR: PROPERTY NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}

	// Get Shell Stuff
	if (((iType == 91) || (iType == 94)) && (pS != NULL)) {
		PSHELL* pSh = (PSHELL*) pS;
		dthk = pSh->dT;
		dBRatio = pSh->d12IT3;
		dSHRatio = pSh->dTST;
		iMID1 = pSh->iMID1;
		iMID2 = pSh->iMID2;
		iMID3 = pSh->iMID3;
		pM1 = MatT->GetItem(iMID1);
		if (iMID2 == -1)
			pM2 = pM1; // defualt
		else
			pM2 = MatT->GetItem(iMID2);
		if (iMID3 == -1)
			pM3 = pM1; // defualt
		else
			pM3 = MatT->GetItem(iMID3);
	}

	if ((pM1 != nullptr) && (pM2 != nullptr) && (pM3 != nullptr)) {
		SHELL_A = pM1->DeeMEM();
		SHELL_D = pM2->DeeBM();
		SHELL_T = pM3->DeeSH();
	} else {
		sprintf_s(S1, "ERROR: MATERIAL NOT FOUND FOR EL %i", iLabel);
		outtext1(S1);
	}
	// This part calculates the 2d membraine stiffness
	// iDof = 2;   //2 dof X,Y per node
	// nip = 4;    //4 intergration points
	// iS = 3;
	double BENSUM = 0;
	double SHRSUM = 0;
	double PSI_HAT = 0;
	double PHI_SQ = 0;
	Vec<double> XSD(4);
	Vec<double> YSD(4);
	Mat XEL = getCoords_XEL(); // Local element coordinates
	// WARNING TE is not nastran diagonal bisector trying as I have it
	C3dMatrix TE = this->GetElSys(); // TE Element coord system
	*XSD.nn(1) = *XEL.mn(1, 1) - *XEL.mn(2, 1); // x coord diffs(in local elem coords)
	*XSD.nn(2) = *XEL.mn(2, 1) - *XEL.mn(3, 1);
	*XSD.nn(3) = *XEL.mn(3, 1) - *XEL.mn(4, 1);
	*XSD.nn(4) = *XEL.mn(4, 1) - *XEL.mn(1, 1);
	*YSD.nn(1) = *XEL.mn(1, 2) - *XEL.mn(2, 2); // y coord diffs(in local elem coords)
	*YSD.nn(2) = *XEL.mn(2, 2) - *XEL.mn(3, 2);
	*YSD.nn(3) = *XEL.mn(3, 2) - *XEL.mn(4, 2);
	*YSD.nn(4) = *XEL.mn(4, 2) - *XEL.mn(1, 2);
	// Note my area is not calculated by numerial integration
	AREA = this->GetArea2d();

	// NOTE BOTH SHELL_A & SHELL_D need transforming to material direction
	Mat SHELL_D_TRIA = SHELL_D;
	Mat SHELL_T_TRIA = SHELL_T;
	SHELL_D_TRIA *= dBRatio * dthk * dthk * dthk / 12;

	SHELL_A *= dthk; // Shell_A need to multiplied by thk
	*SHELL_T_TRIA.mn(1, 1) *= dSHRatio * dthk;
	*SHELL_T_TRIA.mn(2, 2) *= dSHRatio * dthk;
	// For QUAD generate the membrane stiffness
	Mat KE;
	KE = QMEM1_KE(3, AREA, XSD, YSD, SHELL_A); // OPT 3 = K mat
	Mat KBS;
	// bending and trnasverse shear
	KBS = QPLT2_KE(3, AREA, XSD, YSD, SHELL_D_TRIA, SHELL_T_TRIA);
	KE += KBS;
	for (i = 6; i <= 24; i += 6)
		*KE.mn(i, i) = gDRILL_KS; // DRILLING STIFFNES
	Mat TMAT;
	TMAT = KEToKGTransform2(TE); // 20/02/2024 changed to this new function to get TMAT
	Mat TMATT = TMAT;
	TMATT.Transpose();
	Mat T;
	Mat TT;
	T = KE * TMAT;
	TT = TMATT * T;
	// Need to clean up
	SHELL_A.clear();
	SHELL_D.clear();
	SHELL_T.clear();
	SHELL_D_TRIA.clear();
	SHELL_T_TRIA.clear();
	XEL.clear();
	KE.clear();
	KBS.clear();
	T.clear();
	TMAT.clear();
	TMATT.clear();
	// OFFSETS
	if (HasOffsets()) {
		Mat off;
		Mat offT;
		Mat dum1;
		OffsetsToKG(PropsT, off);
		offT = off;
		offT.Transpose();
		dum1 = TT * off;
		TT.clear();
		TT = offT * dum1;
		dum1.clear();
		off.clear();
		offT.clear();
	}

	return (TT);
}

// 01/02/2024 replacing with improved transverse shear above
// Mat E_Object4::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL &bErr)
//{
//	Mat bee;   //strain displacement matrix
//	int nip = 0;
//
//	Mat coord2;
//	Mat deriv;
//	Mat deriv2;
//	Mat fun;
//	Mat Points;
//	Mat jac;
//	int i;
//	double det;
//	Mat bT;
//	Mat db;
//	Mat bdb;
//	int iDof;
//	int iS;
//	int MID = -1;
//	double dE = 210e9;
//	double dv = 0.29;
//	char S1[80];
//	double dthk = 0.001;
//
//	Property* pS = PropsT->GetItem(PID);
//	if (pS != NULL)
//	{
//		MID = pS->GetDefMatID();
//	}
//	Material* pM = MatT->GetItem(MID);
//	if (pS == NULL)
//	{
//		sprintf_s(S1, "ERROR: PROPERTY NOT FOUND FOR EL %i", iLabel);
//		outtext1(S1);
//	}
//	if (pM == NULL)
//	{
//		sprintf_s(S1, "ERROR: MATERIAL NOT FOUND FOR EL %i", iLabel);
//		outtext1(S1);
//	}
//	//Get Shell thickness
//
//	if (((iType == 91) || (iType == 94)) && (pS != NULL))
//	{
//		PSHELL* pSh = (PSHELL*)pS;
//		dthk = pSh->dT;
//	}
//
//	if ((pM != NULL) && (pM->iType = 1))
//	{
//		MAT1* pIsen = (MAT1*)pM;
//		dE = pIsen->dE;
//		dv = pIsen->dNU;
//	}
//	//This part calculates the 2d membraine stiffness
//	iDof = 2;   //2 dof X,Y per node
//	nip = 4;    //4 intergration points
//	iS = 3;
//
//	Mat KM(iDof * iNoNodes, iDof * iNoNodes);
//	Mat dee = DeeMat(dE, dv, iS);         //plain stress material matrix
//	Mat coord = getCoords3d();          //Nodal Coordinates
//	C3dMatrix M3 = this->GetElSys();    //Element Coordinate system
//	//M3.MakeUnit();
//	Points = Sample(nip);               //sample points for integration
//	//Membraine stiffness calculation
//	//for dof 12
//	for (i = 1; i < nip + 1; i++)            // for all integration points
//	{
//		det = 0;
//		fun = ShapeFun(Points, i);
//		deriv = ShapeDer(Points, i);
//		jac = deriv * coord;
//		jac = jac.InvertJac(det);
//		deriv2 = jac * deriv;
//		bee = bmat(coord, deriv2, iS, iDof);
//		bT = bee;
//		bT.Transpose();
//		db = dee * bee;
//		bdb = bT * db;
//		det *= *Points.mn(i, 3);
//		bdb *= det;
//		KM += bdb;
//		fun.clear(); deriv.clear(); jac.clear(), deriv2.clear();
//		bT.clear(); db.clear(); bdb.clear(); bee.clear(); jac.clear();
//	}
//	KM *= dthk;
//	Points.clear();
//	dee.clear();
//	//Mindlin Formulation
//	//Sheer Stifness Calculation
//	//reduced integration 1 sample point
//	double G, kk;
//	int k;
//	dee.Create(2, 2);
//	G = 0.5 * dE / (1 + dv);
//	kk = 5.0 / 6.0;
//	*dee.mn(1, 1) = kk * G * dthk;
//	*dee.mn(2, 2) = kk * G * dthk;
//	*dee.mn(1, 2) = 0;
//	*dee.mn(2, 1) = 0;
//	Mat KM2(12, 12);
//	nip = 1;                        //1 reduced integration point
//	Points = Sample(nip);
//	for (i = 1; i < nip + 1; i++)
//	{
//		det = 0;
//		fun = ShapeFun(Points, i);
//		deriv = ShapeDer(Points, i);
//		jac = deriv * coord;
//		jac = jac.InvertJac(det);
//		deriv2 = jac * deriv;
//		bee.clear();
//		bee.Create(2, 12);
//		for (k = 1; k < 4 + 1; k++)//was m
//		{
//			*bee.mn(1, (k) * 3 - 2) = *deriv2.mn(1, k);
//			*bee.mn(1, (k) * 3 - 1) = 0;
//			*bee.mn(1, (k) * 3 - 0) = *fun.mn(1, k);
//			*bee.mn(2, (k) * 3 - 2) = *deriv2.mn(2, k);
//			*bee.mn(2, (k) * 3 - 1) = -*fun.mn(1, k);
//			*bee.mn(2, (k) * 3 - 0) = 0;
//		}
//		bT = bee;
//		bT.Transpose();
//		db = dee * bee;
//		bdb = bT * db;
//		det *= *Points.mn(i, 3);
//		bdb *= det;
//		KM2 += bdb;
//		fun.clear(); deriv.clear(); jac.clear(), deriv2.clear();
//		bT.clear(); db.clear(); bdb.clear(); bee.clear();
//	}
//
//	//The bending part
//	Points.clear();
//	dee.clear();
//	dee.Create(3, 3);
//	double Cf;
//	Cf = dE * dthk * dthk * dthk / (12 * (1 - dv * dv));
//	nip = 4;
//	Points = Sample(nip);
//	*dee.mn(1, 1) = 1;
//	*dee.mn(1, 2) = dv;
//	*dee.mn(1, 3) = 0;
//	*dee.mn(2, 1) = dv;
//	*dee.mn(2, 2) = 1;
//	*dee.mn(2, 3) = 0;
//	*dee.mn(3, 1) = 0;
//	*dee.mn(3, 2) = 0;
//	*dee.mn(3, 3) = (1 - dv);
//	dee *= Cf;
//	Mat KM3(12, 12);
//	for (i = 1; i < nip + 1; i++)
//	{
//
//		det = 0;
//		fun = ShapeFun(Points, i);
//		deriv = ShapeDer(Points, i);
//		jac = deriv * coord;
//		jac = jac.InvertJac(det);
//		deriv2 = jac * deriv;
//		bee.clear();
//		bee.Create(3, 12);
//		for (k = 1; k < 4 + 1; k++)//was m
//		{
//			*bee.mn(1, (k) * 3 - 2) = 0;
//			*bee.mn(1, (k) * 3 - 1) = 0;
//			*bee.mn(1, (k) * 3 - 0) = -*deriv2.mn(1, k);
//			*bee.mn(2, (k) * 3 - 2) = 0;
//			*bee.mn(2, (k) * 3 - 1) = *deriv2.mn(2, k);
//			*bee.mn(2, (k) * 3 - 0) = 0;
//			*bee.mn(3, (k) * 3 - 2) = 0;
//			*bee.mn(3, (k) * 3 - 1) = *deriv2.mn(1, k);
//			*bee.mn(3, (k) * 3 - 0) = -*deriv2.mn(2, k);
//		}
//		bT = bee;
//		bT.Transpose();
//		db = dee * bee;
//		bdb = bT * db;
//		det *= *Points.mn(i, 3);
//		bdb *= det;
//		KM3 += bdb;
//		fun.clear(); deriv.clear(); jac.clear(), deriv2.clear();
//		bT.clear(); db.clear(); bdb.clear(); bee.clear();
//	}
//	KM2 += KM3;
//	//Assemble all the components inplain,shear and bending in KMf
//	Mat KMf(6 * iNoNodes, 6 * iNoNodes);
//	Vec<int> V(8);
//	*V.nn(1) = 1;
//	*V.nn(2) = 2;
//	*V.nn(3) = 7;
//	*V.nn(4) = 8;
//	*V.nn(5) = 13;
//	*V.nn(6) = 14;
//	*V.nn(7) = 19;
//	*V.nn(8) = 20;
//	int j;
//	for (i = 1; i <= 8; i++)
//	{
//		for (j = 1; j <= 8; j++)
//		{
//			*KMf.mn(V[i - 1], V[j - 1]) = *KM.mn(i, j);
//		}
//	}
//	Vec<int> V1(12);
//	*V1.nn(1) = 3;
//	*V1.nn(2) = 4;
//	*V1.nn(3) = 5;
//	*V1.nn(4) = 9;
//	*V1.nn(5) = 10;
//	*V1.nn(6) = 11;
//	*V1.nn(7) = 15;
//	*V1.nn(8) = 16;
//	*V1.nn(9) = 17;
//	*V1.nn(10) = 21;
//	*V1.nn(11) = 22;
//	*V1.nn(12) = 23;
//
//	for (i = 1; i <= 12; i++)
//	{
//		for (j = 1; j <= 12; j++)
//		{
//			*KMf.mn(V1[i - 1], V1[j - 1]) = *KM2.mn(i, j);
//		}
//	}
//
//	for (i = 6; i <= 24; i += 6)
//	{   //BECAREFUL MAKING THIS VALUE LARGE MESSES THINGS UP
//		*KMf.mn(i, i) = 0.01;       //DRILLING STIFFNESS
//	}
//	//Transform to global
//	//M3.Transpose();
//	Mat TMAT(24, 24);
//
//	for (i = 1; i < 24; i += 3)
//	{
//		*TMAT.mn(i, i) = M3.m_00;
//		*TMAT.mn(i + 1, i) = M3.m_10;
//		*TMAT.mn(i + 2, i) = M3.m_20;
//
//		*TMAT.mn(i, i + 1) = M3.m_01;
//		*TMAT.mn(i + 1, i + 1) = M3.m_11;
//		*TMAT.mn(i + 2, i + 1) = M3.m_21;
//
//		*TMAT.mn(i, i + 2) = M3.m_02;
//		*TMAT.mn(i + 1, i + 2) = M3.m_12;
//		*TMAT.mn(i + 2, i + 2) = M3.m_22;
//	}
//	//TMAT.diag();
//	Mat TMATT = TMAT;
//	TMATT.Transpose();
//	Mat T;
//	Mat TT;
//	T = KMf * TMAT;
//	TT = TMATT * T;
//
//	KM.clear();
//	KM2.clear();
//	KM3.clear();
//	KMf.clear();
//	TMATT.clear();
//	TMAT.clear();
//	T.clear();
//	V.clear();
//	V1.clear();
//	//TT.diag();
//	return (TT);
// }

int E_Object4::noDof() {
	return (6);
}

void E_Object4::Create(Node* pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                       int inMCys, double inMAng, G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	iMCys = inMCys;
	MAng = inMAng;
	int i = 0;
	for (i = 0; i < 4; i++) {
		pVertex[i] = pInVertex[i];
	}
	dZOFFS = 0;
}

void E_Object4::Reverse() {
	Node* pT[8];
	pT[0] = pVertex[0];
	pT[1] = pVertex[1];
	pT[2] = pVertex[2];
	pT[3] = pVertex[3];
	pVertex[0] = pT[0];
	pVertex[1] = pT[3];
	pVertex[2] = pT[2];
	pVertex[3] = pT[1];
}

void E_Object4::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

BOOL E_Object4::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_Object4::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		E_Object::Serialize(ar, iV, MESH);
		ar << iMCys;
		ar << MAng;
		ar << dZOFFS;
		ar << pVertex[0]->iLabel;
		ar << pVertex[1]->iLabel;
		ar << pVertex[2]->iLabel;
		ar << pVertex[3]->iLabel;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		ar >> iMCys;
		ar >> MAng;
		ar >> dZOFFS;
		ar >> iNd;
		pVertex[0] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[1] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[2] = MESH->GetNode(iNd);
		ar >> iNd;
		pVertex[3] = MESH->GetNode(iNd);
		pPr = NULL;
	}
}

void E_Object4::ExportUNV(FILE* pFile) {
	int i;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	for (i = 0; i < iNoNodes; i++) {
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
	}
	fprintf(pFile, "\n", "");
}

void E_Object4::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s", ToString());
}

G_Object* E_Object4::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object4* gret = new E_Object4;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = MESH->GetNode(pVertex[0]->iLabel);
	gret->pVertex[1] = MESH->GetNode(pVertex[1]->iLabel);
	gret->pVertex[2] = MESH->GetNode(pVertex[2]->iLabel);
	gret->pVertex[3] = MESH->GetNode(pVertex[3]->iLabel);
	gret->pParent = MESH;
	gret->iMCys = iMCys;
	gret->MAng = MAng;
	gret->dZOFFS = dZOFFS;
	gret->pPr = pPr;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object4::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	E_Object4* gret = new E_Object4;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	EInd = Source->GetNodeInd(pVertex[0]);
	gret->pVertex[0] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[1]);
	gret->pVertex[1] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[2]);
	gret->pVertex[2] = Target->pNodes[EInd + iSInd];
	EInd = Source->GetNodeInd(pVertex[3]);
	gret->pVertex[3] = Target->pNodes[EInd + iSInd];
	gret->pParent = Target;
	gret->iMCys = iMCys;
	gret->MAng = MAng;
	gret->dZOFFS = dZOFFS;
	gret->pPr = NULL;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_Object4::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	ME_Object* MESH = (ME_Object*) Parrent;
	E_Object4* gret = new E_Object4;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	gret->pVertex[0] = pInVertex[0];
	gret->pVertex[1] = pInVertex[1];
	gret->pVertex[2] = pInVertex[2];
	gret->pVertex[3] = pInVertex[3];
	gret->pParent = Parrent;
	gret->iMCys = iMCys;
	gret->MAng = MAng;
	gret->dZOFFS = dZOFFS;
	gret->pPr = pPr;
	gret->pResV = NULL;
	return (gret);
}

// Draw Object line
void E_Object4::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
	pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	pDC->LineTo((int) pVertex[2]->DSP_Point->x, (int) pVertex[2]->DSP_Point->y);
	pDC->LineTo((int) pVertex[3]->DSP_Point->x, (int) pVertex[3]->DSP_Point->y);
	pDC->LineTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
}

G_Object* E_Object4::GetNode(int i) {
	return (pVertex[i]);
}

int E_Object4::GetLinkList(eEdge* Links[200]) {
	int ic;
	ic = GetCol();
	Links[0] = new eEdge;
	Links[0]->pParent = this;
	Links[0]->pVertex[0] = pVertex[0];
	Links[0]->pVertex[1] = pVertex[1];
	Links[0]->iColour = iColour;
	Links[1] = new eEdge;
	Links[1]->pParent = this;
	Links[1]->pVertex[0] = pVertex[1];
	Links[1]->pVertex[1] = pVertex[2];
	Links[1]->iColour = iColour;
	Links[2] = new eEdge;
	Links[2]->pParent = this;
	Links[2]->pVertex[0] = pVertex[2];
	Links[2]->pVertex[1] = pVertex[3];
	Links[2]->iColour = iColour;
	Links[3] = new eEdge;
	Links[3]->pParent = this;
	Links[3]->pVertex[0] = pVertex[3];
	Links[3]->pVertex[1] = pVertex[0];
	Links[3]->iColour = iColour;
	return (4);
}

void E_Object4::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	double dFS;
	char sLab[20];
	C3dVector d[4];
	int i;
	int ind;

	for (i = 0; i < 4; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	dFS = ME->dResFactor;
	ind = ME->iCVar;
	glLineWidth(gEL_SIZE);
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 4; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		if ((iDspFlgs & DSP_ELEMENTS) > 0) {
			if ((iDspFlgs & DSP_LINE) > 0) {
				glColor3fv(cols[iColour]);
			} else {
				glColor3fv(cols[0]);
			}
			C3dVector vN;
			C3dVector vOff;
			vN = Get_Normal();
			// Need to calculate the offsets here
			double dt = 0;
			double dPCompOff = 0;
			if (pPr != NULL) {
				dt = pPr->GetThk();
				dt *= 0.5;
				if (pPr->iType == 2) {
					PCOMP* pPCOMP = (PCOMP*) pPr;
					dPCompOff = pPCOMP->dZ0 + dt;
				} else if (pPr->iType == 222) {
					PCOMPG* pPCOMP = (PCOMPG*) pPr;
					dPCompOff = pPCOMP->dZ0 + dt;
				}
			}
			if (((iDspFlgs & DSP_OFF) > 0) && (dZOFFS != DBL_MAX)) {
				vOff = vN;
				vOff *= dZOFFS + dPCompOff;
			} else {
				vOff *= 0;
			}

			vN *= dt;
			if ((iDspFlgs & DSP_THK) > 0) {
				glBegin(GL_LINES);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));

				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x - vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y - vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z - vN.z + d[3].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x - vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y - vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z - vN.z + d[3].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));

				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x - vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y - vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z - vN.z + d[3].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glEnd();
			} else {
				vN *= 0;
				glBegin(GL_LINES);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glEnd();
			}
			C3dVector vCent;
			vCent = Get_Centroid();
			// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
			if (gLBL_DSP_TRG)
				bDrawLab = FALSE;
			if (bDrawLab == TRUE)
			// Esp_Mod_Labels_4_27_2025_End
			{
				sprintf_s(sLab, "E%i", iLabel);
				OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
			}
			if (((iDspFlgs & DSP_RESLAB) == 0) && (pResV != NULL)) {
				sprintf_s(sLab, "%f", *pResV->GetAddress(ind));
				OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
			}

			// Results Label
		}
		if ((iDspFlgs & DSP_ELSYS) == 0) {
			glColor3fv(cols[iColour]);
			C3dMatrix mS = GetElSys();
			C3dVector vC = Get_Centroid();
			mS.Transpose();
			C3dVector vX = mS.GetColVec(1);
			C3dVector vY = mS.GetColVec(2);
			;
			C3dVector vZ = mS.GetColVec(3);
			;

			vX *= 0.5 * dS1;
			vY *= 0.5 * dS1;
			vZ *= 0.5 * dS1;
			vX += vC;
			vY += vC;
			vZ += vC;

			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vX.x, (float) vX.y, (float) vX.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vY.x, (float) vY.y, (float) vY.z);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glEnd();
			glRasterPos3f((float) vX.x, (float) vX.y, (float) vX.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPX);
			glRasterPos3f((float) vY.x, (float) vY.y, (float) vY.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPY);
			glRasterPos3f((float) vZ.x, (float) vZ.y, (float) vZ.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}

		if ((iDspFlgs & DSP_MATL) == 0) {
			C3dMatrix mS = GetElSys();
			C3dMatrix mR;
			C3dVector vD;
			C3dVector vC;
			vC = Get_Centroid();
			vD = GetFirstEdge();
			if (this->iMCys == -1) {
				// Note material angle is relative to first edge
				// not element X as I coded below
				// vD.Set(1, 0, 0);
				// mR.Rotate(0, 0, MAng);
				// vD = mR * vD;
				// mS.Transpose();
				// vD = mS * vD;
				// vD *= 0.5 * dS1;
				// vD += vC;
				vD = mS * vD;
				mR.Rotate(0, 0, MAng);
				vD = mR * vD;
				mS.Transpose();
				vD = mS * vD;
				vD.Normalize();
				vD *= 0.5 * dS1;
				vD += vC;
			} else {
				C3dVector vSys;
				if (this->pParent != NULL) {
					ME_Object* ME = (ME_Object*) pParent;
					CoordSys* pS = ME->GetSys(this->iMCys);
					if (pS != NULL) {
						vSys = pS->mOrientMat.GetColVec(1);
						vD = mS * vSys;
						vD.z = 0;
						mS.Transpose();
						vD = mS * vD;
						vD.Normalize();
						vD *= 0.5 * dS1;
						vD += vC;
					}
				}
			}

			glBegin(GL_LINES);
			glVertex3f((float) vC.x, (float) vC.y, (float) vC.z);
			glVertex3f((float) vD.x, (float) vD.y, (float) vD.z);
			glEnd();
		}
	} else {
		Selectable = 0;
	}
}

void E_Object4::OglDraw(int iDspFlgs, double dS1, double dS2) {
	C3dVector d[4];
	int i;
	for (i = 0; i < 4; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	double S;
	S = ME->dScale;
	double dFS = 1.0;
	dFS = ME->dResFactor;
	float fCols[4] = {0, 0, 0, 0};
	BOOL bD = FALSE;
	int iVar;
	iVar = ME->iCVar;
	// Nodal data
	glLineWidth(gEL_SIZE);
	if ((pVertex[0]->pResV != NULL) &&
	    (pVertex[1]->pResV != NULL) &&
	    (pVertex[2]->pResV != NULL) &&
	    (pVertex[3]->pResV != NULL)) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pVertex[0]->pResV->GetAddress(iVar) * dFS);
		fCols[1] = GetContourCol(*pVertex[1]->pResV->GetAddress(iVar) * dFS);
		fCols[2] = GetContourCol(*pVertex[2]->pResV->GetAddress(iVar) * dFS);
		fCols[3] = GetContourCol(*pVertex[3]->pResV->GetAddress(iVar) * dFS);
	}
	if (pResV != NULL) {
		bD = TRUE;
		fCols[0] = GetContourCol(*pResV->GetAddress(iVar) * dFS);
		fCols[1] = fCols[0];
		fCols[2] = fCols[0];
		fCols[3] = fCols[0];
	}
	C3dVector v1;
	C3dVector v2;
	C3dVector Vn;
	C3dVector vN;
	C3dVector vOff;
	vN = Get_Normal();
	double dt = 0;
	double dPCompOff = 0;
	if (pPr != NULL) {
		dt = pPr->GetThk();
		dt *= 0.5;
		if (pPr->iType == 2) {
			PCOMP* pPCOMP = (PCOMP*) pPr;
			dPCompOff = pPCOMP->dZ0 + dt;
		} else if (pPr->iType == 222) {
			PCOMPG* pPCOMP = (PCOMPG*) pPr;
			dPCompOff = pPCOMP->dZ0 + dt;
		}
	}

	if (((iDspFlgs & DSP_OFF) > 0) && (dZOFFS != DBL_MAX)) {
		vOff = vN;
		vOff *= dZOFFS + dPCompOff;
	} else {
		vOff *= 0;
	}

	vN *= dt;
	Vn = Get_Normal();

	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < 4; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		Selectable = 1;
		glColor3fv(cols[iColour]);
		if (((iDspFlgs & DSP_CONT) > 0) || (bD == FALSE)) {
			if ((iDspFlgs & DSP_THK) > 0) {
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glEnd();
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x - vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y - vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z - vN.z + d[3].z));
				glEnd();

				glBegin(GL_POLYGON);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glEnd();

				glBegin(GL_POLYGON);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x - vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y - vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z - vN.z + d[1].z));
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glEnd();

				glBegin(GL_POLYGON);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x - vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y - vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z - vN.z + d[2].z));
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x - vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y - vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z - vN.z + d[3].z));
				glEnd();

				glBegin(GL_POLYGON);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x - vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y - vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z - vN.z + d[3].z));
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x - vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y - vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z - vN.z + d[0].z));
				glEnd();
			} else {
				vN *= 0;
				glBegin(GL_POLYGON);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glEnd();
			}
		} else {
			vN *= 0;

			if (bD) {
				glColor3fv(cols[124]);
				glEnable(GL_TEXTURE_1D);
				glBegin(GL_POLYGON);
				glTexCoord1f(fCols[0]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[0]->Pt_Point->x + vOff.x + vN.x + d[0].x),
				           (float) (pVertex[0]->Pt_Point->y + vOff.y + vN.y + d[0].y),
				           (float) (pVertex[0]->Pt_Point->z + vOff.z + vN.z + d[0].z));
				glTexCoord1f(fCols[1]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[1]->Pt_Point->x + vOff.x + vN.x + d[1].x),
				           (float) (pVertex[1]->Pt_Point->y + vOff.y + vN.y + d[1].y),
				           (float) (pVertex[1]->Pt_Point->z + vOff.z + vN.z + d[1].z));
				glTexCoord1f(fCols[2]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[2]->Pt_Point->x + vOff.x + vN.x + d[2].x),
				           (float) (pVertex[2]->Pt_Point->y + vOff.y + vN.y + d[2].y),
				           (float) (pVertex[2]->Pt_Point->z + vOff.z + vN.z + d[2].z));
				glTexCoord1f(fCols[3]);
				glNormal3f((float) Vn.x, (float) Vn.y, (float) Vn.z);
				glVertex3f((float) (pVertex[3]->Pt_Point->x + vOff.x + vN.x + d[3].x),
				           (float) (pVertex[3]->Pt_Point->y + vOff.y + vN.y + d[3].y),
				           (float) (pVertex[3]->Pt_Point->z + vOff.z + vN.z + d[3].z));
				glEnd();
				glDisable(GL_TEXTURE_1D);
			}
		}
	} else {
		Selectable = 0;
	}
}

int E_Object4::GetfaceList(eFace* Faces[6]) {
	int ic;
	ic = GetCol();
	Faces[0] = new eFace();
	Faces[0]->pParent = this;
	Faces[0]->pVertex[0] = pVertex[0];
	Faces[0]->pVertex[1] = pVertex[1];
	Faces[0]->pVertex[2] = pVertex[2];
	Faces[0]->pVertex[3] = pVertex[3];
	Faces[0]->NoVert = 4;
	Faces[0]->iColour = ic;
	return (1);
}

double E_Object4::GetCentriodVal(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	double dTemp = 0;
	double T = 0;
	int iDOFID;
	int j;
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 0.0;
	*FunPnt.mn(1, 2) = 0.0;
	fun = this->ShapeFun(FunPnt, 1);
	for (j = 0; j < this->iNoNodes; j++) {
		T = 0;
		;
		iDOFID = this->pVertex[j]->dof[iDof];
		if (iDOFID > 0) {
			T = *Disp.nn(iDOFID);
		}
		dTemp += T * *fun.mn(1, j + 1);
	}
	fun.clear();
	FunPnt.clear();
	return (dTemp);
}

double E_Object4::GetElCentriodVal() {
	double dTemp = 0;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		dTemp += pVertex[j]->dTemp;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

C3dVector E_Object4::Get_Centroid() {
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 0;
	*FunPnt.mn(1, 2) = 0;
	fun = ShapeFun(FunPnt, 1);
	C3dVector vT;
	vT.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vT += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
	}

	fun.clear();
	FunPnt.clear();
	return (vT);
}

void E_Object4::Info() {
	char S1[200] = "";
	G_Object::Info();
	sprintf_s(S1, "LAB: %i COL: %i PID: %i ELTP: %i MCID: %i ANG: %f OFF: %f ", iLabel, iColour, PID, iType, iMCys,
	          MAng, dZOFFS);
	outtext1(S1);
	sprintf_s(S1, "NODES %i %i %i %i", pVertex[0]->iLabel, pVertex[1]->iLabel, pVertex[2]->iLabel, pVertex[3]->iLabel);
	outtext1(S1);
}

CString E_Object4::ToString() {
	CString sRT;
	char S1[80];
	CString sDir;
	if (iLabel == 28839)
		iLabel = iLabel;

	if ((iMCys == -1) && (MAng != 0.0)) {
		sDir = e8(MAng); // It is an angle
	} else if (iMCys == -1) {
		sDir = "        ";
	} else {
		sprintf_s(S1, "%8i", iMCys);
		sDir = S1;
	}
	sprintf_s(S1, "%8s%8i%8i%8i%8i%8i%8i%8s%8s\n", "CQUAD4  ", iLabel, PID, pVertex[0]->iLabel, pVertex[1]->iLabel,
	          pVertex[2]->iLabel, pVertex[3]->iLabel, sDir, e8(dZOFFS));
	sRT = S1;
	return (sRT);
}

C3dVector E_Object4::Get_Normal() {
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 0;
	*FunPnt.mn(1, 2) = 0;
	fun = ShapeDer(FunPnt, 1);
	C3dVector vX, vY, vT;
	vX.Set(0, 0, 0);
	vY.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vX += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
		vY += pVertex[j]->Get_Centroid() * *fun.mn(2, j + 1);
	}
	vT = vX.Cross(vY);
	vT.Normalize();
	fun.clear();
	FunPnt.clear();
	return (vT);
}

C3dMatrix E_Object4::GetElSys() {
	// Mat fun;
	// Mat FunPnt(1,2);
	//*FunPnt.mn(1,1)=0;
	//*FunPnt.mn(1,2)=0;
	// fun=ShapeDer(FunPnt,1);
	// C3dVector vX,vY,vT;
	// vX.Set(0,0,0);
	// vY.Set(0,0,0);
	// int j=0;
	// for (j=0;j<iNoNodes;j++)
	//{
	//    vX+=pVertex[j]->Get_Centroid()**fun.mn(1,j+1);
	//    vY+=pVertex[j]->Get_Centroid()**fun.mn(2,j+1);
	// }
	// vX.Normalize();
	// vY.Normalize();
	// vT=vX.Cross(vY);
	// vT.Normalize();
	// vY=vT.Cross(vX);
	// fun.clear();
	// FunPnt.clear();
	// C3dMatrix vR;
	// vR.SetColVec(1,vX);
	// vR.SetColVec(2,vY);
	// vR.SetColVec(3,vT);
	// vR.Transpose();
	//
	// ERROR: QUAD MEMBRANE COOR TRAN TE
	C3dMatrix vR;
	C3dVector vX, vY, vT;
	C3dVector vN13, vN42, vN;
	vN13 = pVertex[2]->Get_Centroid();
	vN13 -= pVertex[0]->Get_Centroid();
	vN13.Normalize();
	vN42 = pVertex[1]->Get_Centroid();
	vN42 -= pVertex[3]->Get_Centroid();
	vN42.Normalize();
	vX = vN13 + vN42;
	vX.Normalize();
	vN = vN42.Cross(vN13);
	vN.Normalize();
	vY = vN.Cross(vX);
	vR.SetColVec(1, vX);
	vR.SetColVec(2, vY);
	vR.SetColVec(3, vN);
	vR.Transpose();
	return (vR);
}

// 26/06/2019
// Explicte version of get coordinate system
// adds in the displacements to git the displaced
// transformation of the element
C3dMatrix E_Object4::GetElSys_Ex(Vec<int>& Steer, Vec<double>& Disp) {
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 0;
	*FunPnt.mn(1, 2) = 0;
	fun = ShapeDer(FunPnt, 1);
	C3dVector vX, vY, vT;
	C3dVector DicpCoord;
	vX.Set(0, 0, 0);
	vY.Set(0, 0, 0);
	DicpCoord.Set(0, 0, 0);
	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		DicpCoord.Set(*Disp.nn(*Steer.nn(j * 3 + 1)), *Disp.nn(*Steer.nn(j * 3 + 2)), *Disp.nn(*Steer.nn(j * 3 + 3)));
		DicpCoord += pVertex[j]->Get_Centroid();
		vX += DicpCoord * *fun.mn(1, j + 1);
		vY += DicpCoord * *fun.mn(2, j + 1);
	}
	vX.Normalize();
	vY.Normalize();
	vT = vX.Cross(vY);
	vT.Normalize();
	vY = vT.Cross(vX);
	fun.clear();
	FunPnt.clear();
	C3dMatrix vR;
	vR.SetColVec(1, vX);
	vR.SetColVec(2, vY);
	vR.SetColVec(3, vT);
	vR.Transpose();
	return (vR);
}

C3dVector E_Object4::GetTestPt() {
	Mat fun;
	Mat FunPnt(1, 2);
	*FunPnt.mn(1, 1) = 1;
	*FunPnt.mn(1, 2) = 0;
	fun = ShapeFun(FunPnt, 1);
	C3dVector vX;
	vX.Set(0, 0, 0);

	int j = 0;
	for (j = 0; j < iNoNodes; j++) {
		vX += pVertex[j]->Get_Centroid() * *fun.mn(1, j + 1);
	}
	return (vX);
}

C3dVector E_Object4::GetFirstEdge() {
	C3dVector vD;
	vD.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	vD.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	vD.z = pVertex[1]->Pt_Point->z - pVertex[0]->Pt_Point->z;

	return (vD);
}

double E_Object4::QualAspect() {
	double drc = 1;
	C3dVector v1;
	C3dVector v2;
	double de1;
	double de2;
	double de3;
	double de4;
	double deMax;
	double deMin;
	v1 = pVertex[0]->Get_Centroid();
	v2 = pVertex[1]->Get_Centroid();
	de1 = (v1 - v2).Mag();
	v1 = pVertex[1]->Get_Centroid();
	v2 = pVertex[2]->Get_Centroid();
	de2 = (v1 - v2).Mag();
	v1 = pVertex[2]->Get_Centroid();
	v2 = pVertex[3]->Get_Centroid();
	de3 = (v1 - v2).Mag();
	v1 = pVertex[3]->Get_Centroid();
	v2 = pVertex[0]->Get_Centroid();
	de4 = (v1 - v2).Mag();
	// Find Maximum value
	deMax = de1;
	if (de2 > deMax)
		deMax = de2;
	if (de3 > deMax)
		deMax = de3;
	if (de4 > deMax)
		deMax = de4;
	// Minimum
	deMin = de1;
	if (de2 < deMin)
		deMin = de2;
	if (de3 < deMin)
		deMin = de3;
	if (de4 < deMin)
		deMin = de4;
	if (deMin != 0)
		drc = deMax / deMin;
	else
		drc = 100000;
	return (drc);
}

CString E_Object4::GetName() {
	return ("Quad Shell (CQUAD4)");
}

int E_Object4::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "PID";
	iNo++;
	sVar[iNo] = "Mat CYS";
	iNo++;
	sVar[iNo] = "Mat Angle";
	iNo++;
	sVar[iNo] = "Z Offset";
	iNo++;
	sVar[iNo] = "N1";
	iNo++;
	sVar[iNo] = "N2";
	iNo++;
	sVar[iNo] = "N3";
	iNo++;
	sVar[iNo] = "N4";
	iNo++;
	return (iNo);
}

int E_Object4::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", PID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMCys);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", MAng);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dZOFFS);
	sVar[iNo] = S1;
	iNo++;

	sprintf_s(S1, "%i", pVertex[0]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[1]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[2]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[3]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void E_Object4::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Node* pN;
	ME_Object* pMe = (ME_Object*) this->pParent;
	iFile = atoi(sVar[0]);
	int newPID = atoi(sVar[1]);
	if (newPID != PID) {
		Property* pr = PT->GetItem(newPID);
		if (pr != NULL) {
			BOOL bC = SetProperty(pr);
			if (bC)
				outtext1("Property has Been Changed");
			else
				outtext1("Invalid Property");
		}
	}
	iMCys = atoi(sVar[2]);
	MAng = atof(sVar[3]);
	;
	dZOFFS = atof(sVar[4]);
	;
	;
	int N1 = atoi(sVar[5]);
	int N2 = atoi(sVar[6]);
	int N3 = atoi(sVar[7]);
	int N4 = atoi(sVar[8]);
	if (pVertex[0]->iLabel != N1) {
		pN = pMe->GetNode(N1);
		if (pN != NULL)
			pVertex[0] = pN;
	}
	if (pVertex[1]->iLabel != N2) {
		pN = pMe->GetNode(N2);
		if (pN != NULL)
			pVertex[1] = pN;
	}
	if (pVertex[2]->iLabel != N3) {
		pN = pMe->GetNode(N3);
		if (pN != NULL)
			pVertex[2] = pN;
	}
	if (pVertex[3]->iLabel != N4) {
		pN = pMe->GetNode(N4);
		if (pN != NULL)
			pVertex[3] = pN;
	}
}

//*************************************************************************************
// Pre: TRUE
// Post: returns area in Y & Y plain only for 2d analysis
//*************************************************************************************
double E_Object4::GetArea2d() {
	C2dVector v, w;
	double dA;
	v.x = pVertex[1]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	v.y = pVertex[1]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	w.x = pVertex[2]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	w.y = pVertex[2]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	dA = 0.5 * abs(v.Cross(w));
	v.x = pVertex[2]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	v.y = pVertex[2]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	w.x = pVertex[3]->Pt_Point->x - pVertex[0]->Pt_Point->x;
	w.y = pVertex[3]->Pt_Point->y - pVertex[0]->Pt_Point->y;
	dA += 0.5 * abs(v.Cross(w));

	return (dA);
}

//*************************************************************************************
// Pre: Property Table and Material Table
// Post: Nodal masses in col vector
// This is an override for the general method in E_Object so we can
// deal with PCOMPs and NSM
//*************************************************************************************
Mat E_Object4::GetElNodalMass(PropTable* PropsT, MatTable* MatT) {
	int nip = 0;
	Mat coord;
	Mat deriv;
	Mat fun;
	Mat NT;
	Mat NS;
	Mat NM;
	Mat Points;
	Mat jac;
	int i;
	double det;
	Mat bT;
	int iDof = -1;
	int iS;
	int MID = -1;
	double dthk = 0.0;
	double dTotthk = 0.0;
	double dRho = 0;
	double dNSM = 0;
	char S1[80];
	Property* pS = NULL;
	Material* pM = NULL;

	// Get Shell Thicknes and Density
	// ************NEED TO DO BEAMS LATTER************

	pS = PropsT->GetItem(PID);
	if (pS != NULL) {
		if (pS->iType == 1) // pShell
		{
			PSHELL* pSh = (PSHELL*) pS;
			dthk = pSh->dT;
			dNSM = pSh->dNSM;
			MID = pS->GetDefMatID();
			if (MatT != NULL)
				pM = MatT->GetItem(MID);
			if (pM != NULL)
				dRho = pM->GetDensity();
		} else if (pS->iType == 2) {
			PCOMP* pSh = (PCOMP*) pS;
			dNSM = pSh->dNSM;
			dTotthk = 0.0;
			dRho = 0.0;
			for (i = 0; i < pSh->iNoLays; i++) {
				dthk = pSh->T[i];
				dTotthk += dthk;
				dNSM = pSh->dNSM;
				MID = pS->GetDefMatID();
				if (MatT != NULL)
					pM = MatT->GetItem(pSh->MID[i]);
				if (pM != NULL) {
					dRho += pM->GetDensity() * dthk;
					// effective density
				}
			}
			if (dTotthk > 0) {
				dRho /= dTotthk;
				dthk = dTotthk;
			} else {
				dRho = 0;
				dthk = 0;
			}
		} else if (pS->iType == 222) {
			PCOMPG* pSh = (PCOMPG*) pS;
			dNSM = pSh->dNSM;
			dTotthk = 0.0;
			dRho = 0.0;
			for (i = 0; i < pSh->iNoLays; i++) {
				dthk = pSh->T[i];
				dTotthk += dthk;
				dNSM = pSh->dNSM;
				MID = pS->GetDefMatID();
				if (MatT != NULL)
					pM = MatT->GetItem(pSh->MID[i]);
				if (pM != NULL) {
					dRho += pM->GetDensity() * dthk;
					// effective density
				}
			}
			if (dTotthk > 0) {
				dRho /= dTotthk;
				dthk = dTotthk;
			} else {
				dRho = 0;
				dthk = 0;
			}
		} else {
			sprintf_s(S1, "ERROR: Invalid Property EL %i", iLabel);
			outtext1(S1);
		}
	} else {
		sprintf_s(S1, "ERROR: Property Not Found For EL %i", iLabel);
		outtext1(S1);
	}

	iDof = 2;
	nip = 4;
	iS = 3;
	//*********************JUST FOR TEST*******************************
	Mat AA(iNoNodes, 1);
	coord = getCoords3d();
	Points = Sample(nip);
	for (i = 1; i < nip + 1; i++) {
		det = 0;
		fun = ShapeFun(Points, i);
		deriv = ShapeDer(Points, i);
		jac = deriv * coord;
		jac = jac.InvertJac(det);
		NT = fun;
		NT.Transpose();
		// MM = NT * S;
		det *= *Points.mn(i, 3);
		NT *= det;
		AA += NT; // FS The shell nodal areas
		// Clean up
		fun.clear();
		deriv.clear();
		jac.clear();
		NT.clear();
	}

	// Mass Area*dRho*dThk+Area*NSM
	NM = AA;
	NS = AA;
	NM *= dthk * dRho; // Element nodal volume mass
	NS *= dNSM; // Element NSM per Area
	NM += NS;
	// FS.diag();
	coord.clear();
	Points.clear();
	AA.clear();
	NS.clear();
	return (NM);
}

double E_Object4::GetPHI_SQ() {
	return (PHI_SQ);
}

BOOL E_Object4::HasOffsets() {
	BOOL brc = FALSE;
	if (dZOFFS != 0)
		brc = TRUE;
	return (brc);
}

BOOL E_Object4::GetOffset(PropTable* PropsT, int iNode, C3dVector& vOff) {
	BOOL brc = FALSE;
	C3dVector vN;
	vOff = Get_Normal();
	// if its a pocmp wll have to include below
	// vOff *= dZOFFS + dPCompOff;
	// assuming its a PSHELL for now
	vOff *= dZOFFS;
	if (vOff.Mag() > 0)
		brc = TRUE;
	return (brc);
}

//----------------------------------------------------------------------------
//    E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(E_ObjectR, CObject)

E_ObjectR::E_ObjectR() {
	G_Object();
	iDOF = DOF_ALL;
	PID = 999;
	PIDunv = 999;
	dALPHA = gDEF_CTE;
	;
}

E_ObjectR::~E_ObjectR() {
	dTemps.clear();
}

void E_ObjectR::Create(Node* pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                       G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		pVertex[i] = pInVertex[i];
	}
	iDOF = DOF_ALL;
	dALPHA = gDEF_CTE;
	;
}

void E_ObjectR::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

BOOL E_ObjectR::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_ObjectR::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	int i;
	if (ar.IsStoring()) {
		// TODO: add storing code here

		E_Object::Serialize(ar, iV, MESH);
		for (i = 0; i < iNoNodes; i++) {
			ar << pVertex[i]->iLabel;
		}
		ar << iDOF;
		ar << dALPHA;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		for (i = 0; i < iNoNodes; i++) {
			ar >> iNd;
			;
			pVertex[i] = MESH->GetNode(iNd);
		}
		ar >> iDOF;
		ar >> dALPHA;
	}
}

G_Object* E_ObjectR::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	int i;
	E_ObjectR* gret = new E_ObjectR;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	for (i = 0; i < iNoNodes; i++) {
		gret->pVertex[i] = MESH->GetNode(pVertex[i]->iLabel);
	}
	gret->iDOF = iDOF;
	gret->pParent = MESH;
	gret->pPr = pPr;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_ObjectR::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	int i;
	E_ObjectR* gret = new E_ObjectR;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	for (i = 0; i < iNoNodes; i++) {
		EInd = Source->GetNodeInd(pVertex[i]);
		gret->pVertex[i] = Target->pNodes[EInd + iSInd];
	}
	gret->iDOF = iDOF;
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_ObjectR::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	int i;
	ME_Object* MESH = (ME_Object*) Parrent;
	E_ObjectR* gret = new E_ObjectR;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	for (i = 0; i < iNoNodes; i++) {
		gret->pVertex[i] = pInVertex[i];
	}
	gret->iDOF = iDOF;
	gret->pParent = Parrent;
	gret->pPr = pPr;
	gret->pResV = NULL;
	return (gret);
}

void E_ObjectR::ExportUNV(FILE* pFile) {
	int i;
	int iC;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	iC = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (iC == 8) {
			fprintf(pFile, "\n", "");
			iC = 0;
		}
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
		iC++;
	}
	fprintf(pFile, "\n", "");
}

CString E_ObjectR::ToString() {
	char S[200] = "";
	CString src = "";

	int i;
	int iFN;
	CString sDof;
	sDof = GetDOFString(iDOF);
	sprintf_s(S, "%8s%8i%8i%8s", "RBE2    ", iLabel, pVertex[0]->iLabel, sDof);
	iFN = 5;
	src += S;
	for (i = 1; i < iNoNodes; i++) {
		sprintf_s(S, "%8i", pVertex[i]->iLabel);
		src += S;
		iFN++;
		if (iFN > 9) {
			iFN = 2;
			sprintf_s(S, "\n%8s", "        ");
			src += S;
		}
	}
	sprintf_s(S, "%8s\n", e8(dALPHA));
	src += S;
	return (src);
}

void E_ObjectR::ExportNAS(FILE* pFile) {
	int i;
	int iFN;
	CString sDof;
	sDof = GetDOFString(iDOF);
	fprintf(pFile, "%8s%8i%8i%8s", "RBE2    ", iLabel, pVertex[0]->iLabel, sDof);
	iFN = 5;

	for (i = 1; i < iNoNodes; i++) {
		fprintf(pFile, "%8i", pVertex[i]->iLabel);
		iFN++;
		if (iFN > 9) {
			iFN = 2;
			fprintf(pFile, "\n", "");
			fprintf(pFile, "%8s", "        ");
		}
	}
	fprintf(pFile, "%8s\n", e8(dALPHA));
}

// Draw Object line
void E_ObjectR::Draw(CDC* pDC, int iDrawmode) {
	int i;
	for (i = 0; i < iNoNodes; i++) {
		pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
		pDC->LineTo((int) pVertex[i]->DSP_Point->x, (int) pVertex[i]->DSP_Point->y);
	}
}

void E_ObjectR::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	OglDraw(iDspFlgs, dS1, dS2);
}

G_Object* E_ObjectR::GetNode(int i) {
	return (pVertex[i]);
}

void E_ObjectR::SetDOFString(CString sDOF) {
	iDOF = GetDOFInt(sDOF);
}

void E_ObjectR::Info() {
	char S1[80];
	G_Object::Info();
	CString sDOF;
	sDOF = GetDOFString(iDOF);
	sprintf_s(S1, "LAB: %i COL: %i PID: %i ELTP: %i", iLabel, iColour, PID, iType);
	outtext1(S1);
	outtext1(sDOF);
}

CString E_ObjectR::GetName() {
	return ("Rigid Spider (RBE2)");
}

int E_ObjectR::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "Centre Node";
	iNo++;
	sVar[iNo] = "DOF String";
	iNo++;
	sVar[iNo] = "CTE Alpha";
	iNo++;
	return (iNo);
}

int E_ObjectR::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", pVertex[0]->iLabel);
	sVar[iNo] = S1;
	iNo++;
	sVar[iNo] = GetDOFString(iDOF);
	iNo++;
	sprintf_s(S1, "%g", dALPHA);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void E_ObjectR::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	ME_Object* pMe = (ME_Object*) this->pParent;
	Node* pN;
	iFile = atoi(sVar[0]);
	int N1 = atoi(sVar[1]);
	if ((pVertex[0]->iLabel != N1) && (pMe != NULL)) {
		pN = pMe->GetNode(N1);
		if (pN != NULL)
			pVertex[0] = pN;
	}
	SetDOFString(sVar[2]);
	dALPHA = atof(sVar[3]);
	;
}

void E_ObjectR::OglDraw(int iDspFlgs, double dS1, double dS2) {
	int i;
	char sLab[20];
	BOOL bD = FALSE;
	C3dVector d[MaxSelNodes];
	double S = 1.0;
	double dFS = 1.0;

	for (i = 0; i < MaxSelNodes; i++) {
		d[i].x = 0;
		d[i].y = 0;
		d[i].z = 0;
	}
	ME_Object* ME = (ME_Object*) this->pParent;
	if (ME != NULL) {
		S = ME->dScale;
		dFS = ME->dResFactor;
	}

	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		Selectable = 1;
		C3dVector vCent;
		glColor3fv(cols[iColour]);
		if ((iDspFlgs & DSP_RESDEF) == 0) {
			for (i = 0; i < iNoNodes; i++) {
				if (pVertex[i]->pResD != NULL) {
					d[i] = pVertex[i]->pResD->GetVec();
					d[i] -= ME->vRelDispOff;
					d[i] *= S * dFS;
				}
			}
		}
		glLineWidth(gEL_SIZE);
		glBegin(GL_LINES);
		for (i = 1; i < iNoNodes; i++) {
			glVertex3f((float) pVertex[0]->Pt_Point->x + d[0].x, (float) pVertex[0]->Pt_Point->y + d[0].y,
			           (float) pVertex[0]->Pt_Point->z + d[0].z);
			glVertex3f((float) pVertex[i]->Pt_Point->x + d[i].x, (float) pVertex[i]->Pt_Point->y + d[i].y,
			           (float) pVertex[i]->Pt_Point->z + d[i].z);
		}
		glEnd();
		vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End: Added global label variable for label display
		{
			sprintf_s(sLab, " R%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		} else {
			sprintf_s(sLab, "%s", " R");
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
	} else {
		Selectable = 0;
	}
}

int E_ObjectR::GetLinkList(eEdge* Links[200]) {
	int i;
	for (i = 0; i < iNoNodes - 1; i++) {
		Links[i] = new eEdge;
		Links[i]->pParent = this;
		Links[i]->pVertex[0] = pVertex[0];
		Links[i]->pVertex[1] = pVertex[i + 1];
		Links[i]->iColour = iColour;
	}
	return (iNoNodes - 1);
}

C3dVector E_ObjectR::Get_Centroid() {
	C3dVector vT;
	vT.x = pVertex[0]->Pt_Point->x;
	vT.y = pVertex[0]->Pt_Point->y;
	vT.z = pVertex[0]->Pt_Point->z;
	return (vT);
}

int E_ObjectR::noDof() {
	return (6);
}

int E_ObjectR::MaxBW() {
	int i;
	int j;

	int MaxDof;
	int MinDof;
	MaxDof = 0;
	MinDof = 99999999;
	for (i = 0; i < iNoNodes; i++) {
		for (j = 0; j < noDof(); j++) {
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] > MaxDof)) {
				MaxDof = pVertex[i]->dof[j];
			}
			if ((pVertex[i]->dof[j] > 0) && (pVertex[i]->dof[j] < MinDof)) {
				MinDof = pVertex[i]->dof[j];
			}
		}
	}
	int iRC;
	if (MaxDof - MinDof < 0) {
		iRC = 0;
	} else {
		iRC = MaxDof - MinDof;
	}
	return (iRC);
}

Vec<int> E_ObjectR::GetSteerVec1d() {
	int i;
	int iOff = 0;
	Vec<int> V(1 * iNoNodes);
	for (i = 0; i < iNoNodes; i++) {
		*V.nn(1 + i) = pVertex[i]->dof[0];
	}

	return (V);
}

Vec<int> E_ObjectR::GetSteerVec3d() {
	int i;
	int iOff = 0;
	Vec<int> V(6 * iNoNodes);
	for (i = 0; i < iNoNodes; i++) {
		*V.nn(1 + iOff) = pVertex[i]->dof[0];
		*V.nn(2 + iOff) = pVertex[i]->dof[1];
		*V.nn(3 + iOff) = pVertex[i]->dof[2];
		*V.nn(4 + iOff) = pVertex[i]->dof[3];
		*V.nn(5 + iOff) = pVertex[i]->dof[4];
		*V.nn(6 + iOff) = pVertex[i]->dof[5];
		iOff += 6;
	}

	return (V);
}

Mat E_ObjectR::GetThermMat(PropTable* PropsT, MatTable* MatT) {
	Mat KM(1 * iNoNodes, 1 * iNoNodes);
	KM.MakeZero();
	Mat KMB(2, 2);
	Vec<int> Steer(12);
	*Steer.nn(1) = 1;
	*Steer.nn(2) = 2;

	double a, b;
	int i, j, k;
	// virtual void Create(Node * pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo, G_Object * Parrent, Property * inPr);
	*KMB.mn(1, 1) = gDEF_THERM_LNK;
	*KMB.mn(2, 1) = -gDEF_THERM_LNK;
	*KMB.mn(1, 2) = -gDEF_THERM_LNK;
	*KMB.mn(2, 2) = gDEF_THERM_LNK;
	for (k = 1; k < iNoNodes; k++) {
		for (i = 1; i <= 2; i++) {
			for (j = 1; j <= 2; j++) {
				a = *Steer.nn(i);
				b = *Steer.nn(j);
				*KM.mn(*Steer.nn(i), *Steer.nn(j)) += *KMB.mn(i, j);
			}
		}
		*Steer.nn(2) += 1;
	}
	// KM.diag();
	Steer.clear();
	KMB.clear();
	return (KM);
}

Mat E_ObjectR::GetStiffMat(PropTable* PropsT, MatTable* MatT, BOOL bOpt, BOOL& bErr) {
	CString sRel = "";
	Mat KM(6 * iNoNodes, 6 * iNoNodes);
	KM.MakeZero();
	Mat KMB;
	Node* pNDs[200];
	Vec<int> Steer(12);
	*Steer.nn(1) = 1;
	*Steer.nn(2) = 2;
	*Steer.nn(3) = 3;
	*Steer.nn(4) = 4;
	*Steer.nn(5) = 5;
	*Steer.nn(6) = 6;
	// second node
	*Steer.nn(7) = 7;
	*Steer.nn(8) = 8;
	*Steer.nn(9) = 9;
	*Steer.nn(10) = 10;
	*Steer.nn(11) = 11;
	*Steer.nn(12) = 12;
	double a, b;
	int i, j, k;
	// virtual void Create(Node * pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo, G_Object * Parrent, Property * inPr);
	E_Object2B* pEB = new E_Object2B();
	pNDs[0] = pVertex[0];
	for (k = 1; k < iNoNodes; k++) {
		pNDs[1] = pVertex[k];
		pEB->Create(pNDs, k, 1, 21, 2, -1, 2, nullptr, nullptr);

		KMB = pEB->GetStiffMat(PropsT, MatT, 2, bErr);
		for (i = 1; i <= 12; i++) {
			for (j = 1; j <= 12; j++) {
				a = *Steer.nn(i);
				b = *Steer.nn(j);
				*KM.mn(*Steer.nn(i), *Steer.nn(j)) += *KMB.mn(i, j);
			}
		}
		KMB.clear();
		*Steer.nn(7) += 6;
		*Steer.nn(8) += 6;
		*Steer.nn(9) += 6;
		*Steer.nn(10) += 6;
		*Steer.nn(11) += 6;
		*Steer.nn(12) += 6;
	}

	//***************************************************************
	//                    PROCESS PIN FLAGS
	//***************************************************************
	sRel = GetDofRelString();
	// This is not working
	// pEB->SetDOFStringA("");     //end release
	// pEB->SetDOFStringB(sRel);   //end release
	// NEED TO SETUP PIN FLAGS
	if (iDOF > 0)
		PinFlgsToKE(KM);

	Steer.clear();
	delete (pEB);
	return (KM);
}

Mat E_ObjectR::GetThermalStrainMat3d(PropTable* PropsT, MatTable* MatT, double dT) {
	int k;
	double L = 1;
	double Area = 1;
	C3dMatrix M3;
	C3dVector vFl;
	C3dVector vFg;
	Node* pNDs[200];
	Mat FS(iNoNodes, 3);
	Area = Pi * gSTIFF_BDIA * gSTIFF_BDIA / 4;
	// gDEF_CTE = atof(sVar[iC++]);
	double dF;
	E_Object2B* pEB = new E_Object2B();
	pNDs[0] = pVertex[0];
	for (k = 1; k < iNoNodes; k++) {
		pNDs[1] = pVertex[k];
		pEB->Create(pNDs, k, 1, 21, 2, -1, 2, nullptr, nullptr);
		M3 = pEB->GetElSys();
		M3.Transpose();
		L = pEB->getLen();
		dF = Area * gDEF_E * gDEF_CTE * dT * gRIGID_MULTIPLIER;
		vFl.x = dF;
		vFl.y = 0;
		vFl.z = 0;
		vFg = M3 * vFl;
		*FS.mn(1, 1) += -vFg.x;
		*FS.mn(1, 2) += -vFg.y;
		*FS.mn(1, 3) += -vFg.z;
		*FS.mn(k + 1, 1) += vFg.x;
		*FS.mn(k + 1, 2) += vFg.y;
		*FS.mn(k + 1, 3) += vFg.z;
		// dTemps = dF;
	}
	delete (pEB);
	return (FS);
}

double E_ObjectR::GetCentriodVal(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	double dTemp = 0;
	int iDOFID;
	double T;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		T = 0;
		;
		iDOFID = this->pVertex[j]->dof[iDof];
		if (iDOFID > 0) {
			T = *Disp.nn(iDOFID);
		}
		dTemp += T;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

double E_ObjectR::GetElCentriodVal() {
	double dTemp = 0;
	int j;
	for (j = 0; j < this->iNoNodes; j++) {
		dTemp += pVertex[j]->dTemp;
	}
	dTemp /= iNoNodes;
	return (dTemp);
}

CString E_ObjectR::GetDofRelString() {
	CString sRel = "";

	if (!(iDOF & DOF_1)) {
		sRel = sRel + "1";
	}
	if (!(iDOF & DOF_2)) {
		sRel = sRel + "2";
	}
	if (!(iDOF & DOF_3)) {
		sRel = sRel + "3";
	}
	if (!(iDOF & DOF_4)) {
		sRel = sRel + "4";
	}
	if (!(iDOF & DOF_5)) {
		sRel = sRel + "5";
	}
	if (!(iDOF & DOF_6)) {
		sRel = sRel + "6";
	}
	return (sRel);
}

// These are the DOF to releae fro this RBE
void E_ObjectR::GetPinFlags(Vec<int>& PDOFS, int& iNoPINs) {
	iNoPINs = 1; // 1 indeded
	PDOFS.Size((iNoNodes - 1) * 6);
	int iD = 6;
	int i;
	for (i = 1; i < iNoNodes; i++) {
		if (!(iDOF & DOF_1)) {
			*PDOFS.nn(iNoPINs++) = iD + 1;
		}
		if (!(iDOF & DOF_2)) {
			*PDOFS.nn(iNoPINs++) = iD + 2;
		}
		if (!(iDOF & DOF_3)) {
			*PDOFS.nn(iNoPINs++) = iD + 3;
		}
		if (!(iDOF & DOF_4)) {
			*PDOFS.nn(iNoPINs++) = iD + 4;
		}
		if (!(iDOF & DOF_5)) {
			*PDOFS.nn(iNoPINs++) = iD + 5;
		}
		if (!(iDOF & DOF_6)) {
			*PDOFS.nn(iNoPINs++) = iD + 6;
		}
		iD += 6;
	}
}

IMPLEMENT_DYNAMIC(E_ObjectR2, CObject)

E_ObjectR2::E_ObjectR2() {
	G_Object();
	iCNA = DOF_ALL;
	iCNB = 0;
	iCMA = 0;
	iCMB = 0;
	dALPHA = 0;
	PIDunv = 999;
}

void E_ObjectR2::Create(Node* pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                        G_Object* Parrent, Property* inPr) {
	E_Object::Create(iLab, iCol, iType, iPID, iMat, iNo, Parrent, inPr);
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		pVertex[i] = pInVertex[i];
	}
}

void E_ObjectR2::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	int i;
	if (ar.IsStoring()) {
		// TODO: add storing code here

		E_Object::Serialize(ar, iV, MESH);
		for (i = 0; i < iNoNodes; i++) {
			ar << pVertex[i]->iLabel;
		}
		ar << dALPHA;
		ar << iCNA;
		ar << iCNB;
		ar << iCMA;
		ar << iCMB;
	} else {
		E_Object::Serialize(ar, iV, MESH);
		for (i = 0; i < iNoNodes; i++) {
			ar >> iNd;
			;
			pVertex[i] = MESH->GetNode(iNd);
		}
		ar >> dALPHA;
		ar >> iCNA;
		ar >> iCNB;
		ar >> iCMA;
		ar >> iCMB;
	}
}

G_Object* E_ObjectR2::Copy(G_Object* Parrent) {
	ME_Object* MESH = (ME_Object*) Parrent;
	int i;
	E_ObjectR2* gret = new E_ObjectR2;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	for (i = 0; i < iNoNodes; i++) {
		gret->pVertex[i] = MESH->GetNode(pVertex[i]->iLabel);
	}
	gret->iDOF = iDOF;
	gret->pParent = MESH;
	gret->pPr = pPr;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_ObjectR2::CopyAppend(int iSInd, ME_Object* Target, ME_Object* Source) {
	int EInd;
	int i;
	E_ObjectR2* gret = new E_ObjectR2;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = PID;
	gret->PIDunv = PIDunv;
	gret->iType = iType;
	gret->iMatID = iMatID;
	gret->iNoNodes = iNoNodes;
	for (i = 0; i < iNoNodes; i++) {
		EInd = Source->GetNodeInd(pVertex[i]);
		gret->pVertex[i] = Target->pNodes[EInd + iSInd];
	}
	gret->iDOF = iDOF;
	gret->pParent = Target;
	gret->pResV = NULL;
	return (gret);
}

G_Object* E_ObjectR2::Copy2(G_Object* Parrent, Node* pInVertex[MaxSelNodes], int inPID, int inMID, int inPIDunv) {
	int i;
	ME_Object* MESH = (ME_Object*) Parrent;
	E_ObjectR2* gret = new E_ObjectR2;
	gret->iObjType = iObjType;
	gret->iLabel = iLabel;
	gret->iColour = iColour;
	gret->Drawn = Drawn;
	gret->Selectable = Selectable;
	gret->Visable = Visable;
	gret->PID = inPID;
	gret->PIDunv = inPIDunv;
	gret->iType = iType;
	gret->iMatID = inMID;
	gret->iNoNodes = iNoNodes;
	for (i = 0; i < iNoNodes; i++) {
		gret->pVertex[i] = pInVertex[i];
	}
	gret->iDOF = iDOF;
	gret->pParent = Parrent;
	gret->pPr = pPr;
	gret->pResV = NULL;
	return (gret);
}

C3dVector E_ObjectR2::Get_Centroid() {
	C3dVector vT;
	vT.x = pVertex[0]->Pt_Point->x;
	vT.y = pVertex[0]->Pt_Point->y;
	vT.z = pVertex[0]->Pt_Point->z;
	return (vT);
}

void E_ObjectR2::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	OglDraw(iDspFlgs, dS1, dS2);
}

void E_ObjectR2::OglDraw(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	C3dVector vCent;
	if ((iDspFlgs & DSP_ELEMENTS) > 0) {
		Selectable = 1;
		glLineWidth(gEL_SIZE);
		glColor3fv(cols[iColour]);
		glBegin(GL_LINES);
		glVertex3f((float) pVertex[0]->Pt_Point->x, (float) pVertex[0]->Pt_Point->y, (float) pVertex[0]->Pt_Point->z);
		glVertex3f((float) pVertex[1]->Pt_Point->x, (float) pVertex[1]->Pt_Point->y, (float) pVertex[1]->Pt_Point->z);
		glEnd();
		vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "E%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
	} else {
		Selectable = 0;
	}
}

void E_ObjectR2::Draw(CDC* pDC, int iDrawmode) {
	int i;
	for (i = 0; i < iNoNodes; i++) {
		pDC->MoveTo((int) pVertex[0]->DSP_Point->x, (int) pVertex[0]->DSP_Point->y);
		pDC->LineTo((int) pVertex[1]->DSP_Point->x, (int) pVertex[1]->DSP_Point->y);
	}
}

BOOL E_ObjectR2::NodeInEl(Node* pN) {
	BOOL brc = FALSE;
	int i = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pN) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

void E_ObjectR2::RepNodeInEl(Node* pThis, Node* pWith) {
	int i = 0;
	int iInd = -1;
	BOOL bRep = TRUE;

	for (i = 0; i < iNoNodes; i++) {
		if (pVertex[i] == pWith) {
			bRep = FALSE;
		}
		if (pVertex[i] == pThis) {
			iInd = i;
		}
	}
	if ((bRep) && (iInd > -1))
		pVertex[iInd] = pWith;
}

void E_ObjectR2::ExportUNV(FILE* pFile) {
	int i;
	int iC;
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", iLabel, iType, PIDunv, iMatID, iColour - 150, iNoNodes);
	iC = 0;
	for (i = 0; i < iNoNodes; i++) {
		if (iC == 8) {
			fprintf(pFile, "\n", "");
			iC = 0;
		}
		fprintf(pFile, "%10i", pVertex[i]->iLabel);
		iC++;
	}
	fprintf(pFile, "\n", "");
}

void E_ObjectR2::SetOther(CString s1,
                          CString s2,
                          CString s3,
                          CString s4,
                          double dAlp) {
	dALPHA = dAlp;
	iCNA = GetDOFInt(s1);
	iCNB = GetDOFInt(s2);
	iCMA = GetDOFInt(s3);
	iCMB = GetDOFInt(s4);
}

void E_ObjectR2::ExportNAS(FILE* pFile) {
	CString sDof1;
	CString sDof2;
	CString sDof3;
	CString sDof4;
	sDof1 = GetDOFString(iCNA);
	sDof2 = GetDOFString(iCNB);
	sDof3 = GetDOFString(iCMA);
	sDof4 = GetDOFString(iCMB);

	fprintf(pFile, "%8s%8i%8i%8i%8s%8s%8s%8s%8s\n", "RBAR    ", iLabel, pVertex[0]->iLabel, pVertex[1]->iLabel, sDof1,
	        sDof2, sDof3, sDof4, e8(dALPHA));
}

//----------------------------------------------------------------------------
//    W O R K  P L A N E    O B J E C T
//----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC(WP_Object, CObject)

void WP_Object::Create(double dWPSize) {
	double ds = 0.1 * dWPSize;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 50;
	iObjType = 999;
	mWPTransform.MakeUnit();
	// mWPTransform.Rotate(30,0,45);
	// mWPTransform.Translate(3,0,2);

	iWPMode = 0; // Defualt cartesian
	Pt_Point[0] = new C3dVector(-dWPSize / 2, -dWPSize / 2, 0);
	Pt_Point[1] = new C3dVector(dWPSize / 2, -dWPSize / 2, 0);
	Pt_Point[2] = new C3dVector(dWPSize / 2, dWPSize / 2, 0);
	Pt_Point[3] = new C3dVector(-dWPSize / 2, dWPSize / 2, 0);

	Pt_Point[4] = new C3dVector(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 0.5, 0);
	Pt_Point[5] = new C3dVector(-dWPSize / 2 + ds * 2, -dWPSize / 2 + ds * 0.5, 0);
	Pt_Point[6] = new C3dVector(-dWPSize / 2 + ds * 2, -dWPSize / 2 + ds * 0.25, 0);
	Pt_Point[7] = new C3dVector(-dWPSize / 2 + ds * 2.4, -dWPSize / 2 + ds * 0.75, 0);
	Pt_Point[8] = new C3dVector(-dWPSize / 2 + ds * 2, -dWPSize / 2 + ds * 1.25, 0);
	Pt_Point[9] = new C3dVector(-dWPSize / 2 + ds * 2, -dWPSize / 2 + ds * 1, 0);

	Pt_Point[10] = new C3dVector(-dWPSize / 2 + ds * 1, -dWPSize / 2 + ds * 1, 0);

	Pt_Point[11] = new C3dVector(-dWPSize / 2 + ds * 1, -dWPSize / 2 + ds * 2, 0);
	Pt_Point[12] = new C3dVector(-dWPSize / 2 + ds * 1.25, -dWPSize / 2 + ds * 2, 0);
	Pt_Point[13] = new C3dVector(-dWPSize / 2 + ds * 0.75, -dWPSize / 2 + ds * 2.4, 0);
	Pt_Point[14] = new C3dVector(-dWPSize / 2 + ds * 0.25, -dWPSize / 2 + ds * 2, 0);
	Pt_Point[15] = new C3dVector(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 2, 0);

	Pt_Point[16] = new C3dVector(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 0.25, 0);
	Pt_Point[17] = new C3dVector(-dWPSize / 2 + ds * 3, -dWPSize / 2 + ds * 1.25, 0);
	Pt_Point[18] = new C3dVector(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 1.25, 0);
	Pt_Point[19] = new C3dVector(-dWPSize / 2 + ds * 3, -dWPSize / 2 + ds * 0.25, 0);

	Pt_Point[20] = new C3dVector(-dWPSize / 2 + ds * 0.75, -dWPSize / 2 + ds * 2.5, 0);
	Pt_Point[21] = new C3dVector(-dWPSize / 2 + ds * 0.75, -dWPSize / 2 + ds * 3, 0);
	Pt_Point[22] = new C3dVector(-dWPSize / 2 + ds * 1, -dWPSize / 2 + ds * 3.5, 0);
	Pt_Point[23] = new C3dVector(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 3.5, 0);

	// The Cross Hairs
	Pt_Point[24] = new C3dVector(0, -dWPSize / 2, 0);
	Pt_Point[25] = new C3dVector(0, dWPSize / 2, 0);
	Pt_Point[26] = new C3dVector(-dWPSize / 2, 0, 0);
	Pt_Point[27] = new C3dVector(dWPSize / 2, 0, 0);
	// The R
	Pt_Point[28] = new C3dVector(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 0.25, 0);
	Pt_Point[29] = new C3dVector(-dWPSize / 2 + ds * 3, -dWPSize / 2 + ds * 0.25, 0);
	Pt_Point[30] = new C3dVector(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 1.25, 0.0);
	Pt_Point[31] = new C3dVector(-dWPSize / 2 + ds * 3.0, -dWPSize / 2 + ds * 1.25, 0.0);
	Pt_Point[32] = new C3dVector(-dWPSize / 2 + ds * 3.0, -dWPSize / 2 + ds * 0.75, 0.0);
	Pt_Point[33] = new C3dVector(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 0.75, 0.0);
	// the thete
	Pt_Point[34] = new C3dVector(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 2.5, 0);
	Pt_Point[35] = new C3dVector(-dWPSize / 2 + ds * 1.0, -dWPSize / 2 + ds * 2.5, 0);
	Pt_Point[36] = new C3dVector(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 3.5, 0.0);
	Pt_Point[37] = new C3dVector(-dWPSize / 2 + ds * 1.0, -dWPSize / 2 + ds * 3.5, 0.0);
	Pt_Point[38] = new C3dVector(-dWPSize / 2 + ds * 1.0, -dWPSize / 2 + ds * 3.0, 0.0);
	Pt_Point[39] = new C3dVector(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 3.0, 0.0);

	DSP_Point[0] = new C3dVector();
	DSP_Point[1] = new C3dVector();
	DSP_Point[2] = new C3dVector();
	DSP_Point[3] = new C3dVector();
	DSP_Point[4] = new C3dVector();
	DSP_Point[5] = new C3dVector();
	DSP_Point[6] = new C3dVector();
	DSP_Point[7] = new C3dVector();
	DSP_Point[8] = new C3dVector();
	DSP_Point[9] = new C3dVector();
	DSP_Point[10] = new C3dVector();
	DSP_Point[11] = new C3dVector();
	DSP_Point[12] = new C3dVector();
	DSP_Point[13] = new C3dVector();
	DSP_Point[14] = new C3dVector();
	DSP_Point[15] = new C3dVector();

	DSP_Point[16] = new C3dVector();
	DSP_Point[17] = new C3dVector();
	DSP_Point[18] = new C3dVector();
	DSP_Point[19] = new C3dVector();

	DSP_Point[20] = new C3dVector();
	DSP_Point[21] = new C3dVector();
	DSP_Point[22] = new C3dVector();
	DSP_Point[23] = new C3dVector();

	DSP_Point[24] = new C3dVector();
	DSP_Point[25] = new C3dVector();
	DSP_Point[26] = new C3dVector();
	DSP_Point[27] = new C3dVector();

	DSP_Point[28] = new C3dVector();
	DSP_Point[29] = new C3dVector();
	DSP_Point[30] = new C3dVector();
	DSP_Point[31] = new C3dVector();
	DSP_Point[32] = new C3dVector();
	DSP_Point[33] = new C3dVector();

	DSP_Point[34] = new C3dVector();
	DSP_Point[35] = new C3dVector();
	DSP_Point[36] = new C3dVector();
	DSP_Point[37] = new C3dVector();
	DSP_Point[38] = new C3dVector();
	DSP_Point[39] = new C3dVector();
}

void WP_Object::ReSize(double dWPSize) {
	double ds = 0.1 * dWPSize;

	if (dWPSize > 0) {
		Pt_Point[0]->Set(-dWPSize / 2, -dWPSize / 2, 0);
		Pt_Point[1]->Set(dWPSize / 2, -dWPSize / 2, 0);
		Pt_Point[2]->Set(dWPSize / 2, dWPSize / 2, 0);
		Pt_Point[3]->Set(-dWPSize / 2, dWPSize / 2, 0);

		Pt_Point[24]->Set(0, -dWPSize / 2, 0);
		Pt_Point[25]->Set(0, dWPSize / 2, 0);
		Pt_Point[26]->Set(-dWPSize / 2, 0, 0);
		Pt_Point[27]->Set(dWPSize / 2, 0, 0);

		Pt_Point[4]->Set(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 0.5, 0);
		Pt_Point[5]->Set(-dWPSize / 2 + ds * 2, -dWPSize / 2 + ds * 0.5, 0);
		Pt_Point[6]->Set(-dWPSize / 2 + ds * 2, -dWPSize / 2 + ds * 0.25, 0);
		Pt_Point[7]->Set(-dWPSize / 2 + ds * 2.4, -dWPSize / 2 + ds * 0.75, 0);
		Pt_Point[8]->Set(-dWPSize / 2 + ds * 2, -dWPSize / 2 + ds * 1.25, 0);
		Pt_Point[9]->Set(-dWPSize / 2 + ds * 2, -dWPSize / 2 + ds * 1, 0);

		Pt_Point[10]->Set(-dWPSize / 2 + ds * 1, -dWPSize / 2 + ds * 1, 0);

		Pt_Point[11]->Set(-dWPSize / 2 + ds * 1, -dWPSize / 2 + ds * 2, 0);
		Pt_Point[12]->Set(-dWPSize / 2 + ds * 1.25, -dWPSize / 2 + ds * 2, 0);
		Pt_Point[13]->Set(-dWPSize / 2 + ds * 0.75, -dWPSize / 2 + ds * 2.4, 0);
		Pt_Point[14]->Set(-dWPSize / 2 + ds * 0.25, -dWPSize / 2 + ds * 2, 0);
		Pt_Point[15]->Set(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 2, 0);

		Pt_Point[16]->Set(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 0.25, 0);
		Pt_Point[17]->Set(-dWPSize / 2 + ds * 3, -dWPSize / 2 + ds * 1.25, 0);
		Pt_Point[18]->Set(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 1.25, 0);
		Pt_Point[19]->Set(-dWPSize / 2 + ds * 3, -dWPSize / 2 + ds * 0.25, 0);

		Pt_Point[20]->Set(-dWPSize / 2 + ds * 0.75, -dWPSize / 2 + ds * 2.5, 0);
		Pt_Point[21]->Set(-dWPSize / 2 + ds * 0.75, -dWPSize / 2 + ds * 3, 0);
		Pt_Point[22]->Set(-dWPSize / 2 + ds * 1, -dWPSize / 2 + ds * 3.5, 0);
		Pt_Point[23]->Set(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 3.5, 0);

		Pt_Point[28]->Set(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 0.25, 0);
		Pt_Point[29]->Set(-dWPSize / 2 + ds * 3, -dWPSize / 2 + ds * 0.25, 0);
		Pt_Point[30]->Set(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 1.25, 0.0);
		Pt_Point[31]->Set(-dWPSize / 2 + ds * 3.0, -dWPSize / 2 + ds * 1.25, 0.0);
		Pt_Point[32]->Set(-dWPSize / 2 + ds * 3.0, -dWPSize / 2 + ds * 0.75, 0.0);
		Pt_Point[33]->Set(-dWPSize / 2 + ds * 2.5, -dWPSize / 2 + ds * 0.75, 0.0);

		Pt_Point[34]->Set(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 2.5, 0);
		Pt_Point[35]->Set(-dWPSize / 2 + ds * 1.0, -dWPSize / 2 + ds * 2.5, 0);
		Pt_Point[36]->Set(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 3.5, 0.0);
		Pt_Point[37]->Set(-dWPSize / 2 + ds * 1.0, -dWPSize / 2 + ds * 3.5, 0.0);
		Pt_Point[38]->Set(-dWPSize / 2 + ds * 1.0, -dWPSize / 2 + ds * 3.0, 0.0);
		Pt_Point[39]->Set(-dWPSize / 2 + ds * 0.5, -dWPSize / 2 + ds * 3.0, 0.0);
	}
}

// Draw Object line
void WP_Object::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) DSP_Point[0]->x, (int) DSP_Point[0]->y);
	pDC->LineTo((int) DSP_Point[1]->x, (int) DSP_Point[1]->y);
	pDC->LineTo((int) DSP_Point[2]->x, (int) DSP_Point[2]->y);
	pDC->LineTo((int) DSP_Point[3]->x, (int) DSP_Point[3]->y);
	pDC->LineTo((int) DSP_Point[0]->x, (int) DSP_Point[0]->y);

	pDC->MoveTo((int) DSP_Point[4]->x, (int) DSP_Point[4]->y);
	pDC->LineTo((int) DSP_Point[5]->x, (int) DSP_Point[5]->y);
	pDC->LineTo((int) DSP_Point[6]->x, (int) DSP_Point[6]->y);
	pDC->LineTo((int) DSP_Point[7]->x, (int) DSP_Point[7]->y);
	pDC->LineTo((int) DSP_Point[8]->x, (int) DSP_Point[8]->y);
	pDC->LineTo((int) DSP_Point[9]->x, (int) DSP_Point[9]->y);
	pDC->LineTo((int) DSP_Point[10]->x, (int) DSP_Point[10]->y);
	pDC->LineTo((int) DSP_Point[11]->x, (int) DSP_Point[11]->y);
	pDC->LineTo((int) DSP_Point[12]->x, (int) DSP_Point[12]->y);
	pDC->LineTo((int) DSP_Point[13]->x, (int) DSP_Point[13]->y);
	pDC->LineTo((int) DSP_Point[14]->x, (int) DSP_Point[14]->y);
	pDC->LineTo((int) DSP_Point[15]->x, (int) DSP_Point[15]->y);
	pDC->LineTo((int) DSP_Point[4]->x, (int) DSP_Point[4]->y);

	pDC->MoveTo((int) DSP_Point[16]->x, (int) DSP_Point[16]->y);
	pDC->LineTo((int) DSP_Point[17]->x, (int) DSP_Point[17]->y);
	pDC->MoveTo((int) DSP_Point[18]->x, (int) DSP_Point[18]->y);
	pDC->LineTo((int) DSP_Point[19]->x, (int) DSP_Point[19]->y);

	pDC->MoveTo((int) DSP_Point[20]->x, (int) DSP_Point[20]->y);
	pDC->LineTo((int) DSP_Point[21]->x, (int) DSP_Point[21]->y);
	pDC->LineTo((int) DSP_Point[22]->x, (int) DSP_Point[22]->y);
	pDC->MoveTo((int) DSP_Point[21]->x, (int) DSP_Point[21]->y);
	pDC->LineTo((int) DSP_Point[23]->x, (int) DSP_Point[23]->y);
}

void WP_Object::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	C3dVector T_Point[40];
	C3dVector V;
	int i;
	if ((iDspFlgs & DSP_WP) > 0) {
		Selectable = 1;
		for (i = 0; i < 40; i++) {
			V.x = Pt_Point[i]->x;
			V.y = Pt_Point[i]->y;
			V.z = Pt_Point[i]->z;
			T_Point[i] = mWPTransform * V;
		}
		glColor3fv(cols[GetCol()]);
		glLineWidth(gWP_SIZE);
		glBegin(GL_LINE_LOOP);
		glVertex3f((float) T_Point[0].x, (float) T_Point[0].y, (float) T_Point[0].z);
		glVertex3f((float) T_Point[1].x, (float) T_Point[1].y, (float) T_Point[1].z);
		glVertex3f((float) T_Point[2].x, (float) T_Point[2].y, (float) T_Point[2].z);
		glVertex3f((float) T_Point[3].x, (float) T_Point[3].y, (float) T_Point[3].z);
		glEnd();

		glBegin(GL_LINE_LOOP);
		glVertex3f((float) T_Point[4].x, (float) T_Point[4].y, (float) T_Point[4].z);
		glVertex3f((float) T_Point[5].x, (float) T_Point[5].y, (float) T_Point[5].z);
		glVertex3f((float) T_Point[6].x, (float) T_Point[6].y, (float) T_Point[6].z);
		glVertex3f((float) T_Point[7].x, (float) T_Point[7].y, (float) T_Point[7].z);
		glVertex3f((float) T_Point[8].x, (float) T_Point[8].y, (float) T_Point[8].z);
		glVertex3f((float) T_Point[9].x, (float) T_Point[9].y, (float) T_Point[9].z);
		glVertex3f((float) T_Point[10].x, (float) T_Point[10].y, (float) T_Point[10].z);
		glVertex3f((float) T_Point[11].x, (float) T_Point[11].y, (float) T_Point[11].z);
		glVertex3f((float) T_Point[12].x, (float) T_Point[12].y, (float) T_Point[12].z);
		glVertex3f((float) T_Point[13].x, (float) T_Point[13].y, (float) T_Point[13].z);
		glVertex3f((float) T_Point[14].x, (float) T_Point[14].y, (float) T_Point[14].z);
		glVertex3f((float) T_Point[15].x, (float) T_Point[15].y, (float) T_Point[15].z);
		glEnd();

		// The R
		if (iWPMode == 1) {
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[28].x, (float) T_Point[28].y, (float) T_Point[28].z);
			glVertex3f((float) T_Point[30].x, (float) T_Point[30].y, (float) T_Point[30].z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[30].x, (float) T_Point[30].y, (float) T_Point[30].z);
			glVertex3f((float) T_Point[31].x, (float) T_Point[31].y, (float) T_Point[31].z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[31].x, (float) T_Point[31].y, (float) T_Point[31].z);
			glVertex3f((float) T_Point[32].x, (float) T_Point[32].y, (float) T_Point[32].z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[32].x, (float) T_Point[32].y, (float) T_Point[32].z);
			glVertex3f((float) T_Point[33].x, (float) T_Point[33].y, (float) T_Point[33].z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[33].x, (float) T_Point[33].y, (float) T_Point[33].z);
			glVertex3f((float) T_Point[29].x, (float) T_Point[29].y, (float) T_Point[29].z);
			glEnd();
			// Theta
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[38].x, (float) T_Point[38].y, (float) T_Point[38].z);
			glVertex3f((float) T_Point[39].x, (float) T_Point[39].y, (float) T_Point[39].z);
			glEnd();
			glBegin(GL_LINE_LOOP);
			glVertex3f((float) T_Point[34].x, (float) T_Point[34].y, (float) T_Point[34].z);
			glVertex3f((float) T_Point[35].x, (float) T_Point[35].y, (float) T_Point[35].z);
			glVertex3f((float) T_Point[37].x, (float) T_Point[37].y, (float) T_Point[37].z);
			glVertex3f((float) T_Point[36].x, (float) T_Point[36].y, (float) T_Point[36].z);
			glEnd();
		} else {
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[16].x, (float) T_Point[16].y, (float) T_Point[16].z);
			glVertex3f((float) T_Point[17].x, (float) T_Point[17].y, (float) T_Point[17].z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[18].x, (float) T_Point[18].y, (float) T_Point[18].z);
			glVertex3f((float) T_Point[19].x, (float) T_Point[19].y, (float) T_Point[19].z);
			glEnd();

			glBegin(GL_LINES);
			glVertex3f((float) T_Point[20].x, (float) T_Point[20].y, (float) T_Point[20].z);
			glVertex3f((float) T_Point[21].x, (float) T_Point[21].y, (float) T_Point[21].z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[21].x, (float) T_Point[21].y, (float) T_Point[21].z);
			glVertex3f((float) T_Point[22].x, (float) T_Point[22].y, (float) T_Point[22].z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) T_Point[21].x, (float) T_Point[21].y, (float) T_Point[21].z);
			glVertex3f((float) T_Point[23].x, (float) T_Point[23].y, (float) T_Point[23].z);
			glEnd();
		}
		glColor3fv(cols[154]);
		glEnable(GL_LINE_STIPPLE);
		glLineStipple(1, 0x0101);
		glBegin(GL_LINES);
		glVertex3f((float) T_Point[24].x, (float) T_Point[24].y, (float) T_Point[24].z);
		glVertex3f((float) T_Point[25].x, (float) T_Point[25].y, (float) T_Point[25].z);
		glEnd();
		glBegin(GL_LINES);
		glVertex3f((float) T_Point[26].x, (float) T_Point[26].y, (float) T_Point[26].z);
		glVertex3f((float) T_Point[27].x, (float) T_Point[27].y, (float) T_Point[27].z);
		glEnd();
		glDisable(GL_LINE_STIPPLE);
		glLineWidth(2.0);
	} else {
		Selectable = 0;
	}
}

void WP_Object::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void WP_Object::Reset() {
	mWPTransform.MakeUnit();
}

C3dVector WP_Object::Get_Centroid() {
	C3dVector vC;
	vC.Set(0, 0, 0);
	vC = mWPTransform.Mult(vC);
	return (vC);
}

void WP_Object::Align(C3dVector p1, C3dVector p2, C3dVector p3) {
	C3dVector vX;
	C3dVector vZ;
	C3dVector vYP;
	vX = p2;
	vX -= p1;
	vX.Normalize();
	vYP = p3;
	vYP -= p1;
	vYP.Normalize();
	if ((vX.Mag() != 0) && (vYP.Mag() != 0)) {
		if (abs(vX.Dot(vYP)) != 1) {
			vZ = vX.Cross(vYP);
			vYP = vZ.Cross(vX);
			vX.Normalize();
			vYP.Normalize();
			vZ.Normalize();
			mWPTransform.SetColVec(1, vX);
			mWPTransform.SetColVec(2, vYP);
			mWPTransform.SetColVec(3, vZ);
			mWPTransform.Translate2(p1.x, p1.y, p1.z);
		}
	}
}

void WP_Object::CentrePt(C3dVector p1) {
	mWPTransform.Translate2(p1.x, p1.y, p1.z);
}

void WP_Object::AlignZ(C3dVector p1, C3dVector p2, C3dVector p3) {
	//  TWP->AlignZ(pO,pX,pZ);
	C3dVector vX;
	C3dVector vZ;
	C3dVector vYP;
	vX = p2;
	vX -= p1;
	vX.Normalize();
	vZ = p3;
	vZ.Normalize();
	if ((vX.Mag() != 0) && (vZ.Mag() != 0)) {
		if (abs(vX.Dot(vZ)) != 1) {
			// vZ=vX.Cross(vYP);
			vYP = vZ.Cross(vX);
			vX = vYP.Cross(vZ);
			vX.Normalize();
			vYP.Normalize();
			vZ.Normalize();
			mWPTransform.SetColVec(1, vX);
			mWPTransform.SetColVec(2, vYP);
			mWPTransform.SetColVec(3, vZ);
			mWPTransform.Translate2(p1.x, p1.y, p1.z);
		}
	}
}

void WP_Object::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	int j = 0;
	C3dVector V;
	C3dVector R;
	C3dMatrix mM;

	for (j = 0; j < 28; j++) {
		V.x = Pt_Point[j]->x;
		V.y = Pt_Point[j]->y;
		V.z = Pt_Point[j]->z;
		R = mWPTransform * V;
		V = pModMat->Mult(R);
		R = pScrTran->Mult(V);
		DSP_Point[j]->x = R.x;
		DSP_Point[j]->y = R.y;
		DSP_Point[j]->z = R.z;
	}
}

void WP_Object::Translate(C3dVector vIn) {
	mWPTransform.m_30 += vIn.x;
	mWPTransform.m_31 += vIn.y;
	mWPTransform.m_32 += vIn.z;
}

void WP_Object::Transform(C3dMatrix TMat) {
	// incorect
	mWPTransform = TMat * mWPTransform;
}

void WP_Object::HighLight(CDC* pDC) {
	Draw(pDC, 4);
}

void WP_Object::Serialize(CArchive& ar, int iV) {
	G_Object::Serialize(ar, iV);
	if (ar.IsStoring()) {
		ar << mWPTransform.m_00;
		ar << mWPTransform.m_01;
		ar << mWPTransform.m_02;
		ar << mWPTransform.m_03;
		ar << mWPTransform.m_10;
		ar << mWPTransform.m_11;
		ar << mWPTransform.m_12;
		ar << mWPTransform.m_13;
		ar << mWPTransform.m_20;
		ar << mWPTransform.m_21;
		ar << mWPTransform.m_22;
		ar << mWPTransform.m_23;
		ar << mWPTransform.m_30;
		ar << mWPTransform.m_31;
		;
		ar << mWPTransform.m_32;
		ar << mWPTransform.m_33;
		ar << iWPMode;
	} else {
		ar >> mWPTransform.m_00;
		ar >> mWPTransform.m_01;
		ar >> mWPTransform.m_02;
		ar >> mWPTransform.m_03;
		ar >> mWPTransform.m_10;
		ar >> mWPTransform.m_11;
		ar >> mWPTransform.m_12;
		ar >> mWPTransform.m_13;
		ar >> mWPTransform.m_20;
		ar >> mWPTransform.m_21;
		ar >> mWPTransform.m_22;
		ar >> mWPTransform.m_23;
		ar >> mWPTransform.m_30;
		ar >> mWPTransform.m_31;
		;
		ar >> mWPTransform.m_32;
		ar >> mWPTransform.m_33;
		ar >> iWPMode;
	}
}

G_ObjectD WP_Object::SelDist(CPoint InPT, Filter FIL) {
	double MinDist = 1e36;
	double dDist;
	int i;
	G_ObjectD Ret;
	Ret.Dist = MinDist;
	Ret.pObj = this;
	Ret.Z = 0;

	for (i = 0; i < 28; i++) {
		dDist = pow((DSP_Point[i]->x - InPT.x), 2) + pow((DSP_Point[i]->y - InPT.y), 2);
		if (dDist < MinDist) {
			MinDist = dDist;
			Ret.Dist = dDist;
			Ret.pObj = this;
			Ret.Z = 0;
		}
	}
	return (Ret);
}

CString WP_Object::GetName() {
	return ("Workplane Object");
}

//****************************************************************************
//           S O L U T I O N    S E T    O B J E C T S
//****************************************************************************
IMPLEMENT_DYNAMIC(Solution, CObject)
// iType 0 = LIN STAT
// iType 1 = THERMAL

Solution::Solution() {
	iType = 0;
	sTitle = "UNDEFINED";
	iNo = 0;
	dTol = 1.0e-9;
	iCur = -1;
}

CString Solution::GetSolutionTitleString() {
	CString src = "ERROR.";
	char S1[80] = "";
	sprintf_s(S1, "%s TP: %i TOL: %g", sTitle, iType, dTol);
	src = S1;
	return (src);
}

Solution::Solution(int iT, CString sTit, double dT) {
	iType = iT;
	sTitle = sTit;
	iNo = 0;
	dTol = dT;
	iCur = -1;
}

Solution::~Solution() {
	iNo = 0;
	iType = 0;
	sTitle = "UNDEFINED";
}

void Solution::AddStep(CString sT, int idLS, int idBS, int idTS, BOOL bRS) {
	if (iNo < MAX_STEPS) {
		LS[iNo] = idLS;
		BS[iNo] = idBS;
		TS[iNo] = idTS;
		RS[iNo] = bRS;
		sStepTitle[iNo] = sT;
		iCur = iNo;
		iNo++;
	} else {
		outtext1("ERROR: Max no of Steps Exceeded in Solution Set.");
	}
}

void Solution::DelStep(int ind) {
	int i;
	if ((ind >= 0) && (ind < iNo)) {
		for (i = ind + 1; i < iNo - 1; i++) {
			LS[i - 1] = LS[i];
			BS[i - 1] = BS[i];
			TS[i - 1] = TS[i];
			RS[i - 1] = RS[i];
			sStepTitle[i - 1] = sStepTitle[i];
		}
		iNo--;
	}
	iCur = -1;
}

void Solution::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		ar << iNo;
		ar << iCur;
		ar << sTitle;
		ar << iType;
		ar << dTol;
		for (i = 0; i < iNo; i++) {
			ar << LS[i];
			ar << BS[i];
			ar << TS[i];
			ar << RS[i];
			ar << sStepTitle[i];
		}
	} else {
		ar >> iNo;
		ar >> iCur;
		ar >> sTitle;
		ar >> iType;
		ar >> dTol;
		for (i = 0; i < iNo; i++) {
			ar >> LS[i];
			ar >> BS[i];
			ar >> TS[i];
			ar >> RS[i];
			ar >> sStepTitle[i];
		}
	}
}

BOOL Solution::SetCurStep(int iC) {
	BOOL brc = FALSE;
	if ((iC > -1) && (iC < iNo)) {
		iCur = iC;
		brc = TRUE;
	} else
		iCur = -1;
	return (brc);
}

int Solution::GetCurStep() {
	return (iCur);
}

CString Solution::GetStepTitleString(int iC) {
	CString src;
	char S1[80] = "";
	if ((iC > -1) && (iC < iNo)) {
		sprintf_s(S1, "STEP: %i LC: %i BC: %i TSET: %i RS: %i %s", iC, LS[iC], BS[iC], TS[iC], RS[iC], sStepTitle[iC]);
		src = S1;
	} else {
		src = "ERROR.";
	}
	return (src);
}

void Solution::Info(int iD) {
	int i;
	char S1[200] = "";
	CString sT;
	sprintf_s(S1, "ID: %i TITLE: %s", iD, sTitle);
	outtext1(S1);

	if (iType == 0)
		sT = "SOLUTION TYPE: Linear Static.";
	else if (iType == 1)
		sT = "SOLUTION TYPE: Steady State Thermal.";
	else
		sT = "SOLUTION TYPE: UNDEFINED.";
	outtext1(sT);

	for (i = 0; i < iNo; i++) {
		sprintf_s(S1, "STEP: %i LC: %i BC: %i TSET: %i RS: %i %s", i, LS[i], BS[i], TS[i], RS[i], sStepTitle[i]);
		outtext1(S1);
	}
}

//****************************************************************************
//               A L L    S O L U T I O N    S E T S
//****************************************************************************
IMPLEMENT_DYNAMIC(SolSets, CObject)

SolSets::SolSets() {
	int i;
	iCur = -1;
	iNo = 0;
	sTitle = "UNDEFINED";
	for (i = 0; i < MAX_SOLS; i++) {
		pSols[i] = NULL;
	}
}

SolSets::SolSets(CString sTitle) {
	int i;
	iCur = -1;
	iNo = 0;
	sTitle = sTitle;
	for (i = 0; i < MAX_SOLS; i++) {
		pSols[i] = NULL;
	}
}

SolSets::~SolSets() {
	int i;
	if (iNo > 0) {
		for (i = 0; i < iNo; i++) {
			if (pSols[i] != NULL)
				delete (pSols[i]);
		}
	}
}

void SolSets::AddSolution(int iT, CString sTit, double dT) {
	if (iNo < MAX_SOLS) {
		pSols[iNo] = new Solution(iT, sTit, dT);
		iCur = iNo;
		iNo++;
	} else {
		outtext1("ERROR: Max No of Solutions Exceeded.");
	}
}

// add step to current solution
void SolSets::AddStep(CString sT, int idLS, int idBS, int idTS, BOOL bRS) {
	if (iCur != -1) {
		if (pSols[iCur] != NULL)
			pSols[iCur]->AddStep(sT, idLS, idBS, idTS, bRS);
	}
}

void SolSets::DelSolution(int ind) {
	int i;
	if ((ind >= 0) && (ind < iNo)) {
		if (pSols[ind] != NULL) {
			delete (pSols[ind]);
			for (i = ind + 1; i < iNo - 1; i++) {
				pSols[i - 1] = pSols[i];
			}
			iNo--;
		}
	}
}

void SolSets::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		ar << iNo;
		ar << iCur;
		ar << sTitle;
		for (i = 0; i < iNo; i++) {
			pSols[i]->Serialize(ar, iV);
		}
	} else {
		ar >> iNo;
		ar >> iCur;
		ar >> sTitle;
		for (i = 0; i < iNo; i++) {
			pSols[i] = new Solution();
			pSols[i]->Serialize(ar, iV);
		}
	}
}

Solution* SolSets::GetCurSolution() {
	Solution* pSol = NULL;
	if (iCur > -1)
		pSol = pSols[iCur];
	return (pSol);
}

BOOL SolSets::SetCurSol(int iC) {
	BOOL brc = FALSE;
	if ((iC > -1) && (iC < iNo)) {
		iCur = iC;
		brc = TRUE;
	} else
		iCur = -1;
	return (brc);
}

BOOL SolSets::SetCurStep(int iC) {
	BOOL brc = FALSE;
	if (iCur > -1)
		brc = pSols[iCur]->SetCurStep(iC);
	else {
		outtext1("ERROR: No Solution Active.");
	}
	return (brc);
}

int SolSets::GetCurStep() {
	int irc = -1;
	if (iCur > -1)
		irc = pSols[iCur]->GetCurStep();
	else
		outtext1("ERROR: No Solution Active.");
	return (irc);
}

CString SolSets::GetTitleString(int iC) {
	CString src;
	char S1[80] = "";

	if (iC > -1) {
		sprintf_s(S1, "SOL %i ", iC);
		src = S1;
		src += " ";
		src += pSols[iC]->GetSolutionTitleString();
	} else
		src = "ERROR.";
	return (src);
}

void SolSets::Info() {
	int i;
	char S1[200] = "";
	outtext1("S O L U T I O N    S E Q E N C E S");
	for (i = 0; i < iNo; i++) {
		pSols[i]->Info(i);
	}
	sprintf_s(S1, "CURRENT SOL SEQ: %i", iCur);
	outtext1(S1);
}

//****************************************************************************
//                 T H E    M E S H    O B J E C T
//****************************************************************************
IMPLEMENT_DYNAMIC(ME_Object, CObject)

// GUID definitions
const IID IID_IME_Object = {0x190D2974, 0x17B6, 0x4295, {0xA4, 0xC5, 0x08, 0xFA, 0x06, 0xFC, 0x6C, 0xD9}};
const CLSID CLSID_ME_Object = {0x7C1C0A34, 0x5974, 0x452F, {0x96, 0xE7, 0xDB, 0x7F, 0x46, 0x41, 0x2B, 0x29}};

BEGIN_DISPATCH_MAP(ME_Object, CCmdTarget)
// Add your dispatch methods here.
DISP_PROPERTY_ID(ME_Object, "iColour", 1, iColour, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iLabel", 2, iLabel, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iObjType", 3, iObjType, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iType", 4, iType, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iFile", 5, iFile, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iIntID", 6, iIntID, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iNdNo", 7, iNdNo, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iElNo", 8, iElNo, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iBCLDs", 9, iBCLDs, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iCYS", 10, iCYS, VT_I4)
DISP_FUNCTION_ID(ME_Object, "GetObjectHeaders", 11, API_GetObjectHeaders, VT_EMPTY, VTS_PVARIANT)
DISP_FUNCTION_ID(ME_Object, "GetObjectVars", 12, API_GetObjectVars, VT_EMPTY, VTS_PVARIANT)
DISP_FUNCTION_ID(ME_Object, "PutObjectVars", 13, API_PutObjectVars, VT_EMPTY, VTS_PVARIANT)
DISP_FUNCTION_ID(ME_Object, "GetObjectName", 14, API_GetObjectName, VT_BSTR, VTS_NONE)
DISP_FUNCTION_ID(ME_Object, "GetFEMName", 15, API_GetFEMName, VT_BSTR, VTS_NONE)
DISP_FUNCTION_ID(ME_Object, "GetNodeByInd", 16, API_GetNodeByInd, VT_DISPATCH, VTS_I4)
DISP_FUNCTION_ID(ME_Object, "GetNodeByID", 17, API_GetNodeByID, VT_DISPATCH, VTS_I4)
DISP_FUNCTION_ID(ME_Object, "GetElementByInd", 18, API_GetElementByInd, VT_DISPATCH, VTS_I4)
DISP_FUNCTION_ID(ME_Object, "GetElementByID", 19, API_GetElementByID, VT_DISPATCH, VTS_I4)
DISP_PROPERTY_ID(ME_Object, "iNoLCs", 20, iNoLCs, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iCurLC", 21, iCurLC, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iNoBCs", 22, iNoBCs, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iCurBC", 23, iCurBC, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iNoTSets", 24, iNoTSets, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iCurTSet", 25, iCurTSet, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iNoRes", 26, iNoRes, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iCurResSetDef", 27, iCurResSetDef, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iResValDef", 28, iResValDef, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iCVarDef", 29, iCVarDef, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iCurResSet", 30, iCurResSet, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iResVal", 31, iResVal, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iPostOpt", 32, iPostOpt, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iCVar", 33, iCVar, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iSecID", 34, iSecID, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iCurResVecSet", 35, iCurResVecSet, VT_I4)
DISP_PROPERTY_ID(ME_Object, "iSecVecID", 36, iSecVecID, VT_I4)
DISP_FUNCTION_ID(ME_Object, "CreateNode", 37, API_CreateNode, VT_DISPATCH,
                 VTS_I4 VTS_I4 VTS_I4 VTS_I4 VTS_R8 VTS_R8 VTS_R8)
DISP_FUNCTION_ID(ME_Object, "CreateNode2", dispidCreateNode2, API_CreateNode2, VT_DISPATCH, VTS_R8 VTS_R8 VTS_R8)
END_DISPATCH_MAP()

BEGIN_INTERFACE_MAP(ME_Object, CCmdTarget)
INTERFACE_PART(ME_Object, IID_IME_Object, Dispatch)
END_INTERFACE_MAP()

// Function 1: GetModel - Retrieves the SAFEARRAY of BSTRs
HRESULT __stdcall ME_Object::API_GetObjectHeaders(VARIANT* pVariant) {
	// Initialize the VARIANT
	int iNoVars;
	CString sVar[100];
	iNoVars = GetVarHeaders(sVar);

	VariantInit(pVariant);
	pVariant->vt = VT_ARRAY | VT_BSTR;

	// Create a SAFEARRAY to hold BSTRs
	SAFEARRAY* psa;
	SAFEARRAYBOUND bounds[1];
	bounds[0].lLbound = 0;
	bounds[0].cElements = iNoVars; // Fix: Use correct size
	psa = SafeArrayCreate(VT_BSTR, 1, bounds);

	if (!psa)
		return E_OUTOFMEMORY; // Handle memory allocation failure

	// Fill the SAFEARRAY
	LONG index;
	for (int i = 0; i < iNoVars; i++) {
		BSTR bstr = sVar[i].AllocSysString(); // Convert CString to BSTR
		index = i; // Use correct index
		SafeArrayPutElement(psa, &index, bstr);
		// Do NOT free bstr here! SafeArrayPutElement takes ownership
	}

	pVariant->parray = psa;
	return S_OK;
}

HRESULT __stdcall ME_Object::API_GetObjectVars(VARIANT* pVariant) {
	// Initialize the VARIANT
	int iNoVars;
	CString sVar[100];
	iNoVars = GetVarValues(sVar);

	VariantInit(pVariant);
	pVariant->vt = VT_ARRAY | VT_BSTR;

	// Create a SAFEARRAY to hold BSTRs
	SAFEARRAY* psa;
	SAFEARRAYBOUND bounds[1];
	bounds[0].lLbound = 0;
	bounds[0].cElements = iNoVars; // Fix: Use correct size
	psa = SafeArrayCreate(VT_BSTR, 1, bounds);

	if (!psa)
		return E_OUTOFMEMORY; // Handle memory allocation failure

	// Fill the SAFEARRAY
	LONG index;
	for (int i = 0; i < iNoVars; i++) {
		BSTR bstr = sVar[i].AllocSysString(); // Convert CString to BSTR
		index = i; // Use correct index
		SafeArrayPutElement(psa, &index, bstr);
		// Do NOT free bstr here! SafeArrayPutElement takes ownership
	}

	pVariant->parray = psa;
	return S_OK;
}

HRESULT __stdcall ME_Object::API_PutObjectVars(VARIANT* pVariant) {
	int iNoVars;
	CString sVar[100];
	if (!pVariant)
		return E_POINTER; // Ensure pVariant is valid
	if (pVariant->vt != (VT_ARRAY | VT_BSTR))
		return E_INVALIDARG; // Ensure correct type

	SAFEARRAY* psa = pVariant->parray;
	if (!psa)
		return E_INVALIDARG; // Ensure SAFEARRAY is valid

	LONG lLower, lUpper;
	if (FAILED(SafeArrayGetLBound(psa, 1, &lLower)) ||
	    FAILED(SafeArrayGetUBound(psa, 1, &lUpper))) {
		return E_FAIL;
	}

	iNoVars = lUpper - lLower + 1; // Number of elements

	if (iNoVars > 100) // Ensure it does not exceed array bounds
		return E_FAIL;

	HRESULT hr = S_OK;
	for (LONG i = 0; i < iNoVars; i++) {
		BSTR bstr;
		LONG index = lLower + i;
		if (FAILED(SafeArrayGetElement(psa, &index, &bstr))) {
			hr = E_FAIL;
			break;
		}
		sVar[i] = CString(bstr); // Convert BSTR to CString
		SysFreeString(bstr); // Free BSTR after use
	}
	// G_Object::PutVarValues(PropTable * PT, int iNo, CString sVar[])
	// Problem how to get pointer to propery table
	PutVarValues(PropsT, iNoVars, sVar);
	return hr;
}

BSTR __stdcall ME_Object::API_GetObjectName() {
	CString strObjectName = GetName();
	return strObjectName.AllocSysString(); // Directly return the BSTR
}

BSTR __stdcall ME_Object::API_GetFEMName() {
	CString strObjectName = sName;
	return strObjectName.AllocSysString(); // Directly return the BSTR
}

IDispatch* __stdcall ME_Object::API_GetNodeByInd(LONG iNo) {
	AFX_MANAGE_STATE(AfxGetAppModuleState());
	if (iNo < iNdNo && pNodes[iNo] != nullptr) // Ensure valid index and object
	{
		return pNodes[iNo]->GetIDispatch(TRUE);
	} else {
		outtext1("Error: API_GetObject returning NULL");
		return nullptr;
	}

	// TODO: Add your dispatch handler code here

	return nullptr;
}

IDispatch* __stdcall ME_Object::API_GetNodeByID(LONG iNID) {
	AFX_MANAGE_STATE(AfxGetAppModuleState());
	G_Object* pN = nullptr;
	pN = GetNode(iNID);
	if (pN != nullptr) // Ensure valid index and object
	{
		return pN->GetIDispatch(TRUE);
		;
	} else {
		outtext1("Error: API_GetObject returning NULL");
		return nullptr;
	}
}

IDispatch* __stdcall ME_Object::API_GetElementByInd(LONG iNo) {
	AFX_MANAGE_STATE(AfxGetAppModuleState());
	if (iNo < iElNo && pElems[iNo] != nullptr) // Ensure valid index and object
	{
		return pElems[iNo]->GetIDispatch(TRUE);
	} else {
		outtext1("Error: API_GetObject returning NULL");
		return nullptr;
	}

	// TODO: Add your dispatch handler code here

	return nullptr;
}

IDispatch* __stdcall ME_Object::API_GetElementByID(LONG iEID) {
	AFX_MANAGE_STATE(AfxGetAppModuleState());
	G_Object* pE = nullptr;
	pE = GetElement(iEID);
	if (pE != nullptr) // Ensure valid index and object
	{
		return pE->GetIDispatch(TRUE);
		;
	} else {
		outtext1("Error: API_GetObject returning NULL");
		return nullptr;
	}
}

IDispatch* __stdcall ME_Object::API_CreateNode(LONG iLab, LONG iCol, LONG iDef, LONG iOut, DOUBLE x, DOUBLE y, DOUBLE z) {
	G_Object* pN = nullptr;
	C3dVector vPt;
	vPt.Set(x, y, z);
	if (iLab == -1) {
		iLab = this->iNodeLab;
		this->iNodeLab++;
	}
	pN = this->AddNode(vPt, iLab, -1, -1, iCol, iDef, iOut);
	if (pN != nullptr) // Ensure valid index and object
	{
		return pN->GetIDispatch(TRUE);
		;
	} else {
		outtext1("Error: API_CreateNode returning NULL");
		return nullptr;
	}
}

ME_Object::~ME_Object() {
	int i;
	for (i = 0; i < iBCLDs; i++) {
		delete (pBCLDs[i]);
		pBCLDs[i] = NULL;
	}
	for (i = 0; i < iElNo; i++) {
		delete (pElems[i]);
	}
	for (i = 0; i < iNdNo; i++) {
		delete (pNodes[i]);
	}
	for (i = 0; i < iNoGps; i++) {
		delete (GPs[i]);
	}
	if (FcList != NULL)
		delete (FcList);
	if (LkList != NULL)
		delete (LkList);
	if (pSOLS != NULL)
		delete (pSOLS);
	if (pResVectors != NULL)
		delete (pResVectors);
}

ME_Object::ME_Object() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 4;
	iNdNo = 0;
	iElNo = 0;
	iNoGps = 0;
	sName = "NULL";
	TransMat.MakeUnit();
	pParent = NULL;
	iNodeLab = 0;
	iElementLab = 0;
	bDrawN = TRUE;
	bDrawCYS = TRUE;
	TempList = NULL;
	iCYS = 0;
	iCYSLab = 1;
	iNodeLab = 1;
	iElementLab = 1;
	dScale = 10;
	dScaleVec = 0.1;
	dResFactor = 1.0;
	vRelDispOff.Set(0, 0, 0);
	iNoRes = 0;
	iCurResSet = -1;
	iResVal = -1;
	iCurResSetDef = -1;
	iResValDef = -1;
	iPostOpt = 0;
	iCurResVecSet = -1;
	iResVec = -1;
	iSecVecID = -1;
	bUserColBar = FALSE;
	// Loadsets BCs and Temperature Sets
	iCurLC = -1;
	iNoLCs = 0;
	iCurBC = -1;
	iNoBCs = 0;
	iCurTSet = -1;
	iNoTSets = 0;
	pResVectors = NULL;
	FcList = NULL;
	LkList = NULL;
	pSOLS = new SolSets("UNDEFINED");
	iIntID = reinterpret_cast<uintptr_t>(this);
	iFileNo = -1;
}

CString ME_Object::GetName() {
	return ("Mesh Object)");
}

int ME_Object::GetVarHeaders(CString sVar[]) {
	sVar[0] = "Name";
	return (1);
}

int ME_Object::GetVarValues(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = sName;
	iNo++;
	return (iNo);
}

void ME_Object::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	sName = sVar[0];
}

void ME_Object::GetBoundingBox(C3dVector& vll, C3dVector& vur) {
	int i;
	C3dVector vMinXYZ;
	C3dVector vMaxXYZ;
	BOOL bFirst = TRUE;
	C3dVector vPt;
	for (i = 0; i < iNdNo; i++) {
		vPt = pNodes[i]->Pt_Point;
		if (bFirst) {
			vMinXYZ = vPt;
			vMaxXYZ = vPt;
			bFirst = FALSE;
		} else {
			if (vPt.x < vMinXYZ.x)
				vMinXYZ.x = vPt.x;
			if (vPt.y < vMinXYZ.y)
				vMinXYZ.y = vPt.y;
			if (vPt.z < vMinXYZ.z)
				vMinXYZ.z = vPt.z;

			if (vPt.x > vMaxXYZ.x)
				vMaxXYZ.x = vPt.x;
			if (vPt.y > vMaxXYZ.y)
				vMaxXYZ.y = vPt.y;
			if (vPt.z > vMaxXYZ.z)
				vMaxXYZ.z = vPt.z;
		}
	}
	vll = vMinXYZ;
	vur = vMaxXYZ;
	BBox[0].Pt_Point->Set(vMinXYZ.x, vMinXYZ.y, vMinXYZ.z);
	BBox[1].Pt_Point->Set(vMinXYZ.x, vMaxXYZ.y, vMinXYZ.z);
	BBox[2].Pt_Point->Set(vMaxXYZ.x, vMaxXYZ.y, vMinXYZ.z);
	BBox[3].Pt_Point->Set(vMaxXYZ.x, vMinXYZ.y, vMinXYZ.z);
	BBox[4].Pt_Point->Set(vMinXYZ.x, vMinXYZ.y, vMaxXYZ.z);
	BBox[5].Pt_Point->Set(vMinXYZ.x, vMaxXYZ.y, vMaxXYZ.z);
	BBox[6].Pt_Point->Set(vMaxXYZ.x, vMaxXYZ.y, vMaxXYZ.z);
	BBox[7].Pt_Point->Set(vMaxXYZ.x, vMinXYZ.y, vMaxXYZ.z);
}

void ME_Object::Create(CString inName, G_Object* Parrent, int iLab) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 4;
	iNdNo = 0;
	iElNo = 0;
	iBCLDs = 0;
	iNoGps = 0;
	sName = inName;
	TransMat.MakeUnit();
	pParent = Parrent;
	iNodeLab = 1;
	iElementLab = 1;
	iLabel = iLab;
	TempList = NULL;
	iCYS = 0;
	iCYSLab = 1;
	CResSet = NULL;
	CResSetDef = NULL;
	iCVar = 0;
	iCVarDef = 0;
	dScale = 10;
	dScaleVec = 0.1;
	iPostOpt = 0;
	bUserColBar = FALSE;
	iCurLC = -1;
	iNoLCs = 0;
	iCurBC = -1;
	iNoBCs = 0;
	iCurTSet = -1;
	iNoTSets = 0;
	iCurResVecSet = -1;
	iResVec = -1;
	iSecVecID = -1;
}

void ME_Object::Info() {
	int i;
	char S1[200];
	sprintf_s(S1, "%s%i%s%i%s%i", "Type ", iObjType, "; Label ", iLabel, " Col; ", iColour);
	outtext1("MESH OBJECT");
	outtext1(S1);
	outtext1("FILES:-");
	outtext1(S1);
	for (i = 0; i < iFileNo; i++) {
		sprintf_s(S1, "File No %i %s", i, sFiles[i]);
		outtext1(S1);
	}
	sprintf_s(S1, "%s%i%s%X", "ID : ", iLabel, " Internal ID : ", iIntID);
	outtext1(S1);
	sprintf_s(S1, "%s%s", "Name : ", sName.GetString());
	outtext1(S1);
	sprintf_s(S1, "%s%i", "Number of Nodes : ", iNdNo);
	outtext1(S1);
	sprintf_s(S1, "%s%i", "Number of Elements : ", iElNo);
	outtext1(S1);
	sprintf_s(S1, "%s%i", "Min Node Label : ", iNodeMinLab);
	outtext1(S1);
	sprintf_s(S1, "%s%i", "Min Elem Label : ", iElementMinLab);
	outtext1(S1);
	sprintf_s(S1, "%s%i", "Min CSYS Label : ", iCYSMinLab);
	outtext1(S1);
	sprintf_s(S1, "%s%i", "Max Node Label : ", iNodeLab - 1);
	outtext1(S1);
	sprintf_s(S1, "%s%i", "Max Elem Label : ", iElementLab - 1);
	outtext1(S1);
	sprintf_s(S1, "%s%i", "Max CSYS Label : ", iCYSLab - 1);
	outtext1(S1);
	outtext1("LOAD / BOUNDARY SETS:-");
	int iS;
	iS = GetLCID(iCurLC);
	sprintf_s(S1, "%s%i", "Current Load Set : ", iS);
	outtext1(S1);
	iS = GetBCID(iCurBC);
	sprintf_s(S1, "%s%i", "Current BC Set   : ", iS);
	outtext1(S1);
	iS = GetTSETID(iCurTSet);
	sprintf_s(S1, "%s%i", "Current Temp Set : ", iS);
	outtext1(S1);

	outtext1("    ****");
}

void ME_Object::BuildNodeList() {
	int i;
	TempList = new ObjTempList();
	for (i = 0; i < iNdNo; i++) {
		if (pNodes[i]->iLabel < 99999999)
			TempList->Objs[pNodes[i]->iLabel] = pNodes[i];
	}
}

void ME_Object::DeleteNodeList() {
	delete (TempList);
	TempList = NULL;
}

BOOL ME_Object::isActiveSolSet() {
	BOOL brc = FALSE;
	if (pSOLS != NULL) {
		if (pSOLS->iCur != -1)
			brc = TRUE;
	}
	return (brc);
}

BOOL ME_Object::isValidLCid(int iLC) {
	int i;
	BOOL brc = FALSE;
	for (i = 0; i < iNoLCs; i++) {
		if (LCS[i]->iLabel == iLC) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

BOOL ME_Object::isValidBCid(int iLC) {
	int i;
	BOOL brc = FALSE;
	for (i = 0; i < iNoBCs; i++) {
		if (BCS[i]->iLabel == iLC) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

BOOL ME_Object::isValidTCid(int iLC) {
	int i;
	BOOL brc = FALSE;
	for (i = 0; i < iNoTSets; i++) {
		if (TSETS[i]->iLabel == iLC) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

int ME_Object::NestTSetID() {
	int i;
	int irc = 0;
	for (i = 0; i < iNoTSets; i++) {
		if (TSETS[i]->iLabel > irc) {
			irc = TSETS[i]->iLabel;
		}
	}
	irc++;
	return (irc);
}

void ME_Object::LabGaps(int iGap) {
	char buff[200];
	int i = 0;
	int iCur;
	int iS;
	vector<int> iLabs;
	vector<int> iSt;
	vector<int> iEnd;
	sprintf_s(buff, "%s %i", "Finding Node Labeling Gaps > ", iGap);
	outtext1(buff);
	// Node label sparsity
	if ((iNdNo > 2) && iGap > 0) {
		for (i = 0; i < iNdNo; i++)
			iLabs.push_back(pNodes[i]->iLabel);
		sort(iLabs.begin(), iLabs.end());
		iSt.push_back(iLabs.front());
		for (i = 1; i < iLabs.size(); i++) {
			iCur = iLabs.at(i - 1);
			iS = iLabs.at(i) - iCur;
			if (iS > iGap) {
				iEnd.push_back(iCur);
				sprintf_s(buff, "%s %i to %i size %i", "Gap Found at:  ", iCur + 1, iLabs.at(i) - 1, iS - 1);
				outtext1(buff);
				iCur = iLabs.at(i);
				iSt.push_back(iCur);
			}
		}
		iEnd.push_back(iLabs.back());
		outtext1("Blocks of Nodes");
		for (i = 0; i < iSt.size(); i++) {
			sprintf_s(buff, "%i %i", iSt.at(i), iEnd.at(i));
			outtext1(buff);
		}
	} else {
		outtext1("ERROR: No Node Gaps Found.");
	}
	iLabs.clear();
	iSt.clear();
	iEnd.clear();
	sprintf_s(buff, "%s %i", "Finding Element Labeling Gaps > ", iGap);
	outtext1(buff);
	if ((iElNo > 2) && (iGap > 0)) {
		for (i = 0; i < iElNo; i++)
			iLabs.push_back(pElems[i]->iLabel);
		sort(iLabs.begin(), iLabs.end());
		iSt.push_back(iLabs.front());
		for (i = 1; i < iLabs.size(); i++) {
			iCur = iLabs.at(i - 1);
			iS = iLabs.at(i) - iCur;
			if (iS > iGap) {
				iEnd.push_back(iCur);
				sprintf_s(buff, "%s %i to %i size %i", "Gap Found at:  ", iCur + 1, iLabs.at(i) - 1, iS - 1);
				outtext1(buff);
				iCur = iLabs.at(i);
				iSt.push_back(iCur);
			}
		}
		iEnd.push_back(iLabs.back());
		outtext1("Blocks of Elements");
		for (i = 0; i < iSt.size(); i++) {
			sprintf_s(buff, "%i %i", iSt.at(i), iEnd.at(i));
			outtext1(buff);
		}
	} else {
		outtext1("ERROR: No Element Gaps Found.");
	}
}

int ME_Object::GetLCID(int ind) {
	int irc = -1;
	if (ind > -1)
		irc = LCS[ind]->iLabel;
	return (irc);
}

int ME_Object::GetLCind(int ID) {
	int iret = -1;
	int i;
	for (i = 0; i < iNoLCs; i++) {
		if (LCS[i]->iLabel == ID) {
			iret = i;
			break;
		}
	}
	return (iret);
}

int ME_Object::GetBCID(int ind) {
	int irc = -1;
	if (ind > -1)
		irc = BCS[ind]->iLabel;
	return (irc);
}

int ME_Object::GetBCind(int ID) {
	int iret = -1;
	int i;
	for (i = 0; i < iNoBCs; i++) {
		if (BCS[i]->iLabel == ID) {
			iret = i;
			break;
		}
	}
	return (iret);
}

int ME_Object::GetTSETID(int ind) {
	int irc = -1;
	if (ind > -1)
		irc = TSETS[ind]->iLabel;
	return (irc);
}

int ME_Object::GetTSETind(int ID) {
	int iret = -1;
	int i;
	for (i = 0; i < iNoTSets; i++) {
		if (TSETS[i]->iLabel == ID) {
			iret = i;
			break;
		}
	}
	return (iret);
}

cLinkedList* ME_Object::GetLC(int iSet) {
	int i;
	cLinkedList* pRet = NULL;
	for (i = 0; i < iNoLCs; i++) {
		if (LCS[i]->iLabel == iSet) {
			pRet = LCS[i];
			break;
		}
	}
	return (pRet);
}

cLinkedListB* ME_Object::GetBC(int iSet) {
	int i;
	cLinkedListB* pRet = NULL;
	for (i = 0; i < iNoBCs; i++) {
		if (BCS[i]->iLabel == iSet) {
			pRet = BCS[i];
			break;
		}
	}

	return (pRet);
}

cLinkedListT* ME_Object::GetTSET(int iSet) {
	int i;
	cLinkedListT* pRet = NULL;
	for (i = 0; i < iNoTSets; i++) {
		if (TSETS[i]->iLabel == iSet) {
			pRet = TSETS[i];
			break;
		}
	}
	return (pRet);
}

void ME_Object::SetCurLC(int iSet) {
	char buff[200];
	int iSInd;
	iSInd = GetLCind(iSet);
	if ((iSInd > -1) && (iSInd < iNoLCs)) {
		iCurLC = iSInd;
		sprintf_s(buff, "%3i%s ID%i %s", iCurLC, " : ", LCS[iCurLC]->iLabel, LCS[iCurLC]->sTitle);
		outtext1(buff);
	} else {
		outtext1("ERROR: Invalid Set ID.");
		iCurLC = -1;
	}
}

void ME_Object::SetCurBC(int iSet) {
	char buff[200];
	int iSInd;
	iSInd = GetBCind(iSet);
	if ((iSInd > -1) && (iSInd < iNoBCs)) {
		iCurBC = iSInd;
		sprintf_s(buff, "%3i%s ID%i %s", iCurBC, " : ", BCS[iCurBC]->iLabel, BCS[iCurBC]->sTitle);
		outtext1(buff);
	} else {
		outtext1("ERROR: Invalid Set ID.");
		iCurBC = -1;
	}
}

void ME_Object::SetCurTSET(int iSet) {
	char buff[200];
	int iSInd;
	iSInd = GetTSETind(iSet);
	if ((iSInd > -1) && (iSInd < iNoTSets)) {
		iCurTSet = iSInd;
		sprintf_s(buff, "%3i%s ID%i %s", iCurTSet, " : ", TSETS[iCurTSet]->iLabel, TSETS[iCurTSet]->sTitle);
		outtext1(buff);
	} else {
		outtext1("ERROR: Invalid Set ID.");
		iCurTSet = -1;
	}
}

void ME_Object::ListLC() {
	int i;
	char buff[200];
	CString iGp;
	CString oLine;
	outtext1("LOAD SET LISTING:-");

	for (i = 0; i < iNoLCs; i++) {
		sprintf_s(buff, "%3i%s ID%i %s", i, " : ", LCS[i]->iLabel, LCS[i]->sTitle);
		outtext1(buff);
	}
	if ((iNoLCs > 0) && (iCurLC < iNoLCs)) {
		outtext1("Active Load Set:-");
		sprintf_s(buff, "%3i%s ID%i %s", iCurLC, " : ", LCS[iCurLC]->iLabel, LCS[iCurLC]->sTitle);
		outtext1(buff);
	} else {
		outtext1("ERROR: No Active Load Set.");
	}
}

void ME_Object::ListBC() {
	int i;
	char buff[200];
	CString iGp;
	CString oLine;
	outtext1("BOUNDARY SET LISTING:-");

	for (i = 0; i < iNoBCs; i++) {
		sprintf_s(buff, "%3i%s ID%i %s", i, " : ", BCS[i]->iLabel, BCS[i]->sTitle);
		outtext1(buff);
	}
	if ((iNoBCs > 0) && (iCurBC < iNoBCs)) {
		outtext1("Active Boundary Set:-");
		sprintf_s(buff, "%3i%s ID%i %s", iCurBC, " : ", BCS[iCurBC]->iLabel, BCS[iCurBC]->sTitle);
		outtext1(buff);
	} else {
		outtext1("ERROR: No Active Boundary Set.");
	}
}

void ME_Object::ListTSET() {
	int i;
	char buff[200];
	CString iGp;
	CString oLine;
	outtext1("TEMPERATURE SET LISTING:-");

	for (i = 0; i < iNoTSets; i++) {
		sprintf_s(buff, "%3i%s ID%i %s", i, " : ", TSETS[i]->iLabel, TSETS[i]->sTitle);
		outtext1(buff);
	}
	if ((iNoTSets > 0) && (iCurTSet < iNoTSets)) {
		outtext1("Active Temperature Set:-");
		sprintf_s(buff, "%3i%s ID%i %s", iCurTSet, " : ", TSETS[iCurTSet]->iLabel, TSETS[iCurTSet]->sTitle);
		outtext1(buff);
	} else {
		outtext1("ERROR: No Active Temperature Set.");
	}
}

void ME_Object::DeleteLC(int iSet) {
	int i;
	char buff[80];

	if ((iSet > -1) && (iSet < iNoLCs)) {
		sprintf_s(buff, "%s%s", "Deleting Load Set:- ", LCS[iSet]->sTitle);
		LCS[iSet]->DeleteAll();
		delete (LCS[iSet]);
		outtext1(buff);
		if (iCurLC >= iSet)
			iCurLC--;

		for (i = iSet; i < iNoLCs - 1; i++) {
			LCS[i] = LCS[i + 1];
		}
		iNoLCs--;
		if (iNoLCs == 0) {
			iCurLC = -1;
		}
	}
}

void ME_Object::DeleteBC(int iSet) {
	int i;
	char buff[80];

	if ((iSet > -1) && (iSet < iNoBCs)) {
		sprintf_s(buff, "%s%s", "Deleting Boundary Set:-", BCS[iSet]->sTitle);
		BCS[iSet]->DeleteAll();
		delete (BCS[iSet]);
		outtext1(buff);
		if (iCurBC >= iSet)
			iCurBC--;
		for (i = iSet; i < iNoBCs - 1; i++) {
			BCS[i] = BCS[i + 1];
		}
		iNoBCs--;
		if (iNoLCs == 0) {
			iCurBC = -1;
		}
	}
}

void ME_Object::DeleteTSET(int iSet) {
	int i;
	char buff[80];

	if ((iSet > -1) && (iSet < iNoTSets)) {
		sprintf_s(buff, "%s%s", "Deleting Temperature Set:-", TSETS[iSet]->sTitle);
		TSETS[iSet]->DeleteAll();
		delete (TSETS[iSet]);
		outtext1(buff);
		if (iCurTSet >= iSet)
			iCurTSet--;
		for (i = iSet; i < iNoTSets - 1; i++) {
			TSETS[i] = TSETS[i + 1];
		}
		iNoTSets--;
		if (iNoLCs == 0) {
			iCurTSet = -1;
		}
	}
}

// Loadset BC as TSet Creation
int ME_Object::CreateLC(int ID, CString sTit) {
	int irc = -1;
	if (iNoLCs < MAX_SETS) {
		LCS[iNoLCs] = new cLinkedList();
		LCS[iNoLCs]->iLabel = ID;
		LCS[iNoLCs]->sTitle = sTit;
		LCS[iNoLCs]->pParent = this;
		if (iCurLC == -1)
			iCurLC = iNoLCs;
		irc = iCurLC;
		iNoLCs++;
	}
	return (irc);
}

int ME_Object::CreateBC(int ID, CString sTit) {
	int irc = -1;
	if (iNoBCs < MAX_SETS) {
		BCS[iNoBCs] = new cLinkedListB();
		BCS[iNoBCs]->iLabel = ID;
		BCS[iNoBCs]->sTitle = sTit;
		BCS[iNoBCs]->pParent = this;
		// if (iCurBC==-1)
		iCurBC = iNoBCs;
		irc = iCurBC;
		iNoBCs++;
	}
	return (irc);
}

int ME_Object::CreateTSET(int ID, CString sTit) {
	int irc = -1;
	if (iNoTSets < MAX_SETS) {
		TSETS[iNoTSets] = new cLinkedListT();
		TSETS[iNoTSets]->iLabel = ID;
		TSETS[iNoTSets]->sTitle = sTit;
		TSETS[iNoTSets]->pParent = this;
		if (iCurTSet == -1)
			iCurTSet = iNoTSets;
		irc = iCurTSet;
		iNoTSets++;
	}
	return (irc);
}

// iType is resulatant entity type
// pThis the object that has the association
void ME_Object::RelTo(G_Object* pThis, ObjList* pList, int iType) {
	int i;
	int j;

	// we are looking for Loads related to either element or node
	if ((iType == 321) || (iType == 323) || (iType == 324) || (iType == 326) || (iType == 328) || (iType == 329)) {
		if (iCurLC != -1) {
			BCLD* pNext;
			pNext = (BCLD*) LCS[iCurLC]->Head;
			while (pNext != NULL) {
				if (pNext->pObj == pThis)
					pList->AddEx(pNext);
				pNext = (BCLD*) pNext->next;
			}
		}
	}
	// we are looking for Restrainrs related to node
	if ((iType == 322) || (iType == 327)) {
		if (iCurBC != -1) {
			BCLD* pNext;
			pNext = (BCLD*) BCS[iCurBC]->Head;
			while (pNext != NULL) {
				if (pNext->pObj == pThis)
					pList->AddEx(pNext);
				pNext = (BCLD*) pNext->next;
			}
		}
	}

	if (iType == 325) {
		if (iCurTSet != -1) {
			BCLD* pNext;
			pNext = (BCLD*) TSETS[iCurTSet]->Head;
			while (pNext != NULL) {
				if (pNext->pObj == pThis)
					pList->AddEx(pNext);
				pNext = (BCLD*) pNext->next;
			}
		}
	}

	if ((iType == 1) || (iType == 3) || (iType == 4) || (iType == 12)) {
		if ((pThis->iObjType == 1) ||
		    (pThis->iObjType == 3) ||
		    (pThis->iObjType == 12) ||
		    (pThis->iObjType == 200) ||
		    (pThis->iObjType == 201) ||
		    (pThis->iObjType == 202)) {
			if (iType == 4) {
				if (pThis->pParent != NULL) {
					pList->AddEx(pThis->pParent);
				}
			} else if ((iType == 1) && (pThis->iObjType == 3) && (pThis->pParent == this)) {
				// Node related to element pThis
				E_Object* pE = (E_Object*) pThis;
				for (j = 0; j < pE->iNoNodes; j++) {
					pList->AddEx(pE->GetNode(j));
				}
			} else if ((iType == 1) && (pThis->iObjType == 12) && (pThis->pParent == this)) {
				// Nodes related to coordsys
				for (i = 0; i < iNdNo; i++) {
					if ((pNodes[i]->DefSys == pThis->iLabel) || (pNodes[i]->OutSys == pThis->iLabel))
						pList->AddEx(pNodes[i]);
				}
			} else if ((iType == 3) && (pThis->iObjType == 12) && (pThis->pParent == this)) {
				// Elements related to coordsys
				// iMCys need to move to E_Object as all element can have it
				for (i = 0; i < iElNo; i++) {
					if (pElems[i]->iType == 94) {
						E_Object4* p4 = (E_Object4*) pElems[i];
						if (p4->iMCys == pThis->iLabel)
							pList->AddEx(pElems[i]);
					} else if (pElems[i]->iType == 91) {
						E_Object3* p3 = (E_Object3*) pElems[i];
						if (p3->iMCys == pThis->iLabel)
							pList->AddEx(pElems[i]);
					} else if (pElems[i]->iType == 136) {
						E_Object2* p2 = (E_Object2*) pElems[i];
						if (p2->iCSYS == pThis->iLabel)
							pList->AddEx(pElems[i]);
					}
				}
			} else if ((iType == 1) && (pThis->iObjType == 321) && (pThis->pParent == this)) {
				// Node related to element pThis
				G_Object* pN;
				pN = GetNode(pThis->iLabel);
				if (pN != NULL)
					pList->AddEx(pN);
			} else if ((iType == 1) && (pThis->iObjType == 322) && (pThis->pParent == this)) {
				// Node related to element pThis
				G_Object* pN;
				pN = GetNode(pThis->iLabel);
				if (pN != NULL)
					pList->AddEx(pN);
			} else if ((iType == 1) && (pThis->iObjType == 326) && (pThis->pParent == this)) {
				// Node related to element pThis
				G_Object* pN;
				pN = GetNode(pThis->iLabel);
				if (pN != NULL)
					pList->AddEx(pN);
			} else if ((iType == 1) && (pThis->iObjType == 327) && (pThis->pParent == this)) {
				// Node related to element pThis
				G_Object* pN;
				pN = GetNode(pThis->iLabel);
				if (pN != NULL)
					pList->AddEx(pN);
			} else if ((iType == 3) && (pThis->iObjType == 324) && (pThis->pParent == this)) {
				// Node related to element pThis
				E_Object* pE;
				pE = GetElement(pThis->iLabel);
				if (pE != NULL)
					pList->AddEx(pE);
			} else if ((iType == 3) && (pThis->iObjType == 325) && (pThis->pParent == this)) {
				// Node related to element pThis
				E_Object* pE;
				pE = GetElement(pThis->iLabel);
				if (pE != NULL)
					pList->AddEx(pE);
			} else if ((iType == 3) && (pThis->iObjType == 328) && (pThis->pParent == this)) {
				// Node related to element pThis
				E_Object* pE;
				pE = GetElement(pThis->iLabel);
				if (pE != NULL)
					pList->AddEx(pE);
			} else if ((iType == 3) && (pThis->iObjType == 329) && (pThis->pParent == this)) {
				// Node related to element pThis
				E_Object* pE;
				pE = GetElement(pThis->iLabel);
				if (pE != NULL)
					pList->AddEx(pE);
			} else if ((iType == 3) && (pThis->iObjType == 1) && (pThis->pParent == this)) {
				// Element related to Node pThis
				for (i = 0; i < iElNo; i++) {
					for (j = 0; j < pElems[i]->iNoNodes; j++) {
						if (pElems[i]->GetNode(j) == pThis) {
							pList->AddEx(pElems[i]);
						}
					}
				}
			} else if ((iType == 12) && (pThis->iObjType == 1) && (pThis->pParent == this)) {
				// Coord related to Node pThis
				G_Object* pC;
				Node* pN;
				pN = (Node*) pThis;
				if (pN->DefSys > 0) {
					pC = GetSys(pN->DefSys);
					if (pC != NULL) {
						pList->AddEx(pC);
					}
				}
				if (pN->OutSys > 0) {
					pC = GetSys(pN->OutSys);
					if (pC != NULL) {
						pList->AddEx(pC);
					}
				}
			} else if ((iType == 12) && (pThis->iObjType == 3) && (pThis->pParent == this)) {
				// Coord related to Element pThis
				G_Object* pC;
				E_Object* pE;
				pE = (E_Object*) pThis;
				if (pE->iType == 136) {
					E_Object2* pE2;
					pE2 = (E_Object2*) pE;
					if (pE2->iCSYS > 0) {
						pC = GetSys(pE2->iCSYS);
						if (pC != NULL) {
							pList->AddEx(pC);
						}
					}
				} else if (pE->iType == 91) {
					E_Object3* pE3;
					pE3 = (E_Object3*) pE;
					if (pE3->iMCys > 0) {
						pC = GetSys(pE3->iMCys);
						if (pC != NULL) {
							pList->AddEx(pC);
						}
					}
				} else if (pE->iType == 94) {
					E_Object4* pE4;
					pE4 = (E_Object4*) pE;
					if (pE4->iMCys > 0) {
						pC = GetSys(pE4->iMCys);
						if (pC != NULL) {
							pList->AddEx(pC);
						}
					}
				}
			}
		}
	}
}

void ME_Object::Serialize(CArchive& ar, int iV) {
	int i;
	int iE;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << sName;
		ar << iFileNo; // new
		for (i = 0; i < iFileNo; i++) // new
			ar << sFiles[i]; // new
		ar << iIntID;
		ar << bDrawN;
		ar << TransMat.m_00;
		ar << TransMat.m_01;
		ar << TransMat.m_02;
		ar << TransMat.m_03;
		ar << TransMat.m_10;
		ar << TransMat.m_11;
		ar << TransMat.m_12;
		ar << TransMat.m_13;
		ar << TransMat.m_20;
		ar << TransMat.m_21;
		ar << TransMat.m_22;
		ar << TransMat.m_23;
		ar << TransMat.m_30;
		ar << TransMat.m_31;
		ar << TransMat.m_32;
		ar << TransMat.m_33;
		ar << iCYS;
		for (i = 0; i < iCYS; i++) {
			pSys[i]->Serialize(ar, iV);
		}
		if (sName != "NULL") {
			ar << iNdNo;
			for (i = 0; i < iNdNo; i++) {
				pNodes[i]->Serialize(ar, iV);
			}
			ar << iElNo;
			for (i = 0; i < iElNo; i++) {
				ar << pElems[i]->iType;
				pElems[i]->Serialize(ar, iV, this);
			}
		} else {
			ar << 0;
			ar << 0;
		}
		// LOAD AND BOUNDARY SETS
		ar << iCurLC;
		ar << iNoLCs;
		for (i = 0; i < iNoLCs; i++) {
			LCS[i]->Serialize(ar, iV, this);
		}
		ar << iCurBC;
		ar << iNoBCs;
		for (i = 0; i < iNoBCs; i++) {
			BCS[i]->Serialize(ar, iV, this);
		}
		ar << iCurTSet;
		ar << iNoTSets;
		for (i = 0; i < iNoTSets; i++) {
			TSETS[i]->Serialize(ar, iV, this);
		}
		pSOLS->Serialize(ar, iV);
	} else {
		G_Object::Serialize(ar, iV);
		ar >> sName;
		if (iV <= -63) {
			ar >> iFileNo; // new
			for (i = 0; i < iFileNo; i++) // new
				ar >> sFiles[i]; // new
		}
		if (iV <= -62) {
			if (iV > -76) {
				int iTemp;
				ar >> iTemp;
				iIntID = iTemp;
			} else {
				ar >> iIntID;
			}
		}
		ar >> bDrawN;
		ar >> TransMat.m_00;
		ar >> TransMat.m_01;
		ar >> TransMat.m_02;
		ar >> TransMat.m_03;
		ar >> TransMat.m_10;
		ar >> TransMat.m_11;
		ar >> TransMat.m_12;
		ar >> TransMat.m_13;
		ar >> TransMat.m_20;
		ar >> TransMat.m_21;
		ar >> TransMat.m_22;
		ar >> TransMat.m_23;
		ar >> TransMat.m_30;
		ar >> TransMat.m_31;
		ar >> TransMat.m_32;
		ar >> TransMat.m_33;
		ar >> iCYS;
		for (i = 0; i < iCYS; i++) {
			pSys[i] = new CoordSys;
			pSys[i]->Serialize(ar, iV);
			pSys[i]->pParent = this;
		}
		ar >> iNdNo;
		if (iNdNo > 5000) {
			TempList = new ObjTempList();
		}
		for (i = 0; i < iNdNo; i++) {
			pNodes[i] = new Node;
			pNodes[i]->Serialize(ar, iV);
			pNodes[i]->pParent = this;
			if ((TempList != NULL) && (pNodes[i]->iLabel < 99999999)) {
				TempList->Objs[pNodes[i]->iLabel] = pNodes[i];
			}
		}
		ar >> iElNo;
		for (i = 0; i < iElNo; i++) {
			ar >> iE;
			switch (iE) {
				case 161:
					pElems[i] = new E_Object1;
					break;
				case 21:
					pElems[i] = new E_Object2B;
					break;
				case 11:
					pElems[i] = new E_Object2R;
					break;
				case 22:
					pElems[i] = new E_Object2B;
					break;
				case 121:
					pElems[i] = new E_ObjectR2;
					break;
				case 136:
					pElems[i] = new E_Object2;
					break;
				case 137:
					pElems[i] = new E_Object2;
					break;
				case 138:
					pElems[i] = new E_Object2BUSH;
					break;
				case 91:
					pElems[i] = new E_Object3;
					break;
				case 94:
					pElems[i] = new E_Object4;
					break;
				case 115:
					pElems[i] = new E_Object38;
					break;
				case 111:
					pElems[i] = new E_Object34;
					break;
				case 310:
					pElems[i] = new E_Object310;
					break;
				case 112:
					pElems[i] = new E_Object36;
					break;
				case 122:
					pElems[i] = new E_ObjectR;
					break;
				case 1000:
					pElems[i] = new E_CellS;
					break;
			}
			pElems[i]->Serialize(ar, iV, this);
			pElems[i]->pParent = this;
		}
		// LOAD AND BOUNDARY SETS
		ar >> iCurLC;
		ar >> iNoLCs;
		for (i = 0; i < iNoLCs; i++) {
			LCS[i] = new cLinkedList();
			LCS[i]->pParent = this;
			LCS[i]->Serialize(ar, iV, this);
		}
		ar >> iCurBC;
		ar >> iNoBCs;
		for (i = 0; i < iNoBCs; i++) {
			BCS[i] = new cLinkedListB();
			BCS[i]->pParent = this;
			BCS[i]->Serialize(ar, iV, this);
		}
		ar >> iCurTSet;
		ar >> iNoTSets;
		for (i = 0; i < iNoTSets; i++) {
			TSETS[i] = new cLinkedListT();
			TSETS[i]->pParent = this;
			TSETS[i]->Serialize(ar, iV, this);
		}
		// NEW SOLUTION SEQUENCES
		pSOLS->Serialize(ar, iV);
	}
	if (TempList != NULL) {
		delete (TempList);
		TempList = NULL;
	}
	this->MaxLab();
}

G_Object* ME_Object::Copy(G_Object* Parrent) {
	int i;
	int iE;
	ME_Object* rME = new ME_Object;
	rME->Drawn = Drawn;
	rME->Selectable = Selectable;
	rME->Visable = Visable;
	rME->iColour = iColour;
	rME->iObjType = iObjType;
	rME->iLabel = iLabel;
	rME->sName = sName;
	rME->iNdNo = iNdNo;
	rME->bDrawN = bDrawN;
	rME->pParent = NULL;

	// rME->iNoMats=iNoMats;
	// for (i=0;i<iNoMats;i++)
	//{
	//   rME->pMats[i]=pMats[i]->Copy();
	// }
	for (i = 0; i < iNdNo; i++) {
		rME->pNodes[i] = new Node;
		rME->pNodes[i] = (Node*) pNodes[i]->Copy(rME);
	}

	rME->iElNo = iElNo;
	for (i = 0; i < iElNo; i++) {
		iE = pElems[i]->iType;
		switch (iE) {
			case 161:
				rME->pElems[i] = (E_Object1*) pElems[i]->Copy(rME);
				break;
			case 21:
				rME->pElems[i] = (E_Object2*) pElems[i]->Copy(rME);
				break;
			case 22:
				rME->pElems[i] = (E_Object2*) pElems[i]->Copy(rME);
				break;
			case 121:
				rME->pElems[i] = (E_Object2*) pElems[i]->Copy(rME);
				break;
			case 136:
				rME->pElems[i] = (E_Object2*) pElems[i]->Copy(rME);
				break;
			case 137:
				rME->pElems[i] = (E_Object2*) pElems[i]->Copy(rME);
				break;
			case 91:
				rME->pElems[i] = (E_Object3*) pElems[i]->Copy(rME);
				break;
			case 94:
				rME->pElems[i] = (E_Object4*) pElems[i]->Copy(rME);
				break;
			case 115:
				rME->pElems[i] = (E_Object38*) pElems[i]->Copy(rME);
				break;
			case 111:
				rME->pElems[i] = (E_Object34*) pElems[i]->Copy(rME);
				break;
			case 112:
				rME->pElems[i] = (E_Object36*) pElems[i]->Copy(rME);
				break;
			case 122:
				rME->pElems[i] = (E_ObjectR*) pElems[i]->Copy(rME);
				break;
			case 310:
				rME->pElems[i] = (E_Object310*) pElems[i]->Copy(rME);
				break;
		}
		rME->pElems[i]->pParent = rME;
	}
	rME->iCYS = iCYS;
	for (i = 0; i < iCYS; i++) {
		rME->pSys[i] = (CoordSys*) pSys[i]->Copy(rME);
	}

	return (rME);
}

BOOL ME_Object::isFaceDeletable(eFace* inFace) {
	BOOL bRet = TRUE;
	eFace* Fc[8];
	int iN;
	int i, j;
	int iC;
	iC = 0;
	for (i = 0; i < iElNo; i++) {
		iN = pElems[i]->GetfaceList(Fc);
		if (iN > 0) {
			for (j = 0; j < iN; j++) {
				if (inFace->isSame(Fc[j]) == TRUE) {
					iC++;
					delete (Fc[j]);
				}
			}
			if (iC > 1) {
				break;
			}
		}
	}
	if (iC > 1) {
		bRet = FALSE;
	}
	return (bRet);
}

BOOL ME_Object::isLinkDeletable(eEdge* inLink) {
	BOOL bRet = TRUE;
	eEdge* Lk[12];
	int iN;
	int i, j;
	int iC;
	iC = 0;
	for (i = 0; i < iElNo; i++) {
		iN = pElems[i]->GetLinkList(Lk);

		if (iN > 0) {
			for (j = 0; j < iN; j++) {
				if (inLink->isSame(Lk[j]) == TRUE) {
					iC++;
					delete (Lk[j]);
				}
			}
			if (iC > 1) {
				break;
			}
		}
	}
	if (iC > 1) {
		bRet = FALSE;
	}
	return (bRet);
}

void ME_Object::BuildLinkList() {
	eFace* Fc[8];
	eEdge* Lk[200];
	int iN;
	int i, j;
	for (i = 0; i < iElNo; i++) {
		iN = pElems[i]->GetfaceList(Fc);
		if (iN > 0) {
			for (j = 0; j < iN; j++) {
				FcList->Add(Fc[j]);
			}
		}
		iN = pElems[i]->GetLinkList(Lk);
		if (iN > 0) {
			for (j = 0; j < iN; j++) {
				LkList->Add(Lk[j]);
			}
		}
	}
	outtext1("Finished List Generation.");
}

void ME_Object::Append(ME_Object* pMexh, int iNInc, int iEInc) {
	int i;
	int iSNodePos;

	iSNodePos = this->iNdNo;

	if (pMexh != NULL) {
		GPs[iNoGps] = new NEList();
		GPs[iNoGps]->Title = pMexh->sName;
		iNoGps++;
		for (i = 0; i < pMexh->iNdNo; i++) {
			this->pNodes[iNdNo] = new Node;
			this->pNodes[iNdNo] = (Node*) pMexh->pNodes[i]->Copy(this);
			this->pNodes[iNdNo]->iLabel = iNdNo + 1 + iNInc;
			GPs[iNoGps - 1]->ids[GPs[iNoGps - 1]->iNo] = this->pNodes[iNdNo]->iLabel;
			GPs[iNoGps - 1]->iType[GPs[iNoGps - 1]->iNo] = 1;
			GPs[iNoGps - 1]->iNo++;
			iNdNo++;
		}
		int iE;
		for (i = 0; i < pMexh->iElNo; i++) {
			iE = pMexh->pElems[i]->iType;
			switch (iE) {
				case 161:
					this->pElems[iElNo] = (E_Object1*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 21:
					this->pElems[iElNo] = (E_Object2*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 22:
					this->pElems[iElNo] = (E_Object2*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 121:
					this->pElems[iElNo] = (E_Object2*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 136:
					this->pElems[iElNo] = (E_Object2*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 137:
					this->pElems[iElNo] = (E_Object2*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 91:
					this->pElems[iElNo] = (E_Object3*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 94:
					this->pElems[iElNo] = (E_Object4*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 115:
					this->pElems[iElNo] = (E_Object38*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 111:
					this->pElems[iElNo] = (E_Object34*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 112:
					this->pElems[iElNo] = (E_Object36*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
				case 122:
					this->pElems[iElNo] = (E_ObjectR*) pMexh->pElems[i]->CopyAppend(iSNodePos, this, pMexh);
					break;
			}
			this->pElems[iElNo]->iLabel = iElNo + 1 + iEInc;
			this->pElems[iElNo]->pPr = NULL;
			GPs[iNoGps - 1]->ids[GPs[iNoGps - 1]->iNo] = this->pElems[iElNo]->iLabel;
			GPs[iNoGps - 1]->iType[GPs[iNoGps - 1]->iNo] = 3;
			GPs[iNoGps - 1]->iNo++;
			iElNo++;
		}
	}
}

ME_Object* ME_Object::GetMesh() // GetPtr to this
{
	return (this);
}

void ME_Object::ExportSec(FILE* pFile, int id, CString Name, double w, double h, double t) {
	double Area;
	double w1;
	double h1;
	double Ixx;
	double Iyy;
	w1 = w - 2 * t;
	h1 = h - 2 * t;
	Area = w * h - w1 * h1;
	Ixx = (w * h * h * h) / 12 - (w1 * h1 * h1 * h1) / 12;
	Iyy = (h * w * w * w) / 12 - (h1 * w1 * w1 * w1) / 12;

	fprintf(pFile, "%10i%10i%10i\n", id, 2, 0);
	fprintf(pFile, "%20s\n", Name);
	fprintf(pFile, "%13.6E%13.6E%13.6E%13.6E%13.6E%13.6E\n", w, h, t, t, 0.0, 0.0);
	fprintf(pFile, "%13.6E%13.6E%13.6E%13.6E\n", 0.0, 0.0, 0.0, 0.0);
	fprintf(pFile, "%13.6E%13.6E%13.6E%13.6E%13.6E%13.6E\n", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	fprintf(pFile, "%13.6E%13.6E%13.6E%13.6E%13.6E%13.6E\n", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	fprintf(pFile, "%13.6E%13.6E%13.6E%13.6E%13.6E%13.6E\n", 0.0, 0.0, 0.0, 0.0, w / 2, h / 2);
	fprintf(pFile, "%13.6E%13.6E%13.6E%13.6E%13.6E%13.6E\n", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	fprintf(pFile, "%13.6E%13.6E%13.6E%13.6E%13.6E%13.6E\n", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	fprintf(pFile, "%13.6E%13.6E%13.6E%13.6E%13.6E%13.6E\n", 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	fprintf(pFile, "%13.6E%13.6E%13.6E%13.6E\n", 0.0, 0.0, 0.0, 0.0);
	fprintf(pFile, "%10i%10i%10i%10i%10i%10i\n", 6, 6, 6, 6, 6, 6);
	fprintf(pFile, "%10i%10i%10i%10i%13.6E\n", 0, 45, 1, 11, 1.0);
}

void ME_Object::ExportRes(FILE* pFile) {
	int i;
	for (i = 0; i < iNoRes; i++) {
		ResultsSets[i]->PrintToFile(pFile);
	}
}

void ME_Object::ExportNASExec(FILE* pFile, SecTable* pS) {
	int iC = pSOLS->iCur;
	if (iC != -1) {
		if (pSOLS->pSols[iC]->iType == 0) {
			// SOL 101
			fprintf(pFile, "%s\n", "SOL 101");
			fprintf(pFile, "%s\n", "CEND");
			ExportNASCase101(pFile, pS);
		} else if (pSOLS->pSols[iC]->iType == 1) {
			// SOL STEADY STATE HEAT
			fprintf(pFile, "%s\n", "$ERROR NO EXECUTIVE STATEMENT AVAILABLE FOR STEADY STATE HEAT TRANSFUR");
		} else if (pSOLS->pSols[iC]->iType == 2) {
			// SOL 101
			fprintf(pFile, "%s\n", "SOL 101");
			fprintf(pFile, "%s\n", "CEND");
			ExportNASCase101(pFile, pS);
		} else if (pSOLS->pSols[iC]->iType == 3) {
			fprintf(pFile, "%s\n", "SOL 103");
			fprintf(pFile, "%s\n", "CEND");
			fprintf(pFile, "%s\n", "$ERROR CASE CONTROL NOT IMPLEMENTED YET");
		}
	}
}

void ME_Object::ExportNASCase101(FILE* pFile, SecTable* pS) {
	int i = 0;
	int iNoSteps = 0;
	int iC = pSOLS->iCur;
	fprintf(pFile, "%s\n", "$******************* CASE CONTROL *************************");
	fprintf(pFile, "%s\n", "$");
	fprintf(pFile, "TITLE = %s\n", pSOLS->pSols[iC]->sTitle);
	fprintf(pFile, "%s\n", "ECHO = NONE");
	Solution* pSOL = pSOLS->pSols[iC];
	iNoSteps = pSOL->iNo;
	for (i = 0; i < iNoSteps; i++) {
		fprintf(pFile, "SUBCASE %i\n", i + 1);
		fprintf(pFile, "    TITLE = %s\n", pSOL->sStepTitle[i]);
		if (pSOL->LS[i] > 0) {
			fprintf(pFile, "    LOAD = %i\n", pSOL->LS[i]);
		}
		if (pSOL->BS[i] > 0) {
			fprintf(pFile, "    SPC  = %i\n", pSOL->BS[i]);
		}
		if (pSOL->TS[i] > 0) {
			fprintf(pFile, "    TEMP = %i\n", pSOL->TS[i]);
		}
		fprintf(pFile, "    %s\n", "DISPLACEMENT(PRINT, PLOT) = ALL");
		fprintf(pFile, "    %s\n", "FORCE(PRINT, PLOT) = ALL");
		fprintf(pFile, "    %s\n", "STRESS(PRINT, PLOT, CENTER) = ALL");
		fprintf(pFile, "    %s\n", "OLOAD(PRINT) = ALL");
	}
}

void ME_Object::ExportNAS(FILE* pFile, SecTable* pS, int iFileNo) {
	int i;
	fprintf(pFile, "%s\n", "$***************COORDINATE SYSTEMS*************************");
	for (i = 0; i < iCYS; i++) {
		if ((iFileNo == -1) || (pSys[i]->iFile == iFileNo))
			pSys[i]->ExportNAS(pFile);
	}

	fprintf(pFile, "%s\n", "$********************NODES*********************************");
	for (i = 0; i < iNdNo; i++) {
		CoordSys* pDef = GetSys(pNodes[i]->DefSys);
		if ((iFileNo == -1) || (pNodes[i]->iFile == iFileNo))
			pNodes[i]->ExportNAS(pFile, pDef);
	}
	fprintf(pFile, "%s\n", "$*******************ELEMENTS******************************");
	for (i = 0; i < iElNo; i++) {
		if ((iFileNo == -1) || (pElems[i]->iFile == iFileNo))
			pElems[i]->ExportNAS(pFile);
	}
}

void ME_Object::ExportNAS_SETS(FILE* pFile, SecTable* pS, int iFileNo) {
	NEList* LCS = new NEList();
	NEList* BCS = new NEList();
	;
	NEList* TS = new NEList();
	;
	int i;
	int iC = pSOLS->iCur;
	Solution* pSOL = pSOLS->pSols[iC];
	int iNoSteps = pSOL->iNo;
	for (i = 0; i < iNoSteps; i++) {
		if ((pSOL->LS[i] > 0) && (!LCS->IsIn(pSOL->LS[i]))) {
			LCS->Add(pSOL->LS[i], 1);
			cLinkedList* pCLC = GetLC(pSOL->LS[i]);
			if (pCLC != nullptr) {
				fprintf(pFile, "$%s\n", pCLC->sTitle);
				BCLD* pNext;
				pNext = (BCLD*) pCLC->Head;
				while (pNext != NULL) {
					if ((iFileNo == -1) || (pNext->iFile == iFileNo))
						pNext->ExportNAS(pFile);
					pNext = (BCLD*) pNext->next;
				}
			}
		}
		if ((pSOL->BS[i] > 0) && (!BCS->IsIn(pSOL->BS[i]))) {
			BCS->Add(pSOL->BS[i], 1);
			cLinkedList* pCBC = GetBC(pSOL->BS[i]);
			if (pCBC != nullptr) {
				fprintf(pFile, "$%s\n", pCBC->sTitle);
				BCLD* pNext;
				pNext = (BCLD*) pCBC->Head;
				while (pNext != NULL) {
					if ((iFileNo == -1) || (pNext->iFile == iFileNo))
						pNext->ExportNAS(pFile);
					pNext = (BCLD*) pNext->next;
				}
			}
		}
		if ((pSOL->TS[i] > 0) && (!TS->IsIn(pSOL->TS[i]))) {
			TS->Add(pSOL->TS[i], 1);
			cLinkedList* pTSET = GetTSET(pSOL->TS[i]);
			if (pTSET != nullptr) {
				fprintf(pFile, "$%s\n", pTSET->sTitle);
				BCLD* pNext;
				pNext = (BCLD*) pTSET->Head;
				while (pNext != NULL) {
					if ((iFileNo == -1) || (pNext->iFile == iFileNo))
						pNext->ExportNAS(pFile);
					pNext = (BCLD*) pNext->next;
				}
			}
		}
	}
	delete (LCS);
	delete (BCS);
	delete (TS);
}

ResSet* ME_Object::GetResultsSet(int iSet) {
	ResSet* pRS = NULL;
	if ((iSet < iNoRes) && (iSet > -1)) {
		pRS = ResultsSets[iSet];
	}
	return (pRS);
}

void ME_Object::SetColourBar(float fMax, float fMin) {
	SetColBar(fMin, fMax);
}

void ME_Object::NullResults() {
	int i;
	for (i = 0; i < iNdNo; i++) {
		pNodes[i]->pResV = NULL;
	}
	for (i = 0; i < iElNo; i++) {
		pElems[i]->pResV = NULL;
	}
}

void ME_Object::DeleteAllResults() {
	int i;
	NullResults();
	for (i = 0; i < iNoRes; i++) {
		delete (ResultsSets[i]);
	}

	iNoRes = 0;
	iCurResSet = -1;
	iResVal = -1;
	iCurResSetDef = -1;
	iResValDef = -1;
	CResSet = NULL;
	CResSetDef = NULL;
	iCVar = -1;
	iCVarDef = -1;
	iPostOpt = 0;
}

void ME_Object::ResEnvMin(CString sSeq[], int iNo) {
	int iRS[50];
	int iVAR[50];
	int iOPT[50];
	// ExtractSubString2(int iP, CString sIn)

	int i;
	int j;
	for (i = 0; i < iNo; i++) {
		iRS[i] = atoi(ExtractSubString2(1, sSeq[i]));
		iVAR[i] = atoi(ExtractSubString2(2, sSeq[i]));
		iOPT[i] = atoi(ExtractSubString2(3, sSeq[i]));
	}

	double dVal;
	ResSet* pENV = NULL;
	ResSet* pC = NULL;

	// Create New ResSet
	ResultsSets[iNoRes] = new ResSet();
	ResultsSets[iNoRes]->sFile = "None";
	ResultsSets[iNoRes]->sTitle = "Envelop Min";
	ResultsSets[iNoRes]->sSubTitle = "Derived Results";
	ResultsSets[iNoRes]->ACODE = ResultsSets[iRS[0]]->ACODE;
	ResultsSets[iNoRes]->TCODE = ResultsSets[iRS[0]]->TCODE;
	ResultsSets[iNoRes]->TYPE = ResultsSets[iRS[0]]->TYPE;
	ResultsSets[iNoRes]->LC = 0;
	ResultsSets[iNoRes]->WID = 1;
	;
	pENV = ResultsSets[iNoRes];
	pENV->iNoV = 4;
	pENV->sName = "ENV MIN";
	iNoRes++;
	// create intial results to first set
	pC = ResultsSets[iRS[0]];
	pENV->lab[0] = "Res Set ID";
	pENV->lab[1] = "Varible ID";
	pENV->lab[2] = "Optional ID";
	pENV->lab[3] = pC->lab[iVAR[0]];
	for (i = 0; i < iElNo; i++) {
		Res* pR = pC->Get(pElems[i]->iLabel, iOPT[0]);
		if (pR != NULL) {
			Res4* pRes = new Res4();
			pRes->ID = pR->ID;
			pRes->v[0] = iRS[0];
			pRes->v[1] = iVAR[0];
			pRes->v[2] = iOPT[0];
			pRes->v[3] = *pR->GetAddress(iVAR[0]);
			pENV->Add(pRes);
		}
	}
	for (j = 1; j < iNo; j++) {
		pC = ResultsSets[iRS[j]];
		for (i = 0; i < iElNo; i++) {
			Res* pR = pC->Get(pElems[i]->iLabel, iOPT[j]);
			if (pR != NULL) {
				Res4* pRes = (Res4*) pENV->Get(pElems[i]->iLabel, 0);
				// pRes->ID = pR->ID;
				dVal = *pR->GetAddress(iVAR[j]);
				if (dVal < pRes->v[3]) {
					pRes->v[0] = iRS[j];
					pRes->v[1] = iVAR[j];
					pRes->v[2] = iOPT[j];
					pRes->v[3] = dVal;
				}
			}
		}
	}
}

void ME_Object::ResEnvMax(CString sSeq[], int iNo) {
	int iRS[50];
	int iVAR[50];
	int iOPT[50];
	// ExtractSubString2(int iP, CString sIn)

	int i;
	int j;
	for (i = 0; i < iNo; i++) {
		iRS[i] = atoi(ExtractSubString2(1, sSeq[i]));
		iVAR[i] = atoi(ExtractSubString2(2, sSeq[i]));
		iOPT[i] = atoi(ExtractSubString2(3, sSeq[i]));
	}

	double dVal;
	ResSet* pENV = NULL;
	ResSet* pC = NULL;

	// Create New ResSet
	ResultsSets[iNoRes] = new ResSet();
	ResultsSets[iNoRes]->sFile = "None";
	ResultsSets[iNoRes]->sTitle = "Envelop Max";
	ResultsSets[iNoRes]->sSubTitle = "Derived Results";
	ResultsSets[iNoRes]->ACODE = ResultsSets[iRS[0]]->ACODE;
	ResultsSets[iNoRes]->TCODE = ResultsSets[iRS[0]]->TCODE;
	ResultsSets[iNoRes]->TYPE = ResultsSets[iRS[0]]->TYPE;
	ResultsSets[iNoRes]->LC = 0;
	ResultsSets[iNoRes]->WID = 1;
	;
	pENV = ResultsSets[iNoRes];
	pENV->iNoV = 4;
	pENV->sName = "ENV MAX";
	iNoRes++;
	// create intial results to first set
	pC = ResultsSets[iRS[0]];
	pENV->lab[0] = "Res Set ID";
	pENV->lab[1] = "Varible ID";
	pENV->lab[2] = "Optional ID";
	pENV->lab[3] = pC->lab[iVAR[0]];
	for (i = 0; i < iElNo; i++) {
		Res* pR = pC->Get(pElems[i]->iLabel, iOPT[0]);
		if (pR != NULL) {
			Res4* pRes = new Res4();
			pRes->ID = pR->ID;
			pRes->v[0] = iRS[0];
			pRes->v[1] = iVAR[0];
			pRes->v[2] = iOPT[0];
			pRes->v[3] = *pR->GetAddress(iVAR[0]);
			pENV->Add(pRes);
		}
	}
	for (j = 1; j < iNo; j++) {
		pC = ResultsSets[iRS[j]];
		for (i = 0; i < iElNo; i++) {
			Res* pR = pC->Get(pElems[i]->iLabel, iOPT[j]);
			if (pR != NULL) {
				Res4* pRes = (Res4*) pENV->Get(pElems[i]->iLabel, 0);
				// pRes->ID = pR->ID;
				dVal = *pR->GetAddress(iVAR[j]);
				if (dVal > pRes->v[3]) {
					pRes->v[0] = iRS[j];
					pRes->v[1] = iVAR[j];
					pRes->v[2] = iOPT[j];
					pRes->v[3] = dVal;
				}
			}
		}
	}
}

void ME_Object::ResSetScale(CString sSeq, double dS) {
	int iRS;
	int iVAR;
	int iOPT;

	int i;
	iRS = atoi(ExtractSubString2(1, sSeq));
	iVAR = atoi(ExtractSubString2(2, sSeq));
	iOPT = atoi(ExtractSubString2(3, sSeq));

	ResSet* pC = NULL;
	pC = ResultsSets[iRS];
	if (pC != NULL) {
		for (i = 0; i < iElNo; i++) {
			Res* pR = pC->Get(pElems[i]->iLabel, iOPT);
			if (pR != NULL) {
				*pR->GetAddress(iVAR) *= dS;
			}
		}
	} else {
		outtext1("ERROR: No Results Set Found.");
	}
}

void ME_Object::ResSetDivInTo(CString sSeq, double dS) {
	int iRS;
	int iVAR;
	int iOPT;
	double dV;

	int i;
	iRS = atoi(ExtractSubString2(1, sSeq));
	iVAR = atoi(ExtractSubString2(2, sSeq));
	iOPT = atoi(ExtractSubString2(3, sSeq));

	ResSet* pC = NULL;
	pC = ResultsSets[iRS];
	if (pC != NULL) {
		for (i = 0; i < iElNo; i++) {
			Res* pR = pC->Get(pElems[i]->iLabel, iOPT);
			if (pR != NULL) {
				dV = *pR->GetAddress(iVAR);
				if (abs(dV) > 1.0e-36)
					*pR->GetAddress(iVAR) = dS / dV;
				else
					*pR->GetAddress(iVAR) = FLT_MAX;
			}
		}
	} else {
		outtext1("ERROR: No Results Set Found.");
	}
}

void ME_Object::PostContourVals(ResSet* pRes, int iVar, int iOpt, float& fMax, float& fMin) {
	int i;
	fMax = 0;
	fMin = 0;
	BOOL bFirst = TRUE;
	if (iOpt == 0)
		iOpt = pRes->iDefID;
	if ((pRes != CResSet) || (iOpt != iPostOpt)) {
		NullResults();
		iPostOpt = iOpt;
		if (iElNo > 0) {
			if ((pRes->TCODE == 4) ||
			    (pRes->TCODE == 5) ||
			    (pRes->TCODE == 25) ||
			    (pRes->TCODE == 18) ||
			    (pRes->TCODE == 1004) ||
			    (pRes->TCODE == 1005) ||
			    (pRes->TCODE == 4004) || // GRMS FORCE?
			    (pRes->TCODE == 4005)) // Not sure where this tcode is documented Grms Rand
			{
				for (i = 0; i < iElNo; i++) {
					Res* pR = pRes->Get(pElems[i]->iLabel, iOpt);
					if (pR != NULL) {
						pElems[i]->pResV = pR;
					}
				}
			}
		}
		if (iNdNo > 0) {
			if ((pRes->TCODE == 1) || (pRes->TCODE == 7) || (pRes->TCODE == 39) || (pRes->TCODE == 1011) || (pRes->TCODE == 1039)) {
				for (i = 0; i < iNdNo; i++) {
					if (pRes->iNoV == 6) {
						Res6* pR = (Res6*) pRes->Get(pNodes[i]->iLabel, 0);
						if (pR != NULL) {
							pNodes[i]->pResV = pR;
						}
					} else if (pRes->iNoV == 1) {
						Res1* pR = (Res1*) pRes->Get(pNodes[i]->iLabel, 0);
						if (pR != NULL) {
							pNodes[i]->pResV = pR;
						}
					} else if (pRes->iNoV == 13) {
						Res13* pR = (Res13*) pRes->Get(pNodes[i]->iLabel, 0);
						if (pR != NULL) {
							pNodes[i]->pResV = pR;
						}
					}
				}
			}
		}
	}
	float fResVal;
	// Calculate Max Min
	bFirst = TRUE;
	if (iNdNo > 0) {
		if ((pRes->TCODE == 1) || (pRes->TCODE == 7) || (pRes->TCODE == 39) || (pRes->TCODE == 1011) || (pRes->TCODE == 1039)) {
			for (i = 0; i < iNdNo; i++) {
				if (pNodes[i]->pResV != NULL) {
					fResVal = *pNodes[i]->pResV->GetAddress(iVar);
					if (bFirst) {
						fMax = fResVal;
						fMin = fResVal;
						bFirst = FALSE;
					} else {
						if (fResVal > fMax) {
							fMax = fResVal;
						}
						if (fResVal < fMin) {
							fMin = fResVal;
						}
					}
				}
			}
		}
	}
	if (iElNo > 0) {
		if ((pRes->TCODE == 4) ||
		    (pRes->TCODE == 5) ||
		    (pRes->TCODE == 25) ||
		    (pRes->TCODE == 18) ||
		    (pRes->TCODE == 1004) ||
		    (pRes->TCODE == 1005) ||
		    (pRes->TCODE == 4004) || // GRMS FORCE
		    (pRes->TCODE == 4005)) // GRMS FORCE
		{
			for (i = 0; i < iElNo; i++) {
				if (pElems[i]->pResV != NULL) {
					fResVal = *pElems[i]->pResV->GetAddress(iVar);
					if (bFirst) {
						fMax = fResVal;
						fMin = fResVal;
						bFirst = FALSE;
					} else {
						if (fResVal > fMax) {
							fMax = fResVal;
						}
						if (fResVal < fMin) {
							fMin = fResVal;
						}
					}
				}
			}
		}
	}
	pRes->fMaxV = fMax;
	pRes->fMinV = fMin;
	CResSet = pRes;
	iCVar = iVar;
	if (!bUserColBar)
		SetColBar(fMin, fMax);
}

void ME_Object::PostElResDef(ResSet* pRes, int iVar, float& fMax, float& fMin) {
	int i;
	fMax = (float) -1e+20;
	fMin = (float) 1e+20;

	if (pRes != CResSetDef) {
		for (i = 0; i < iNdNo; i++) {
			pNodes[i]->pResD = NULL;
		}
		if (iNdNo > 0) {
			if ((pRes->TCODE == 1) || (pRes->TCODE == 7)) {
				for (i = 0; i < iNdNo; i++) {
					if (pRes->iNoV == 6) {
						Res6* pR = (Res6*) pRes->Get(pNodes[i]->iLabel, 0);
						if (pR != NULL) {
							pNodes[i]->pResD = pR;
						}
					}
				}
			}
		}
	}

	CResSetDef = pRes;
	iCVarDef = iVar;
	BuildDeromedVecs();
}

void ME_Object::DeleteResVectors() {
	if (pResVectors != NULL) {
		pResVectors->DeleteAll();
		delete (pResVectors);
		pResVectors = NULL;
	}
	cBarMax = -FLT_MAX;
	cBarMin = FLT_MAX;
}

// 051019
void ME_Object::GenResVectors(int iSet, int iVec, int iDf) {
	int i;
	int iD = -1;
	int iS;
	int iEID;
	C3dMatrix mTMat;
	float fMax = (float) -1e+20;
	float fMin = (float) 1e+20;
	Res* pR;
	C3dVector vVec;
	C3dVector vC;
	BOOL isGood = FALSE;
	ResSet* pRes;
	ResDef* pDef;
	ResultsVec* pDspVec;
	pRes = this->GetResultsSet(iSet);
	if (pRes != NULL) {
		pDef = pRes->GetResDef(iVec);
		if (pDef != NULL)
			isGood = TRUE;
	}
	if (isGood) {
		if (pResVectors == NULL)
			pResVectors = new cLinkedList();
		// Vector is on node and is a vector
		if ((pDef->iLoc == 0) && (pDef->iResType == 1)) {
			for (i = 0; i < iNdNo; i++) {
				pR = pRes->Get(pNodes[i]->iLabel, 0);
				if (pR != NULL) {
					vC = pNodes[i]->Get_Centroid();
					iD = pNodes[i]->iLabel;
					vVec.x = 0;
					vVec.y = 0;
					vVec.z = 0;
					iS = 1;
					if (iDf == 3) {
						vVec.x = *pR->GetAddress(pDef->iComponents[0]);
						vVec.y = *pR->GetAddress(pDef->iComponents[1]);
						vVec.z = *pR->GetAddress(pDef->iComponents[2]);
						iS = 1; // Sign is magnitude
					} else if (iDf == 0) {
						vVec.x = *pR->GetAddress(pDef->iComponents[0]);
						if (vVec.x < 0)
							iS = -1;
					} else if (iDf == 1) {
						vVec.y = *pR->GetAddress(pDef->iComponents[1]);
						if (vVec.y < 0)
							iS = -1;
					} else if (iDf == 2) {
						vVec.z = *pR->GetAddress(pDef->iComponents[2]);
						if (vVec.z < 0)
							iS = -1;
					}

					double dM;
					dM = iS * vVec.Mag();
					if (dM > fMax)
						fMax = dM;
					if (dM < fMin)
						fMin = dM;
					pDspVec = new ResultsVec(iD, vC, vVec, 4, iDf, iS, pDef->iResType);
					pDspVec->pParent = this;
					pResVectors->Add(pDspVec);
				}
			}
			SetColBarVec(fMin, fMax);
		} else if ((pDef->iLoc == 1) && (pDef->iResType == 1)) {
			for (i = 0; i < iElNo; i++) {
				iS = 1;
				pR = pRes->Get(pElems[i]->iLabel, 0);
				if (pR != NULL) {
					vC = pElems[i]->Get_Centroid();
					iD = pElems[i]->iLabel;
					vVec.x = 0;
					vVec.y = 0;
					vVec.z = 0;
					iS = 1;
					if (iDf == 3) {
						vVec.x = *pR->GetAddress(pDef->iComponents[0]);
						vVec.y = *pR->GetAddress(pDef->iComponents[1]);
						vVec.z = *pR->GetAddress(pDef->iComponents[2]);
						iS = 1; // Sign is magnitude
					} else if (iDf == 0) {
						vVec.x = *pR->GetAddress(pDef->iComponents[0]);
						if (vVec.x < 0)
							iS = -1;
					} else if (iDf == 1) {
						vVec.y = *pR->GetAddress(pDef->iComponents[1]);
						if (vVec.y < 0)
							iS = -1;
					} else if (iDf == 2) {
						vVec.z = *pR->GetAddress(pDef->iComponents[2]);
						if (vVec.z < 0)
							iS = -1;
					}

					double dM;
					dM = iS * vVec.Mag();
					if (dM > fMax)
						fMax = dM;
					if (dM < fMin)
						fMin = dM;
					pDspVec = new ResultsVec(iD, vC, vVec, 4, iDf, iS, pDef->iResType);
					pDspVec->pParent = this;
					pResVectors->Add(pDspVec);
				}
			}
			SetColBarVec(fMin, fMax);
		} else if ((pDef->iLoc == 1) && (pDef->iResType == 4)) // 3d Tensor
		{
			// Its a 3d Tensor at element centroid
			for (i = 0; i < iElNo; i++) {
				iS = 1;
				pR = pRes->Get(pElems[i]->iLabel, 0);
				if (pR != NULL) {
					iEID = pElems[i]->iLabel;
					vC = pElems[i]->Get_Centroid();
					iD = pElems[i]->iLabel;
					vVec.x = 0;
					vVec.y = 0;
					vVec.z = 0;
					// vVec.x = *pR->GetAddress(pDef->iComponents[0]);  //Sxx
					if (iDf == 0) // X stress
					{
						vVec.x = *pR->GetAddress(pDef->iComponents[0]);
						if (vVec.x < 0)
							iS = -1;
					} else if (iDf == 1) // Y stress
					{
						vVec.y = *pR->GetAddress(pDef->iComponents[1]);
						if (vVec.y < 0)
							iS = -1;
					} else if (iDf == 2) // z stress
					{
						vVec.z = *pR->GetAddress(pDef->iComponents[2]);
						if (vVec.z < 0)
							iS = -1;
					} else if (iDf == 3) // XY stress
					{
						vVec.y = *pR->GetAddress(pDef->iComponents[3]);
						if (vVec.y < 0)
							iS = -1;
					} else if (iDf == 4) // yz stress
					{
						vVec.z = *pR->GetAddress(pDef->iComponents[4]);
						if (vVec.z < 0)
							iS = -1;
					} else if (iDf == 5) // zx stress
					{
						vVec.x = *pR->GetAddress(pDef->iComponents[5]);
						if (vVec.x < 0)
							iS = -1;
					} else // Its a principal 6,7,8
					{
						C3dVector vX, vY, vZ;
						vX.x = *pR->GetAddress(pDef->iComponents[0]);
						vX.y = *pR->GetAddress(pDef->iComponents[3]);
						vX.z = *pR->GetAddress(pDef->iComponents[5]);
						vY.x = *pR->GetAddress(pDef->iComponents[3]);
						vY.y = *pR->GetAddress(pDef->iComponents[1]);
						vY.z = *pR->GetAddress(pDef->iComponents[4]);
						vZ.x = *pR->GetAddress(pDef->iComponents[5]);
						vZ.y = *pR->GetAddress(pDef->iComponents[4]);
						vZ.z = *pR->GetAddress(pDef->iComponents[2]);
						double p1;
						p1 = *pR->GetAddress(pDef->iComponents[iDf]);
						vVec = EigenVector3d(iEID, vX, vY, vZ, p1);
						iS = 1;
						if (p1 < 0)
							iS = -1;
					}
					double dM;
					dM = iS * vVec.Mag();
					if (dM > fMax)
						fMax = dM;
					if (dM < fMin)
						fMin = dM;
					pDspVec = new ResultsVec(iD, vC, vVec, 4, iDf, iS, pDef->iResType);
					pDspVec->pParent = this;
					pResVectors->Add(pDspVec);
				}
			}
			SetColBarVec(fMin, fMax);
		} else if ((pDef->iLoc == 1) && (pDef->iResType == 3)) // 2d Tensor
		{
			// Its a 2d Tensor at element centroid
			for (i = 0; i < iElNo; i++) {
				iS = 1;
				pR = pRes->Get(pElems[i]->iLabel, 0);
				if (pR != NULL) {
					iEID = pElems[i]->iLabel;
					mTMat = pElems[i]->GetElSys();
					vC = pElems[i]->Get_Centroid();
					iD = pElems[i]->iLabel;
					vVec.x = 0;
					vVec.y = 0;
					vVec.z = 0;
					// vVec.x = *pR->GetAddress(pDef->iComponents[0]);  //Sxx
					if (iDf == 0) // X stress
					{
						vVec.x = *pR->GetAddress(pDef->iComponents[0]);
						if (vVec.x < 0)
							iS = -1;
					} else if (iDf == 1) // Y stress
					{
						vVec.y = *pR->GetAddress(pDef->iComponents[1]);
						if (vVec.y < 0)
							iS = -1;
					} else if (iDf == 2) // XY stress
					{
						vVec.y = *pR->GetAddress(pDef->iComponents[2]);
						if (vVec.y < 0)
							iS = -1;
					} else // Its a principal 3,4
					{
						C3dVector vX, vY, vZ;
						vX.x = *pR->GetAddress(pDef->iComponents[0]);
						vX.y = *pR->GetAddress(pDef->iComponents[2]);
						vX.z = 0;
						vY.x = *pR->GetAddress(pDef->iComponents[3]);
						vY.y = *pR->GetAddress(pDef->iComponents[1]);
						vY.z = 0;
						double p1;
						p1 = *pR->GetAddress(pDef->iComponents[iDf]);
						vVec = EigenVector2d(iEID, vX, vY, p1);
						iS = 1;
						if (p1 < 0)
							iS = -1;
					}
					mTMat.Transpose();
					vVec = mTMat.Mult(vVec);
					double dM;
					dM = iS * vVec.Mag();
					if (dM > fMax)
						fMax = dM;
					if (dM < fMin)
						fMin = dM;
					pDspVec = new ResultsVec(iD, vC, vVec, 4, iDf, iS, pDef->iResType);
					pDspVec->pParent = this;
					pResVectors->Add(pDspVec);
				}
			}
			SetColBarVec(fMin, fMax);
		}
	}
}

void ME_Object::BuildDeromedVecs() {
	int i;
	if (CResSetDef != NULL) {
		if (iNdNo > 0) {
			if ((CResSetDef->TCODE == 1) || (CResSetDef->TCODE == 7)) {
				for (i = 0; i < iNdNo; i++) {
					Res* pR = pNodes[i]->pResD;
					if (pR != NULL) {
						if (pR->pVec != NULL) {
							delete (pR->pVec);
							pR->pVec = NULL;
						}
						pR->pVec = new C3dVector();

						pR->pVec->x = *pR->GetAddress(0);
						pR->pVec->y = *pR->GetAddress(1);
						pR->pVec->z = *pR->GetAddress(2);
						if (iResValDef == 0) {
							pR->pVec->y = 0;
							pR->pVec->z = 0;
						}
						if (iResValDef == 1) {
							pR->pVec->x = 0;
							pR->pVec->z = 0;
						}
						if (iResValDef == 2) {
							pR->pVec->x = 0;
							pR->pVec->y = 0;
						}
					}
				}
			}
		}
	}
}

void ME_Object::DeleteDeromedVecs() {
	int i;
	for (i = 0; i < iNdNo; i++) {
		Res* pR = pNodes[i]->pResD;
		if (pR != NULL) {
			if (pR->pVec != NULL) {
				delete (pR->pVec);
				pR->pVec = NULL;
			}
		}
	}
}

void ME_Object::ExportGroups(FILE* pFile) {
	int i;
	int j;
	E_Object* pE;
	Node* pN;
	fprintf(pFile, "%-10s%-10s%-10s%-10s%-10s\n", "ELEM", "ID", "COL", "PID", "TYPE");
	fprintf(pFile, "%-10s%-10s%-10s%-10s%-10s\n", "NODE", "ID", "COL", "DEF", "OUT");
	for (i = 0; i < iNoGps; i++) {
		fprintf(pFile, "%-s\n", "GROUP");
		fprintf(pFile, "%-s\n", GPs[i]->Title);
		fprintf(pFile, "%-i\n", GPs[i]->iNo);
		for (j = 0; j < GPs[i]->iNo; j++) {
			if (GPs[i]->iType[j] == 3) {
				pE = this->GetElement(GPs[i]->ids[j]);
				if (pE != NULL)
					fprintf(pFile, "%-10s%-10i%-10i%-10i%-10i\n", "ELEM", GPs[i]->ids[j], pE->iColour, pE->PID,
					        pE->iType);
			}
			if (GPs[i]->iType[j] == 1) {
				pN = this->GetNode(GPs[i]->ids[j]);
				if (pN != NULL)
					fprintf(pFile, "%-10s%-10i%-10i%-10i%-10i\n", "NODE", GPs[i]->ids[j], pN->iColour, pN->DefSys,
					        pN->OutSys);
			}
		}
	}
}

void ME_Object::ExportUNV(FILE* pFile, SecTable* pS) {
	int i;
	int j;
	COleDateTime timeStart;
	timeStart = COleDateTime::GetCurrentTime();

	int year = timeStart.GetYear();
	int Mon = timeStart.GetMonth();
	if (year < 2050) {
		BOOL bNL;
		// Dataset 164 Units
		fprintf(pFile, "%6s\n", "-1");
		fprintf(pFile, "%6s\n", "164");
		fprintf(pFile, "%10i%20s%10i\n", 1, "Meter (newton)               ", 2);
		fprintf(pFile, "%25.16E%25.16E%25.16E\n", 1.0, 1.0, 1.0);
		fprintf(pFile, "%25.16E\n", 1.0);
		fprintf(pFile, "%6s\n", "-1");
		if (pS != NULL) {
			pS->ExportSecs(pFile);
		}
		fprintf(pFile, "%6s\n", "-1");
		fprintf(pFile, "%6s\n", "2411");
		for (i = 0; i < iNdNo; i++) {
			pNodes[i]->ExportUNV(pFile);
		}
		fprintf(pFile, "%6s\n", "-1");
		fprintf(pFile, "%6s\n", "-1");
		fprintf(pFile, "%6s\n", "2412");
		for (i = 0; i < iElNo; i++) {
			pElems[i]->ExportUNV(pFile);
		}
		fprintf(pFile, "%6s\n", "-1");
		fprintf(pFile, "%6s\n", "-1");
		fprintf(pFile, "%6s\n", "2438");
		for (i = 0; i < iElNo; i++) {
			if (pElems[i]->iType == 21) {
				E_Object2B* E = (E_Object2B*) pElems[i];
				E->ExportUPVecs(pFile);
			}
		}
		fprintf(pFile, "%6s\n", "-1");
		fprintf(pFile, "%6s\n", "-1");
		fprintf(pFile, "%6s\n", "2435");
		for (i = 0; i < iNoGps; i++) {
			fprintf(pFile, "%10i%10i%10i%10i%10i%10i%10i%10i\n", i + 1, 0, 0, 0, 0, 0, 0, GPs[i]->iNo);
			fprintf(pFile, "%s\n", GPs[i]->Title);
			bNL = FALSE;
			for (j = 0; j < GPs[i]->iNo; j++) {
				if (GPs[i]->iType[j] == 3) {
					fprintf(pFile, "%10i%10i%10i%10i", 8, GPs[i]->ids[j], 0, 0);
				} else if (GPs[i]->iType[j] == 1) {
					fprintf(pFile, "%10i%10i%10i%10i", 7, GPs[i]->ids[j], 0, 0);
				}
				if (bNL == FALSE) {
					bNL = TRUE;
				} else {
					bNL = FALSE;
					fprintf(pFile, "\n", "");
				}
			}
			if (bNL == TRUE) {
				fprintf(pFile, "\n", "");
			}
		}
		fprintf(pFile, "%6s\n", "-1");
	}
}

void ME_Object::ExportSTL(CString sFileName) {
	int i;
	C3dVector vN;
	std::ofstream file(sFileName);
	if (!file.is_open()) {
		outtext1("ERROR: Opening File.");
		return;
	}

	COleDateTime timeStart;
	timeStart = COleDateTime::GetCurrentTime();

	int year = timeStart.GetYear();
	int Mon = timeStart.GetMonth();
	file << "solid " << sFileName << std::endl;
	for (i = 0; i < iElNo; i++) {
		if (pElems[i]->iType == 91) // its a tri element (facet);
		{
			// pElems[i]->ExportSTL(pFile);
			E_Object3* pE = (E_Object3*) pElems[i]->Copy(this);
			pE->Reverse();
			vN = pElems[i]->Get_Normal();

			file << "  facet normal " << vN.x << " " << vN.y << " " << vN.z << std::endl;
			file << "    outer loop" << std::endl;
			for (int i = 0; i < 3; i++) {
				file << "      vertex " << pE->pVertex[i]->Pt_Point->x << " " << pE->pVertex[i]->Pt_Point->y << " " << pE->pVertex[i]->Pt_Point->z << std::endl;
			}
			file << "    endloop" << std::endl;
			file << "  endfacet" << std::endl;
			delete (pE);
		}
	}
	file << "endsolid " << sFileName << std::endl;
	file.close();
	outtext1("STL file written successfully");
}

void ME_Object::ImportSTL(CString sFileName) {
	C3dVector vN;
	C3dVector vP;
	Node* pENodes[MaxSelNodes];
	std::ifstream file(sFileName);
	if (!file.is_open()) {
		outtext1("ERROR: Reading File.");
		return;
	}

	COleDateTime timeStart;
	timeStart = COleDateTime::GetCurrentTime();

	int year = timeStart.GetYear();
	int Mon = timeStart.GetMonth();

	std::string line;
	std::string token;
	int vertexIndex = 0;

	while (std::getline(file, line)) {
		std::istringstream iss(line);
		iss >> token;

		if (token == "facet") {
			iss >> token; // Read "normal"
			iss >> vN.x >> vN.y >> vN.z;
		} else if (token == "vertex") {
			iss >> vP.x >> vP.y >> vP.z;
			pENodes[vertexIndex] = AddNode(vP, iNodeLab, 0, 0, 11, 0, 0);
			iNodeLab++;
			++vertexIndex;
			if (vertexIndex == 3) {
				vertexIndex = 0;
				E_Object* cAddedEl = AddEl(pENodes, iElementLab, 4, 91, -1, -1, 3, -1, -1, -1, FALSE, -1, 0);
				cAddedEl->Reverse();
				iElementLab++;
			}
		}
	}

	file.close();
	outtext1("STL file read successfully");
}

int ME_Object::GetNoNode(int iType) {
	int iRC = -1;
	switch (iType) {
		case 115:
			iRC = 8; // 115 //BRICK 8
			break;
		case 112:
			iRC = 6; // WEDGE 6
			break;
		case 111:
			iRC = 4; // TET 4
			break;
		case 94:
			iRC = 4; // QUAD 4
			break;
		case 91:
			iRC = 3; // TRI 3
			break;
		case 161:
			iRC = 1; // SCALAR
			break;
		case 121:
			iRC = 2; // UNKNOWN 2
			break;
		case 136:
			iRC = 2; // TSPRING
			break;
		case 137:
			iRC = 2; // RSPRING
			break;
		case 138:
			iRC = 2; // BUSH
			break;
		case 21:
			iRC = 2; // BEAM 2
			break;
		case 11:
			iRC = 2; // ROD 2
			break;
		case 22:
			iRC = 2; // UNKNOWN 2
			break;
		case 122:
			iRC = 2000; // RIGID 200
			break;
		case 1000:
			iRC = 4; // STAGGERED CELL
			break;
	}
	return (iRC);
}

void ME_Object::Test(PropTable* PropsT, MatTable* MatT) {
	int i, j, neq;
	BOOL bOpt, bErr;
	bOpt = FALSE;
	bErr = FALSE;
	COleDateTime timeStart;
	timeStart = COleDateTime::GetCurrentTime();
	int Hour = timeStart.GetHour();
	int Min = timeStart.GetMinute();
	int Sec = timeStart.GetSecond();
	char s1[80];
	int iLC = -1;
	CString sSol("");
	CString sStep("");
	bool bGo;
	BOOL bRS;
	double AA;
	int iStep = 0;
	cLinkedList* pLC = NULL;
	cLinkedListB* pBC = NULL;
	cLinkedListT* pTC = NULL;
	sprintf_s(s1, "%s %i:%i:%i\n", "START TIME", Hour, Min, Sec);
	outtext1(s1);
	bGo = GetStepCasesLinStat(iStep, sSol, sStep, AA, pLC, pBC, pTC, bRS);
	if (iStep == -1) {
		outtext1("ERROR: No Solution Step is Active.");
	}
	if (bGo) {
		for (i = 0; i < iNdNo; i++) {
			for (j = 0; j < 6; j++) {
				pNodes[i]->dof[j] = 0;
			}
		}

		Mat KME;
		// Mat dee=DeeMat(100,0.29,6);
		this->ApplyRes(pBC);
		neq = GenDofs();
		if (neq == 0) {
			outtext1("ERROR: No Degrees of Freedoms Exist.");
			outtext1("Ensure the Correct F.E. Model is Active.");
		} else {
			Vec<double> FVec;
			Vec<int> Steer;

			if (neq != 0) {
				ZeroThermalStrains(0.0);
				BuildForceVector(PropsT, MatT, pLC, pTC, neq, FVec);
				bGo = TRUE;
			}

			// FVec = GetForceVec(pLC,neq);
			// GetPressureLoads(pLC,neq,FVec);
			// if (pTC != NULL)
			//{
			//  //convert nodal temps to element centroid
			//  cLinkedList* pTC_ELEM;
			//  double dDefT = 0;
			//  BOOL bTEMPD = FALSE;
			//  bTEMPD = TSEThasTEMPD(pTC, dDefT);
			//  pTC_ELEM = TSetNodaltoElement(pTC, dDefT);
			//  GetThermalLoads(PropsT, MatT, pTC_ELEM, neq, FVec);    //Add Thermal loads
			// }

			int iBW = this->MaxBW();
			Vec<double> KM(neq * (iBW + 1));
			LocalRes(neq, Steer, KM);
			outtext1("STARTING ASSY");
			E_Object* pE;

			for (i = 0; i < iElNo; i++) {
				pE = pElems[i];

				if (pE->ChkNegJac() == FALSE) {
					KME = pE->GetStiffMat(PropsT, MatT, bOpt, bErr);
					Steer = pE->GetSteerVec3d();
				} else {
					pE = (E_Object*) pElems[i]->Copy(this);
					pE->Reverse();
					KME = pE->GetStiffMat(PropsT, MatT, bOpt, bErr);
					Steer = pE->GetSteerVec3d();
					delete (pE);
					pE = NULL;
				}

				formkv(KM, KME, Steer, neq);
				// KME.diag();
				KME.clear();
			}

			// KM.diag();
			outtext1("STARTING BAND REDUCTION");
			banred(KM, neq);
			outtext1("STARTING BACK SUBSTITUTION");
			bacsub(KM, FVec);
			outtext1("FINISHED SOLUTION");
			Displacements(iStep, sSol, sStep, Steer, FVec);
			ForcesRod(iStep, sSol, sStep, PropsT, MatT, Steer, FVec);
			ForcesBUSH(iStep, sSol, sStep, PropsT, MatT, Steer, FVec);
			ForcesBeam(iStep, sSol, sStep, PropsT, MatT, Steer, FVec);
			// Stresses2d(iLC, sSol, sStep, PropsT,MatT,Steer,FVec);
			RecoverShell(iStep, sSol, sStep, PropsT, MatT, Steer, FVec);
			Stresses3d(iStep, sSol, sStep, PropsT, MatT, Steer, FVec);
			outtext1("FINISHED SOLUTION");

			KM.DeleteAll();
			Steer.DeleteAll();
		}
		timeStart = COleDateTime::GetCurrentTime();
		Hour = timeStart.GetHour();
		Min = timeStart.GetMinute();
		Sec = timeStart.GetSecond();
		sprintf_s(s1, "%s %i:%i:%i\n", "END TIME", Hour, Min, Sec);
	} else
		outtext1("FATAL ERROR");
}

Mat GetG(Vec<double>& AA, Vec<int>& G) {
	int iS;
	int i;
	iS = G.n;

	Mat pMult(iS, 1);
	for (i = 1; i <= iS; i++) {
		if (*G.nn(i) > 0) {
			int ii;
			ii = *G.nn(i);
			double pM = *AA.nn(ii);
			*pMult.mn(i, 1) = *AA.nn(ii);
		}
	}
	return (pMult);
}

double IterConv(Vec<double>& X, Vec<double>& XNew) {
	int iS;
	int i;
	double dD = 0;
	double dDa = 0;
	double MaxDiff = 0;
	double MaxDiff1 = 0;
	iS = X.n;
	for (i = 0; i < iS; i++) {
		double a = XNew(i);
		double b = X(i);
		dD = abs(XNew(i) - X(i));
		dDa = abs(XNew(i));
		if (dD > MaxDiff)
			MaxDiff = dD;
		if (dDa > MaxDiff1)
			MaxDiff1 = dDa;
	}
	return (MaxDiff / MaxDiff1);
}

double DotProd(Vec<double>& AA, Vec<double>& BB) {
	int iS;
	int i;
	double dP = 0;
	iS = AA.n;

	for (i = 0; i < iS; i++) {
		double f = AA(i);
		double p = BB(i);
		dP += AA(i) * BB(i);
	}
	return (dP);
}

void PutG(Vec<double>& AA, Vec<int>& G, Mat& M) {
	int iS;
	int i;
	iS = G.n;
	int ii;

	for (i = 1; i <= iS; i++) {
		ii = *G.nn(i);
		if (ii > 0) {
			double mmm = *M.mn(i, 1);
			*AA.nn(ii) += *M.mn(i, 1);
		}
	}
}

void ME_Object::ZeroDOF() {
	int i;
	int j;
	for (i = 0; i < iNdNo; i++) {
		for (j = 0; j < 6; j++) {
			pNodes[i]->dof[j] = 0;
		}
	}
}

BOOL ME_Object::GetStepCasesLinStat(int& iStep, CString& sSol, CString& sStep, double& dTol, cLinkedList*& pLC,
                                    cLinkedListB*& pBC, cLinkedListT*& pTC, BOOL& bRS) {
	BOOL bRet = FALSE;
	Solution* pCSol;
	pLC = NULL;
	pBC = NULL;
	pTC = NULL;
	bRS = TRUE;
	int iLC = -1;
	int iBC = -1;
	int iTC = -1;
	char S1[200];
	sSol = "NULL";
	sStep = "NULL";
	if (pSOLS->iCur != -1) {
		sprintf_s(S1, "SOLUTION: %s", pSOLS->pSols[pSOLS->iCur]->sTitle);
		outtext1(S1);
		pCSol = pSOLS->pSols[pSOLS->iCur];

		dTol = pCSol->dTol; // solution tolerence
		if ((pCSol->iType == 0) || (pCSol->iType == 1) || (pCSol->iType == 2)) {
			iStep = pCSol->GetCurStep();
			if ((iStep < pCSol->iNo) && (iStep != -1)) {
				iLC = pCSol->LS[iStep];
				iBC = pCSol->BS[iStep];
				iTC = pCSol->TS[iStep];
				bRS = pCSol->RS[iStep];
				sSol = pCSol->GetSolutionTitleString();
				sStep = pCSol->GetStepTitleString(iStep);
				bRet = TRUE;
			}
			if (iLC != -1)
				pLC = GetLC(iLC);
			if (iBC != -1)
				pBC = GetBC(iBC);
			if (iTC != -1)
				pTC = GetTSET(iTC);
		} else {
			outtext1("ERROR: N/A.");
		}
	}

	return (bRet);
}

void ME_Object::IterSol3dLin(PropTable* PropsT, MatTable* MatT) {
	BOOL bErr;
	CString sSol;
	CString sStep;
	int i, j, neq;
	char s1[80];
	double dErr;
	int iELCnt;
	int m;
	double up;
	double beta;
	double alpha;
	int aaa = 0;
	BOOL bGo = FALSE;
	Mat KME;
	Vec<double> FVec;
	Vec<int> Steer;
	int iStep;
	cLinkedList* pLC = NULL;
	cLinkedListB* pBC = NULL;
	cLinkedListT* pTC = NULL;

	double dTol;
	BOOL bRS;
	iStep = 0;

	PrintTime("START TIME: ");
	bGo = GetStepCasesLinStat(iStep, sSol, sStep, dTol, pLC, pBC, pTC, bRS);
	if (iStep == -1) {
		outtext1("ERROR: No Solution Step is Active.");
	}
	if (bGo) {
		ZeroDOF(); // Zero the DOFS
		// THIS NEED TO BE REPERFORMED ONLY IF BC CHANGE THEN NEED TO RESTART ALL
		this->ApplyRes(pBC); // APply Restraints (not local ones
		neq = GenDofs(); // Gen DOFS numbers
		sprintf_s(s1, "%s %i\n", "NO OF EQUATIONS:-", neq);
		outtext1(s1);
		if (neq != 0) {
			ZeroThermalStrains(0.0);
			BuildForceVector(PropsT, MatT, pLC, pTC, neq, FVec);
			bGo = TRUE;
		} else {
			outtext1("ERROR: No Degrees of Freedom Exist.");
			outtext1("Ensure the Correct F.E. Model is Active.");
		}
		if (bGo == TRUE) {
			int iBW = this->MaxBW(); // NOT USED IN THIS ITERATIVE SOLUTION
			iELCnt = 0;
			int iNoRestEl = LocalResCount();
			Mat* KM = new Mat[iElNo + iNoRestEl];
			Vec<int>* G = new Vec<int>[iElNo + iNoRestEl];
			if (iNoRestEl > 0)
				GenLocalResraints(KM, G, iELCnt); // GENERATE SPRINGS FOR LOCAL RESTRAINTD
			outtext1("STARTING ASSY");
			E_Object* pE;
			Vec<double> DiagPrecon(neq);
			for (i = 0; i < iElNo; i++) {
				pE = pElems[i];
				if (pE->ChkNegJac() == FALSE) {
					KME = pE->GetStiffMat(PropsT, MatT, FALSE, bErr);
					Steer = pE->GetSteerVec3d();
				} else {
					outtext1("ERROR: negative jacobian");
					pE->Reverse();
					KME = pE->GetStiffMat(PropsT, MatT, FALSE, bErr);
					Steer = pE->GetSteerVec3d();
				}
				KM[iELCnt] = KME;
				G[iELCnt] = Steer;
				iELCnt++;
				KME.clear();
				Steer.clear();
			}
			//***************************************************************

			for (i = 0; i < iELCnt; i++) {
				for (m = 1; m <= KM[i].m; m++) {
					if (G[i](m - 1) > 0) {
						double d1;
						d1 = G[i](m - 1);
						*DiagPrecon.nn(G[i](m - 1)) += *KM[i].mn(m, m);
					}
				}
			}
			// Invert DiagPrecon
			Vec<double> d(neq);
			Vec<double> p(neq);
			for (i = 0; i < neq; i++) {
				DiagPrecon(i) = 1.0 / DiagPrecon(i);
				double dT = DiagPrecon(i) * FVec(i);
				d(i) = DiagPrecon(i) * FVec(i);
				p(i) = d(i);
			}

			Mat pMult;
			Vec<double> x(neq);
			Vec<double> xnew(neq);
			outtext1("STARTING ITERATIVE SOLUTION");
			i = 0;
			do {
				Vec<double> u(neq);
				for (j = 0; j < iELCnt; j++) {
					pMult = GetG(p, G[j]);
					Mat uTemp = KM[j] * pMult;
					PutG(u, G[j], uTemp);
					pMult.clear();
				}
				up = DotProd(FVec, d);
				if (up == 0) {
					outtext1("ERROR: Forced Stop.");
					dErr = IterConv(x, xnew);
					break;
				}
				alpha = up / DotProd(p, u);
				for (m = 0; m < xnew.n; m++) {
					xnew(m) = x(m) + p(m) * alpha;
					FVec(m) = FVec(m) - u(m) * alpha;
					d(m) = DiagPrecon(m) * FVec(m);
				}
				beta = DotProd(FVec, d) / up;
				for (m = 0; m < xnew.n; m++) {
					p(m) = d(m) + p(m) * beta;
				}
				dErr = IterConv(x, xnew);
				x = xnew;
				if (i % 100 == 0) {
					sprintf_s(s1, "%s: %i %s: %1.16f\n", "ITER", i, "Err", dErr);
					outtext1(s1);
				}
				u.clear();
				i++;
			} while (dErr > dTol);
			sprintf_s(s1, "%s: %i %s: %1.16f\n", "FINAL ERROR ITER", i, "Err", dErr);
			outtext1(s1);
			for (i = 0; i < iELCnt; i++) {
				KM[i].clear();
				G[i].clear();
			}
			delete[] KM;
			delete[] G;
			outtext1("FINISHED SOLUTION");
			Displacements(iStep, sSol, sStep, Steer, xnew);
			TranslationalSpringForces(iStep, sSol, sStep, PropsT, MatT, Steer, xnew);
			ForcesBUSH(iStep, sSol, sStep, PropsT, MatT, Steer, xnew);
			ForcesRod(iStep, sSol, sStep, PropsT, MatT, Steer, xnew);
			ForcesBeam(iStep, sSol, sStep, PropsT, MatT, Steer, xnew);
			// Stresses2d(iStep, sSol, sStep, PropsT, MatT, Steer, xnew);
			RecoverShell(iStep, sSol, sStep, PropsT, MatT, Steer, xnew);
			Stresses3d(iStep, sSol, sStep, PropsT, MatT, Steer, xnew);
		}
		PrintTime("END TIME: ");
	} else {
		outtext1("FATAL ERROR");
	}
}

//*********************************************************************************
//                   E X P L I C I T    S O L
//*********************************************************************************

Mat ME_Object::LocalDisp_E(C3dMatrix TMAT, Vec<int>& Steer, Vec<double>& Disp) {
	double dof1;
	int idof;
	int j;

	Mat disp;
	Mat disp3d;
	disp.Create(8, 1);
	disp3d.Create(3, 4);

	for (j = 0; j < 4; j++) {
		// Get the displacements
		dof1 = 0;
		idof = *Steer.nn(j * 3 + 1);
		dof1 = *Disp.nn(idof);
		*disp3d.mn(1, j + 1) = dof1;
		idof = *Steer.nn(j * 3 + 2);
		dof1 = *Disp.nn(idof);
		*disp3d.mn(2, j + 1) = dof1;
		idof = *Steer.nn(j * 3 + 3);
		dof1 = *Disp.nn(idof);
		*disp3d.mn(3, j + 1) = dof1;
	}
	C3dVector v;
	C3dVector R;
	int n;
	// displacements in plain of element
	for (j = 0; j < 4; j++) {
		v.x = *disp3d.mn(1, j + 1);
		v.y = *disp3d.mn(2, j + 1);
		v.z = *disp3d.mn(3, j + 1);
		v = TMAT.Mult(v);
		n = 1 + j * 2;
		*disp.mn(n, 1) = v.x;
		*disp.mn(n + 1, 1) = v.y;
	}
	disp3d.clear();
	return (disp);
}

void ME_Object::FtoGlobal_E(Mat* LForce, C3dMatrix TMAT, Vec<int>& Steer, Vec<double>& FI) {
	int idof;
	int j;
	Mat GForce;
	TMAT.Transpose();
	C3dVector vF;
	for (j = 0; j < 4; j++) {
		// Get the displacements
		vF.x = *LForce->mn(j * 2 + 1, 1);
		vF.y = *LForce->mn(j * 2 + 2, 1);
		vF.z = 0;
		vF = TMAT.Mult(vF);
		idof = *Steer.nn(j * 3 + 1);
		*FI.nn(idof) += vF.x;
		idof = *Steer.nn(j * 3 + 2);
		*FI.nn(idof) += vF.y;
		idof = *Steer.nn(j * 3 + 3);
		*FI.nn(idof) += vF.z;
	}
}

void ME_Object::ExplicitSolTest(PropTable* PropsT, MatTable* MatT) {
	char s1[80];
	double dT = 0.000001; // Time Step
	double t = 0;
	double dMass = 0.1;
	C3dMatrix TMat;
	Vec<int> Steer;
	Mat bee;
	Mat KM;
	Mat Ldisp; // Local displacements in xi eta
	Mat LForce;
	Mat eStrainInc;
	Mat eStrainTot(3, 1);
	Mat eStress;
	int i;
	int k;
	int neq;
	double det;
	bool bGo;
	int iStep;
	CString sSol;
	CString sStep;
	double dTol;
	cLinkedList* pLC = NULL;
	cLinkedListB* pBC = NULL;
	cLinkedListT* pTC = NULL;
	BOOL bRS;
	Solution* pSol;
	pSol = pSOLS->GetCurSolution();
	if (pSol != NULL) {
		sSol = pSOLS->GetTitleString(pSOLS->iCur);
		iStep = pSol->GetCurStep();
		if (iStep != -1) {
			sStep = pSol->GetStepTitleString(iStep);
			bGo = GetStepCasesLinStat(iStep, sSol, sStep, dTol, pLC, pBC, pTC, bRS);
		} else {
			outtext1("ERROR: No Step Exists.");
		}
	}
	bGo = GetStepCasesLinStat(iStep, sSol, sStep, dTol, pLC, pBC, pTC, bRS);
	E_Object4* pE;
	Node* pN;
	// Get Current Loadcase and solution set
	ZeroDOF();
	// Zero the DOFS                                //THIS NEED TO BE REPORFED ONLY IF BC CHANGE THEN NEED TO RESTART ALL
	int iDof = 1;
	neq = GenDofs3D(iDof); // Generate 3 Dof at each node (membrain action only shell)
	// Initial conditions
	Vec<double> FI(neq);
	Vec<double> FE(neq);
	Vec<double> u(neq); // last stet displacement increment
	Vec<double> x(neq); // Total displacement
	Vec<double> xd(neq);
	Vec<double> xdd(neq);
	// Strain history
	Vec<double> eX(iElNo);
	Vec<double> eY(iElNo);
	Vec<double> eXY(iElNo);

	//*FE.nn(127) = 1;
	//*FE.nn(130) = 1;

	//*FE.nn(10) = 10;
	//******************************************************
	// START SOLUTION
	//******************************************************
	for (k = 0; k < 1000000; k++) {
		for (i = 0; i < iNdNo; i++) {
			pN = (Node*) pNodes[i];
			// Update the displacement central diff
			*u.nn(pN->dof[0]) = *xd.nn(pN->dof[0]) * dT + *xdd.nn(pN->dof[0]) * dT * dT;
			*u.nn(pN->dof[1]) = *xd.nn(pN->dof[1]) * dT + *xdd.nn(pN->dof[1]) * dT * dT;
			*u.nn(pN->dof[2]) = *xd.nn(pN->dof[2]) * dT + *xdd.nn(pN->dof[2]) * dT * dT;
			*x.nn(pN->dof[0]) += *xd.nn(pN->dof[0]) * dT + *xdd.nn(pN->dof[0]) * dT * dT;
			*x.nn(pN->dof[1]) += *xd.nn(pN->dof[1]) * dT + *xdd.nn(pN->dof[1]) * dT * dT;
			*x.nn(pN->dof[2]) += *xd.nn(pN->dof[2]) * dT + *xdd.nn(pN->dof[2]) * dT * dT;
		}

		*u.nn(1) = 0;
		*u.nn(2) = 0;
		*u.nn(3) = 0;
		*u.nn(31) = 0;
		*u.nn(32) = 0;
		*u.nn(33) = 0;
		*x.nn(1) = 0;
		*x.nn(2) = 0;
		*x.nn(3) = 0;
		*x.nn(31) = 0;
		*x.nn(32) = 0;
		*x.nn(33) = 0;

		*x.nn(662) = 0;
		*x.nn(665) = 0;
		*x.nn(668) = 0;
		*x.nn(671) = 0;
		*x.nn(674) = 0;
		*x.nn(677) = 0;
		*x.nn(683) = 0;
		*x.nn(684) = 0;
		*x.nn(689) = 0;
		*x.nn(692) = 0;

		*u.nn(662) = 0;
		*u.nn(665) = 0;
		*u.nn(668) = 0;
		*u.nn(671) = 0;
		*u.nn(674) = 0;
		*u.nn(677) = 0;
		*u.nn(683) = 0;
		*u.nn(684) = 0;
		*u.nn(689) = 0;
		*u.nn(692) = 0;

		//*x.nn(693) = 1;
		//*u.nn(693) = 0;
		//*x.nn(663) = 0;
		//*u.nn(663) = 0;

		if (k < 38000) {
			*FE.nn(661) = 1;
			*FE.nn(664) = 1;
			*FE.nn(667) = 1;
			*FE.nn(670) = 1;
			*FE.nn(673) = 1;
			*FE.nn(676) = 1;
			*FE.nn(679) = 1;
			*FE.nn(682) = 1;
			*FE.nn(685) = 1;
			*FE.nn(688) = 1;
			*FE.nn(691) = 1;
		}

		FI.Zero(); // Zero nodal forces at each step
		// Update force vector
		if (k == 200)
			i = 0;

		for (i = 0; i < iElNo; i++) {
			if (pElems[i]->iType == 94) {
				pE = (E_Object4*) pElems[i];
				Steer = pE->GetSteerVec3d_E(); // 3 dof steering vector
				TMat = pE->GetElSys_Ex(Steer, x); // 4 pt integerated membrain action (no bending) 8x8
				bee = pE->GetB_1pt(det); // 1 Pt bee mat
				Mat dee = pE->DeeMat(50e3, 0.29, 3); // Note Hard coded Properties for Now
				Ldisp = LocalDisp_E(TMat, Steer, u); // Strain Increment
				// Ldisp.diag();
				eStrainInc = bee * Ldisp;
				// Element Strain total
				*eX.nn(i + 1) += *eStrainInc.mn(1, 1);
				*eY.nn(i + 1) += *eStrainInc.mn(2, 1);
				*eXY.nn(i + 1) += *eStrainInc.mn(3, 1);
				*eStrainTot.mn(1, 1) = *eX.nn(i + 1);
				*eStrainTot.mn(2, 1) = *eY.nn(i + 1);
				*eStrainTot.mn(3, 1) = *eXY.nn(i + 1);
				eStress = dee * eStrainTot;
				bee.Transpose();
				LForce = bee * eStress;
				// LForce.diag();
				if (k % 100 == 0) {
					// sprintf_s(s1, "%s: %i %s: %1.16f %s: %1.16f %s: %g\n", "ITER", k, "X", *Ldisp.mn(1,1), "Y", *Ldisp.mn(2, 1),"F" , *LForce.mn(1,1));
					// outtext1(s1);
				}

				FtoGlobal_E(&LForce, TMat, Steer, FI);

				bee.clear();
				dee.clear();
				Ldisp.clear();
				Steer.clear();
				LForce.clear();
				eStrainInc.clear();
			}
		}
		// FI.diag();
		// FE.diag();

		for (i = 0; i < iNdNo; i++) {
			pN = (Node*) pNodes[i];
			// Calc acceleration t+dt
			double acctdt;
			acctdt = (*FE.nn(pN->dof[0]) - *FI.nn(pN->dof[0])) / dMass;
			*xd.nn(pN->dof[0]) += (*xdd.nn(pN->dof[0]) + acctdt) * dT * 0.5;
			*xdd.nn(pN->dof[0]) = acctdt;

			acctdt = (*FE.nn(pN->dof[1]) - *FI.nn(pN->dof[1])) / dMass;
			*xd.nn(pN->dof[1]) += (*xdd.nn(pN->dof[1]) + acctdt) * dT * 0.5;
			*xdd.nn(pN->dof[1]) = acctdt;

			acctdt = (*FE.nn(pN->dof[2]) - *FI.nn(pN->dof[2])) / dMass;
			*xd.nn(pN->dof[2]) += (*xdd.nn(pN->dof[2]) + acctdt) * dT * 0.5;
			*xdd.nn(pN->dof[2]) = acctdt;
		}
		// sprintf_s(s1, "%s: %i %s: %1.16f %s: %1.16f\n", "ITER", k, "FI", *FI.nn(4), "x", *x.nn(4));
		// outtext1(s1);
		// x.diag();
		t += dT;
		if (k % 2000 == 0) {
			sprintf_s(s1, "%s: %g %s: %g %s: %g %s: %g\n", "T ", t, "X ", *x.nn(130), "Y ", *x.nn(131), "Z ",
			          *x.nn(132));
			// sprintf_s(s1, "%s: %i %s: %g %s: %g %s: %g\n", "ITER", k, "X1 ", TMat.m_00, "X2 ", TMat.m_01, "X3 ", TMat.m_02);
			outtext1(s1);
			Displacements(k, "T", "A", Steer, x);
		}
	}
}

//*********************************************************************************
//                   1 D O F    T H E R M A L    S O L
//*********************************************************************************
void ME_Object::IterSol1dSS(PropTable* PropsT, MatTable* MatT) {
	int i, j, neq;
	char s1[80];
	double dErr;
	int iELCnt;
	int m;
	double up;
	double beta;
	double alpha;
	int aaa = 0;
	double d1;
	BOOL bGo = FALSE;
	Mat KME;
	Vec<double> QVec;
	Vec<double> TVec;
	Vec<int> Steer;
	int iStep;
	Solution* pSol;
	cLinkedList* pLC = NULL;
	cLinkedListB* pBC = NULL;
	cLinkedListT* pTC = NULL;
	Mat pMult;
	double dTol;
	BOOL bRS;
	CString sSol;
	CString sStep;

	pSol = pSOLS->GetCurSolution();
	if (pSol != NULL) {
		sSol = pSOLS->GetTitleString(pSOLS->iCur);
		iStep = pSol->GetCurStep();
		if (iStep != -1) {
			sStep = pSol->GetStepTitleString(iStep);
			bGo = GetStepCasesLinStat(iStep, sSol, sStep, dTol, pLC, pBC, pTC, bRS);
		} else {
			outtext1("ERROR: No Step Exists.");
		}
	} else {
		outtext1("ERROR: No Solution Exists.");
	}
	if (bGo) {
		outtext1("STARTING SOLUTION OF:-");
		outtext1(sSol);
		outtext1(sStep);
		PrintTime("START TIME: ");
		ZeroDOF();
		// Zero the DOFS                                //THIS NEED TO BE REPORFED ONLY IF BC CHANGE THEN NEED TO RESTART ALL
		int iDof = ApplyResSS(pBC); // APply Restraints (not local ones
		neq = GenDofs1D(iDof); // Gen DOFS numbers
		sprintf_s(s1, "%s %i\n", "NO OF EQUATIONS:-", neq);
		outtext1(s1);
		if (neq != 0) {
			TVec = GetTempVec(pBC, neq);
			// TVec.diag();
			QVec.Size(neq);
			QVec.Zero();
			GetForceVec(pLC, neq, QVec);
			// QVec.diag();
			ReportQResultant(QVec);
			// BuildForceVector(PropsT,MatT,pLC,pTC,neq,QVec);
			bGo = TRUE;
		} else {
			outtext1("ERROR: No Degrees of Freedom Exist.");
			outtext1("Ensure the Correct F.E. Model is Active.");
		}
		if (bGo == TRUE) {
			int iBW = this->MaxBW(); // NOT USED IN ITERATIVE SOL
			iELCnt = 0;
			Mat* KM = new Mat[iElNo];
			Vec<int>* G = new Vec<int>[iElNo];

			E_Object* pE;
			Vec<double> DiagPrecon(neq);
			for (i = 0; i < iElNo; i++) {
				pE = pElems[i];
				if (pE->ChkNegJac() == FALSE) {
					KME = pE->GetThermMat(PropsT, MatT);
					Steer = pE->GetSteerVec1d();
				} else {
					outtext1("ERROR: negative jacobian reversing element.");
					pE->Reverse();
					KME = pE->GetThermMat(PropsT, MatT);
					Steer = pE->GetSteerVec1d();
				}
				KM[iELCnt] = KME;
				G[iELCnt] = Steer;
				iELCnt++;
				KME.clear();
				Steer.clear();
			}
			//***************************************************************
			for (i = 0; i < iELCnt; i++) {
				for (m = 1; m <= KM[i].m; m++) {
					if (G[i](m - 1) > 0) {
						d1 = G[i](m - 1);
						*DiagPrecon.nn(G[i](m - 1)) += *KM[i].mn(m, m);
					}
				}
			}
			// DiagPrecon.diag();
			//*********** APPLY THE TEMPS AS FLUX ADDITION TO QVEC ***********
			// TVec.diag();
			for (j = 0; j < iELCnt; j++) {
				pMult = GetG(TVec, G[j]);
				Mat uTemp = KM[j] * pMult;
				PutG(QVec, G[j], uTemp);
				pMult.clear();
			}
			//****************** INVERT THR PRE-CODITIONER **********************
			Vec<double> d(neq);
			Vec<double> p(neq);
			for (i = 0; i < neq; i++) {
				if (i < iDof - 1) {
					DiagPrecon(i) = 0;
				} else {
					DiagPrecon(i) = 1.0 / DiagPrecon(i);
				}
				d(i) = DiagPrecon(i) * QVec(i);
				p(i) = d(i);
			}

			Vec<double> x(neq);
			Vec<double> xnew(neq);
			outtext1("STARTING ITERATIVE SOLUTION");
			i = 0;
			do {
				Vec<double> u(neq);
				// QVec.diag();
				// p.diag();
				// d.diag();
				for (j = 0; j < iELCnt; j++) {
					pMult = GetG(p, G[j]);
					// pMult.diag();
					// KM[j].diag();
					Mat uTemp = KM[j] * pMult;
					// uTemp.diag();
					PutG(u, G[j], uTemp);
					pMult.clear();
				}
				// u.diag();
				up = DotProd(QVec, d);
				if (up == 0) {
					outtext1("ERROR: Forced Stop.");
					dErr = IterConv(x, xnew);

					break;
				}
				alpha = up / DotProd(p, u);
				for (m = 0; m < xnew.n; m++) {
					xnew(m) = x(m) + p(m) * alpha;
					QVec(m) = QVec(m) - u(m) * alpha;
					d(m) = DiagPrecon(m) * QVec(m);
				}
				beta = DotProd(QVec, d) / up;
				for (m = 0; m < xnew.n; m++) {
					p(m) = d(m) + p(m) * beta;
				}
				dErr = IterConv(x, xnew);
				x = xnew;
				if (i % 100 == 0) {
					sprintf_s(s1, "%s: %i %s: %1.16f\n", "ITER", i, "Err", dErr);
					outtext1(s1);
					// inner thermal loop temporarylly here
					// RadiationLoss(Steer, xnew, QVec);
				}
				u.clear();
				i++;
			} while (dErr > dTol);
			sprintf_s(s1, "%s: %i %s: %1.16f\n", "FINAL ERROR ITER", i, "Err", dErr);
			outtext1(s1);
			for (i = 0; i < iELCnt; i++) {
				KM[i].clear();
				G[i].clear();
			}
			delete[] KM;
			delete[] G;
			outtext1("FINISHED SOLUTION");
			for (i = 0; i < iDof - 1; i++) {
				xnew(i) = -TVec(i);
			}
			Temperatures(iStep, sSol, sStep, Steer, xnew);
			TempBCSet(iStep, sSol, sStep, Steer, xnew);
		}
		PrintTime("END TIME: ");
	} else {
		outtext1("FATAL ERROR");
	}

	TVec.clear();
	QVec.clear();
}

void ME_Object::PrintTime(CString cS) {
	int Hour;
	int Min;
	int Sec;
	char s1[80];
	COleDateTime timeStart;
	timeStart = COleDateTime::GetCurrentTime();
	Hour = timeStart.GetHour();
	Min = timeStart.GetMinute();
	Sec = timeStart.GetSecond();
	sprintf_s(s1, "%s %i:%i:%i\n", cS, Hour, Min, Sec);
	outtext1(s1);
}

int ME_Object::MaxBW() {
	int iMaxBW = 0;
	int iMB;
	int i;
	for (i = 0; i < iElNo; i++) {
		iMB = pElems[i]->MaxBW();
		if (iMB > iMaxBW) {
			iMaxBW = iMB;
		}
	}
	return (iMaxBW);
}

G_Object* ME_Object::AddForce(Node* pInNode, C3dVector inF, int inSetID) {
	cLinkedList* pSet = NULL;
	Force* pF = NULL;
	int ID;
	if ((inSetID == -1) && (iCurLC == -1)) {
		outtext1("ERROR: No Load Case Active.");
	} else if ((inSetID == -1) && (iCurLC != -1)) {
		pSet = LCS[iCurLC];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = GetLC(inSetID);
		ID = pSet->iLabel;
	}
	if (pSet != NULL) {
		pF = new Force();
		pF->Create(pInNode,
		           pSet,
		           inF,
		           ID);
		pSet->Add(pF);
	}
	return (pF);
}

G_Object* ME_Object::AddTempD(double inT, int inSetID) {
	cLinkedList* pSet = NULL;
	TEMPD* pT = nullptr;
	if ((inSetID == -1) && (iCurTSet == -1)) {
		outtext1("ERROR: No Temperature Set Active.");
	} else if ((inSetID == -1) && (iCurTSet != -1)) {
		pSet = TSETS[iCurTSet];
	} else if (inSetID != -1) {
		pSet = GetTSET(inSetID);
	}
	if (pSet != nullptr) {
		pT = new TEMPD();
		pT->Create(this->Get_Centroid(), pSet, inSetID, inT);
		pSet->Add(pT);
		outtext1("TEMPD Created.");
	}
	return (pT);
}

G_Object* ME_Object::AddGRAV(int inSetID, int iCID, double dScl, C3dVector vV) {
	cLinkedList* pSet = NULL;
	GRAV* pT = nullptr;
	int ID;
	if ((inSetID == -1) && (iCurLC == -1)) {
		outtext1("ERROR: No Temperature Set Active.");
	} else if ((inSetID == -1) && (iCurLC != -1)) {
		pSet = LCS[iCurLC];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = GetLC(inSetID);
		ID = pSet->iLabel;
	}
	if (pSet != nullptr) {
		pT = new GRAV();
		pT->Create(this->Get_Centroid(), pSet, inSetID, iCID, dScl, vV);
		pSet->Add(pT);
	}
	return (pT);
}

G_Object* ME_Object::AddTemperature(Node* pN, double inT, int inSetID) {
	cLinkedList* pSet = NULL;
	Temperature* pT = NULL;
	int ID;
	if ((inSetID == -1) && (iCurTSet == -1)) {
		outtext1("ERROR: No Temperature Set Active.");
	} else if ((inSetID == -1) && (iCurTSet != -1)) {
		pSet = TSETS[iCurTSet];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = GetTSET(inSetID);
		ID = pSet->iLabel;
	}
	if (pSet != NULL) {
		pT = new Temperature();
		pT->Create(pN,
		           pSet,
		           inT,
		           ID);
		pSet->Add(pT);
	}
	return (pT);
}

G_Object* ME_Object::AddAccel(E_Object* pInE, C3dVector vA, int inSetID) {
	cLinkedList* pSet = NULL;
	AccelLoad* pA = NULL;
	int ID;
	if ((inSetID == -1) && (iCurLC == -1)) {
		outtext1("ERROR: No Load Set Active.");
	} else if ((inSetID == -1) && (iCurLC != -1)) {
		pSet = LCS[iCurLC];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = LCS[iCurLC];
		ID = pSet->iLabel;
	}
	if (pSet != NULL) {
		pA = new AccelLoad();
		pA->Create(pInE,
		           pSet,
		           vA,
		           ID);
		pSet->Add(pA);
	}
	return (pA);
}

G_Object* ME_Object::AddRotAccel(E_Object* pInE, C3dVector vAxisD, C3dVector vAxisC, double dw, int inSetID) {
	cLinkedList* pSet = NULL;
	RotationLoad* pA = NULL;
	int ID;
	if ((inSetID == -1) && (iCurLC == -1)) {
		outtext1("ERROR: No Load Set Active.");
	} else if ((inSetID == -1) && (iCurLC != -1)) {
		pSet = LCS[iCurLC];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = LCS[iCurLC];
		ID = pSet->iLabel;
	}
	if (pSet != NULL) {
		pA = new RotationLoad();
		pA->Create(pInE,
		           pSet,
		           vAxisD,
		           vAxisC,
		           dw,
		           ID);
		pSet->Add(pA);
	}
	return (pA);
}

G_Object* ME_Object::AddFluxQ(Node* pInNode, double inT, int inSetID) {
	cLinkedList* pSet = NULL;
	Temperature* pT = NULL;
	int ID;
	if ((inSetID == -1) && (iCurLC == -1)) {
		outtext1("ERROR: No Load Set Active.");
	} else if ((inSetID == -1) && (iCurLC != -1)) {
		pSet = LCS[iCurLC];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = GetLC(inSetID);
		ID = pSet->iLabel;
	}
	if (pSet != NULL) {
		pT = new FluxLoad();
		pT->Create(pInNode,
		           pSet,
		           inT,
		           ID);
		pSet->Add(pT);
	}
	return (pT);
}

G_Object* ME_Object::AddTemperatureBC(Node* pInNode, double inT, int inSetID) {
	cLinkedList* pSet = NULL;
	Temperature* pT = NULL;
	int ID;
	if ((inSetID == -1) && (iCurBC == -1)) {
		outtext1("ERROR: No Boundary Set Active.");
	} else if ((inSetID == -1) && (iCurBC != -1)) {
		pSet = BCS[iCurBC];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = GetBC(inSetID);
		ID = pSet->iLabel;
	}
	if (pSet != NULL) {
		pT = new TemperatureBC();
		pT->Create(pInNode,
		           pSet,
		           inT,
		           ID);
		pSet->Add(pT);
	}
	return (pT);
}

G_Object* ME_Object::AddMoment(Node* pInNode, C3dVector inF, int inSetID) {
	cLinkedList* pSet = NULL;
	Moment* pF = NULL;
	int ID;
	if ((inSetID == -1) && (iCurLC == -1)) {
		outtext1("ERROR: No Load Set Active.");
	} else if ((inSetID == -1) && (iCurLC != -1)) {
		pSet = LCS[iCurLC];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = GetLC(inSetID);
		ID = pSet->iLabel;
	}
	if (pSet != NULL) {
		pF = new Moment();
		pF->Create(pInNode,
		           pSet,
		           inF,
		           ID);
		pSet->Add(pF);
		// pBCLDs[iBCLDs] = pF;
		// iBCLDs++;
	}
	return (pF);
}

G_Object* ME_Object::AddPressure(E_Object* pInE, C3dVector inF, int inSetID) {
	cLinkedList* pSet = NULL;
	Pressure* pF = NULL;
	int ID;
	if ((inSetID == -1) && (iCurLC == -1)) {
		outtext1("ERROR: No Load Set Active.");
	} else if ((inSetID == -1) && (iCurLC != -1)) {
		pSet = LCS[iCurLC];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = GetLC(inSetID);
		ID = pSet->iLabel;
	}
	if (pSet != NULL) {
		pF = new Pressure();
		pF->Create(pInE,
		           pSet,
		           inF,
		           ID);
		pSet->Add(pF);
	}
	return (pF);
}

void ME_Object::BuildForceVector(PropTable* PropsT, MatTable* MatT, cLinkedList* pLC, cLinkedList* pTC, int neq,
                                 Vec<double>& FVec) {
	FVec.Size(neq);
	FVec.Zero();
	if (pLC != NULL) {
		GetForceVec(pLC, neq, FVec); // Get all external forces
		GetPressureLoads(pLC, neq, FVec); // Add in all Surface pressure loads
		//****************** IS THRE A NASTRAN GRAV CARD **************************
		GRAV* pGRAV = nullptr;
		pGRAV = LSEThasGRAV(pLC);
		if (pGRAV != nullptr) {
			GetGRAVLoads(PropsT, MatT, pGRAV, neq, FVec); // need to gen nastrn style grave loads
		}
		//*************************************************************************
		GetAccelLoads(PropsT, MatT, pLC, neq, FVec); // Add In all Body loads
		GetRotAccelLoads(PropsT, MatT, pLC, neq, FVec); // Add In all Rotational Body loads
		ReportFResultant(FVec);
	}

	if (pTC != NULL) {
		// convert nodal temps to element centroid
		cLinkedList* pTC_ELEM;
		double dDefT = 0;
		BOOL bTEMPD = FALSE;
		bTEMPD = TSEThasTEMPD(pTC, dDefT);
		pTC_ELEM = TSetNodaltoElement(pTC, dDefT);
		GetThermalLoads(PropsT, MatT, pTC_ELEM, neq, FVec); // Add Thermal loads
	}
}

void ME_Object::ReportFResultant(Vec<double>& FVec) {
	int i;
	char s1[80];
	double FXTot = 0;
	double FYTot = 0;
	double FZTot = 0;
	double MXTot = 0;
	double MYTot = 0;
	double MZTot = 0;
	Node* pN;
	C3dVector vC;
	C3dVector vF;
	C3dVector vM;
	// sprintf_s(s1,"%s: %i %s: %1.16f\n","ITER",i,"Err",dErr);
	outtext1("GLOBAL LOADS RESULTANT:-");
	for (i = 0; i < iNdNo; i++) {
		pN = pNodes[i];
		vC = pN->Get_Centroid();
		vF.Set(0, 0, 0);

		if (pN->dof[0] > 0) {
			vF.x = *FVec.nn(pN->dof[0]);
		}
		if (pN->dof[1] > 0) {
			vF.y = *FVec.nn(pN->dof[1]);
		}
		if (pN->dof[2] > 0) {
			vF.z = *FVec.nn(pN->dof[2]);
		}
		// MOMENTS
		vM = vC.Cross(vF);
		FXTot += vF.x;
		FYTot += vF.y;
		FZTot += vF.z;
		MXTot += vM.x;
		MYTot += vM.y;
		MZTot += vM.z;
		if (pN->dof[3] > 0) {
			MXTot += *FVec.nn(pN->dof[3]);
		}
		if (pN->dof[4] > 0) {
			MYTot += *FVec.nn(pN->dof[4]);
		}
		if (pN->dof[5] > 0) {
			MZTot += *FVec.nn(pN->dof[5]);
		}
	}
	sprintf_s(s1, "%s: %1.16f\n", "FX", FXTot);
	outtext1(_T(s1));
	sprintf_s(s1, "%s: %1.16f\n", "FY", FYTot);
	outtext1(_T(s1));
	sprintf_s(s1, "%s: %1.16f\n", "FZ", FZTot);
	outtext1(_T(s1));

	sprintf_s(s1, "%s: %1.16f\n", "MX", MXTot);
	outtext1(_T(s1));
	sprintf_s(s1, "%s: %1.16f\n", "MY", MYTot);
	outtext1(_T(s1));
	sprintf_s(s1, "%s: %1.16f\n", "MZ", MZTot);
	outtext1(_T(s1));
}

void ME_Object::ReportQResultant(Vec<double>& QVec) {
	int i;
	char s1[80];
	double Q = 0;

	Node* pN;

	// sprintf_s(s1,"%s: %i %s: %1.16f\n","ITER",i,"Err",dErr);
	outtext1("GLOBAL FLUX RESULTANT:-");
	for (i = 0; i < iNdNo; i++) {
		pN = pNodes[i];
		if (pN->dof[0] > 0) {
			Q += *QVec.nn(pN->dof[0]);
		}
	}
	sprintf_s(s1, "%s: %f\n", "Q", Q);
	outtext1(_T(s1));
}

GRAV* ME_Object::LSEThasGRAV(cLinkedList* pLC) {
	GRAV* pGRAV = nullptr;
	BCLD* pNext;
	// Search for TEMPD Card
	pNext = (BCLD*) pLC->Head;
	while (pNext != nullptr) {
		if (pNext->iObjType == 332) {
			pGRAV = (GRAV*) pNext;
			break;
		}
		pNext = (BCLD*) pNext->next;
	}

	return (pGRAV);
}

BOOL ME_Object::TSEThasTEMPD(cLinkedList* pTC, double& defT) {
	BOOL brc = FALSE;
	BCLD* pNext;
	// Search for TEMPD Card
	pNext = (BCLD*) pTC->Head;
	while (pNext != nullptr) {
		if (pNext->iObjType == 331) {
			TEMPD* pTD = (TEMPD*) pNext;
			defT = pTD->dTempD;
			brc = TRUE;
			break;
		}
		pNext = (BCLD*) pNext->next;
	}

	return (brc);
}

// recently changed temperature to be on node as in nastran
// we need element temps to cal force so creating the original
// element based temps
cLinkedList* ME_Object::TSetNodaltoElement(cLinkedList* pTC_Nodal, double defT) {
	double dT;
	int i;
	cLinkedList* pTC_Elem = new cLinkedList();
	BCLD* pNext;
	SetDefNodeTemp(defT); // just using dTemp to cal average element T from modes
	pNext = (BCLD*) pTC_Nodal->Head;
	while (pNext != nullptr) {
		if (pNext->iObjType == 325) {
			Temperature* pT = (Temperature*) pNext;
			if (pT->pObj->iObjType == 1) {
				Node* pN = (Node*) pT->pObj;
				pN->dTemp = pT->dV;
			}
		}
		pNext = (BCLD*) pNext->next;
	}

	// for all elements get centroid temperatre and add to pTC_Elem
	for (i = 0; i < iElNo; i++) {
		dT = pElems[i]->GetElCentriodVal();
		Temperature* pT = new Temperature();
		pT->Create(pElems[i], pTC_Elem, dT, pTC_Nodal->iLabel);
		pTC_Elem->Add(pT);
	}
	return (pTC_Elem);
}

void ME_Object::GetThermalLoads(PropTable* PropsT, MatTable* MatT, cLinkedList* pTC, int neq, Vec<double>& FVec) {
	BCLD* pNext;
	Mat TF;
	Vec<int> vS;
	E_Object* pE;
	int iNS;
	int iD;
	int i, k;
	BOOL bOff;
	C3dVector vOff;
	C3dVector vFl;
	C3dVector vFg;
	C3dMatrix M3;

	if (PropsT == nullptr || MatT == nullptr) {
		outtext1("ERROR: Property or Mat Table Missing, Body Loads Not Calculated.");
		return;
	}

	pNext = (BCLD*) pTC->Head;
	while (pNext != nullptr) {
		if (pNext->iObjType == 325) {
			Temperature* pT = (Temperature*) pNext;
			double dT = pT->dV;
			pE = (E_Object*) pNext->pObj;
			M3 = pE->GetElSys();
			M3.Transpose();
			vS = pE->GetSteerVec3d();
			TF = pE->GetThermalStrainMat3d(PropsT, MatT, dT);
			iNS = pE->iNoNodes;
			iD = pE->noDof();
			if ((pE->iType == 115) || (pE->iType == 111) || (pE->iType == 112)) {
				for (i = 0; i < iNS; i++) {
					int iDD0, iDD1, iDD2;
					iDD0 = *vS.nn(i * iD + 1);
					iDD1 = *vS.nn(i * iD + 2);
					iDD2 = *vS.nn(i * iD + 3);
					if (iDD0 != -1)
						*FVec.nn(iDD0) += *TF.mn(i * iD + 1, 1);
					if (iDD1 != -1)
						*FVec.nn(iDD1) += *TF.mn(i * iD + 2, 1);
					if (iDD2 != -1)
						*FVec.nn(iDD2) += *TF.mn(i * iD + 3, 1);
				}
			} else if ((pE->iType == 91) || (pE->iType == 94)) {
				Mat TOff(6, 6);
				Mat vF(6, 1);
				Mat vFoff;
				for (i = 0; i < iNS; i++) // For each node
				{
					vFoff.clear(); // Offset
					vF.MakeZero(); // Offset
					TOff.MakeZero(); // Offset
					vFl.Set(*TF.mn(i * 2 + 1, 1), *TF.mn(i * 2 + 2, 1), 0);
					vFg = M3 * vFl;
					// NEED TODO OFFSET TRANSFORM
					*vF.mn(1, 1) = vFg.x;
					*vF.mn(2, 1) = vFg.y;
					*vF.mn(3, 1) = vFg.z;
					vFoff = vF;
					bOff = pE->GetOffset(PropsT, i, vOff);
					if (bOff) // Element has non zeror offsets
					{
						vFoff.clear();
						pE->OffsetsTransform(TOff, vOff);
						TOff.Transpose();
						vFoff = TOff * (vF);
					}

					for (k = 1; k <= iD; k++) {
						int iDD0;
						iDD0 = *vS.nn(i * iD + k);
						if (iDD0 != -1)
							*FVec.nn(iDD0) += *vFoff.mn(k, 1);
					}
				}
			} else if (pE->iType == 11) // for rod and psuedo rbe2
			{
				for (i = 0; i < iNS; i++) // For each node
				{
					vFl.Set(*TF.mn(i + 1, 1), 0, 0);
					vFg = M3 * vFl;
					int iDD0, iDD1, iDD2;
					iDD0 = *vS.nn(i * iD + 1);
					iDD1 = *vS.nn(i * iD + 2);
					iDD2 = *vS.nn(i * iD + 3);
					if (iDD0 != -1)
						*FVec.nn(iDD0) += vFg.x;
					if (iDD1 != -1)
						*FVec.nn(iDD1) += vFg.y;
					if (iDD2 != -1)
						*FVec.nn(iDD2) += vFg.z;
				}
			} else if (pE->iType == 122) // for rod and psuedo rbe2
			{
				for (i = 0; i < iNS; i++) // For each node
				{
					// For the PSEUDO RBE2 forces allready in element
					vFg.Set(*TF.mn(i + 1, 1), *TF.mn(i + 1, 2), *TF.mn(i + 1, 3));
					int iDD0, iDD1, iDD2;
					iDD0 = *vS.nn(i * iD + 1);
					iDD1 = *vS.nn(i * iD + 2);
					iDD2 = *vS.nn(i * iD + 3);
					if (iDD0 != -1)
						*FVec.nn(iDD0) += vFg.x;
					if (iDD1 != -1)
						*FVec.nn(iDD1) += vFg.y;
					if (iDD2 != -1)
						*FVec.nn(iDD2) += vFg.z;
				}
			} else if (pE->iType == 21) // BEAM ELEMENT THERMAL LOAD IS AXIAL
			{
				E_Object2B* pB = (E_Object2B*) pE;
				Mat TOff(6, 6);
				Mat vF(6, 1);
				Mat vFoff;
				for (i = 0; i < iNS; i++) {
					vFoff.clear();
					vF.MakeZero();
					TOff.MakeZero();
					vFl.Set(*TF.mn(i + 1, 1), 0, 0);
					vFg = M3 * vFl; // IN GLONAL
					// NEED TODO OFFSET TRANSFORM
					*vF.mn(1, 1) = vFg.x;
					*vF.mn(2, 1) = vFg.y;
					*vF.mn(3, 1) = vFg.z;
					vFoff = vF;
					bOff = pB->GetOffset(PropsT, i, vOff);
					if (bOff) // Element has non zeror offsets
					{
						vFoff.clear();
						pB->OffsetsTransform(TOff, vOff);
						TOff.Transpose();
						vFoff = TOff * (vF);
					}
					for (k = 1; k <= iD; k++) {
						int iDD0;
						iDD0 = *vS.nn(i * iD + k);
						if (iDD0 != -1)
							*FVec.nn(iDD0) += *vFoff.mn(k, 1);
					}
				}
				TOff.clear();
				vF.clear();
				vFoff.clear();
			}
		}
		pNext = (BCLD*) pNext->next;
	}
}

void ME_Object::ZeroThermalStrains(double dVal) {
	int i;
	for (i = 0; i < iElNo; i++) {
		pElems[i]->dTemp = dVal;
	}
}

void ME_Object::SetDefNodeTemp(double dVal) {
	int i;
	for (i = 0; i < iNdNo; i++) {
		pNodes[i]->dTemp = dVal;
	}
}

void ME_Object::GetGRAVLoads(PropTable* PropsT, MatTable* MatT, GRAV* pGrav, int neq, Vec<double>& FVec) {
	E_Object* pE;
	Mat MM;
	Vec<int> vS;
	int iNS;
	int iD;
	int i;
	C3dVector vAC;
#
	if (pGrav->iCID > 0) {
		outtext1("ERROR: Only GRAV loads in Basic Cartesian Support at Present.");
		return;
	}
	vAC = pGrav->vV;
	vAC *= pGrav->dScl; // Acceleration vector in global

	if ((PropsT == NULL) || (MatT == NULL)) {
		outtext1("ERROR: Property or Mat Table Missing, Body Loads Not Calculated.");
	} else {
		for (i = 0; i < iElNo; i++) {
			pE = pElems[i];
			if (pE != NULL) {
				vS = pE->GetSteerVec3d();
				MM = pE->GetElNodalMass(PropsT, MatT);
				iNS = pE->iNoNodes;
				iD = pE->noDof();
				int i;
				for (i = 0; i < iNS; i++) {
					int iDD0, iDD1, iDD2;
					iDD0 = *vS.nn(i * iD + 1);
					iDD1 = *vS.nn(i * iD + 2);
					iDD2 = *vS.nn(i * iD + 3);
					double dTTT = *MM.mn(i + 1, 1);
					if (iDD0 != -1)
						*FVec.nn(iDD0) += *MM.mn(i + 1, 1) * vAC.x;
					if (iDD1 != -1)
						*FVec.nn(iDD1) += *MM.mn(i + 1, 1) * vAC.y;
					if (iDD2 != -1)
						*FVec.nn(iDD2) += *MM.mn(i + 1, 1) * vAC.z;
				}
			}
		}
	}
}

void ME_Object::GetAccelLoads(PropTable* PropsT, MatTable* MatT, cLinkedList* pLC, int neq, Vec<double>& FVec) {
	BCLD* pNext;
	Mat MM;
	Vec<int> vS;
	E_Object* pE;
	int iNS;
	int iD;

	if ((PropsT == NULL) || (MatT == NULL)) {
		outtext1("ERROR: Property or Mat Table Missing, Body Loads Not Calculated.");
	} else if (pLC != NULL) {
		pNext = (BCLD*) pLC->Head;
		while (pNext != NULL) {
			if (pNext->iObjType == 328) {
				AccelLoad* pA = (AccelLoad*) pNext;
				C3dVector vAC = pA->vA;
				pE = (E_Object*) pNext->pObj;
				if (pE != NULL) {
					vS = pE->GetSteerVec3d();
					MM = pE->GetElNodalMass(PropsT, MatT);
					iNS = pE->iNoNodes;
					iD = pE->noDof();
					int i;
					for (i = 0; i < iNS; i++) {
						int iDD0, iDD1, iDD2;
						iDD0 = *vS.nn(i * iD + 1);
						iDD1 = *vS.nn(i * iD + 2);
						iDD2 = *vS.nn(i * iD + 3);
						double dTTT = *MM.mn(i + 1, 1);
						if (iDD0 != -1)
							*FVec.nn(iDD0) += *MM.mn(i + 1, 1) * vAC.x;
						if (iDD1 != -1)
							*FVec.nn(iDD1) += *MM.mn(i + 1, 1) * vAC.y;
						if (iDD2 != -1)
							*FVec.nn(iDD2) += *MM.mn(i + 1, 1) * vAC.z;
					}
				}
			}
			pNext = (BCLD*) pNext->next;
		}
	}
}

void ME_Object::GetRotAccelLoads(PropTable* PropsT, MatTable* MatT, cLinkedList* pLC, int neq, Vec<double>& FVec) {
	BCLD* pNext;
	Mat MM;
	Vec<int> vS;
	E_Object* pE;
	int iNS;
	int iD;

	if ((PropsT == NULL) || (MatT == NULL)) {
		outtext1("ERROR: Property or Mat Table Missing, Body Loads Not Calculated.");
	} else if (pLC != NULL) {
		pNext = (BCLD*) pLC->Head;
		while (pNext != NULL) {
			if (pNext->iObjType == 329) {
				RotationLoad* pA = (RotationLoad*) pNext;
				C3dVector vAC = pA->vAxisC;
				C3dVector vAD = pA->vAxisD;
				double dw = pA->w;
				pE = (E_Object*) pNext->pObj;
				if (pE != NULL) {
					vS = pE->GetSteerVec3d();
					MM = pE->GetElNodalMass(PropsT, MatT);
					iNS = pE->iNoNodes;
					iD = pE->noDof();
					int i;
					C3dVector pN = pE->Get_Centroid(); // Node location
					C3dVector vw = pN - vAC;
					C3dVector P = vAD;
					P *= vw.Dot(vAD);
					P += vAC;
					C3dVector R = pN - P;
					double dR = R.Mag();
					R.Normalize(); // Error here
					for (i = 0; i < iNS; i++) {
						int iDD0, iDD1, iDD2;
						iDD0 = *vS.nn(i * iD + 1);
						iDD1 = *vS.nn(i * iD + 2);
						iDD2 = *vS.nn(i * iD + 3);
						double dTTT = *MM.mn(i + 1, 1);
						if (iDD0 != -1)
							*FVec.nn(iDD0) += *MM.mn(i + 1, 1) * R.x * dw * dw * dR;
						if (iDD1 != -1)
							*FVec.nn(iDD1) += *MM.mn(i + 1, 1) * R.y * dw * dw * dR;
						if (iDD2 != -1)
							*FVec.nn(iDD2) += *MM.mn(i + 1, 1) * R.z * dw * dw * dR;
					}
				}
			}
			pNext = (BCLD*) pNext->next;
		}
	}
}

void ME_Object::GetPressureLoads(cLinkedList* pLC, int neq, Vec<double>& FVec) {
	double dTot = 0;
	int j, k;
	double P;
	Mat coord;
	Mat Press;
	Mat deriv;
	Mat deriv2;
	Mat fun;
	Mat jac;
	Mat Points;
	double det;
	double nip;
	BCLD* pNext;
	pNext = (BCLD*) pLC->Head;

	while (pNext != NULL) {
		if (pNext->iObjType == 324) {
			E_Object* pE = (E_Object*) pNext->pObj;
			Pressure* pP = (Pressure*) pNext;
			P = pP->F.x;
			if (pE->iType == 91) {
				nip = 1;
			} else if (pE->iType == 94) {
				nip = 4;
			}
			coord.clear();
			Points.clear();
			Press.clear();
			Press.Create(1, pE->iNoNodes);
			coord = pE->getCoords3d();
			Points = pE->Sample((int) nip);
			for (k = 1; k < nip + 1; k++) {
				det = 0;
				fun = pE->ShapeFun(Points, k);
				deriv = pE->ShapeDer(Points, k);
				jac = deriv * coord;
				jac = jac.InvertJac(det);
				for (j = 0; j < pE->iNoNodes; j++) {
					*Press.mn(1, j + 1) += *fun.mn(1, j + 1) * P * det * *Points.mn(k, 3);
					double pp = *Press.mn(1, j + 1);
					pp = pp;
				}
			}
			C3dVector vN;
			vN = pE->Get_Normal();
			vN.Normalize();
			Node* pN;

			for (j = 0; j < pE->iNoNodes; j++) {
				pN = (Node*) pE->GetNode(j);
				if (pN->dof[0] > 0) {
					*FVec.nn(pN->dof[0]) += *Press.mn(1, j + 1) * vN.x;
				}
				if (pN->dof[1] > 0) {
					*FVec.nn(pN->dof[1]) += *Press.mn(1, j + 1) * vN.y;
				}
				if (pN->dof[2] > 0) {
					*FVec.nn(pN->dof[2]) += *Press.mn(1, j + 1) * vN.z;
				}
			}
		}
		pNext = (BCLD*) pNext->next;
	}
	dTot = dTot;
}

Vec<double> ME_Object::GetTempVec(cLinkedList* pTS, int neq) {
	Vec<double> TVec(neq);
	BCLD* pNext;
	pNext = (BCLD*) pTS->Head;
	if (pTS != NULL) {
		pNext = (BCLD*) pTS->Head;
		while (pNext != NULL) {
			if (pNext->iObjType == 327) {
				TemperatureBC* pR = (TemperatureBC*) pNext;
				Node* pNode = (Node*) pR->pObj;
				*TVec.nn(pNode->dof[0]) = -pR->dV;
			}
			pNext = (BCLD*) pNext->next;
		}
	}
	return (TVec);
}

void ME_Object::GetForceVec(cLinkedList* pLC, int neq, Vec<double>& FVec) {
	if (pLC != nullptr) {
		BCLD* pNext;
		pNext = (BCLD*) pLC->Head;
		while (pNext != NULL) {
			if (pNext->iObjType == 321) {
				Node* pNode = (Node*) pNext->pObj;
				Force* pF = (Force*) pNext;
				if (pNode->dof[0] > 0) {
					*FVec.nn(pNode->dof[0]) = pF->F.x;
				}
				if (pNode->dof[1] > 0) {
					*FVec.nn(pNode->dof[1]) = pF->F.y;
				}
				if (pNode->dof[2] > 0) {
					*FVec.nn(pNode->dof[2]) = pF->F.z;
				}
			} else if (pNext->iObjType == 323) {
				Node* pNode = (Node*) pNext->pObj;
				Moment* pF = (Moment*) pNext;
				if (pNode->dof[3] > 0) {
					*FVec.nn(pNode->dof[3]) = pF->F.x;
				}
				if (pNode->dof[4] > 0) {
					*FVec.nn(pNode->dof[4]) = pF->F.y;
				}
				if (pNode->dof[5] > 0) {
					*FVec.nn(pNode->dof[5]) = pF->F.z;
				}
			} else if (pNext->iObjType == 326) {
				Node* pNode = (Node*) pNext->pObj;
				FluxLoad* pF = (FluxLoad*) pNext;
				if (pNode->dof[0] > 0) {
					*FVec.nn(pNode->dof[0]) = pF->dV;
				}
			}
			pNext = (BCLD*) pNext->next;
		}
	}
}

G_Object* ME_Object::AddRestraint(Node* pInNode,
                                  BOOL xon,
                                  BOOL yon,
                                  BOOL zon,
                                  BOOL rxon,
                                  BOOL ryon,
                                  BOOL rzon,
                                  int inSetID) {
	cLinkedList* pSet = NULL;
	Restraint* pF = NULL;
	int ID = -1;
	if ((inSetID == -1) && (iCurBC == -1)) {
		outtext1("ERROR: No Boundary Set Active.");
	} else if ((inSetID == -1) && (iCurBC != -1)) {
		pSet = BCS[iCurBC];
		ID = pSet->iLabel;
	} else if (inSetID != -1) {
		pSet = GetBC(inSetID);
		ID = pSet->iLabel;
	}
	if (pSet != NULL) {
		pF = new Restraint();
		pF->Create(pInNode,
		           pSet,
		           xon, yon, zon, rxon, ryon, rzon,
		           inSetID);
		pSet->Add(pF);
	}
	return (pF);
}

void ME_Object::ApplyRes(cLinkedListB* pBC) {
	int j;
	BCLD* pNext;
	if (pBC != NULL) {
		pNext = (BCLD*) pBC->Head;
		while (pNext != NULL) {
			if (pNext->iObjType == 322) {
				Restraint* pR = (Restraint*) pNext;
				Node* pNode = (Node*) pR->pObj;
				// only apply the restrain if it a global dof restraint
				// else it local and need transformation
				if (pNode->OutSys == 0) {
					for (j = 0; j < 6; j++) {
						if (pR->REST[j] == TRUE) {
							pNode->dof[j] = -1;
						}
					}
				}
			}
			pNext = (BCLD*) pNext->next;
		}
	}
}

int ME_Object::ApplyResSS(cLinkedListB* pBC) {
	int iDof = 1;
	BCLD* pNext;
	if (pBC != NULL) {
		pNext = (BCLD*) pBC->Head;
		while (pNext != NULL) {
			if (pNext->iObjType == 327) {
				TemperatureBC* pR = (TemperatureBC*) pNext;
				Node* pNode = (Node*) pR->pObj;
				// only apply the restrain if its ZEROR else need to use penulty method
				pNode->dof[0] = iDof;
				iDof++;
			}
			pNext = (BCLD*) pNext->next;
		}
	}
	return (iDof);
}

void ME_Object::LocalRes(int neq, Vec<int>& Steer, Vec<double>& KMA) {
	int i, j, k;
	C3dVector K;
	C3dMatrix r;
	CoordSys* pS;
	Vec<int> V(2 * 3);
	Mat KM(6, 6);
	Mat t(6, 6);
	Mat tt(6, 6);
	Mat Kmt;
	Mat tKmt;

	for (k = 0; k < iBCLDs; k++) {
		if (pBCLDs[k]->iObjType == 322) {
			Restraint* pR = (Restraint*) pBCLDs[k];
			Node* pNode = (Node*) pR->pObj;
			if (pNode->OutSys != 0) {
				pS = this->GetSys(pNode->OutSys);
				if (pS != NULL) {
					// This composes the stiffness tranformation matrix
					r = GetNodalSys(pNode);
					r.Transpose();
					Mat mr(3, 3);
					*mr.mn(1, 1) = r.m_00;
					*mr.mn(1, 2) = r.m_01;
					*mr.mn(1, 3) = r.m_02;
					*mr.mn(2, 1) = r.m_10;
					*mr.mn(2, 2) = r.m_11;
					*mr.mn(2, 3) = r.m_12;
					*mr.mn(3, 1) = r.m_20;
					*mr.mn(3, 2) = r.m_21;
					*mr.mn(3, 3) = r.m_22;
					for (i = 1; i < 4; i++) {
						for (j = 1; j < 4; j++) {
							*t.mn(i, j) = *mr.mn(i, j);
							*t.mn(i + 3, j + 3) = *mr.mn(i, j);
							*tt.mn(i, j) = *mr.mn(i, j);
							*tt.mn(i + 3, j + 3) = *mr.mn(i, j);
						}
					}
					tt.Transpose();
					// This composes the local stiffness matrix
					KM *= 0;
					if (pR->REST[0] == TRUE) // X
					{
						*KM.mn(1, 1) = 1e15;
						*KM.mn(4, 4) = 1e15;
						*KM.mn(1, 4) = -1e15;
						*KM.mn(4, 1) = -1e15;
					}
					if (pR->REST[1] == TRUE) // Y
					{
						*KM.mn(2, 2) = 1e15;
						*KM.mn(5, 5) = 1e15;
						*KM.mn(2, 5) = -1e15;
						*KM.mn(5, 2) = -1e15;
					}
					if (pR->REST[2] == TRUE) // Z
					{
						*KM.mn(3, 3) = 1e15;
						*KM.mn(6, 6) = 1e15;
						*KM.mn(3, 6) = -1e15;
						*KM.mn(6, 3) = -1e15;
					}
					// This transforms the local stiffness to global coord sys
					Kmt.clear();
					tKmt.clear();
					Kmt = KM * t;
					tKmt = tt * Kmt;
					// The steering vector
					*V.nn(1) = -1;
					*V.nn(2) = -1;
					*V.nn(3) = -1;
					*V.nn(4) = pNode->dof[0];
					*V.nn(5) = pNode->dof[1];
					*V.nn(6) = pNode->dof[2];
					// Put into global KM array
					formkv(KMA, tKmt, V, neq);
					// do sae for rotational restrains
					KM *= 0;
					if (pR->REST[3] == TRUE) // X
					{
						*KM.mn(1, 1) = 1e15;
						*KM.mn(4, 4) = 1e15;
						*KM.mn(1, 4) = -1e15;
						*KM.mn(4, 1) = -1e15;
					}
					if (pR->REST[4] == TRUE) // Y
					{
						*KM.mn(2, 2) = 1e15;
						*KM.mn(5, 5) = 1e15;
						*KM.mn(2, 5) = -1e15;
						*KM.mn(5, 2) = -1e15;
					}
					if (pR->REST[5] == TRUE) // Z
					{
						*KM.mn(3, 3) = 1e15;
						*KM.mn(6, 6) = 1e15;
						*KM.mn(3, 6) = -1e15;
						*KM.mn(6, 3) = -1e15;
					}
					// This transforms the local stiffness to global coord sys
					Kmt.clear();
					tKmt.clear();
					Kmt = KM * t;
					tKmt = tt * Kmt;
					// The steering vector
					*V.nn(1) = -1;
					*V.nn(2) = -1;
					*V.nn(3) = -1;
					*V.nn(4) = pNode->dof[3];
					*V.nn(5) = pNode->dof[4];
					*V.nn(6) = pNode->dof[5];
					// Put into global KM array
					formkv(KMA, tKmt, V, neq);
				}
			}
		}
	}
}

// Count the number retraint element need before KM can be allocated
int ME_Object::LocalResCount() {
	int iCnt = 0;
	int k;
	for (k = 0; k < iBCLDs; k++) {
		if (pBCLDs[k]->iObjType == 322) {
			Restraint* pR = (Restraint*) pBCLDs[k];
			Node* pNode = (Node*) pR->pObj;
			if (pNode->OutSys != 0) {
				iCnt++;
				iCnt++;
			}
		}
	}
	return (iCnt);
}

// This version for iterative solver where no
// syatem matrix (KM) exists
void ME_Object::LocalResIter(Restraint* pR, Vec<int>& SteerT, Mat& KMAT, Vec<int>& SteerB, Mat& KMAB) {
	int i, j;
	C3dVector K;
	C3dMatrix r;
	CoordSys* pS;
	Vec<int> V(2 * 3);

	Mat KM(6, 6);
	Mat t(6, 6);
	Mat tt(6, 6);
	Mat Kmt;
	Mat tKmt;

	Node* pNode = (Node*) pR->pObj;
	if (pNode->OutSys != 0) {
		pS = this->GetSys(pNode->OutSys);
		if (pS != NULL) {
			// This composes the stiffness tranformation matrix
			r = GetNodalSys(pNode);
			r.Transpose();
			Mat mr(3, 3);
			*mr.mn(1, 1) = r.m_00;
			*mr.mn(1, 2) = r.m_01;
			*mr.mn(1, 3) = r.m_02;
			*mr.mn(2, 1) = r.m_10;
			*mr.mn(2, 2) = r.m_11;
			*mr.mn(2, 3) = r.m_12;
			*mr.mn(3, 1) = r.m_20;
			*mr.mn(3, 2) = r.m_21;
			*mr.mn(3, 3) = r.m_22;
			for (i = 1; i < 4; i++) {
				for (j = 1; j < 4; j++) {
					*t.mn(i, j) = *mr.mn(i, j);
					*t.mn(i + 3, j + 3) = *mr.mn(i, j);
					*tt.mn(i, j) = *mr.mn(i, j);
					*tt.mn(i + 3, j + 3) = *mr.mn(i, j);
				}
			}
			tt.Transpose();
			// This composes the local stiffness matrix
			KM *= 0;
			if (pR->REST[0] == TRUE) // X
			{
				*KM.mn(1, 1) = 1e13;
				*KM.mn(4, 4) = 1e13;
				*KM.mn(1, 4) = -1e13;
				*KM.mn(4, 1) = -1e13;
			}
			if (pR->REST[1] == TRUE) // Y
			{
				*KM.mn(2, 2) = 1e13;
				*KM.mn(5, 5) = 1e13;
				*KM.mn(2, 5) = -1e13;
				*KM.mn(5, 2) = -1e13;
			}
			if (pR->REST[2] == TRUE) // Z
			{
				*KM.mn(3, 3) = 1e13;
				*KM.mn(6, 6) = 1e13;
				*KM.mn(3, 6) = -1e13;
				*KM.mn(6, 3) = -1e13;
			}
			// This transforms the local stiffness to global coord sys
			Kmt.clear();
			tKmt.clear();
			Kmt = KM * t;
			tKmt = tt * Kmt;
			// The steering vector
			*V.nn(1) = -1;
			*V.nn(2) = -1;
			*V.nn(3) = -1;
			*V.nn(4) = pNode->dof[0];
			*V.nn(5) = pNode->dof[1];
			*V.nn(6) = pNode->dof[2];
			SteerT = V;
			KMAT = tKmt;
			// Put into global KM array
			// formkv(KMA,tKmt,V,neq);
			//  do same for rotational restrains

			KM *= 0;
			if (pR->REST[3] == TRUE) // X
			{
				*KM.mn(1, 1) = 1e13;
				*KM.mn(4, 4) = 1e13;
				*KM.mn(1, 4) = -1e13;
				*KM.mn(4, 1) = -1e13;
			}
			if (pR->REST[4] == TRUE) // Y
			{
				*KM.mn(2, 2) = 1e13;
				*KM.mn(5, 5) = 1e13;
				*KM.mn(2, 5) = -1e13;
				*KM.mn(5, 2) = -1e13;
			}
			if (pR->REST[5] == TRUE) // Z
			{
				*KM.mn(3, 3) = 1e13;
				*KM.mn(6, 6) = 1e13;
				*KM.mn(3, 6) = -1e13;
				*KM.mn(6, 3) = -1e13;
			}
			// This transforms the local stiffness to global coord sys
			Kmt.clear();
			tKmt.clear();
			Kmt = KM * t;
			tKmt = tt * Kmt;
			// The steering vector
			*V.nn(1) = -1;
			*V.nn(2) = -1;
			*V.nn(3) = -1;
			*V.nn(4) = pNode->dof[3];
			*V.nn(5) = pNode->dof[4];
			*V.nn(6) = pNode->dof[5];
			SteerB = V;
			KMAB = tKmt;
		}
	}
}

void ME_Object::GenLocalResraints(Mat* KM, Vec<int>* G, int& iELCnt) {
	// THIS GENERATES THE SPRING TO HANGLE LOCAL RETRAINT DIRECTION NOT GLOBAL
	int i;
	Mat KResT(6, 6);
	Vec<int> SResT(6);
	Mat KResB(6, 6);
	Vec<int> SResB(6);
	for (i = 0; i < iBCLDs; i++) {
		if (pBCLDs[i]->iObjType == 322) {
			Restraint* pR = (Restraint*) pBCLDs[i];
			Node* pNode = (Node*) pR->pObj;
			if (pNode->OutSys != 0) {
				LocalResIter(pR, SResT, KResT, SResB, KResB);
				KM[iELCnt] = KResT;
				G[iELCnt] = SResT;
				iELCnt++;
				KM[iELCnt] = KResB;
				G[iELCnt] = SResB;
				iELCnt++;
			}
		}
	}
}

int ME_Object::GenDofs() {
	int i, j;
	int iDof = 1;
	int mdof;
	// FILE* pFile;
	// pFile = fopen("GENDOF_DIAG.txt","w");

	// fprintf(pFile,"%s%i\n","NO of Nodes ",iNdNo);
	for (i = 0; i < iNdNo; i++) {
		mdof = MaxDof(pNodes[i]);
		for (j = 0; j < mdof; j++) {
			if (pNodes[i]->dof[j] != -1) {
				// fprintf(pFile,"%s %i %s %i\n","Node ",pNodes[i]->iLabel,"DOF",j);
				pNodes[i]->dof[j] = iDof;
				iDof++;
			}
		}
		for (j = mdof; j < 6; j++) {
			pNodes[i]->dof[j] = 0;
		}
	}
	// fprintf(pFile,"%s%i\n","iDof ",iDof);
	// fclose(pFile);
	return (iDof - 1);
}

int ME_Object::GenDofs1D(int iD) {
	int i;
	int iDof = iD;
	// FILE* pFile;
	// pFile = fopen("GENDOF_DIAG.txt","w");
	// fprintf(pFile,"%s%i\n","NO of Nodes ",iNdNo);
	for (i = 0; i < iNdNo; i++) {
		if (pNodes[i]->dof[0] == 0) {
			// fprintf(pFile,"%s %i %s %i\n","Node ",pNodes[i]->iLabel,"DOF",0);
			pNodes[i]->dof[0] = iDof;
			iDof++;
		}
	}
	// fprintf(pFile,"%s%i\n","iDof ",iDof);
	// fclose(pFile);
	return (iDof - 1);
}

int ME_Object::GenDofs3D(int iD) {
	int i;
	int iDof = iD;
	FILE* pFile;
	pFile = fopen("GENDOF.txt", "w");
	fprintf(pFile, "%s%i\n", "NO of Nodes ", iNdNo);
	for (i = 0; i < iNdNo; i++) {
		if (pNodes[i]->dof[0] == 0) {
			fprintf(pFile, "%s %i %s %i\n", "Node ", pNodes[i]->iLabel, "DOF", iDof);
			pNodes[i]->dof[0] = iDof;
			iDof++;
		}
		if (pNodes[i]->dof[1] == 0) {
			fprintf(pFile, "%s %i %s %i\n", "Node ", pNodes[i]->iLabel, "DOF", iDof);
			pNodes[i]->dof[1] = iDof;
			iDof++;
		}
		if (pNodes[i]->dof[2] == 0) {
			fprintf(pFile, "%s %i %s %i\n", "Node ", pNodes[i]->iLabel, "DOF", iDof);
			pNodes[i]->dof[2] = iDof;
			iDof++;
		}
	}
	fprintf(pFile, "%s%i\n", "iDof ", iDof);
	fclose(pFile);
	return (iDof - 1);
}

C3dMatrix ME_Object::GetNodalSys(Node* pN) {
	C3dMatrix mRC;
	C3dMatrix mInvRC;
	C3dVector pt;
	C3dVector pO;
	CoordSys* pC;
	double ang;

	pC = GetSys(pN->OutSys);
	if (pC != NULL) {
		mRC = pC->GetTMat();
		if (pC->CysType == 2) {
			pt = pN->GetCoords();
			pO = pC->Get_Centroid();
			pt -= pO;
			mRC.Transpose();
			pt = mRC * pt;
			ang = atan2(pt.y, pt.x) * 180 / Pi;
			mInvRC.MakeUnit();
			mInvRC.Rotate(0, 0, ang);
			mRC.Transpose();
			mRC *= mInvRC;
			mInvRC = mRC;
		} else if (pC->CysType == 1) {
			mInvRC = mRC;
		} else {
			outtext1("ERROR: Spherical Coordinate Sys Not Supported.");
		}
	} else {
		outtext1("ERROR: Coordinateord Sys Not Found.");
	}

	return (mInvRC);
}

BOOL ME_Object::DeleteNd(Node* pN) {
	BOOL b1 = FALSE;
	BOOL brc = FALSE;
	int i;
	b1 = NodeInBCSet(pN);
	if (b1 == FALSE) {
		b1 = NodeInEl(pN);
	}
	if (b1 == FALSE) {
		for (i = 0; i < iNdNo; i++) {
			if (pNodes[i] == pN) {
				delete (pNodes[i]);
				pNodes[i] = pNodes[iNdNo - 1];
				pNodes[iNdNo - 1] = NULL;
				iNdNo--;
				brc = TRUE;
				break;
			}
		}
	}
	return (brc);
}

void ME_Object::IncludeToGroup(int iF, ObjGp* Group) {
	int i;
	// Coordinate systems
	for (i = 0; i < iCYS; i++) {
		if (pSys[i]->iFile == iF)
			Group->Add(pSys[i]);
	}
	// Nodes
	for (i = 0; i < iNdNo; i++) {
		if (pNodes[i]->iFile == iF)
			Group->Add(pNodes[i]);
	}
	// Elements
	for (i = 0; i < iElNo; i++) {
		if (pElems[i]->iFile == iF)
			Group->Add(pElems[i]);
	}
	// Boundary Conditions
	for (i = 0; i < iBCLDs; i++) {
		if (pBCLDs[i]->iFile == iF)
			Group->Add(pBCLDs[i]);
	}
}

BOOL ME_Object::CanDeleteEl(E_Object* pEl) {
	BOOL brc = FALSE;
	BOOL b1;

	b1 = ElemInBCSet(pEl);
	if (b1 == FALSE) {
		brc = TRUE;
	}
	return (brc);
}

BOOL ME_Object::DeleteEl(E_Object* pEl) {
	int i;
	BOOL brc = FALSE;
	if (CanDeleteEl(pEl) == TRUE) {
		for (i = 0; i < iElNo; i++) {
			if (pElems[i] == pEl) {
				delete (pElems[i]);
				pElems[i] = pElems[iElNo - 1];
				pElems[iElNo - 1] = NULL;
				iElNo--;
				brc = TRUE;
				break;
			}
		}
	}
	return (brc);
}

BOOL ME_Object::DeleteCys(CoordSys* pS) {
	int i;
	BOOL brc = FALSE;
	for (i = 0; i < iCYS; i++) {
		if ((pSys[i] == pS) && (pS != NULL)) {
			// need to check no body loads
			// on element
			delete (pSys[i]);
			pSys[i] = pSys[iCYS - 1];
			pSys[iCYS - 1] = NULL;
			iCYS--;
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

BOOL ME_Object::DeleteBC(BCLD* pS) {
	BOOL brc = TRUE;
	if (iCurLC != -1) {
		cLinkedList* pC = LCS[iCurLC];
		pC->Remove(pS);
	}
	if (iCurBC != -1) {
		cLinkedList* pC = BCS[iCurBC];
		pC->Remove(pS);
	}
	if (iCurTSet != -1) {
		cLinkedList* pC = TSETS[iCurTSet];
		pC->Remove(pS);
	}
	return (brc);
}

// Check to see if a node is used in any boundary set.
// if so we can delete if
BOOL ME_Object::NodeInBCSet(Node* pN) {
	int i;
	BOOL brc = FALSE;
	G_Object* pC;
	BCLD* pBC;
	// Check all load sets for dependancy on pN
	for (i = 0; i < iNoLCs; i++) {
		if (!brc) {
			pC = LCS[i]->Head;
			while (pC != NULL) {
				pBC = (BCLD*) pC;
				if (pN == pBC->pObj) {
					brc = TRUE;
					break;
				}
				pC = (eEdge*) pC->next;
			}
		}
	}
	for (i = 0; i < iNoBCs; i++) {
		if (!brc) {
			pC = BCS[i]->Head;
			while (pC != NULL) {
				pBC = (BCLD*) pC;
				if (pN == pBC->pObj) {
					brc = TRUE;
					break;
				}
				pC = (eEdge*) pC->next;
			}
		}
	}

	return (brc);
}

// Check to see if a node is used in any boundary set.
// if so we can delete if
BOOL ME_Object::ElemInBCSet(E_Object* pE) {
	int i;
	BOOL brc = FALSE;
	G_Object* pC;
	BCLD* pBC;
	// Check all load sets for dependancy on pN
	for (i = 0; i < iNoLCs; i++) {
		if (!brc) {
			pC = LCS[i]->Head;
			while (pC != NULL) {
				pBC = (BCLD*) pC;
				if (pE == pBC->pObj) {
					brc = TRUE;
					break;
				}
				pC = (eEdge*) pC->next;
			}
		}
	}
	for (i = 0; i < iNoTSets; i++) {
		if (!brc) {
			pC = TSETS[i]->Head;
			while (pC != NULL) {
				pBC = (BCLD*) pC;
				if (pE == pBC->pObj) {
					brc = TRUE;
					break;
				}
				pC = (eEdge*) pC->next;
			}
		}
	}

	return (brc);
}

void ME_Object::GetClosestNodes(C3dVector pTrg, ObjList* pRes, double dTol) {
	int i;
	double dDist;
	C3dVector pN;
	pRes->Clear();
	for (i = 0; i < iNdNo; i++) {
		pN = pNodes[i]->GetCoords();
		dDist = pN.Dist(pTrg);
		if (dDist < dTol)
			pRes->Add(pNodes[i]);
	}
}

Node* ME_Object::GetClosestNode(Node* pIn, double* dMinDist) {
	int i;
	double dDist = 1e36;
	*dMinDist = 1e36;

	Node* pRet = NULL;
	C3dVector pT;
	C3dVector pS = pIn->GetCoords();
	for (i = 0; i < iNdNo; i++) {
		pT = pNodes[i]->GetCoords();
		pT -= pS;
		dDist = pT.Mag();
		if (pNodes[i] != pIn) {
			if (dDist < *dMinDist) {
				*dMinDist = dDist;
				pRet = pNodes[i];
			}
		}
	}
	return (pRet);
}

Node* ME_Object::GetClosestNode2(C3dVector pIn, double& dMinDist) {
	int i;
	double dDist = 1e36;
	dMinDist = 1e36;

	Node* pRet = NULL;
	C3dVector pT;
	C3dVector pS = pIn;
	for (i = 0; i < iNdNo; i++) {
		pT = pNodes[i]->GetCoords();
		pT -= pS;
		dDist = pT.Mag();
		if (dDist < dMinDist) {
			dMinDist = dDist;
			pRet = pNodes[i];
		}
	}
	return (pRet);
}

void ME_Object::CNodesMerge(double dTol) {
	Node* pWith = NULL;
	double dDist;
	int i;
	int j;

	for (i = 0; i < iNdNo; i++) {
		if (pNodes[i]->iColour == 160) {
			if ((pNodes[i]->iLabel == 1059) || (pNodes[i]->iLabel == 1079)) {
				dDist = dDist;
			}

			pWith = GetClosestNode(pNodes[i], &dDist);
			if ((dDist < dTol) && (pWith != NULL)) {
				for (j = 0; j < iElNo; j++) {
					pElems[j]->RepNodeInEl(pNodes[i], pWith);
				}
				// DeleteNd(pNodes[i]);
			}
		}
	}
}

void ME_Object::RepNodeInEl(Node* pThis, Node* pWith) {
	int j;
	if (pThis != pWith) {
		for (j = 0; j < iElNo; j++) {
			pElems[j]->RepNodeInEl(pThis, pWith);
		}
	}
}

ObjList* ME_Object::CNodesMerge2(double dTol, BOOL UpLab, BOOL bDel) {
	Node* pWith = NULL;
	ObjList* DelNode = new ObjList();
	double dDist;
	int i;
	int j;

	for (i = 0; i < iNdNo; i++) {
		pWith = GetClosestNode(pNodes[i], &dDist);
		if ((dDist < dTol) && (pWith != NULL)) {
			if ((pWith->iLabel > pNodes[i]->iLabel) && (UpLab == TRUE)) {
				for (j = 0; j < iElNo; j++) {
					pElems[j]->RepNodeInEl(pNodes[i], pWith);
				}
				if (bDel == TRUE)
					DelNode->AddEx(pNodes[i]);
			} else {
				for (j = 0; j < iElNo; j++) {
					pElems[j]->RepNodeInEl(pWith, pNodes[i]);
				}
				if (bDel == TRUE)
					DelNode->AddEx(pWith);
			}
		}
	}
	return (DelNode);
}

BOOL ME_Object::NodeInEl(Node* pN) {
	int i;
	BOOL brc = FALSE;
	for (i = 0; i < iElNo; i++) {
		if (pElems[i]->NodeInEl(pN) == TRUE) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

int ME_Object::MaxDof(Node* pN) {
	int i;
	int id = 0;
	int imax = 0;
	for (i = 0; i < iElNo; i++) {
		if (pElems[i]->NodeInEl(pN) == TRUE) {
			id = pElems[i]->noDof();
			if (id > imax) {
				imax = id;
			}
		}
	}
	return (imax);
}

void ME_Object::CoordToGlocal() {
	int i;
	int iRID;
	CoordSys* pC = NULL;
	CoordSys* pCNext = NULL;
	for (i = 0; i < iCYS; i++) {
		pC = (CoordSys*) pSys[i];
		iRID = pC->RID;
		if (iRID > 0) {
			do {
				pCNext = GetSys(iRID);
				if (pCNext == NULL) {
					outtext1("ERROR: Coordinate Sys Not Found.");
				} else {
					iRID = pCNext->RID;
					C3dMatrix A = pCNext->mOrientMat;
					pC->Origin = A * pC->Origin;
					pC->Origin += pCNext->Origin;
					pC->mOrientMat = A * pC->mOrientMat;
					if (pCNext->bG)
						iRID = 0; // Has been transformed already - quit
				}
			} while (iRID > 0);
		}
		pC->bG = TRUE;
	}
}

void ME_Object::UpdatePropRef(PropTable* pT) {
	int i;
	Property* p = NULL;
	for (i = 0; i < iElNo; i++) {
		p = pT->GetItem(pElems[i]->PID);
		if (p != NULL) {
			pElems[i]->SetProperty(p);
		} else {
			// sprintf_s(S1,"%s%i","Property not found PID",pElems[i]->PID);
			// outtext1(S1);
		}
	}
}

// Elplicitly add an element directly
void ME_Object::AddElEx(E_Object* pEl) {
	pElems[iElNo] = pEl;
	iElNo++;
}

E_Object* ME_Object::AddEl2(int pVnode[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNoNodes,
                            int A, int B, int C, int iMatCys, double dMatAng) {
	int iCnt = -1;
	E_Object* cAddedEl;
	Node* pENodes[MaxSelNodes];
	if (iCnt > MaxSelNodes)
		outtext1("WARNING: Max RBE2 Nodes Exceeded.");
	if (TempList != NULL) {
		for (iCnt = 0; iCnt < iNoNodes; iCnt++) {
			if (iCnt < MaxSelNodes)
				pENodes[iCnt] = (Node*) TempList->Objs[pVnode[iCnt]];
		}
	} else {
		for (iCnt = 0; iCnt < iNoNodes; iCnt++) {
			if (iCnt < MaxSelNodes)
				pENodes[iCnt] = GetNode(pVnode[iCnt]);
		}
	}
	if (iLab > iElementLab) {
		iElementLab = iLab;
	}
	cAddedEl = AddEl(pENodes, iLab, iCol, iType, iPID, iMat, iNoNodes, A, B, C, FALSE, iMatCys, dMatAng);
	return (cAddedEl);
}

void ME_Object::MaxLab() {
	int iCnt;
	iNodeLab = 0;
	iElementLab = 0;
	iCYSLab = 0;
	iNodeMinLab = 99999999;
	iElementMinLab = 99999999;
	iCYSMinLab = 99999999;
	if (iNdNo == 0) {
		iNodeMinLab = 0;
	} else {
		for (iCnt = 0; iCnt < iNdNo; iCnt++) {
			if (pNodes[iCnt]->iLabel > iNodeLab) {
				iNodeLab = pNodes[iCnt]->iLabel;
			}
			if (pNodes[iCnt]->iLabel < iNodeMinLab) {
				iNodeMinLab = pNodes[iCnt]->iLabel;
			}
		}
	}
	if (iElNo == 0) {
		iElementMinLab = 0;
	} else {
		for (iCnt = 0; iCnt < iElNo; iCnt++) {
			if (pElems[iCnt]->iLabel > iElementLab) {
				iElementLab = pElems[iCnt]->iLabel;
			}
			if (pElems[iCnt]->iLabel < iElementMinLab) {
				iElementMinLab = pElems[iCnt]->iLabel;
			}
		}
	}
	if (iCYS == 0) {
		iCYSMinLab = 0;
	} else {
		for (iCnt = 0; iCnt < iCYS; iCnt++) {
			if (pSys[iCnt]->iLabel > iCYSLab) {
				iCYSLab = pSys[iCnt]->iLabel;
			}
			if (pSys[iCnt]->iLabel < iCYSMinLab) {
				iCYSMinLab = pSys[iCnt]->iLabel;
			}
		}
	}
	iNodeLab++;
	iElementLab++;
	iCYSLab++;
}

// pInVertex[2000]	Nodes
// int iLab			Element Label
// int iCol			Element Colour
// int iType		Element Type
// int iPID			Element Property ID
// int iMat
// int iNo			No of Nodes
// int iA
// int iB
// int iC
// BOOL AddDisp
// int iMatCys
// double dMatAng)
E_Object* ME_Object::AddEl(Node* pInVertex[MaxSelNodes], int iLab, int iCol, int iType, int iPID, int iMat, int iNo,
                           int iA, int iB, int iC, BOOL AddDisp, int iMatCys, double dMatAng) {
	E_Object* pERet = NULL;

	if (iElNo < MAX_FESIZE) {
		if (iType == 115) {
			E_Object38* pEL8 = new E_Object38();
			pEL8->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			if (pEL8->ChkNegJac() == TRUE) {
				pEL8->Reverse();
				outtext1("ERROR: reversing.");
			}
			pElems[iElNo] = pEL8;
			pERet = pEL8;
			iElNo++;
		} else if (iType == 112) {
			E_Object36* pEL6 = new E_Object36();
			pEL6->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			if (pEL6->ChkNegJac() == TRUE) {
				pEL6->Reverse();
				outtext1("ERROR: Reversing.");
			}
			pElems[iElNo] = pEL6;
			pERet = pEL6;
			iElNo++;
		} else if (iType == 94) {
			E_Object4* pEL4 = new E_Object4();
			pEL4->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, iMatCys, dMatAng, this, NULL);
			pElems[iElNo] = pEL4;
			pERet = pEL4;
			iElNo++;
		} else if (iType == 91) {
			E_Object3* pEL3 = new E_Object3();
			pEL3->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, iMatCys, dMatAng, this, NULL);
			pElems[iElNo] = pEL3;
			pERet = pEL3;
			// AddElEdges(pElems[iElNo]);
			iElNo++;
		} else if (iType == 161) {
			E_Object1* pEL1 = new E_Object1();
			pEL1->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			pElems[iElNo] = pEL1;
			pERet = pEL1;
			iElNo++;
		} else if ((iType == 136) || (iType == 137)) {
			E_Object2* pEL2 = new E_Object2();
			pEL2->Create(pInVertex, iLab, iCol, iType, iPID, iMatCys, iNo, this, NULL);
			pElems[iElNo] = pEL2;
			pERet = pEL2;
			iElNo++;
		} else if (iType == 138) {
			E_Object2BUSH* pEL2 = new E_Object2BUSH();
			pEL2->Create(pInVertex, iLab, iCol, iType, iPID, iMatCys, iNo, this, NULL);
			pElems[iElNo] = pEL2;
			pERet = pEL2;
			iElNo++;
		} else if (iType == 121) {
			E_ObjectR2* pEL2 = new E_ObjectR2();
			pEL2->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			pElems[iElNo] = pEL2;
			pERet = pEL2;
			iElNo++;
		} else if ((iType == 21) || (iType == 22)) {
			E_Object2B* pEL2 = new E_Object2B();
			pEL2->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			pEL2->SetSec(iA, iB, iC);
			pElems[iElNo] = pEL2;
			pERet = pEL2;
			iElNo++;
		} else if (iType == 11) {
			E_Object2R* pEL2 = new E_Object2R();
			pEL2->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			pEL2->SetSec(iA, iB, iC);
			pElems[iElNo] = pEL2;
			pERet = pEL2;
			iElNo++;
		} else if (iType == 111) {
			E_Object34* pEL34 = new E_Object34();
			pEL34->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			if (pEL34->ChkNegJac() == TRUE) {
				pEL34->Reverse();
				outtext1("ERROR: Reversing.");
			}
			pElems[iElNo] = pEL34;
			pERet = pEL34;
			iElNo++;
		} else if (iType == 310) {
			E_Object310* pEL310 = new E_Object310();
			pEL310->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			if (pEL310->ChkNegJac() == TRUE) {
				pEL310->Reverse();
				outtext1("ERROR: Reversing.");
			}
			pElems[iElNo] = pEL310;
			pERet = pEL310;
			iElNo++;
		} else if (iType == 122) {
			E_ObjectR* pELR = new E_ObjectR();
			pELR->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			pElems[iElNo] = pELR;
			pERet = pELR;
			iElNo++;
		} else if (iType == 1000) {
			E_CellS* pELR = new E_CellS();
			pELR->Create(pInVertex, iLab, iCol, iType, iPID, iMat, iNo, this, NULL);
			pElems[iElNo] = pELR;
			pERet = pELR;
			iElNo++;
		}
	} else {
		outtext1("ERROR: Max ELMAX SIZE");
	}

	return (pERet);
}

void ME_Object::GlobalToLocal(C3dVector& vRet, int iDef) {
	int iRet;
	iRet = 0;
	CoordSys* Cys;
	// int CysID;
	if (iDef != 0) {
		Cys = GetSys(iDef);
		if (Cys == NULL) {
			outtext1("ERROR: Coordinate Sys Not Found.");
		} else {
			C3dMatrix A = Cys->mOrientMat;
			A.Transpose();
			iRet = Cys->RID;
			if (Cys->CysType == 1) {
				vRet = A * vRet;
				vRet -= Cys->Origin;
			} else if (Cys->CysType == 2) {
				outtext1("ERROR: Not Implemented for Cylindrical.");
			} else if (Cys->CysType == 3) {
				outtext1("ERROR: Not Implemented for Sperical.");
			}
		}
	}
}

int ME_Object::NodeToGlobal(C3dVector& vRet, int iDef) {
	int iRet;
	iRet = 0;
	CoordSys* Cys;
	// int CysID;
	if (iDef != 0) {
		Cys = GetSys(iDef);
		if (Cys == NULL) {
			outtext1("ERROR: Coordinate Sys Not Found.");
		} else {
			C3dMatrix A = Cys->mOrientMat;
			iRet = Cys->RID;
			if (Cys->CysType == 1) {
				vRet = A * vRet;
				vRet += Cys->Origin;
			} else if (Cys->CysType == 2) {
				C3dVector pCart;
				pCart.x = vRet.x * cos(D2R * vRet.y);
				pCart.y = vRet.x * sin(D2R * vRet.y);
				pCart.z = vRet.z;
				pCart = A * pCart;
				pCart += Cys->Origin;
				vRet = pCart;
			} else if (Cys->CysType == 3) {
				C3dVector pCart;
				pCart.x = vRet.x * sin(D2R * vRet.y) * cos(D2R * vRet.z);
				pCart.y = vRet.x * sin(D2R * vRet.y) * sin(D2R * vRet.z);
				pCart.z = vRet.x * cos(D2R * vRet.y);
				pCart = A * pCart;
				pCart += Cys->Origin;
				vRet = pCart;
			}
		}
	}

	return (iRet);
}

// We Need Theta in the Cylindrical coords Sys before
// we can convert results from cylindrical output to global
C3dVector ME_Object::CartToCylCYS(CoordSys* pCy, C3dVector pP) {
	C3dVector v1moved;
	C3dVector v2Glob;
	C3dMatrix mTran;
	C3dMatrix mInv;
	C3dVector vCyl;
	C3dVector vCent;
	mTran = pCy->GetTMat();
	vCent = pCy->Get_Centroid();
	v1moved = pP;
	v1moved.x = v1moved.x - vCent.x;
	v1moved.y = v1moved.y - vCent.y;
	v1moved.z = v1moved.z - vCent.z;
	mTran.m_30 = 0;
	mTran.m_31 = 0;
	mTran.m_32 = 0;
	mInv = mTran.Inv();
	v2Glob = mInv * v1moved;
	vCyl.x = pow(v2Glob.x * v2Glob.x + v2Glob.y * v2Glob.y, 0.5);
	vCyl.y = atan2(v2Glob.y, v2Glob.x) * 180 / Pi;
	vCyl.z = v2Glob.z;
	return (vCyl);
}

int ME_Object::VecToGlobal(Node* pN, C3dVector& vRet, int iDef) {
	int iRet;
	int iLab;
	iRet = 0;
	CoordSys* Cys;
	// int CysID;
	if ((pN->iLabel == 162) || (pN->iLabel == 163))
		iLab = pN->iLabel;
	if (iDef != 0) {
		Cys = GetSys(iDef);
		if (Cys == NULL) {
			outtext1("ERROR: Coordiinate Sys Not Found.");
		} else {
			C3dMatrix A = Cys->mOrientMat;
			iRet = Cys->RID;
			if (Cys->CysType == 1) {
				vRet = A * vRet;
			} else if (Cys->CysType == 2) {
				C3dVector vRG;
				vRG = CartToCylCYS(Cys, pN->Get_Centroid());
				C3dVector pCart;
				pCart.x = vRet.x * cos(D2R * (vRG.y)) - vRet.y * sin(D2R * (vRG.y));
				pCart.y = vRet.x * sin(D2R * (vRG.y)) + vRet.y * cos(D2R * (vRG.y));
				pCart.z = vRet.z;
				pCart = A * pCart;
				vRet = pCart;
			} else if (Cys->CysType == 3) {
				C3dVector pCart;
				pCart.x = vRet.x * sin(D2R * vRet.y) * cos(D2R * vRet.z);
				pCart.y = vRet.x * sin(D2R * vRet.y) * sin(D2R * vRet.z);
				pCart.z = vRet.x * cos(D2R * vRet.y);
				pCart = A * pCart;
				vRet = pCart;
			}
		}
	}

	return (iRet);
}

Node* ME_Object::AddNode(C3dVector InPt, int iLab, int i2, int i3, int iC, int iDef, int iOut) {
	int iRID;
	iRID = iDef;
	if (iNdNo < MAX_FESIZE) {
		do {
			iRID = NodeToGlobal(InPt, iRID);
		} while (iRID > 0);
		pNodes[iNdNo] = new Node;
		pNodes[iNdNo]->Create(InPt, iLab, i2, i3, iC, iDef, iOut, this);
		if (TempList != NULL) {
			TempList->Objs[iLab] = pNodes[iNdNo];
		}
		if (iLab > iNodeLab) {
			iNodeLab = iLab;
		}
		iNdNo++;
	} else {
		outtext1("ERROR: Max Node Limit Exceeded.");
	}
	return (pNodes[iNdNo - 1]);
}

CoordSys* ME_Object::AddSys(C3dVector Orig, C3dMatrix RMat, int iRID, int iTp, int iLab, int iC) {
	if (iCYS < MAX_FESIZE) {
		pSys[iCYS] = new CoordSys;
		pSys[iCYS]->Create(Orig, RMat, iRID, iTp, iLab, iC, this);
		if (iLab > iCYSLab) {
			iCYSLab = iLab;
		}
		iCYS++;
	} else {
		outtext1("ERROR: Max No of Coordinate Sys Exceeded.");
	}

	return (pSys[iCYS - 1]);
}

CoordSys* ME_Object::GetSys(int iLab) {
	int i;
	CoordSys* oRet = NULL;
	if ((iLab > 0) && (iCYS > 0)) {
		for (i = 0; i < iCYS; i++) {
			if (pSys[i]->iLabel == iLab) {
				oRet = pSys[i];
				break;
			}
		}
	}
	return (oRet);
}

Node* ME_Object::GetNode(int iRLab) {
	int iCnt;
	Node* pRetPt = nullptr;
	if ((TempList != NULL) && (iRLab < 99999999)) {
		pRetPt = (Node*) TempList->Objs[iRLab];
	} else {
		for (iCnt = 0; iCnt < iNdNo; iCnt++) {
			if (pNodes[iCnt]->iLabel == iRLab) {
				pRetPt = pNodes[iCnt];
				break;
			}
		}
	}
	return (pRetPt);
}

int ME_Object::GetNodeInd(Node* pThisNode) {
	int iCnt;

	for (iCnt = 0; iCnt < iNdNo; iCnt++) {
		if (pNodes[iCnt] == pThisNode) {
			break;
		}
	}
	return (iCnt);
}

E_Object* ME_Object::GetElement(int iRLab) {
	int iCnt;
	E_Object* pRetPt = NULL;

	for (iCnt = 0; iCnt < iElNo; iCnt++) {
		if (pElems[iCnt]->iLabel == iRLab) {
			pRetPt = pElems[iCnt];
			break;
		}
	}

	return (pRetPt);
}

E_Object* ME_Object::GetShellFromNodes(int n1, int n2, int n3) {
	int iCnt;
	BOOL bIS = FALSE;
	E_Object* pRetPt = nullptr;

	for (iCnt = 0; iCnt < iElNo; iCnt++) {
		if ((pElems[iCnt]->iType == 92) ||
		    (pElems[iCnt]->iType == 94)) {
			if ((pElems[iCnt]->NodeInEl(this->GetNode(n1))) &&
			    (pElems[iCnt]->NodeInEl(this->GetNode(n2))) &&
			    (pElems[iCnt]->NodeInEl(this->GetNode(n3)))) {
				pRetPt = pElems[iCnt];
				break;
			}
		}
	}
	return (pRetPt);
}

// contour map
// float Texture17[30][3] =
//{
//{0.00f, 0.00f, 1.00f},    //151 Blue
//{0.00f, 0.33f, 1.00f},    //152 Grey Blue
//{0.00f, 0.66f, 1.00f},    //153 Light Blue
//{0.00f, 1.00f, 1.00f},    //154 Cyan
//{1.00f, 0.33f, 1.00f},    //163 Light Magenta
//{1.00f, 0.00f, 1.00f},    //162 Magenta
//{0.00f, 0.33f, 0.00f},    //155 Dark Olive
//{0.00f, 0.66f, 0.00f},    //156 Dark Green
//{0.00f, 1.00f, 0.00f},    //157 Green
//{1.00f, 1.00f, 0.00f},    //158 Yellow
//{1.00f, 0.66f, 0.00f},    //159 Golden Orange
//{1.00f, 0.33f, 0.00f},    //160 Orange
//{1.00f, 0.00f, 0.00f}};   //161 Red

float Texture17[30][3] =
    {
        {0.00f, 0.00f, 1.00f}, // 151 Blue
        {0.00f, 0.33f, 1.00f}, // 152 Grey Blue
        {0.00f, 0.66f, 1.00f}, // 153 Light Blue
        {0.00f, 1.00f, 0.66f}, // 154 Cyan
        {0.00f, 1.00f, 0.33f}, // 163 Light Magenta
        {0.33f, 1.00f, 0.00f}, // 162 Magenta
        {0.66f, 1.00f, 0.00f}, // 155 Dark Olive
        {1.00f, 0.90f, 0.00f}, // 156 Dark Green
        {1.00f, 0.50f, 0.00f}, // 157 Green
        {1.00f, 0.00f, 0.00f}}; // 161 Red

float Texture18[30][3] =
    {
        {1.00f, 0.00f, 0.00f}, // 161 Red
        {1.00f, 0.50f, 0.00f}, // 157 Green
        {1.00f, 0.90f, 0.00f}, // 156 Dark Green
        {0.66f, 1.00f, 0.00f}, // 155 Dark Olive
        {0.33f, 1.00f, 0.00f}, // 162 Magenta
        {0.00f, 1.00f, 0.33f}, // 163 Light Magenta
        {0.00f, 1.00f, 0.66f}, // 154 Cyan
        {0.00f, 0.66f, 1.00f}, // 153 Light Blue
        {0.00f, 0.33f, 1.00f}, // 152 Grey Blue
        {0.00f, 0.00f, 1.00f}}; // 151 Blue

void CreateTexture(BOOL bRev) {
	// This bit does the results contour mapping
	//  Set pixel stora   BOOL glTexCoord1f(TOrd[i]);ge mode
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	// Generate a texture name
	GLuint m_nTexName = NULL;
	glGenTextures(1, &m_nTexName);
	// Create a texture object
	glBindTexture(GL_TEXTURE_1D, m_nTexName);
	glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER,
	                GL_NEAREST);
	glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER,
	                GL_NEAREST);
	if (bRev)
		glTexImage1D(GL_TEXTURE_1D, 0, 3, 10, 0, GL_RGB, GL_FLOAT, Texture18);
	else
		glTexImage1D(GL_TEXTURE_1D, 0, 3, 10, 0, GL_RGB, GL_FLOAT, Texture17);
}

void DrawColBar(int iDspFlgs, double dW, double dH) {
	int iNoCols = 13;
	float YOrd[30];
	float TOrd[30];
	float VOrd[30];
	float fCw;
	fCw = (float) (0.1 * dW);
	int i;
	float dHS;
	float dWInc;
	float fSpan;
	float fInc;
	float tCol;
	fSpan = cBarMax - cBarMin;
	fInc = fSpan / iNoCols;

	dHS = (float) (2 * dH / (iNoCols + 2));
	dWInc = (float) (0.3 * dW);
	for (i = 0; i < iNoCols + 1; i++) {
		YOrd[i] = (float) (-dH + dHS + dHS * i);
		TOrd[i] = (float) (fInc * i / fSpan);
		VOrd[i] = (float) (cBarMin + fInc * i);
	}
	glColor3fv(cols[124]);
	glEnable(GL_TEXTURE_1D);
	for (i = 0; i < iNoCols; i++) {
		tCol = (TOrd[i] + TOrd[i + 1]) / 2;
		glBegin(GL_POLYGON);
		glTexCoord1f(tCol);
		glNormal3f(0, 0, 1);
		glVertex3f((float) (dW - fCw - dWInc), (float) YOrd[i], (float) 100);
		glTexCoord1f(tCol);
		glNormal3f(0, 0, 1);
		glVertex3f((float) (dW - dWInc), (float) YOrd[i], (float) 100);
		glTexCoord1f(tCol);
		glNormal3f(0, 0, 1);
		glVertex3f((float) (dW - dWInc), (float) YOrd[i + 1], (float) 100);
		glTexCoord1f(tCol);
		glNormal3f(0, 0, 1);
		glVertex3f((float) dW - fCw - dWInc, (float) YOrd[i + 1], 100);
		glEnd();
	}
	glDisable(GL_TEXTURE_1D);
	char sLab[80];
	for (i = 0; i < iNoCols + 1; i++) {
		sprintf_s(sLab, "%g", VOrd[i]);
		OglString(iDspFlgs, dW - 0.95 * dWInc, YOrd[i], 100, &sLab[0]);
	}
}

void ME_Object::OglDraw(int iDspFlgs, double dS1, double dS2) {
	int i;

	if (iElNo > 0) {
		for (i = 0; i < iElNo; i++) {
			pElems[i]->OglDraw(iDspFlgs, dS1, dS2);
		}
	}
	if ((iNdNo > 0) && (bDrawN == TRUE)) {
		for (i = 0; i < iNdNo; i++) {
			pNodes[i]->OglDraw(iDspFlgs, dS1, dS2);
		}
	}
	if (iCurLC != -1) {
		LCS[iCurLC]->OglDraw(iDspFlgs, dS1, dS2);
	}
	if (iCurBC != -1) {
		BCS[iCurBC]->OglDraw(iDspFlgs, dS1, dS2);
	}
	if (iCurTSet != -1) {
		TSETS[iCurTSet]->OglDraw(iDspFlgs, dS1, dS2);
	}

	if (iCYS > 0) {
		for (i = 0; i < iCYS; i++) {
			pSys[i]->OglDraw(iDspFlgs, dS1, dS2);
		}
	}

	// if (FcList!=NULL)
	//   FcList->OglDraw(iDspFlgs,dS1,dS2);
}

void ME_Object::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	int i;
	char sLab[80];
	if (pResVectors != NULL)
		pResVectors->OglDrawW(iDspFlgs, dS1, dS2);
	if (iElNo > 0) {
		for (i = 0; i < iElNo; i++) {
			pElems[i]->OglDrawW(iDspFlgs, dS1, dS2);
		}
	}
	if ((iNdNo > 0) && (bDrawN == TRUE)) {
		for (i = 0; i < iNdNo; i++) {
			pNodes[i]->OglDrawW(iDspFlgs, dS1, dS2);
		}
	}

	if (iCurLC != -1) {
		LCS[iCurLC]->OglDrawW(iDspFlgs, dS1, dS2);
	}
	if (iCurBC != -1) {
		BCS[iCurBC]->OglDrawW(iDspFlgs, dS1, dS2);
	}
	if (iCurTSet != -1) {
		TSETS[iCurTSet]->OglDrawW(iDspFlgs, dS1, dS2);
	}

	if (iBCLDs > 0) {
		for (i = 0; i < iBCLDs; i++) {
			pBCLDs[i]->OglDrawW(iDspFlgs, dS1, dS2);
		}
	}
	if (iCYS > 0) {
		for (i = 0; i < iCYS; i++) {
			pSys[i]->OglDraw(iDspFlgs, dS1, dS2);
		}
	}

	// New Results Vectors

	C3dVector vCent;
	vCent = Get_Centroid();
	// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
	if (gLBL_DSP_TRG)
		bDrawLab = FALSE;
	if (bDrawLab == TRUE)
	// Esp_Mod_Labels_4_27_2025_End
	{
		sprintf_s(sLab, "ME: %s", sName);
		OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, sLab);
	}
}

void ME_Object::Draw(CDC* pDC, int iDrawmode) {
	int i;
	if (iDrawmode != 2) {
		if ((iNdNo > 0) && (bDrawN == TRUE)) {
			for (i = 0; i < iNdNo; i++) {
				pNodes[i]->Draw(pDC, iDrawmode);
			}
		}
		if (iElNo > 0) {
			for (i = 0; i < iElNo; i++) {
				pElems[i]->Draw(pDC, iDrawmode);
			}
		}
		if (iCurLC != -1) {
			LCS[iCurLC]->Draw(pDC, iDrawmode);
		}
		if (iCurBC != -1) {
			BCS[iCurBC]->Draw(pDC, iDrawmode);
		}
		if (iCurTSet != -1) {
			TSETS[iCurTSet]->Draw(pDC, iDrawmode);
		}

		if (iBCLDs > 0) {
			for (i = 0; i < iBCLDs; i++) {
				pBCLDs[i]->Draw(pDC, iDrawmode);
			}
		}
		if (iCYS > 0) {
			for (i = 0; i < iCYS; i++) {
				pSys[i]->Draw(pDC, iDrawmode);
			}
		}
	}
}

void ME_Object::Colour(int iCol) {
	int i;
	if (iNdNo > 0) {
		for (i = 0; i < iNdNo; i++) {
			pNodes[i]->Colour(iCol);
		}
	}

	if (iElNo > 0) {
		for (i = 0; i < iElNo; i++) {
			pElems[i]->Colour(iCol);
		}
	}

	if (iBCLDs > 0) {
		for (i = 0; i < iBCLDs; i++) {
			pBCLDs[i]->Colour(iCol);
		}
	}
	if (iCYS > 0) {
		for (i = 0; i < iCYS; i++) {
			pSys[i]->Colour(iCol);
		}
	}
}

void ME_Object::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	int i;
	C3dVector ll, uu;
	GetBoundingBox(ll, uu);
	for (i = 0; i < 8; i++)
		BBox[i].SetToScr(pModMat, pScrTran);
	if (iNdNo > 0) {
		for (i = 0; i < iNdNo; i++) {
			pNodes[i]->SetToScr(pModMat, pScrTran);
		}
	}

	if (iElNo > 0) {
		for (i = 0; i < iElNo; i++) {
			pElems[i]->SetToScr(pModMat, pScrTran);
		}
	}

	if (iCurLC != -1) {
		LCS[iCurLC]->SetToScr(pModMat, pScrTran);
	}
	if (iCurBC != -1) {
		BCS[iCurBC]->SetToScr(pModMat, pScrTran);
	}
	if (iCurTSet != -1) {
		TSETS[iCurTSet]->SetToScr(pModMat, pScrTran);
	}

	if (iBCLDs > 0) {
		for (i = 0; i < iBCLDs; i++) {
			pBCLDs[i]->SetToScr(pModMat, pScrTran);
		}
	}

	if (pResVectors != NULL)
		pResVectors->SetToScr(pModMat, pScrTran);

	if (iCYS > 0) {
		for (i = 0; i < iCYS; i++) {
			pSys[i]->SetToScr(pModMat, pScrTran);
		}
	}
}

void ME_Object::Transform(C3dMatrix TMat) {
	int i;
	TransMat = TMat;
	if (iNdNo > 0) {
		for (i = 0; i < iNdNo; i++) {
			pNodes[i]->Transform(TMat);
		}
	}
	if (iElNo > 0) {
		for (i = 0; i < iElNo; i++) {
			pElems[i]->Transform(TMat);
		}
	}
}

void ME_Object::Translate(C3dVector vIn) {
	int i;
	if (iNdNo > 0) {
		for (i = 0; i < iNdNo; i++) {
			pNodes[i]->Translate(vIn);
		}
	}

	if (iCYS > 0) {
		for (i = 0; i < iCYS; i++) {
			pSys[i]->Translate(vIn);
		}
	}
}

void ME_Object::HighLight(CDC* pDC) {
	int i = 0;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	for (i = 1; i < 4; i++)
		pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 0;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);

	i = 4;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	for (i = 5; i < 8; i++)
		pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 4;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);

	i = 0;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 4;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 1;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 5;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 2;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 6;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 3;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 7;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
}

int ME_Object::GetMeshYExt() {
	int irc = -1;
	int i;
	int iYMin;
	int iYMax;

	if (iNdNo > 1) {
		iYMin = (int) pNodes[0]->DSP_Point->y;
		iYMax = iYMin;
		for (i = 0; i < iNdNo; i++) {
			if (pNodes[i]->DSP_Point->y > iYMax)
				iYMax = pNodes[i]->DSP_Point->y;
			if (pNodes[i]->DSP_Point->y < iYMin)
				iYMin = pNodes[i]->DSP_Point->y;
		}
		irc = iYMax - iYMin;
	}
	return (irc);
}

C3dVector ME_Object::Get_Centroid() {
	C3dVector vRet;
	vRet.Set(0, 0, 0);
	int i;
	if (iNdNo > 0) {
		for (i = 0; i < iNdNo; i++) {
			vRet += pNodes[i]->Get_Centroid();
		}
		vRet.x = vRet.x / iNdNo;
		vRet.y = vRet.y / iNdNo;
		vRet.z = vRet.z / iNdNo;
	}
	return (vRet);
}

G_ObjectD ME_Object::SelDist(CPoint InPT, Filter FIL) {
	G_Object* pSel = NULL;
	G_Object* pMinSel = NULL;
	G_ObjectD Ret;
	int i;
	double dDist = 1e36;
	Ret.pObj = NULL;
	Ret.Dist = dDist;
	// search the node regardless of
	// filter so we can  get a dist
	// for the mesh
	if (iNdNo > 0) {
		for (i = 0; i < iNdNo; i++) {
			if (pNodes[i]->isSelectable() == 1) {
				Ret = pNodes[i]->SelDist(InPT, FIL);
				if (Ret.Dist < dDist) {
					pMinSel = Ret.pObj;
					dDist = Ret.Dist;
				}
			}
		}
	}

	if (FIL.isFilter(3)) {
		if (iElNo > 0) {
			for (i = 0; i < iElNo; i++) {
				if (pElems[i]->isSelectable() == 1) {
					Ret = pElems[i]->SelDist(InPT, FIL);
					if (Ret.Dist < dDist) {
						pMinSel = Ret.pObj;
						dDist = Ret.Dist;
					}
				}
			}
		}
	}

	// loads
	if (iCurLC != -1) {
		if ((FIL.isFilter(200)) ||
		    (FIL.isFilter(321)) ||
		    (FIL.isFilter(323)) ||
		    (FIL.isFilter(324)) ||
		    (FIL.isFilter(326)) ||
		    (FIL.isFilter(328)) ||
		    (FIL.isFilter(329))) {
			Ret = LCS[iCurLC]->SelDist(InPT, FIL);
			if (Ret.Dist < dDist) {
				pMinSel = Ret.pObj;
				dDist = Ret.Dist;
			}
		}
	}
	// Boundary condition
	if (iCurBC != -1) {
		if ((FIL.isFilter(201)) ||
		    (FIL.isFilter(322)) ||
		    (FIL.isFilter(327))) {
			Ret = BCS[iCurBC]->SelDist(InPT, FIL);
			if (Ret.Dist < dDist) {
				pMinSel = Ret.pObj;
				dDist = Ret.Dist;
			}
		}
	}

	if (iCurTSet != -1) {
		if ((FIL.isFilter(202)) ||
		    (FIL.isFilter(325))) {
			Ret = TSETS[iCurTSet]->SelDist(InPT, FIL);
			if (Ret.Dist < dDist) {
				pMinSel = Ret.pObj;
				dDist = Ret.Dist;
			}
		}
	}

	if (FIL.isFilter(12)) {
		if (iCYS > 0) {
			for (i = 0; i < iCYS; i++) {
				Ret = pSys[i]->SelDist(InPT, FIL);
				if (Ret.Dist < dDist) {
					pMinSel = Ret.pObj;
					dDist = Ret.Dist;
				}
			}
		}
	}

	if ((FIL.isFilter(3) == TRUE) || (FIL.isFilter(1) == TRUE) || (FIL.isFilter(200) == TRUE) || (FIL.isFilter(201) == TRUE) || (FIL.isFilter(202) == TRUE) || (FIL.isFilter(321) == TRUE) || (FIL.isFilter(322) == TRUE) || (FIL.isFilter(323) == TRUE) || (FIL.isFilter(324) == TRUE) || (FIL.isFilter(325) == TRUE) || (FIL.isFilter(326) == TRUE) || (FIL.isFilter(327) == TRUE) || (FIL.isFilter(328) == TRUE) || (FIL.isFilter(12) == TRUE)) {
		Ret.pObj = pMinSel;
		Ret.Dist = dDist;
	} else {
		Ret.pObj = this;
		Ret.Dist = dDist;
	}
	return (Ret);
}

void ME_Object::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	int i;
	if (iNdNo > 0) {
		for (i = 0; i < iNdNo; i++) {
			if (pNodes[i]->isSelectable() == 1) {
				pNodes[i]->S_Box(P1, P2, pSel);
			}
		}
	}

	if (iElNo > 0) {
		for (i = 0; i < iElNo; i++) {
			if (pElems[i]->isSelectable() == 1) {
				pElems[i]->S_Box(P1, P2, pSel);
			}
		}
	}

	if (iCYS > 0) {
		for (i = 0; i < iCYS; i++) {
			if (pSys[i]->isSelectable() == 1) {
				pSys[i]->S_Box(P1, P2, pSel);
			}
		}
	}

	if (iBCLDs > 0) {
		for (i = 0; i < iBCLDs; i++) {
			if (pBCLDs[i]->isSelectable() == 1) {
				pBCLDs[i]->S_Box(P1, P2, pSel);
			}
		}
	}
	if (pResVectors != NULL)
		pResVectors->S_Box(P1, P2, pSel);

	if (iCurLC != -1) {
		LCS[iCurLC]->S_Box(P1, P2, pSel);
	}

	if (iCurBC != -1) {
		BCS[iCurBC]->S_Box(P1, P2, pSel);
	}

	if (iCurTSet != -1) {
		TSETS[iCurTSet]->S_Box(P1, P2, pSel);
	}
}

void ME_Object::S_Sel(int iT, ObjList* pSel) {
	int i;
	if ((iT == 1) || (iT == -1)) {
		for (i = 0; i < iNdNo; i++) {
			pSel->Add(pNodes[i]);
		}
	}

	if ((iT == 3) || (iT == -1)) {
		for (i = 0; i < iElNo; i++) {
			pSel->Add(pElems[i]);
		}
	}

	if ((iT == 12) || (iT == -1)) {
		for (i = 0; i < iCYS; i++) {
			pSel->Add(pSys[i]);
		}
	}

	if (((iT == 321) || (iT == 322) || (iT == 323) || (iT == 324) || (iT == 328)) || (iT == -1)) {
		for (i = 0; i < iBCLDs; i++) {
			if (pBCLDs[i]->iObjType == iT)
				pSel->Add(pBCLDs[i]);
		}
	}
}

G_Object* ME_Object::GetObj(int iType, int iLab) {
	G_Object* pRet;
	pRet = NULL;
	if (iType == 1) {
		pRet = GetNode(iLab);
	} else if (iType == 3) {
		pRet = GetElement(iLab);
	} else if (iType == 12) {
		pRet = GetSys(iLab);
	} else if (iType == 200) {
		pRet = GetLC(iLab);
	} else if (iType == 201) {
		pRet = GetBC(iLab);
	} else if (iType == 202) {
		pRet = GetTSET(iLab);
	}
	return (pRet);
}

//************************************************************************
// Coeff Mat ,el stiff matrix,steering vec and no off equ
// Post : el assembled into bk
//************************************************************************
void ME_Object::formkv(Vec<double>& bk, Mat& KM, Vec<int>& g, int neq) {
	int i, j, ndof, icd, ival;
	ndof = KM.m;
	for (i = 1; i < ndof + 1; i++) {
		if (*g.nn(i) > 0) {
			for (j = 1; j < ndof + 1; j++) {
				if (*g.nn(j) > 0) {
					icd = *g.nn(j) - *g.nn(i) + 1;
					if ((icd - 1) >= 0) {
						ival = neq * (icd - 1) + *g.nn(i);
						*bk.nn(ival) = *bk.nn(ival) + *KM.mn(i, j);
					}
				}
			}
		}
	}
}

//************************************************************************
// Coeff Mat in upper baned vector form and no of equs
// Post : guass reduction
//************************************************************************
void ME_Object::banred(Vec<double>& bk, int neq) {
	int iw, i, j, il1, kbl, ij;
	double sum;
	int m, nkb, ni, nj;
	sum = 0;
	iw = bk.n / neq - 1;
	for (i = 2; i < neq + 1; i++) {
		il1 = i - 1;
		kbl = il1 + iw + 1;
		if (kbl - neq > 0) {
			kbl = neq;
		}
		for (j = i; j < kbl + 1; j++) {
			ij = (j - i) * neq + i;
			sum = bk.v[ij - 1];
			nkb = j - iw;
			if (nkb <= 0) {
				nkb = 1;
			}
			if (nkb - il1 <= 0) {
				for (m = nkb; m < il1 + 1; m++) {
					ni = (i - m) * neq + m;
					nj = (j - m) * neq + m;
					sum = sum - bk.v[ni - 1] * bk.v[nj - 1] / bk.v[m - 1];
				}
			}
			bk.v[ij - 1] = sum;
		}
	}
}

//************************************************************************
// Reduced Coeff Matrix and load vector
// Post : load vector contain solution
//************************************************************************
void ME_Object::bacsub(Vec<double>& bk, Vec<double>& Loads) {
	double sum;
	int nkb, k, i, jn, jj, i1, n, iw;
	n = Loads.n;
	iw = bk.n / n - 1;
	*Loads.nn(1) = *Loads.nn(1) / (*bk.nn(1));
	for (i = 2; i < n + 1; i++) {
		sum = *Loads.nn(i);
		i1 = i - 1;
		nkb = i - iw;
		if (nkb <= 0) {
			nkb = 1;
		}
		for (k = nkb; k < i1 + 1; k++) {
			jn = (i - k) * n + k;
			sum = sum - *bk.nn(jn) * *Loads.nn(k);
		}
		*Loads.nn(i) = sum / (*bk.nn(i));
	}
	for (jj = 2; jj < n + 1; jj++) {
		i = n - jj + 1;
		sum = 0;
		i1 = i + 1;
		nkb = i + iw;
		if ((nkb - n) > 0) {
			nkb = n;
		}
		for (k = i1; k < nkb + 1; k++) {
			jn = (k - i) * n + i;
			sum = sum + *bk.nn(jn) * *Loads.nn(k);
		}
		*Loads.nn(i) = *Loads.nn(i) - sum / (*bk.nn(i));
	}
}

double ME_Object::GetDisp(int iDof, Vec<int>& Steer, Vec<double>& Disp) {
	double dret = 0;
	dret = *Disp.nn(iDof);
	return (dret);
}

Mat ME_Object::GetNodalDispVec(E_Object* pE, Vec<int>& Steer, Vec<double>& Disp) {
	int i, j;
	int iDof, iNoNds, iPos;
	iDof = pE->noDof();
	iNoNds = pE->iNoNodes;
	Mat DispG(iDof * iNoNds, 1);
	DispG.MakeZero();
	iPos = 1;
	for (i = 0; i < iNoNds; i++) {
		for (j = 0; j < iDof; j++) {
			Node* pN = (Node*) pE->GetNode(i);
			if (pN->dof[j] > 0) {
				*DispG.mn(iPos, 1) = GetDisp(pN->dof[j], Steer, Disp);
			}
			iPos++;
		}
	}
	return (DispG);
}

void ME_Object::Displacements(int iLC, CString sSol, CString sStep, Vec<int>& Steer, Vec<double>& Disp) {
	ResSet* Res = new ResSet();

	Res->ACODE = 11;
	Res->TCODE = 1;
	Res->TYPE = 0;
	Res->LC = iLC;
	Res->sSubTitle = sStep;
	Res->sTitle = sSol;
	Res->WID = 8;
	Res->sName = "DISPLACEMENT";
	Res->iNoV = 6;
	Res->lab[0] = "TX";
	Res->lab[1] = "TY";
	Res->lab[2] = "TZ";
	Res->lab[3] = "RX";
	Res->lab[4] = "RY";
	Res->lab[5] = "RZ";

	int i;
	// FILE* pFile;
	// pFile = fopen("DispRes.txt","w");
	// fprintf(pFile,"%s\n","DISPLACEMENTS");
	float X, Y, Z;

	for (i = 0; i < iNdNo; i++) {
		Res6* pRes = new Res6;
		pRes->ID = pNodes[i]->iLabel;
		pRes->v[0] = 0;
		pRes->v[1] = 0;
		pRes->v[2] = 0;
		pRes->v[3] = 0;
		pRes->v[4] = 0;
		pRes->v[5] = 0;

		X = 0;
		Y = 0;
		Z = 0;
		if (pNodes[i]->dof[0] > 0) {
			X = (float) GetDisp(pNodes[i]->dof[0], Steer, Disp);
			pRes->v[0] = X;
		}
		if (pNodes[i]->dof[1] > 0) {
			Y = (float) GetDisp(pNodes[i]->dof[1], Steer, Disp);
			pRes->v[1] = Y;
		}
		if (pNodes[i]->dof[2] > 0) {
			Z = (float) GetDisp(pNodes[i]->dof[2], Steer, Disp);
			pRes->v[2] = Z;
		}

		if (pNodes[i]->dof[3] > 0) {
			Z = (float) GetDisp(pNodes[i]->dof[3], Steer, Disp);
			pRes->v[3] = Z;
		}
		if (pNodes[i]->dof[4] > 0) {
			Z = (float) GetDisp(pNodes[i]->dof[4], Steer, Disp);
			pRes->v[4] = Z;
		}
		if (pNodes[i]->dof[5] > 0) {
			Z = (float) GetDisp(pNodes[i]->dof[5], Steer, Disp);
			pRes->v[5] = Z;
		}
		Res->Add(pRes);
		// fprintf_s(pFile,"%s%6i%s%6.4f%s%6.4f%s%6.4f\n","Node ",pNodes[i]->iLabel," X: ",X," Y: ",Y," Z: ",Z);
	}
	// fclose(pFile);
	if (Res->iCnt > 0) {
		ResultsSets[iNoRes] = Res;
		//**********Define the Vector********************
		ResDef* pVT = new ResDef();
		pVT->sResType = "DISP TRANS VEC";
		pVT->iResType = 1; // Vector Translation
		pVT->iLoc = 0; // Nodal
		pVT->iComponents[0] = 0;
		pVT->iComponents[1] = 1;
		pVT->iComponents[2] = 2;
		pVT->iComponents[3] = -1;
		pVT->iCompNo = 4;
		pVT->GenDefualtHeaders();
		ResDef* pVR = new ResDef();
		pVR->sResType = "DISP ROTA VEC";
		pVR->iResType = 1; // Vector Rotation
		pVR->iLoc = 0; // Nodal
		pVR->iComponents[0] = 3;
		pVR->iComponents[1] = 4;
		pVR->iComponents[2] = 5;
		pVR->iComponents[3] = -1;
		pVR->iCompNo = 4;
		pVT->GenDefualtHeaders();
		ResultsSets[iNoRes]->AddResDef(pVT);
		ResultsSets[iNoRes]->AddResDef(pVR);
		//***********************************************
		iNoRes++;
	} else {
		delete (Res);
	}
}

//***************************************************************
//  Radient Heat Loss Calculation
//***************************************************************
void ME_Object::RadiationLoss(Vec<int>& Steer, Vec<double>& T, Vec<double>& Q) {
	int i;
	E_Object* pE;
	E_Object4* pE4;
	double dA = 1;
	double dSBC = 5.67E-8;

	// For all shell elements calculate their radient heat loss
	for (i = 0; i < iElNo; i++) {
		pE = pElems[i];
		if (pE->iType == 94) {
			pE4 = (E_Object4*) pE;
		}
	}
}

void ME_Object::Temperatures(int iLC, CString sSol, CString sStep, Vec<int>& Steer, Vec<double>& Disp) {
	ResSet* Res = new ResSet();
	Res->ACODE = 11;
	Res->TCODE = 1;
	Res->TYPE = 0;
	Res->LC = iLC;
	Res->WID = 1;

	Res->sName = "TEMPERATURES";
	Res->sTitle = sSol;
	Res->sSubTitle = sStep;
	Res->iNoV = 1;
	Res->lab[0] = "T";
	int i;
	float T;
	for (i = 0; i < iNdNo; i++) {
		Res1* pRes = new Res1;
		pRes->ID = pNodes[i]->iLabel;
		pRes->v[0] = 0;
		T = 0;
		;
		if (pNodes[i]->dof[0] > 0) {
			T = (float) GetDisp(pNodes[i]->dof[0], Steer, Disp);
			pRes->v[0] = T;
		}
		Res->Add(pRes);
	}
	if (Res->iCnt > 0) {
		ResultsSets[iNoRes] = Res;
		iNoRes++;
	} else {
		delete (Res);
	}
}

void ME_Object::TempBCSet(int iLC, CString sSol, CString sStep, Vec<int>& Steer, Vec<double>& Disp) {
	int i;
	int iTS;
	int iTSetID;
	Node* pN;
	double dTemp;
	iTSetID = NestTSetID();
	iTS = CreateTSET(iTSetID, sStep);
	cLinkedListT* pTS = GetTSET(iTSetID);
	for (i = 0; i < iNdNo; i++) {
		pN = pNodes[i];
		dTemp = *Disp.nn(pN->dof[0]);
		Temperature* pT = new Temperature();
		pT->Create(pN, pTS, dTemp, pTS->iLabel);
		pTS->Add(pT);
	}
}

void ME_Object::TranslationalSpringForces(int iLC, CString sSol, CString sStep, PropTable* PropsT, MatTable* MatT,
                                          Vec<int>& Steer, Vec<double>& Disp) {
	BOOL bErr;
	int i, j, k, iNoNodes;
	double dof1;
	ResSet* ResS = new ResSet();
	ResS->ACODE = 11;
	ResS->TCODE = 4;
	ResS->TYPE = 0;
	ResS->LC = iLC;
	ResS->sSubTitle = sStep;
	ResS->sTitle = sSol;
	ResS->WID = 3;

	ResS->sName = "SPRING FORCES/MOMENTS";
	ResS->iNoV = 3;
	ResS->lab[0] = "FX";
	ResS->lab[1] = "FY";
	ResS->lab[2] = "FZ";

	Mat disp;
	Mat KM;
	Mat Res;
	C3dVector TRA;
	C3dVector RRA;
	C3dVector TRB;
	C3dVector RRB;
	CoordSys* pCSys = NULL;
	C3dMatrix TMAT;
	int aa = 0;
	for (i = 0; i < iElNo; i++) {
		iNoNodes = 0;
		if ((pElems[i]->iType == 136) || (pElems[i]->iType == 137)) {
			E_Object2* pE2 = (E_Object2*) pElems[i];
			pCSys = this->GetSys(pE2->iCSYS);
			if (pCSys != NULL)
				TMAT = pE2->GetSpringSys(pCSys);
			else
				TMAT.MakeUnit();
			// TMAT=pElems[i]->GetElSys();
			iNoNodes = 2;
			disp.Create(6, 1);
			for (j = 0; j < iNoNodes; j++) {
				for (k = 0; k < 3; k++) {
					dof1 = 0;
					Node* pN = (Node*) pElems[i]->GetNode(j);
					if (pN->dof[k] > 0) {
						dof1 = GetDisp(pN->dof[k], Steer, Disp);
					}
					*disp.mn(3 * j + (k + 1), 1) = dof1;
				}
			}
			if (pElems[i]->iLabel == 84)
				aa++;
			KM = pElems[i]->GetStiffMat(PropsT, MatT, TRUE, bErr);
			// KM.diag();
			// Res=KM*disp;
			C3dVector vFG;
			C3dVector vLG;

			vFG.x = *disp.mn(4, 1) - *disp.mn(1, 1);
			vFG.y = *disp.mn(5, 1) - *disp.mn(2, 1);
			vFG.z = *disp.mn(6, 1) - *disp.mn(3, 1);
			double dMag;
			// if (pElems[i]->iLabel==196)
			dMag = vFG.Mag();
			// Need to transform to local
			Res3* pRes = new Res3;
			pRes->ID = pElems[i]->iLabel;
			// TRANSFORM WHEN ADDED
			TMAT.Transpose();

			vLG.x = (float) vFG.x * *KM.mn(1, 1) + vFG.y * *KM.mn(1, 2) + vFG.z * *KM.mn(1, 3);
			vLG.y = (float) vFG.x * *KM.mn(2, 1) + vFG.y * *KM.mn(2, 2) + vFG.z * *KM.mn(2, 3);
			vLG.z = (float) vFG.x * *KM.mn(3, 1) + vFG.y * *KM.mn(3, 2) + vFG.z * *KM.mn(3, 3);
			vLG = TMAT.Mult(vLG);
			pRes->v[0] = (float) vLG.x;
			pRes->v[1] = (float) vLG.y;
			pRes->v[2] = (float) vLG.z;
			dMag = vFG.Mag();
			ResS->Add(pRes);
			KM.clear();
			Res.clear();
			disp.clear();
		}
	}
	if (ResS->iCnt > 0) {
		ResultsSets[iNoRes] = ResS;
		iNoRes++;
	} else {
		delete (ResS);
	}
}

void ME_Object::ForcesBUSH(int iLC, CString sSol, CString sStep, PropTable* PropsT, MatTable* MatT, Vec<int>& Steer,
                           Vec<double>& Disp) {
	BOOL bErr;
	int i, j, k, iNoNodes;
	double dof1;
	Mat disp;
	Mat KM;
	Mat Res;
	Mat t;
	Mat F;
	Mat FG;
	C3dMatrix r;
	CoordSys* pCSYS = nullptr;
	ResSet* ResS = new ResSet();
	ResS->ACODE = 11;
	ResS->TCODE = 4;
	ResS->TYPE = 0;
	ResS->LC = iLC;
	ResS->sSubTitle = sStep;
	ResS->sTitle = sSol;
	ResS->WID = 6;

	ResS->sName = "BUSH FORCES/MOMENTS";
	ResS->iNoV = 6;
	ResS->lab[0] = "FX";
	ResS->lab[1] = "FY";
	ResS->lab[2] = "FZ";
	ResS->lab[3] = "MX";
	ResS->lab[4] = "MY";
	ResS->lab[5] = "MZ";

	int aa = 0;
	for (i = 0; i < iElNo; i++) {
		iNoNodes = 0;
		if (pElems[i]->iType == 138) {
			E_Object2BUSH* pE2 = (E_Object2BUSH*) pElems[i];
			iNoNodes = 2;
			disp.Create(12, 1);
			for (j = 0; j < iNoNodes; j++) {
				for (k = 0; k < 6; k++) {
					dof1 = 0;
					Node* pN = (Node*) pElems[i]->GetNode(j);
					if (pN->dof[k] > 0) {
						dof1 = GetDisp(pN->dof[k], Steer, Disp);
					}
					*disp.mn(6 * j + (k + 1), 1) = dof1;
				}
			}

			KM = pElems[i]->GetStiffMat(PropsT, MatT, TRUE, bErr);
			FG = KM * disp;
			// TRANSFORM TO LOCAL
			int iCS = pE2->iCSYS;
			if (iCS != -1) {
				pCSYS = GetSys(iCS);
				if (pCSYS != NULL) {
					r = pE2->GetSpringSys(pCSYS);
					t = pE2->KEToKGTransform2(r);
					t.Transpose();
					F = t * FG;
				} else {
					bErr = TRUE;
				}
			}

			Res6* pRes = new Res6;
			pRes->ID = pElems[i]->iLabel;
			pRes->v[0] = (float) *F.mn(7, 1);
			pRes->v[1] = (float) *F.mn(8, 1);
			pRes->v[2] = (float) *F.mn(9, 1);
			pRes->v[3] = (float) *F.mn(10, 1);
			pRes->v[4] = (float) *F.mn(11, 1);
			pRes->v[5] = (float) *F.mn(12, 1);

			ResS->Add(pRes);
			KM.clear();
			Res.clear();
			disp.clear();
			t.clear();
			F.clear();
		}
	}
	if (ResS->iCnt > 0) {
		ResultsSets[iNoRes] = ResS;
		iNoRes++;
	} else {
		delete (ResS);
	}
}

void ME_Object::ForcesRod(int iLC, CString sSol, CString sStep, PropTable* PropsT, MatTable* MatT, Vec<int>& Steer,
                          Vec<double>& Disp) {
	BOOL bOpt, bErr;
	bOpt = FALSE;
	bErr = FALSE;
	int i, j, k, iNoNodes;
	double dof1;
	Mat disp;
	Mat KM;
	Mat Res;
	C3dMatrix TMAT;
	C3dVector TRA;
	C3dVector RRA;
	C3dVector TRB;
	C3dVector RRB;
	double dL = 0;

	ResSet* ResS = new ResSet();
	ResS->ACODE = 11;
	ResS->TCODE = 4;
	ResS->TYPE = 0;
	ResS->LC = iLC;
	ResS->sSubTitle = sStep;
	ResS->sTitle = sSol;
	ResS->WID = 2;
	ResS->sName = "ROD FORCES";
	ResS->iNoV = 2;
	ResS->lab[0] = "AF (axial force)";
	ResS->lab[1] = "TRQ (torque)";

	for (i = 0; i < iElNo; i++) {
		iNoNodes = 0;
		if (pElems[i]->iType == 11) {
			E_Object2R* pE = (E_Object2R*) pElems[i];
			TMAT = pElems[i]->GetElSys();
			iNoNodes = 2;
			disp.Create(12, 1);
			for (j = 0; j < iNoNodes; j++) {
				for (k = 0; k < 6; k++) {
					dof1 = 0;
					Node* pN = (Node*) pElems[i]->GetNode(j);
					if (pN->dof[k] > 0) {
						dof1 = GetDisp(pN->dof[k], Steer, Disp);
					}
					*disp.mn(6 * j + (k + 1), 1) = dof1;
				}
			}

			KM = pElems[i]->GetStiffMat(PropsT, MatT, TRUE, bErr);
			Res = KM * disp;

			TRA.x = *Res.mn(1, 1);
			TRA.y = *Res.mn(2, 1);
			TRA.z = *Res.mn(3, 1);
			RRA.x = *Res.mn(4, 1);
			RRA.y = *Res.mn(5, 1);
			RRA.z = *Res.mn(6, 1);

			TRB.x = *Res.mn(7, 1);
			TRB.y = *Res.mn(8, 1);
			TRB.z = *Res.mn(9, 1);
			RRB.x = *Res.mn(10, 1);
			RRB.y = *Res.mn(11, 1);
			RRB.z = *Res.mn(12, 1);
			// Transform global forces to element local
			TRA = TMAT * TRA;
			RRA = TMAT * RRA;
			TRB = TMAT * TRB;
			RRB = TMAT * RRB;

			KM.clear();
			Res.clear();
			disp.clear();
			//****************************************
			Res2* pRes = new Res2;
			pRes->ID = pElems[i]->iLabel;
			pRes->v[0] = (float) (TRB.x - pElems[i]->dTemp); // Fx(axial force for BAR or ROD)
			pRes->v[1] = (float) RRB.x; // T(torque for BAR or ROD)
			ResS->Add(pRes);
		}
	}
	if (ResS->iCnt > 0) {
		ResultsSets[iNoRes] = ResS;
		iNoRes++;
	} else {
		delete (ResS);
	}
}

void ME_Object::ForcesBeam(int iLC, CString sSol, CString sStep, PropTable* PropsT, MatTable* MatT, Vec<int>& Steer,
                           Vec<double>& Disp) {
	BOOL bOpt, bErr;
	bOpt = FALSE;
	bErr = FALSE;
	C3dVector vOff1, vOff2;
	vOff1.Set(0, 0, 0);
	vOff2.Set(0, 0, 0);
	int i, j, k, iNoNodes;
	double dof1;
	ResSet* ResS = new ResSet();
	ResS->ACODE = 11;
	ResS->TCODE = 4;
	ResS->TYPE = 0;
	ResS->LC = iLC;
	ResS->sSubTitle = sStep;
	ResS->sTitle = sSol;
	ResS->WID = 8;

	ResS->sName = "BEAM GRID PT REACTIONS";
	ResS->iNoV = 8;
	ResS->lab[0] = "BM1A (bending moment, plane 1, end a)";
	ResS->lab[1] = "BM2A (bending moment, plane 2, end a)";
	ResS->lab[2] = "BM1B (bending moment, plane 1, end b)";
	ResS->lab[3] = "BM2B (bending moment, plane 2, end b)";
	ResS->lab[4] = "TS1 (plane 1 shear)";
	ResS->lab[5] = "TS2 (plane 2 shear)";
	ResS->lab[6] = "AF (axial force)";
	ResS->lab[7] = "TRQ (torque)";
	// ResS->lab[8]="END B FZ";
	// ResS->lab[9]="END B BX";
	// ResS->lab[10]="END B BY";
	// ResS->lab[11]="END B BZ";

	Mat disp;
	Mat KM;
	Mat Res;
	C3dMatrix TMAT;
	C3dVector TRA;
	C3dVector RRA;
	C3dVector TRB;
	C3dVector RRB;
	double dL = 0;
	for (i = 0; i < iElNo; i++) {
		iNoNodes = 0;
		if (pElems[i]->iType == 21) {
			E_Object2R* pE = (E_Object2R*) pElems[i];
			dL = pE->getLen();
			vOff1 = pE->OffA;
			vOff2 = pE->OffB;
			TMAT = pElems[i]->GetElSys();
			iNoNodes = 2;
			disp.Create(12, 1);
			for (j = 0; j < iNoNodes; j++) {
				for (k = 0; k < 6; k++) {
					dof1 = 0;
					Node* pN = (Node*) pElems[i]->GetNode(j);
					if (pN->dof[k] > 0) {
						dof1 = GetDisp(pN->dof[k], Steer, Disp);
					}
					*disp.mn(6 * j + (k + 1), 1) = dof1;
				}
			}

			// account for offset in global disp
			// move disp from grid to offset node
			if (pElems[i]->HasOffsets())
				pElems[i]->DispOffsets(PropsT, disp);
			//*disp.mn(1, 1) += +vOff1.z * *disp.mn(5, 1) - vOff1.y * *disp.mn(6, 1);
			//*disp.mn(2, 1) += -vOff1.z * *disp.mn(4, 1) + vOff1.x * *disp.mn(6, 1);
			//*disp.mn(3, 1) += +vOff1.y * *disp.mn(4, 1) - vOff1.x * *disp.mn(5, 1);

			//*disp.mn(7, 1) += +vOff2.z * *disp.mn(11, 1) - vOff2.y * *disp.mn(12, 1);
			//*disp.mn(8, 1) += -vOff2.z * *disp.mn(10, 1) + vOff2.x * *disp.mn(12, 1);
			//*disp.mn(9, 1) += +vOff2.y * *disp.mn(10, 1) - vOff2.x * *disp.mn(11, 1);
			//******************************************************
			KM = pElems[i]->GetStiffMat(PropsT, MatT, TRUE, bErr);
			Res = KM * disp;

			TRA.x = *Res.mn(1, 1);
			TRA.y = *Res.mn(2, 1);
			TRA.z = *Res.mn(3, 1);
			RRA.x = *Res.mn(4, 1);
			RRA.y = *Res.mn(5, 1);
			RRA.z = *Res.mn(6, 1);

			TRB.x = *Res.mn(7, 1);
			TRB.y = *Res.mn(8, 1);
			TRB.z = *Res.mn(9, 1);
			RRB.x = *Res.mn(10, 1);
			RRB.y = *Res.mn(11, 1);
			RRB.z = *Res.mn(12, 1);
			// Transform global forces to element local
			TRA = TMAT * TRA;
			RRA = TMAT * RRA;
			TRB = TMAT * TRB;
			RRB = TMAT * RRB;

			KM.clear();
			Res.clear();
			disp.clear();
			//****************************************
			Res8* pRes = new Res8;
			pRes->ID = pElems[i]->iLabel;
			pRes->v[0] = (float) -RRA.z; // M1a(bending moment, plane 1, end a for BAR)
			pRes->v[1] = (float) RRA.y; // M2a(bending moment, plane 1, end b for BAR)
			pRes->v[2] = (float) -RRA.z + dL * TRA.y; // M1a(bending moment, plane 2, end a for BAR)
			pRes->v[3] = (float) RRA.y + dL * TRA.z; // M2b(bending moment, plane 2, end b for BAR)
			pRes->v[4] = (float) TRB.y; // V1(plane 1 shear for BAR)
			pRes->v[5] = (float) TRB.z; // V2(plane 2 shear for BAR)
			pRes->v[6] = (float) (TRB.x - pElems[i]->dTemp); // Fx(axial force for BAR or ROD)
			pRes->v[7] = (float) RRB.x; // T(torque for BAR or ROD)

			ResS->Add(pRes);
		}
	}
	if (ResS->iCnt > 0) {
		ResultsSets[iNoRes] = ResS;
		iNoRes++;
	} else {
		delete (ResS);
	}
}

ResSet* ME_Object::Create2dStrainResSet(CString sTitle, int iLC, CString sStep, CString sSol) {
	ResSet* ResStrn = new ResSet();
	ResStrn->ACODE = 11;
	ResStrn->TCODE = 4;
	ResStrn->TYPE = 0;
	ResStrn->LC = iLC;
	ResStrn->WID = 8;
	ResStrn->sName = "2d EL STRAINS";
	ResStrn->iNoV = 10;
	ResStrn->lab[0] = "Strain X";
	ResStrn->lab[1] = "Strain Y";
	ResStrn->lab[2] = "Strain XY";
	ResStrn->lab[3] = "Prin 1";
	ResStrn->lab[4] = "Prin 2";
	ResStrn->lab[5] = "Strain Curv X";
	ResStrn->lab[6] = "Strain Curv Y";
	ResStrn->lab[7] = "Strain Curv XY";
	ResStrn->lab[8] = "Prin 1";
	ResStrn->lab[9] = "Prin 2";
	ResDef* pVT;
	pVT = new ResDef();
	pVT->sResType = "2d STRAIN (Mid)";
	pVT->iResType = 3; // 2d Tenspr
	pVT->iLoc = 1; // Element Centroid(cys global)
	pVT->iComponents[0] = 0;
	pVT->iComponents[1] = 1;
	pVT->iComponents[2] = 2;
	pVT->iComponents[3] = 3;
	pVT->iComponents[4] = 4;
	pVT->iCompNo = 5;
	pVT->GenDefualtHeaders();
	ResStrn->AddResDef(pVT);

	pVT = new ResDef();
	pVT->sResType = "2d CURVATURE (Mid)";
	pVT->iResType = 3; // 2d Tenspr
	pVT->iLoc = 1; // Element Centroid(cys global)
	pVT->iComponents[0] = 5;
	pVT->iComponents[1] = 6;
	pVT->iComponents[2] = 7;
	pVT->iComponents[3] = 8;
	pVT->iComponents[4] = 9;
	pVT->iCompNo = 5;
	pVT->GenDefualtHeaders();
	ResStrn->AddResDef(pVT);
	return (ResStrn);
}

ResSet* ME_Object::Create2dForceResSet(CString sTitle, int iLC, CString sStep, CString sSol) {
	ResSet* ResS = new ResSet();
	ResS->ACODE = 11;
	ResS->TCODE = 4;
	ResS->TYPE = 0;
	ResS->LC = iLC;
	ResS->sSubTitle = sStep;
	ResS->sTitle = sSol;
	ResS->WID = 8;

	ResS->sName = sTitle;
	ResS->iNoV = 8;
	ResS->lab[0] = "Nxx: Normal x Force";
	ResS->lab[1] = "Nyy: Normal y Force";
	ResS->lab[2] = "Nxy: Shear xy Force";
	ResS->lab[3] = "Mxx: Moment x Plane";
	ResS->lab[4] = "Myy: Moment y Plane";
	ResS->lab[5] = "Mxy: Twist Mom xy";
	ResS->lab[6] = "Qx : Transv Shear x";
	ResS->lab[7] = "Qy : Transv Shear y";

	ResSet* ResSt = new ResSet();
	ResDef* pVT;
	pVT = new ResDef();
	pVT->sResType = sTitle + "(Flux Mid)";
	pVT->iResType = 3; // 2d Tensor
	pVT->iLoc = 1; // Element Centroid(cys global)
	pVT->iComponents[0] = 0;
	pVT->iComponents[1] = 1;
	pVT->iComponents[2] = 2;

	pVT->iCompNo = 3;
	pVT->GenDefualtHeaders();
	ResS->AddResDef(pVT);
	return (ResS);
}

ResSet* ME_Object::Create2dStressResSet(CString sTitle, int iLC, CString sStep, CString sSol) {
	ResSet* ResS = new ResSet();
	ResS->ACODE = 11;
	ResS->TCODE = 4;
	ResS->TYPE = 0;
	ResS->LC = iLC;
	ResS->sSubTitle = sStep;
	ResS->sTitle = sSol;
	ResS->WID = 8;

	ResS->sName = sTitle;
	ResS->iNoV = 21;
	ResS->lab[0] = "Stress X (Mid)";
	ResS->lab[1] = "Stress Y (Mid)";
	ResS->lab[2] = "Stress XY (Mid)";
	ResS->lab[3] = "Max Prin (Mid)";
	ResS->lab[4] = "Min Prin (Mid)";
	ResS->lab[5] = "Max Shear (Mid)";
	ResS->lab[6] = "Von Mises (Mid)";

	ResS->lab[7] = "Stress X (Z1 Bot)";
	ResS->lab[8] = "Stress Y (Z1 Bot)";
	ResS->lab[9] = "Stress XY (Z1 Bot)";
	ResS->lab[10] = "Max Prin (Z1 Bot)";
	ResS->lab[11] = "Min Prin (Z1 Bot)";
	ResS->lab[12] = "Max Shear (Z1 Bot)";
	ResS->lab[13] = "Von Mises (Z1 Bot)";

	ResS->lab[14] = "Stress X (Z2 Top)";
	ResS->lab[15] = "Stress Y (Z2 Top)";
	ResS->lab[16] = "Stress XY (Z2 Top)";
	ResS->lab[17] = "Max Prin (Z2 Top)";
	ResS->lab[18] = "Min Prin (Z2 Top)";
	ResS->lab[19] = "Max Shear (Z2 Top)";
	ResS->lab[20] = "Von Mises (Z2 Top)";
	// ResSet* ResSt = new ResSet();
	ResDef* pVT;
	pVT = new ResDef();
	pVT->sResType = sTitle + "(Mid)";
	pVT->iResType = 3; // 2d Tenspr
	pVT->iLoc = 1; // Element Centroid(cys global)
	pVT->iComponents[0] = 0;
	pVT->iComponents[1] = 1;
	pVT->iComponents[2] = 2;
	pVT->iComponents[3] = 3;
	pVT->iComponents[4] = 4;
	pVT->iCompNo = 5;
	pVT->GenDefualtHeaders();
	ResS->AddResDef(pVT);

	pVT = new ResDef();
	pVT->sResType = sTitle + "(Z1 Bot)";
	pVT->iResType = 3; // 2d Tenspr
	pVT->iLoc = 1; // Element Centroid(cys global)
	pVT->iComponents[0] = 7;
	pVT->iComponents[1] = 8;
	pVT->iComponents[2] = 9;
	pVT->iComponents[3] = 10;
	pVT->iComponents[4] = 11;
	pVT->iCompNo = 5;
	pVT->GenDefualtHeaders();
	ResS->AddResDef(pVT);

	pVT = new ResDef();
	pVT->sResType = sTitle + "(Z2 Top)";
	pVT->iResType = 3; // 2d Tenspr
	pVT->iLoc = 1; // Element Centroid(cys global)
	pVT->iComponents[0] = 14;
	pVT->iComponents[1] = 15;
	pVT->iComponents[2] = 16;
	pVT->iComponents[3] = 17;
	pVT->iComponents[4] = 18;
	pVT->iCompNo = 5;
	pVT->GenDefualtHeaders();
	ResS->AddResDef(pVT);
	return (ResS);
}

void ME_Object::Add2dStressRes(ResSet* pSSet, int ID, Mat Res, Mat ResZ1, Mat ResZ2) {
	double SX, SY, SXY;
	double cS, Mag, p1, p2;
	SX = *Res.mn(1, 1);
	SY = *Res.mn(2, 1);
	SXY = *Res.mn(3, 1);
	cS = (SX + SY) * 0.5;
	Mag = pow((SX - cS) * (SX - cS) + (SXY * SXY), 0.5);
	p2 = cS + Mag;
	p1 = cS - Mag;
	Res21* pRes = new Res21;
	pRes->ID = ID;
	pRes->v[0] = (float) SX;
	pRes->v[1] = (float) SY;
	pRes->v[2] = (float) SXY;
	pRes->v[3] = (float) (cS + Mag);
	pRes->v[4] = (float) (cS - Mag);
	pRes->v[5] = (float) Mag;
	pRes->v[6] = (float) pow(p1 * p1 - p1 * p2 + p2 * p2, 0.5);

	SX = *ResZ1.mn(1, 1);
	SY = *ResZ1.mn(2, 1);
	SXY = *ResZ1.mn(3, 1);
	cS = (SX + SY) * 0.5;
	Mag = pow((SX - cS) * (SX - cS) + (SXY * SXY), 0.5);
	p2 = cS + Mag;
	p1 = cS - Mag;
	pRes->ID = ID;
	pRes->v[7] = (float) SX;
	pRes->v[8] = (float) SY;
	pRes->v[9] = (float) SXY;
	pRes->v[10] = (float) (cS + Mag);
	pRes->v[11] = (float) (cS - Mag);
	pRes->v[12] = (float) Mag;
	pRes->v[13] = (float) pow(p1 * p1 - p1 * p2 + p2 * p2, 0.5);

	SX = *ResZ2.mn(1, 1);
	SY = *ResZ2.mn(2, 1);
	SXY = *ResZ2.mn(3, 1);
	cS = (SX + SY) * 0.5;
	Mag = pow((SX - cS) * (SX - cS) + (SXY * SXY), 0.5);
	p2 = cS + Mag;
	p1 = cS - Mag;
	pRes->ID = ID;
	pRes->v[14] = (float) SX;
	pRes->v[15] = (float) SY;
	pRes->v[16] = (float) SXY;
	pRes->v[17] = (float) (cS + Mag);
	pRes->v[18] = (float) (cS - Mag);
	pRes->v[19] = (float) Mag;
	pRes->v[20] = (float) pow(p1 * p1 - p1 * p2 + p2 * p2, 0.5);
	pSSet->Add(pRes);
}

void ME_Object::Stresses2d(int iLC, CString sSol, CString sStep, PropTable* PropsT, MatTable* MatT, Vec<int>& Steer,
                           Vec<double>& Disp) {
	// ALL THESE MATS NEED TO BE CLEARED!!!
	Mat dee; // stress strain
	Mat bee; // Strain displacement
	int nip = 1; // Centroid stresses only
	Mat coord; // Nodal Coordinates
	Mat deriv; // shape function derivatives
	Mat fun; // shape function
	Mat Points; // sample points
	Mat deriv2;
	Mat jac;
	Mat db;
	Mat mStrn;
	Mat Res;
	Mat ResZ1;
	Mat ResZ2;
	Mat disp;
	Mat disp3d;
	Mat disp3dR;
	Mat MAT_TS;
	double dSHRatio = 1;
	C3dVector v;
	C3dVector R;
	int n;
	double det;
	double dof1;
	double dofR;
	double dE = 210e9;
	double dv = 0.29;
	double dthk = 0.001;
	double cS;
	double Mag;
	int MID = -1;
	int i;
	int j;
	int k;
	double SX, SY, SXY, RX, RY, RXY;
	ResSet* ResS; // Mid Stress Results Set
	ResSet* ResStrn; // Strain (dir & cur) Results Set
	ResS = Create2dStressResSet("2d EL STRESSES", iLC, sStep, sSol);
	ResStrn = Create2dStrainResSet("2d EL STRAINS (Mid)", iLC, sStep, sSol);

	SX = 0;
	SY = 0, SXY = 0;
	RX = 0;
	RY = 0;
	RXY = 0;
	int iNoNodes = 0;
	for (i = 0; i < iElNo; i++) {
		iNoNodes = 0;
		if (pElems[i]->iType == 91) {
			iNoNodes = 3;
			disp.Create(6, 1);
			disp3d.Create(3, 3);
			disp3dR.Create(3, 3);
		} else if (pElems[i]->iType == 94) {
			iNoNodes = 4;
			disp.Create(8, 1);
			disp3d.Create(3, 4);
			disp3dR.Create(3, 4);
		}
		Property* pS = PropsT->GetItem(pElems[i]->PID);
		if (pS != NULL) {
			MID = pS->GetDefMatID();
		}
		Material* pM = MatT->GetItem(MID);

		// Get Shell thickness

		if (((pElems[i]->iType == 91) || (pElems[i]->iType == 94)) && (pS != NULL)) {
			PSHELL* pSh = (PSHELL*) pS;
			dthk = pSh->dT;
			dSHRatio = pSh->dTST;
		}

		if ((pM != NULL) && (pM->iType = 1)) {
			MAT1* pIsen = (MAT1*) pM;
			dE = pIsen->dE;
			dv = pIsen->dNU;
			MAT_TS = pM->DeeSH();
		}
		//************START OF CALCULATION************
		if (iNoNodes > 0) {
			for (j = 0; j < iNoNodes; j++) {
				// Get the displacements
				for (k = 0; k < 3; k++) {
					dof1 = 0;
					dofR = 0;
					Node* pN = (Node*) pElems[i]->GetNode(j);
					if (pN->dof[k] > 0) {
						dof1 = GetDisp(pN->dof[k], Steer, Disp);
					}
					*disp3d.mn(k + 1, j + 1) = dof1; // Nodal translations
					if (pN->dof[k + 3] > 0) {
						dofR = GetDisp(pN->dof[k + 3], Steer, Disp);
					}
					*disp3dR.mn(k + 1, j + 1) = dofR; // Nodal Rotations
				}
			}

			// WILL NEED TO MODIFY DICPLACEMENT TO ACCOUNT FOR OFFSET
			//  BE DONE
			C3dMatrix M = pElems[i]->GetElSys();
			// TRANSFORM GLOBAL DISPS TO LOCAL ELEMENT
			int iNoNds = pElems[i]->iNoNodes;
			Mat DispTS(iNoNds * 6, 1);
			for (j = 0; j < iNoNodes; j++) {
				// Translations
				v.x = *disp3d.mn(1, j + 1);
				v.y = *disp3d.mn(2, j + 1);
				v.z = *disp3d.mn(3, j + 1);
				v = M.Mult(v);
				n = 1 + j * 2;
				*disp.mn(n, 1) = v.x; // Displecement vector for membarne
				*disp.mn(n + 1, 1) = v.y;
				// Rotations					//Diplacements for bending and TShear
				R.x = *disp3dR.mn(1, j + 1); // Theta global X
				R.y = *disp3dR.mn(2, j + 1); // Theta global Y
				R.z = *disp3dR.mn(3, j + 1); // Theta global Z
				R = M.Mult(R);
				// update the plate bending / shear disp vector
				*disp3dR.mn(1, j + 1) = v.z; // Z displacement
				*disp3dR.mn(2, j + 1) = R.x; // theta X
				*disp3dR.mn(3, j + 1) = R.y; // theta Y (disregard theta Z)
				// full TS local element disp vector
				*DispTS.mn(j * 6 + 1, 1) = v.x;
				*DispTS.mn(j * 6 + 2, 1) = v.y;
				*DispTS.mn(j * 6 + 3, 1) = v.z;
				*DispTS.mn(j * 6 + 4, 1) = R.x;
				*DispTS.mn(j * 6 + 5, 1) = R.y;
				*DispTS.mn(j * 6 + 6, 1) = R.z;
			}
			disp3d.clear();
			dee = pElems[i]->DeeMat(dE, dv, 3);
			coord = pElems[i]->getCoords3d(); // Coords in element CSYS this case actually 2d
			Points = pElems[i]->Sample(nip); // Only 1 integration point at centre of element
			det = 0;
			fun = pElems[i]->ShapeFun(Points, 1); // 1x4 shape fuction values at el centre
			deriv = pElems[i]->ShapeDer(Points, 1); // 2x4 shape fuction derivatives
			jac = deriv * coord;
			jac = jac.InvertJac(det);
			deriv2 = jac * deriv;

			// Bending Strain Components curvatures k11,k22,k12
			// 1 pt at el centre
			C3dMatrix Bb;
			C3dVector d;
			C3dVector Curv;
			Curv.Set(0, 0, 0);
			// BENDING TERMS Bb is BENDING B MATRIX
			for (k = 1; k < iNoNodes + 1; k++) {
				Bb.m_00 = 0;
				Bb.m_01 = 0;
				Bb.m_02 = -*deriv2.mn(1, k);
				Bb.m_10 = 0;
				Bb.m_11 = *deriv2.mn(2, k);
				Bb.m_12 = 0;
				Bb.m_20 = 0;
				Bb.m_21 = *deriv2.mn(1, k);
				Bb.m_22 = -*deriv2.mn(2, k);
				d.x = *disp3dR.mn(1, k);
				d.y = *disp3dR.mn(2, k);
				d.z = *disp3dR.mn(3, k);
				Curv += Bb.Mult(d);
			}

			// Out of Plain Shear Strain Components gamma1, gamma2
			Mat BEE_TS = pElems[i]->BEE_TS_Recovery();
			Mat STRAIN_TV = BEE_TS * DispTS;
			Mat STRESS_TV = MAT_TS * STRAIN_TV;
			STRESS_TV *= pElems[i]->GetPHI_SQ();
			// NOTE FOR TRANSVERSE FORCES * by dSHRatio
			// end shear strains

			disp3dR.clear();
			// in plane components x,y,xy
			bee = pElems[i]->bmat(coord, deriv2, 3, 2);
			db = bee * disp;
			SX = *db.mn(1, 1);
			SY = *db.mn(2, 1);
			SXY = *db.mn(3, 1);
			// RX = *db.mn(4, 1);
			// RY = *db.mn(5, 1);
			// RXY = *db.mn(6, 1);
			SXY *= 0.5; // Not sure about ENGINEERING SHEAR STRAIN!!
			Res10* pResStrn = new Res10;
			pResStrn->ID = pElems[i]->iLabel;
			pResStrn->v[0] = (float) SX;
			pResStrn->v[1] = (float) SY;
			pResStrn->v[2] = (float) SXY;
			cS = (SX + SY) * 0.5;
			Mag = pow((SX - cS) * (SX - cS) + (SXY * SXY), 0.5);
			pResStrn->v[3] = (float) (cS + Mag);
			pResStrn->v[4] = (float) (cS - Mag);
			pResStrn->v[5] = (float) Curv.x;
			pResStrn->v[6] = (float) Curv.y;
			pResStrn->v[7] = (float) Curv.z;
			SX = Curv.x;
			SY = Curv.y;
			SXY = Curv.z;
			cS = (SX + SY) * 0.5;
			Mag = pow((SX - cS) * (SX - cS) + (SXY * SXY), 0.5);
			pResStrn->v[8] = (float) (cS + Mag);
			pResStrn->v[9] = (float) (cS - Mag);
			// Principals
			ResStrn->Add(pResStrn);
			// THERMAL STRAINS REMOVED
			*db.mn(1, 1) -= pElems[i]->dTemp; // Subtract thermal strains
			*db.mn(2, 1) -= pElems[i]->dTemp; // Subtract thermal strains
			// Z1 bending Stress (Top surface Z2 is thick/2 z1 is -thick/2)
			mStrn = db;
			*mStrn.mn(1, 1) += 0.5 * Curv.x * dthk;
			*mStrn.mn(2, 1) += 0.5 * Curv.y * dthk;
			*mStrn.mn(3, 1) += 0.5 * Curv.z * dthk; // Engininerring Strain to Strain????
			ResZ1 = dee * mStrn; // Calculate Stresses
			mStrn.clear();
			// Z2 bending Stress (Bot surface Z1 is -thick/2 z1 is -thick/2)
			mStrn = db;
			*mStrn.mn(1, 1) -= 0.5 * Curv.x * dthk;
			*mStrn.mn(2, 1) -= 0.5 * Curv.y * dthk;
			*mStrn.mn(3, 1) -= 0.5 * Curv.z * dthk;
			ResZ2 = dee * mStrn; // Calculare Stresses
			mStrn.clear();
			// Mid bending Stress (Bot surface Z1 is thick/2 z1 is -thick/2)
			mStrn = db;
			Res = dee * mStrn;
			Add2dStressRes(ResS, pElems[i]->iLabel, Res, ResZ1, ResZ2);
			Res.clear();
			ResZ1.clear();
			ResZ2.clear();
			mStrn.clear();
		}
	}
	if (ResStrn->iCnt > 0) {
		ResultsSets[iNoRes] = ResStrn;
		iNoRes++;
	} else {
		delete (ResStrn);
	}
	if (ResS->iCnt > 0) {
		ResultsSets[iNoRes] = ResS;
		iNoRes++;
	} else {
		delete (ResS);
	}
}

// was Stresses2d
// rewriten for shell strains stress and engineering forces including
// transverse shear
void ME_Object::RecoverShell(int iLC, CString sSol, CString sStep, PropTable* PropsT, MatTable* MatT, Vec<int>& Steer,
                             Vec<double>& Disp) {
	// ALL THESE MATS NEED TO BE CLEARED!!!

	Mat mStrn;
	Mat Res;
	Mat ResZ1;
	Mat ResZ2;

	Mat DispGlobal; // Global displacements
	Mat DispEl; // local element displacements
	Mat TMAT; // transfomation mat global to local
	Mat MAT_TS;
	Mat MAT_BM;
	Mat MAT_BB;
	double dSHRatio = 1;
	double dthk = 0.001;
	double cS;
	double Mag;
	int MID = -1;
	int i;
	double SX, SY, SXY, RX, RY, RXY, TX, TY, BX, BY, BXY;
	ResSet* ResF;
	ResSet* ResS; // Mid Stress Results Set
	ResSet* ResStrn; // Strain (dir & cur) Results Set
	ResF = Create2dForceResSet("2d EL FORCES", iLC, sStep, sSol);
	ResS = Create2dStressResSet("2d EL STRESSES", iLC, sStep, sSol);
	ResStrn = Create2dStrainResSet("2d EL STRAINS (Mid)", iLC, sStep, sSol);

	SX = 0;
	SY = 0, SXY = 0;
	RX = 0;
	RY = 0;
	RXY = 0;
	int iNoNodes = 0;
	for (i = 0; i < iElNo; i++) {
		// If its a shell element then process
		if ((pElems[i]->iType == 91) || (pElems[i]->iType == 94)) {
			Property* pS = PropsT->GetItem(pElems[i]->PID);
			if (pS != NULL) {
				MID = pS->GetDefMatID();
			}
			Material* pM = MatT->GetItem(MID);
			// Get Shell thickness
			if (((pElems[i]->iType == 91) || (pElems[i]->iType == 94)) && (pS != NULL)) {
				PSHELL* pSh = (PSHELL*) pS;
				dthk = pSh->dT;
				dSHRatio = pSh->dTST;
			}

			if ((pM != NULL) && (pM->iType = 1)) {
				MAT1* pIsen = (MAT1*) pM;
				MAT_TS = pM->DeeSH();
				MAT_BM = pM->DeeMEM();
				MAT_BB = pM->DeeBM();
			}
			//************START OF CALCULATION************

			DispGlobal = GetNodalDispVec(pElems[i], Steer, Disp);
			// WE NEED TO MODIFY DICPLACEMENT TO ACCOUNT FOR OFFSET
			if (pElems[i]->HasOffsets())
				pElems[i]->DispOffsets(PropsT, DispGlobal);
			TMAT = pElems[i]->KEToKGTransform();
			// TMAT.Transpose();
			DispEl = TMAT * DispGlobal;

			Mat BEE_BM = pElems[i]->BEE_BM_Recovery();
			Mat STRAIN_BM = BEE_BM * DispEl;
			Mat STRESS_BM = MAT_BM * STRAIN_BM;
			//*********** End of Membrane Components ****************
			//**************  Bending Components ********************
			Mat BEE_BB = pElems[i]->BEE_BB_Recovery();
			Mat STRAIN_BB = BEE_BB * DispEl;
			// NOT SURE WHY I HAVE TO *-1!!??????????????????????????????
			// STRAIN_BB *= -1; //Mystran gives -ve BB ???????????????
			*STRAIN_BB.mn(3, 1) *= 0.5;
			Mat STRESS_BB = MAT_BB * STRAIN_BB;
			//************ End of Bending Components *****************
			//**************Transverse Shear Components***************
			Mat BEE_TS = pElems[i]->BEE_TS_Recovery();
			Mat STRAIN_TV = BEE_TS * DispEl;
			Mat STRESS_TV = MAT_TS * STRAIN_TV;
			STRESS_TV *= pElems[i]->GetPHI_SQ();
			//        NOTE FOR TRANSVERSE FORCES * by dSHRatio
			//************End of Transverse Shear Components**********
			//
			//***********  R E P O R T    R E SU L T S ***************
			//                   S T R A I N S
			SX = *STRAIN_BM.mn(1, 1);
			SY = *STRAIN_BM.mn(2, 1);
			SXY = *STRAIN_BM.mn(3, 1);
			SXY *= 0.5; // Not sure about ENGINEERING SHEAR STRAIN!!
			RX = *STRAIN_BB.mn(1, 1); // not sure why we have a -
			RY = *STRAIN_BB.mn(2, 1);
			RXY = *STRAIN_BB.mn(3, 1);
			TX = *STRESS_TV.mn(1, 1);
			TY = *STRESS_TV.mn(2, 1);

			Res10* pResStrn = new Res10;
			pResStrn->ID = pElems[i]->iLabel;
			pResStrn->v[0] = (float) SX;
			pResStrn->v[1] = (float) SY;
			pResStrn->v[2] = (float) SXY;
			cS = (SX + SY) * 0.5;
			Mag = pow((SX - cS) * (SX - cS) + (SXY * SXY), 0.5);
			pResStrn->v[3] = (float) (cS + Mag);
			pResStrn->v[4] = (float) (cS - Mag);
			pResStrn->v[5] = (float) RX;
			pResStrn->v[6] = (float) RY;
			pResStrn->v[7] = (float) RXY;

			BX = *STRAIN_BB.mn(1, 1);
			BY = *STRAIN_BB.mn(2, 1);
			BXY = *STRAIN_BB.mn(3, 1);
			cS = (BX + BY) * 0.5;
			Mag = pow((BX - cS) * (BX - cS) + (BXY * BXY), 0.5);
			pResStrn->v[8] = (float) (cS + Mag);
			pResStrn->v[9] = (float) (cS - Mag);

			ResStrn->Add(pResStrn);
			// THERMAL STRAINS REMOVED
			*STRAIN_BM.mn(1, 1) -= pElems[i]->dTemp; // Subtract thermal strains ;
			*STRAIN_BM.mn(2, 1) -= pElems[i]->dTemp; // Subtract thermal strains ;
			// Z1 bending Stress (Top surface Z2 is thick/2 z1 is -thick/2)
			mStrn = STRAIN_BM;
			*mStrn.mn(1, 1) += 0.5 * *STRAIN_BB.mn(1, 1) * dthk;
			*mStrn.mn(2, 1) += 0.5 * *STRAIN_BB.mn(2, 1) * dthk;
			*mStrn.mn(3, 1) += 0.5 * *STRAIN_BB.mn(3, 1) * dthk; // Engininerring Strain to Strain????
			ResZ1 = MAT_BM * mStrn; // Calculate Stresses
			mStrn.clear();
			// Z2 bending Stress (Bot surface Z1 is -thick/2 z1 is -thick/2)
			mStrn = STRAIN_BM;
			*mStrn.mn(1, 1) -= 0.5 * *STRAIN_BB.mn(1, 1) * dthk;
			*mStrn.mn(2, 1) -= 0.5 * *STRAIN_BB.mn(2, 1) * dthk;
			*mStrn.mn(3, 1) -= 0.5 * *STRAIN_BB.mn(3, 1) * dthk; // Engininerring Strain to Strain????
			ResZ2 = MAT_BM * mStrn; // Calculare Stresses
			mStrn.clear();
			// Mid bending Stress (Bot surface Z1 is thick/2 z1 is -thick/2)
			mStrn = STRAIN_BM;
			Res = MAT_BM * mStrn;
			Add2dStressRes(ResS, pElems[i]->iLabel, Res, ResZ1, ResZ2);
			// add element forces
			Res8* pRes = new Res8;
			pRes->ID = pElems[i]->iLabel;
			pRes->v[0] = (float) (*Res.mn(1, 1) * dthk);
			pRes->v[1] = (float) (*Res.mn(2, 1) * dthk);
			pRes->v[2] = (float) (*Res.mn(3, 1) * dthk);

			pRes->v[3] = (float) (*STRESS_BB.mn(1, 1) * dthk * dthk * dthk / 12);
			pRes->v[4] = (float) (*STRESS_BB.mn(2, 1) * dthk * dthk * dthk / 12);
			pRes->v[5] = (float) (*STRESS_BB.mn(3, 1) * dthk * dthk * dthk / 12);

			pRes->v[6] = (float) (TX * dthk * dSHRatio);
			pRes->v[7] = (float) (TY * dthk * dSHRatio);
			ResF->Add(pRes);
			Res.clear();
			ResZ1.clear();
			ResZ2.clear();
			mStrn.clear();

			DispGlobal.clear();
			DispEl.clear();
			TMAT.clear();

			MAT_TS.clear();
			BEE_TS.clear();
			STRAIN_TV.clear();
			STRESS_TV.clear();

			MAT_BB.clear();
			BEE_BB.clear();
			STRAIN_BB.clear();
			STRESS_BB.clear();

			MAT_BM.clear();
			BEE_BM.clear();
			STRAIN_BM.clear();
			STRESS_BM.clear();
		}
	}
	if (ResF->iCnt > 0) {
		ResultsSets[iNoRes] = ResF;
		iNoRes++;
	} else {
		delete (ResF);
	}
	if (ResStrn->iCnt > 0) {
		ResultsSets[iNoRes] = ResStrn;
		iNoRes++;
	} else {
		delete (ResStrn);
	}
	if (ResS->iCnt > 0) {
		ResultsSets[iNoRes] = ResS;
		iNoRes++;
	} else {
		delete (ResS);
	}
}

C3dVector ME_Object::EigenVector3d(int iEID, C3dVector rX, C3dVector rY, C3dVector rZ, double lambda) {
	C3dVector res;
	rX.x -= lambda;
	rY.y -= lambda;
	rZ.z -= lambda;
	char s80[80];
	double dS1;
	// Assume trail X=1 for eigen vetoy
	if (rX.z != 0) {
		dS1 = rY.z / rX.z;
		rX *= dS1;
		// Subtract First *dS1 form second
		rY -= rX;
		res.x = 1;
		res.y = -rY.x / rY.y;
		res.z = -(rX.x + res.y * rX.y) / rX.z;
	} else {
		sprintf_s(s80, "%s %i", "Eigenvector undetermined for EID ", iEID);
		outtext1(s80);
	}
	res.Normalize();
	res *= lambda;
	return (res);
}

C3dVector ME_Object::EigenVector2d(int iEID, C3dVector rX, C3dVector rY, double lambda) {
	C3dVector res;
	rX.x -= lambda;
	rY.y -= lambda;
	char s80[80];
	// Assume trail X=1 for eigen vector
	if (rX.y != 0) {
		res.x = 1;
		res.y = -rX.x / rX.y;
		res.z = 0;
	} else {
		sprintf_s(s80, "%s %i", "Eigenvector undetermined for EID ", iEID);
		outtext1(s80);
	}
	res.Normalize();
	res *= lambda;
	return (res);
}

void ME_Object::CalcPrinStress(double XX, double YY, double ZZ,
                               double XY, double YZ, double XZ,
                               double& P1, double& P2, double& P3) {
	double a, b, c, d;
	a = 1;
	b = -1 * (XX + YY + ZZ);
	c = XX * YY + YY * ZZ + XX * ZZ - XY * XY - YZ * YZ - XZ * XZ;
	d = -1 * (XX * YY * ZZ + 2 * XY * YZ * XZ - XY * XY * ZZ - YZ * YZ * XX - XZ * XZ * YY);
	// Use the equation from above to get your cubic equation and combine all constant terms possible to
	// give you a reduced equation we will use a, b, c and d to denote the coefficients of this equation.
	double x, y, z;

	x = ((3 * c / a) - (b * b / (a * a))) / 3.0;
	y = ((2 * b * b * b / (a * a * a)) - (9 * b * c / (a * a)) + (27 * d / a)) / 27.0;
	z = y * y / 4 + x * x * x / 27;
	//
	double i, j, k, m, n, p;
	i = pow((y * y / 4 - z), 0.5);
	j = -pow(i, (1.0 / 3.0));
	k = acos(-(y / (2 * i)));
	m = cos(k / 3);
	n = pow(3, 0.5) * sin(k / 3);
	p = b / (3 * a);
	//
	double Eig1, Eig2, Eig3;
	Eig1 = -(2 * j * m + p);
	Eig2 = -(-j * (m + n) + p);
	Eig3 = -(-j * (m - n) + p);
	P1 = Eig1;
	if (Eig2 > P1)
		P1 = Eig2;
	if (Eig3 > P1)
		P1 = Eig3;
	P3 = Eig1;
	if (Eig2 < P3)
		P3 = Eig2;
	if (Eig3 < P3)
		P3 = Eig3;
	P2 = Eig1;
	if ((Eig1 < P1) && (Eig1 > P3))
		P2 = Eig1;
	if ((Eig2 < P1) && (Eig2 > P3))
		P2 = Eig2;
	if ((Eig3 < P1) && (Eig3 > P3))
		P2 = Eig3;
}

void ME_Object::Stresses3d(int iLC, CString sSol, CString sStep, PropTable* PropsT, MatTable* MatT, Vec<int>& Steer,
                           Vec<double>& Disp) {
	ResSet* ResS = new ResSet();

	ResS->ACODE = 11;
	ResS->TCODE = 4;
	ResS->TYPE = 0;
	ResS->LC = iLC;
	ResS->sSubTitle = sStep;
	ResS->sTitle = sSol;
	ResS->WID = 8;

	ResS->sName = "3d GLOBAL STRESSES";
	ResS->iNoV = 11;
	ResS->lab[0] = "Stress GX";
	ResS->lab[1] = "Stress GY";
	ResS->lab[2] = "Stress GZ";
	ResS->lab[3] = "Stress GXY";
	ResS->lab[4] = "Stress GYZ";
	ResS->lab[5] = "Stress GXZ";
	ResS->lab[6] = "Stress Max Prin";
	ResS->lab[7] = "Stress Mid Prin";
	ResS->lab[8] = "Stress Min Prin1";
	ResS->lab[9] = "Stress Max Shear";
	ResS->lab[10] = "Stress Von Mises";
	ResDef* pVT = new ResDef();
	pVT->sResType = "3d Stress Tensor SOLID";
	pVT->iResType = 4; // 3d Tenspr
	pVT->iLoc = 1; // Element Centroid(cys global)
	pVT->iComponents[0] = 0;
	pVT->iComponents[1] = 1;
	pVT->iComponents[2] = 2;
	pVT->iComponents[3] = 3;
	pVT->iComponents[4] = 4;
	pVT->iComponents[5] = 5;
	pVT->iComponents[6] = 6;
	pVT->iComponents[7] = 7;
	pVT->iComponents[8] = 8;
	pVT->iCompNo = 9;
	pVT->GenDefualtHeaders();
	ResS->AddResDef(pVT);

	ResSet* ResSt = new ResSet();
	ResSt->ACODE = 11;
	ResSt->TCODE = 4;
	ResSt->TYPE = 0;
	ResSt->LC = iLC;
	ResSt->WID = 8;

	ResSt->sName = "3d GLOBAL STRAINS";
	ResSt->iNoV = 9;
	ResSt->lab[0] = "Strain GX";
	ResSt->lab[1] = "Strain GY";
	ResSt->lab[2] = "Strain GZ";
	ResSt->lab[3] = "Strain GXY";
	ResSt->lab[4] = "Strain GYZ";
	ResSt->lab[5] = "Strain GXZ";
	ResSt->lab[6] = "Strain Max Prin";
	ResSt->lab[7] = "Strain Mid Prin";
	ResSt->lab[8] = "Strain Min Prin";

	ResDef* pVS = new ResDef();
	pVS->sResType = "3d Strain Tensor SOLID";
	pVS->iResType = 4; // 3d Tenspr
	pVS->iLoc = 1; // Element Centroid(cys global)
	pVS->iComponents[0] = 0;
	pVS->iComponents[1] = 1;
	pVS->iComponents[2] = 2;
	pVS->iComponents[3] = 3;
	pVS->iComponents[4] = 4;
	pVS->iComponents[5] = 5;
	pVS->iComponents[6] = 6;
	pVS->iComponents[7] = 7;
	pVS->iComponents[8] = 8;
	pVT->GenDefualtHeaders();
	pVS->iCompNo = 9;
	ResSt->AddResDef(pVS);

	int i;
	int j;
	int k;
	Mat disp;

	double SX, SY, SZ;
	double SXY, SYZ, SXZ;
	int iNoNodes = 0;
	for (i = 0; i < iElNo; i++) {
		// FOR SOLID ELEMENTS ONLY
		if ((pElems[i]->iType == 115) || (pElems[i]->iType == 112) || (pElems[i]->iType == 111)) {
			iNoNodes = 0;
			if (pElems[i]->iType == 115) {
				iNoNodes = 8;
				disp.Create(24, 1);
			} else if (pElems[i]->iType == 112) {
				iNoNodes = 6;
				disp.Create(18, 1);
			} else if (pElems[i]->iType == 111) {
				iNoNodes = 4;
				disp.Create(12, 1);
			}

			Mat dee; // stress strain
			Mat bee; // Strain displacement
			int nip = 1; // Centroid stresses only
			Mat coord; // Nodal Coordinates
			Mat deriv; // shape function derivatives
			Mat fun; // shape function
			Mat Points; // sample points
			Mat deriv2;
			Mat jac;
			Mat db;
			Mat Res;
			// Defualt values
			double det;
			double dof1;
			double dE = 210e9;
			double dv = 0.29;
			double dthk = 0.001;
			int MID = -1;
			Property* pS = PropsT->GetItem(pElems[i]->PID);
			if (pS != NULL) {
				MID = pS->GetDefMatID();
			}
			Material* pM = MatT->GetItem(MID);
			if ((pM != NULL) && (pM->iType = 1)) {
				MAT1* pIsen = (MAT1*) pM;
				dE = pIsen->dE;
				dv = pIsen->dNU;
			}
			if (iNoNodes > 0) {
				for (j = 0; j < iNoNodes; j++) {
					// Get the displacements
					for (k = 0; k < 3; k++) {
						dof1 = 0;
						Node* pN = (Node*) pElems[i]->GetNode(j);
						if (pN->dof[k] > 0)
							dof1 = GetDisp(pN->dof[k], Steer, Disp);
						int n;
						n = j * 3 + k + 1;
						*disp.mn(n, 1) = dof1;
					}
				}
				dee = pElems[i]->DeeMat(dE, dv, 6);
				coord = pElems[i]->getCoords3d();
				Points = pElems[i]->Sample(nip);
				det = 0;
				fun = pElems[i]->ShapeFun(Points, 1);
				deriv = pElems[i]->ShapeDer(Points, 1);
				jac = deriv * coord;
				jac = jac.InvertJac(det);
				deriv2 = jac * deriv;
				bee = pElems[i]->bmat(coord, deriv2, 6, 3);
				db = bee * disp;
				SX = *db.mn(1, 1);
				SY = *db.mn(2, 1);
				SZ = *db.mn(3, 1);
				SXY = *db.mn(4, 1);
				SYZ = *db.mn(5, 1);
				SXZ = *db.mn(6, 1);
				Res11* pResS = new Res11;
				pResS->ID = pElems[i]->iLabel;
				pResS->v[0] = (float) SX;
				pResS->v[1] = (float) SY;
				pResS->v[2] = (float) SZ;
				pResS->v[3] = (float) SXY;
				pResS->v[4] = (float) SYZ;
				pResS->v[5] = (float) SXZ;
				double p1, p2, p3;
				CalcPrinStress(SX, SY, SZ, SXY, SYZ, SXZ, p1, p2, p3);
				pResS->v[6] = (float) p1;
				pResS->v[7] = (float) p2;
				pResS->v[8] = (float) p3;

				ResSt->Add(pResS);
				*db.mn(1, 1) -= pElems[i]->dTemp; // Thermal Strains
				*db.mn(2, 1) -= pElems[i]->dTemp;
				*db.mn(3, 1) -= pElems[i]->dTemp;
				Res = dee * db;
				SX = *Res.mn(1, 1);
				SY = *Res.mn(2, 1);
				SZ = *Res.mn(3, 1);
				SXY = *Res.mn(4, 1);
				SYZ = *Res.mn(5, 1);
				SXZ = *Res.mn(6, 1);

				CalcPrinStress(SX, SY, SZ, SXY, SYZ, SXZ, p1, p2, p3);
				Res11* pRes = new Res11;
				pRes->ID = pElems[i]->iLabel;
				pRes->v[0] = (float) SX;
				pRes->v[1] = (float) SY;
				pRes->v[2] = (float) SZ;
				pRes->v[3] = (float) SXY;
				pRes->v[4] = (float) SYZ;
				pRes->v[5] = (float) SXZ;
				pRes->v[6] = (float) p1;
				pRes->v[7] = (float) p2;
				pRes->v[8] = (float) p3;
				pRes->v[9] = (float) 0.5 * (p1 - p3);
				pRes->v[10] = (float) pow(0.5 * ((p1 - p2) * (p1 - p2) + (p2 - p3) * (p2 - p3) + (p1 - p3) * (p1 - p3)),
				                          0.5);
				ResS->Add(pRes);
				// sEL = "STRESS CHEXA";
			}
		}
	}
	if (ResSt->iCnt > 0) {
		ResultsSets[iNoRes] = ResSt;
		iNoRes++;
	} else {
		delete (ResSt);
	}
	if (ResS->iCnt > 0) {
		ResultsSets[iNoRes] = ResS;
		iNoRes++;
	} else {
		delete (ResS);
	}
}

void ME_Object::AddOEFRes(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName) {
	int i;
	int iTC;
	ResultsSets[iNoRes] = new ResSet();
	ResultsSets[iNoRes]->sFile = inName;
	ResultsSets[iNoRes]->sTitle = sTitle;
	ResultsSets[iNoRes]->sSubTitle = sSubTitle;
	ResultsSets[iNoRes]->ACODE = Vals[0];
	ResultsSets[iNoRes]->TCODE = Vals[1];
	ResultsSets[iNoRes]->TYPE = Vals[2];
	ResultsSets[iNoRes]->LC = Vals[3];
	ResultsSets[iNoRes]->WID = Vals[6];
	ResultsSets[iNoRes]->FCODE = Vals[7];
	ResultsSets[iNoRes]->SCODE = Vals[8];
	iTC = ResultsSets[iNoRes]->TCODE / 1000;
	CString sEL;
	BOOL isGood = FALSE;

	if (Vals[2] == 33) {
		isGood = TRUE;
		if ((iTC == 4) || (iTC == 5))
			sEL = "RMS FORCE CQUAD4";
		else
			sEL = "FORCE CQUAD4";
	} else if (Vals[2] == 74) {
		isGood = TRUE;
		if ((iTC == 4) || (iTC == 5))
			sEL = "RMS FORCE CTRIA3";
		else
			sEL = "FORCE CTRIA3";
	} else if (Vals[2] == 2) {
		sEL = "FORCE CBEAM (not read)";
		ResultsSets[iNoRes]->sName = sEL;
	} else if (Vals[2] == 102) {
		if ((iTC == 4) || (iTC == 5))
			sEL = "RMS FORCE CBUSH";
		else
			sEL = "FORCE CBUSH";
	} else if (Vals[2] == 34) {
		if ((iTC == 4) || (iTC == 5))
			sEL = "RMS FORCE CBAR";
		else
			sEL = "FORCE CBAR";
	} else if (Vals[2] == 95) {
		if ((iTC == 4) || (iTC == 5))
			sEL = "RMS FAILURE INDICES CQUAD4";
		else
			sEL = "FAILURE INDICES CQUAD4";
	} else if (Vals[2] == 97) {
		if ((iTC == 4) || (iTC == 5))
			sEL = "RMS FAILURE INDICES CTRIA3";
		else
			sEL = "FAILURE INDICES CTRIA3";
	} else if (Vals[2] == 1) {
		if ((iTC == 4) || (iTC == 5))
			sEL = "RMS FORCE CROD";
		else
			sEL = "FORCE CROD";
	}

	if ((iCnt > 10) && (isGood)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 8;
		ResultsSets[iNoRes]->lab[0] = "FX";
		ResultsSets[iNoRes]->lab[1] = "FY";
		ResultsSets[iNoRes]->lab[2] = "FXY";
		ResultsSets[iNoRes]->lab[3] = "MX";
		ResultsSets[iNoRes]->lab[4] = "MY";
		ResultsSets[iNoRes]->lab[5] = "MXY";
		ResultsSets[iNoRes]->lab[6] = "TX";
		ResultsSets[iNoRes]->lab[7] = "TY";
		for (i = 10; i < iCnt; i += 9) {
			Res8* pRes = new Res8;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 5) && ((ResultsSets[iNoRes]->TYPE == 95) || (ResultsSets[iNoRes]->TYPE == 97))) {
		// failure index
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 5;
		ResultsSets[iNoRes]->lab[0] = "Lamina number";
		ResultsSets[iNoRes]->lab[1] = "Failure index for direct stresses";
		ResultsSets[iNoRes]->lab[2] = "Failure mode for maximum strain theory";
		ResultsSets[iNoRes]->lab[3] = "Failure index for interlaminar shear stress or -1";
		ResultsSets[iNoRes]->lab[4] = "Maximum of FP and FB or -1.";
		ResultsSets[iNoRes]->sOpName = "Layer ";
		ResultsSets[iNoRes]->iDefID = 1;
		ResultsSets[iNoRes]->iSecondaryID = 0;
		int ID;
		char* ss;
		CString S;
		for (i = 10; i < iCnt; i += 9) {
			Res5* pRes = new Res5;
			if (Vals[i] != -1)
				ID = Vals[i];
			pRes->ID = ID;
			pRes->v[0] = Vals[i + 3];
			pRes->v[1] = *(float*) &Vals[i + 4];

			ss = (char*) &Vals[i + 5];
			S = "";
			S += ss[0];
			S += ss[1];
			S += ss[2];
			S += ss[3];
			pRes->v[2] = atof(S); // Was this??
			if (Vals[i + 6] == -1)
				pRes->v[3] = Vals[i + 6];
			else
				pRes->v[3] = *(float*) &Vals[i + 6];
			if (Vals[i + 7] == -1)
				pRes->v[4] = Vals[i + 7];
			else
				pRes->v[4] = *(float*) &Vals[i + 7];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 5) && (ResultsSets[iNoRes]->TYPE == 102)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 6;
		ResultsSets[iNoRes]->lab[0] = "FX";
		ResultsSets[iNoRes]->lab[1] = "FY";
		ResultsSets[iNoRes]->lab[2] = "FZ";
		ResultsSets[iNoRes]->lab[3] = "MX";
		ResultsSets[iNoRes]->lab[4] = "MY";
		ResultsSets[iNoRes]->lab[5] = "MZ";

		for (i = 10; i < iCnt; i += 7) {
			Res6* pRes = new Res6;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 5) && (ResultsSets[iNoRes]->TYPE == 34)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 8;
		ResultsSets[iNoRes]->lab[0] = "BM1A";
		ResultsSets[iNoRes]->lab[1] = "BM2A";
		ResultsSets[iNoRes]->lab[2] = "BM1B";
		ResultsSets[iNoRes]->lab[3] = "BM2B";
		ResultsSets[iNoRes]->lab[4] = "TS1";
		ResultsSets[iNoRes]->lab[5] = "TS2";
		ResultsSets[iNoRes]->lab[6] = "AF";
		ResultsSets[iNoRes]->lab[7] = "TRQ";
		for (i = 10; i < iCnt; i += 9) {
			Res8* pRes = new Res8;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 5) && (ResultsSets[iNoRes]->TYPE == 1)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 2;
		ResultsSets[iNoRes]->lab[0] = "Axial Force";
		ResultsSets[iNoRes]->lab[1] = "Torque";

		for (i = 10; i < iCnt; i += 9) {
			Res8* pRes = new Res8;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	iNoRes++;
}

void ME_Object::AddOEFResF(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName, double dF) {
	int i;
	char s80[80];
	ResultsSets[iNoRes] = new ResSet();
	ResultsSets[iNoRes]->sFile = inName;
	ResultsSets[iNoRes]->sTitle = sTitle;
	ResultsSets[iNoRes]->sSubTitle = sSubTitle;
	ResultsSets[iNoRes]->ACODE = Vals[0];
	ResultsSets[iNoRes]->TCODE = Vals[1];
	ResultsSets[iNoRes]->TYPE = Vals[2];
	ResultsSets[iNoRes]->LC = Vals[3];
	ResultsSets[iNoRes]->WID = Vals[6];
	ResultsSets[iNoRes]->FCODE = Vals[7];
	ResultsSets[iNoRes]->SCODE = Vals[8];
	ResultsSets[iNoRes]->dFreq = dF;
	int iWID = ResultsSets[iNoRes]->WID;
	CString sEL;
	BOOL isGood = FALSE;

	if (Vals[2] == 33) {
		isGood = TRUE;
		sEL = "FORCE CQUAD4";
	} else if (Vals[2] == 74) {
		isGood = TRUE;
		sEL = "FORCE CTRIA3";
	} else if (Vals[2] == 2) {
		sEL = "FORCE CBEAM (not read)";
		ResultsSets[iNoRes]->sName = sEL;
	} else if (Vals[2] == 102) {
		sEL = "FORCE CBUSH";
	} else if (Vals[2] == 34) {
		sEL = "FORCE CBAR";
	} else if (Vals[2] == 95) {
		sEL = "FAILURE INDICES CQUAD4";
	} else if (Vals[2] == 97) {
		sEL = "FAILURE INDICES CTRIA3";
	} else if (Vals[2] == 1) {
		sEL = "FORCE CROD";
	}

	if ((iCnt > 5) && (ResultsSets[iNoRes]->TYPE == 102)) {
		sprintf_s(s80, "%s %g %s", sEL, dF, "Hz");
		ResultsSets[iNoRes]->sName = s80;
		ResultsSets[iNoRes]->iNoV = 13;
		if (ResultsSets[iNoRes]->FCODE == 3) {
			// MAG / PHASE
			ResultsSets[iNoRes]->lab[0] = "Freq";
			ResultsSets[iNoRes]->lab[1] = "(Mag) FX";
			ResultsSets[iNoRes]->lab[2] = "(Mag) FY";
			ResultsSets[iNoRes]->lab[3] = "(Mag) FZ";
			ResultsSets[iNoRes]->lab[4] = "(Mag) MX";
			ResultsSets[iNoRes]->lab[5] = "(Mag) MY";
			ResultsSets[iNoRes]->lab[6] = "(Mag) MZ";
			ResultsSets[iNoRes]->lab[7] = "(Phi) FX";
			ResultsSets[iNoRes]->lab[8] = "(Phi) FY";
			ResultsSets[iNoRes]->lab[9] = "(Phi) FZ";
			ResultsSets[iNoRes]->lab[10] = "(Phi) MX";
			ResultsSets[iNoRes]->lab[11] = "(Phi) MY";
			ResultsSets[iNoRes]->lab[12] = "(Phi) MZ";
			//**********Define the Vector********************
			ResDef* pVT = new ResDef();
			pVT->sResType = "FORCE TRANS MAG VEC";
			pVT->iResType = 1; // Vector Forec Magnitude Translation
			pVT->iLoc = 1; // Element
			pVT->iComponents[0] = 1;
			pVT->iComponents[1] = 2;
			pVT->iComponents[2] = 3;
			pVT->iComponents[3] = -1;
			pVT->iCompNo = 4;
			pVT->GenDefualtHeaders();
			ResultsSets[iNoRes]->AddResDef(pVT);
		} else {
			ResultsSets[iNoRes]->lab[0] = "Freq";
			ResultsSets[iNoRes]->lab[1] = "(Re) FX";
			ResultsSets[iNoRes]->lab[2] = "(Re) FY";
			ResultsSets[iNoRes]->lab[3] = "(Re) FZ";
			ResultsSets[iNoRes]->lab[4] = "(Re) MX";
			ResultsSets[iNoRes]->lab[5] = "(Re) MY";
			ResultsSets[iNoRes]->lab[6] = "(Re) MZ";
			ResultsSets[iNoRes]->lab[7] = "(Im) FX";
			ResultsSets[iNoRes]->lab[8] = "(Im) FY";
			ResultsSets[iNoRes]->lab[9] = "(Im) FZ";
			ResultsSets[iNoRes]->lab[10] = "(Im) MX";
			ResultsSets[iNoRes]->lab[11] = "(Im) MY";
			ResultsSets[iNoRes]->lab[12] = "(Im) MZ";
		}

		for (i = 10; i < iCnt; i += iWID) {
			Res13* pRes = new Res13;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = dF;
			pRes->v[1] = *(float*) &Vals[i + 1];
			pRes->v[2] = *(float*) &Vals[i + 2];
			pRes->v[3] = *(float*) &Vals[i + 3];
			pRes->v[4] = *(float*) &Vals[i + 4];
			pRes->v[5] = *(float*) &Vals[i + 5];
			pRes->v[6] = *(float*) &Vals[i + 6];
			pRes->v[7] = *(float*) &Vals[i + 7];
			pRes->v[8] = *(float*) &Vals[i + 8];
			pRes->v[9] = *(float*) &Vals[i + 9];
			pRes->v[10] = *(float*) &Vals[i + 10];
			pRes->v[11] = *(float*) &Vals[i + 11];
			pRes->v[12] = *(float*) &Vals[i + 12];
			ResultsSets[iNoRes]->Add(pRes);
		}
	} else if ((iCnt > 5) && ((ResultsSets[iNoRes]->TYPE == 33) || (ResultsSets[iNoRes]->TYPE == 74))) {
		// QUAD4 FEQUENCY RESULTS
		sprintf_s(s80, "%s %g %s", sEL, dF, "Hz");
		ResultsSets[iNoRes]->sName = s80;
		ResultsSets[iNoRes]->iNoV = iWID - 1;
		if (ResultsSets[iNoRes]->FCODE == 3) {
			// MAG / PHASE
			ResultsSets[iNoRes]->lab[0] = "Freq";
			ResultsSets[iNoRes]->lab[1] = "(Mag) Membrane in x";
			ResultsSets[iNoRes]->lab[2] = "(Mag) Membrane in y";
			ResultsSets[iNoRes]->lab[3] = "(Mag) Membrane in xy";
			ResultsSets[iNoRes]->lab[4] = "(Mag) Bending in x";
			ResultsSets[iNoRes]->lab[5] = "(Mag) Bending in y";
			ResultsSets[iNoRes]->lab[6] = "(Mag) Bending in xy";
			ResultsSets[iNoRes]->lab[7] = "(Mag) Transverse Shear in x";
			ResultsSets[iNoRes]->lab[8] = "(Mag) Transverse Shear in y";
			ResultsSets[iNoRes]->lab[9] = "(Phi)  Membrane in x";
			ResultsSets[iNoRes]->lab[10] = "(Phi) Membrane in y";
			ResultsSets[iNoRes]->lab[11] = "(Phi) Membrane in xy";
			ResultsSets[iNoRes]->lab[12] = "(Phi) Bending in x";
			ResultsSets[iNoRes]->lab[13] = "(Phi) Bending in y";
			ResultsSets[iNoRes]->lab[14] = "(Phi) Transverse Shear in x";
			ResultsSets[iNoRes]->lab[15] = "(Phi) Transverse Shear in y";
		} else {
			ResultsSets[iNoRes]->lab[0] = "Freq";
			ResultsSets[iNoRes]->lab[1] = "(Re) Membrane in x";
			ResultsSets[iNoRes]->lab[2] = "(Re) Membrane in y";
			ResultsSets[iNoRes]->lab[3] = "(Re) Membrane in xy";
			ResultsSets[iNoRes]->lab[4] = "(Re) Bending in x";
			ResultsSets[iNoRes]->lab[5] = "(Re) Bending in y";
			ResultsSets[iNoRes]->lab[6] = "(Re) Bending in xy";
			ResultsSets[iNoRes]->lab[7] = "(Re) Transverse Shear in x";
			ResultsSets[iNoRes]->lab[8] = "(Re) Transverse Shear in y";
			ResultsSets[iNoRes]->lab[9] = "(Im)  Membrane in x";
			ResultsSets[iNoRes]->lab[10] = "(Im) Membrane in y";
			ResultsSets[iNoRes]->lab[11] = "(Im) Membrane in xy";
			ResultsSets[iNoRes]->lab[12] = "(Im) Bending in x";
			ResultsSets[iNoRes]->lab[13] = "(Im) Bending in y";
			ResultsSets[iNoRes]->lab[14] = "(Im) Transverse Shear in x";
			ResultsSets[iNoRes]->lab[15] = "(Im) Transverse Shear in y";
		}

		for (i = 10; i < iCnt; i += iWID) {
			Res15* pRes = new Res15;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = dF;
			pRes->v[1] = *(float*) &Vals[i + 1];
			pRes->v[2] = *(float*) &Vals[i + 2];
			pRes->v[3] = *(float*) &Vals[i + 3];
			pRes->v[4] = *(float*) &Vals[i + 4];
			pRes->v[5] = *(float*) &Vals[i + 5];
			pRes->v[6] = *(float*) &Vals[i + 6];
			pRes->v[7] = *(float*) &Vals[i + 7];
			pRes->v[8] = *(float*) &Vals[i + 8];
			pRes->v[9] = *(float*) &Vals[i + 9];
			pRes->v[10] = *(float*) &Vals[i + 10];
			pRes->v[11] = *(float*) &Vals[i + 11];
			pRes->v[12] = *(float*) &Vals[i + 12];
			pRes->v[13] = *(float*) &Vals[i + 13];
			pRes->v[14] = *(float*) &Vals[i + 14];
			pRes->v[15] = *(float*) &Vals[i + 15];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}

	iNoRes++;
}

void ME_Object::AddOES1Res(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName) {
	int i;

	ResultsSets[iNoRes] = new ResSet();
	ResultsSets[iNoRes]->sFile = inName;
	ResultsSets[iNoRes]->sTitle = sTitle;
	ResultsSets[iNoRes]->sSubTitle = sSubTitle;
	ResultsSets[iNoRes]->ACODE = Vals[0];
	ResultsSets[iNoRes]->TCODE = Vals[1];
	ResultsSets[iNoRes]->TYPE = Vals[2];
	ResultsSets[iNoRes]->LC = Vals[3];
	ResultsSets[iNoRes]->WID = Vals[6];
	ResultsSets[iNoRes]->FCODE = Vals[7];
	ResultsSets[iNoRes]->SCODE = Vals[8];
	CString sEL;
	BOOL isGood = FALSE;

	if (Vals[2] == 33) {
		isGood = TRUE;
		sEL = "STRESS CENTRE CQUAD4";
		ResDef* pVT;
		pVT = new ResDef();
		pVT->sResType = "2d EL STRESSES (Z1 Bot Surf)";
		pVT->iResType = 3; // 2d Tenspr
		pVT->iLoc = 1; // Element Centroid(cys global)
		pVT->iComponents[0] = 1; // X
		pVT->iComponents[1] = 2; // Y
		pVT->iComponents[2] = 3; // XY
		pVT->iComponents[3] = 5; // P1
		pVT->iComponents[4] = 6; // P2
		pVT->iCompNo = 5;
		pVT->GenDefualtHeaders();
		ResultsSets[iNoRes]->AddResDef(pVT);
		pVT = new ResDef();
		pVT->sResType = "2d EL STRESSES (Z2 Top Surf)";
		pVT->iResType = 3; // 2d Tenspr
		pVT->iLoc = 1; // Element Centroid(cys global)
		pVT->iComponents[0] = 10; // X
		pVT->iComponents[1] = 11; // Y
		pVT->iComponents[2] = 12; // XY
		pVT->iComponents[3] = 14; // P1
		pVT->iComponents[4] = 15; // P2
		pVT->iCompNo = 5;
		pVT->GenDefualtHeaders();
		ResultsSets[iNoRes]->AddResDef(pVT);
	} else if (Vals[2] == 74) {
		isGood = TRUE;
		sEL = "STRESS CENTRE CTRIA3";
	} else if (Vals[2] == 1) {
		sEL = "STRESS CROD";
	} else if (Vals[2] == 102) {
		sEL = "STRESS CBUSH";
	} else if (Vals[2] == 34) {
		sEL = "STRESS CBAR";
	} else if (Vals[2] == 67) {
		sEL = "STRESS CHEXA";
		ResDef* pVT = new ResDef();
		pVT->sResType = "Stress Tensor CHEXA";
		pVT->iResType = 4; // 3d Tenspr
		pVT->iLoc = 1; // Element Centroid(cys global)
		pVT->iComponents[0] = 1;
		pVT->iComponents[1] = 9;
		pVT->iComponents[2] = 15;
		pVT->iComponents[3] = 2;
		pVT->iComponents[4] = 10;
		pVT->iComponents[5] = 16;
		pVT->iComponents[6] = 3;
		pVT->iComponents[7] = 11;
		pVT->iComponents[8] = 17;
		pVT->iCompNo = 9;
		pVT->GenDefualtHeaders();
		ResDef* pVR = new ResDef();
		ResultsSets[iNoRes]->AddResDef(pVT);
	} else if (Vals[2] == 39) {
		sEL = "STRESS CTETRA";
	} else if (Vals[2] == 68) {
		sEL = "STRESS CPENTA";
	} else if (Vals[2] == 95) {
		sEL = "STRESS CQUAD LAYERED";
	} else if (Vals[2] == 97) {
		sEL = "STRESS CTRIA LAYERED";
	}
	if ((iCnt > 10) && (isGood)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 18;
		ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
		ResultsSets[iNoRes]->lab[1] = "Normal in x at Z1";
		ResultsSets[iNoRes]->lab[2] = "Normal in y at Z1";
		ResultsSets[iNoRes]->lab[3] = "Shear in xy at Z1";
		ResultsSets[iNoRes]->lab[4] = "Theta ( Shear Angle ) at Z1";
		ResultsSets[iNoRes]->lab[5] = "Major Principal at Z1";
		ResultsSets[iNoRes]->lab[6] = "Minor Principal at Z1";
		ResultsSets[iNoRes]->lab[7] = "Maximum Shear at Z1";
		ResultsSets[iNoRes]->lab[8] = "Derived VM Stress Z1";
		ResultsSets[iNoRes]->lab[9] = "Z2 = Fibre distance";
		ResultsSets[iNoRes]->lab[10] = "Normal in x at Z2";
		ResultsSets[iNoRes]->lab[11] = "Normal in y at Z1";
		ResultsSets[iNoRes]->lab[12] = "Shear in xy at Z2";
		ResultsSets[iNoRes]->lab[13] = "Theta ( Shear Angle ) at Z2";
		ResultsSets[iNoRes]->lab[14] = "Major Principal at Z2";
		ResultsSets[iNoRes]->lab[15] = "Minor Principal at Z2";
		ResultsSets[iNoRes]->lab[16] = "Maximum Shear at Z2";
		ResultsSets[iNoRes]->lab[17] = "Derived VM Stress Z2";
		double p1;
		double p2;
		double vm;
		for (i = 10; i < iCnt; i += 17) {
			Res18* pRes = new Res18;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			// Derive VM stress from principles
			p1 = *(float*) &Vals[i + 6];
			p2 = *(float*) &Vals[i + 7];
			vm = pow(p1 * p1 - p1 * p2 + p2 * p2, 0.5);
			pRes->v[7] = 0.5 * (p1 - p2);
			pRes->v[8] = vm;
			pRes->v[9] = *(float*) &Vals[i + 9];
			pRes->v[10] = *(float*) &Vals[i + 10];
			pRes->v[11] = *(float*) &Vals[i + 11];
			pRes->v[12] = *(float*) &Vals[i + 12];
			pRes->v[13] = *(float*) &Vals[i + 13];
			pRes->v[14] = *(float*) &Vals[i + 14];
			pRes->v[15] = *(float*) &Vals[i + 15]; // Minor prin
			p1 = *(float*) &Vals[i + 14];
			p2 = *(float*) &Vals[i + 15];
			vm = pow(p1 * p1 - p1 * p2 + p2 * p2, 0.5);
			pRes->v[16] = 0.5 * (p1 - p2);
			pRes->v[17] = vm;
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 34)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 15;
		ResultsSets[iNoRes]->lab[0] = "SA1";
		ResultsSets[iNoRes]->lab[1] = "SA2";
		ResultsSets[iNoRes]->lab[2] = "SA3";
		ResultsSets[iNoRes]->lab[3] = "SA4";
		ResultsSets[iNoRes]->lab[4] = "Axial";
		ResultsSets[iNoRes]->lab[5] = "SA maximum";
		ResultsSets[iNoRes]->lab[6] = "SA minimum";
		ResultsSets[iNoRes]->lab[7] = "Safety margin in tension*";
		ResultsSets[iNoRes]->lab[8] = "SB1";
		ResultsSets[iNoRes]->lab[9] = "SB2";
		ResultsSets[iNoRes]->lab[10] = "SB3";
		ResultsSets[iNoRes]->lab[11] = "SB4";
		ResultsSets[iNoRes]->lab[12] = "SB maximum";
		ResultsSets[iNoRes]->lab[13] = "SB minimum";
		ResultsSets[iNoRes]->lab[14] = "Safety margin in comp*";
		for (i = 10; i < iCnt; i += 16) {
			Res15* pRes = new Res15;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			pRes->v[8] = *(float*) &Vals[i + 9];
			pRes->v[9] = *(float*) &Vals[i + 10];
			pRes->v[10] = *(float*) &Vals[i + 11];
			pRes->v[11] = *(float*) &Vals[i + 12];
			pRes->v[12] = *(float*) &Vals[i + 13];
			pRes->v[13] = *(float*) &Vals[i + 14];
			pRes->v[14] = *(float*) &Vals[i + 15];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && ((ResultsSets[iNoRes]->TYPE == 95) || (ResultsSets[iNoRes]->TYPE == 97))) {
		double p1;
		double p2;
		double vm;
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 11;
		ResultsSets[iNoRes]->sOpName = "Layer ";
		ResultsSets[iNoRes]->iDefID = 1;
		ResultsSets[iNoRes]->iSecondaryID = 0;
		ResultsSets[iNoRes]->lab[0] = "Lamina Number";
		ResultsSets[iNoRes]->lab[1] = "Normal-1";
		ResultsSets[iNoRes]->lab[2] = "Normal-2";
		ResultsSets[iNoRes]->lab[3] = "Shear-12";
		ResultsSets[iNoRes]->lab[4] = "Shear-1Z";
		ResultsSets[iNoRes]->lab[5] = "Shear-2Z";
		ResultsSets[iNoRes]->lab[6] = "Shear angle";
		ResultsSets[iNoRes]->lab[7] = "Major principal*";
		ResultsSets[iNoRes]->lab[8] = "Minor principal";
		ResultsSets[iNoRes]->lab[9] = "Maximum shear";
		ResultsSets[iNoRes]->lab[10] = "Derived VM Stress";
		for (i = 10; i < iCnt; i += 11) {
			Res15* pRes = new Res15;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			pRes->v[8] = *(float*) &Vals[i + 9];
			pRes->v[9] = *(float*) &Vals[i + 10];
			p1 = *(float*) &Vals[i + 8];
			p2 = *(float*) &Vals[i + 9];
			vm = pow(p1 * p1 - p1 * p2 + p2 * p2, 0.5);
			pRes->v[10] = vm;
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 102)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 6;
		ResultsSets[iNoRes]->lab[0] = "Translation x";
		ResultsSets[iNoRes]->lab[1] = "Translation y";
		ResultsSets[iNoRes]->lab[2] = "Translation z";
		ResultsSets[iNoRes]->lab[3] = "Rotation x";
		ResultsSets[iNoRes]->lab[4] = "Rotation y";
		ResultsSets[iNoRes]->lab[5] = "Rotation z";
		for (i = 10; i < iCnt; i += 7) {
			Res6* pRes = new Res6;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 1)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 4;
		ResultsSets[iNoRes]->lab[0] = "Axial strain";
		ResultsSets[iNoRes]->lab[1] = "Axial safety margin*";
		ResultsSets[iNoRes]->lab[2] = "Torsional strain";
		ResultsSets[iNoRes]->lab[3] = "Torsional safety margin*";

		for (i = 10; i < iCnt; i += 5) {
			Res4* pRes = new Res4;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 67)) // CHEXA LIN STRESS
	{
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 189;
		ResultsSets[iNoRes]->lab[4 - 4] = "GRID0 ID";
		ResultsSets[iNoRes]->lab[25 - 4] = "GRID1 ID";
		ResultsSets[iNoRes]->lab[46 - 4] = "GRID2 ID";
		ResultsSets[iNoRes]->lab[67 - 4] = "GRID3 ID";
		ResultsSets[iNoRes]->lab[88 - 4] = "GRID4 ID";
		ResultsSets[iNoRes]->lab[109 - 4] = "GRID5 ID";
		ResultsSets[iNoRes]->lab[130 - 4] = "GRID6 ID";
		ResultsSets[iNoRes]->lab[151 - 4] = "GRID7 ID";
		ResultsSets[iNoRes]->lab[172 - 4] = "GRID8 ID";

		ResultsSets[iNoRes]->lab[1] = "Normal in x";
		ResultsSets[iNoRes]->lab[2] = "Shear in xy";
		ResultsSets[iNoRes]->lab[3] = "First principal stress";
		ResultsSets[iNoRes]->lab[4] = "First principal x cosine";
		ResultsSets[iNoRes]->lab[5] = "Second principal x cosine";
		ResultsSets[iNoRes]->lab[6] = "Third principal x cosine";
		ResultsSets[iNoRes]->lab[7] = "Mean pressure";
		ResultsSets[iNoRes]->lab[8] = "Octahedral shear stress";
		ResultsSets[iNoRes]->lab[9] = "Normal in y";
		ResultsSets[iNoRes]->lab[10] = "Shear in yz";
		ResultsSets[iNoRes]->lab[11] = "Second principal stress";
		ResultsSets[iNoRes]->lab[12] = "First principal y cosine";
		ResultsSets[iNoRes]->lab[13] = "Second principal y cosine";
		ResultsSets[iNoRes]->lab[14] = "Third principal y cosine";
		ResultsSets[iNoRes]->lab[15] = "Normal in z";
		ResultsSets[iNoRes]->lab[16] = "Shear in zx";
		ResultsSets[iNoRes]->lab[17] = "Third principal stress";
		ResultsSets[iNoRes]->lab[18] = "First principal z cosine";
		ResultsSets[iNoRes]->lab[19] = "Second principal z cosine";
		ResultsSets[iNoRes]->lab[20] = "Third principal z cosine";
		int j;
		for (i = 10; i < iCnt; i += 193) {
			Res189* pRes = new Res189;
			pRes->ID = Vals[i] / 10;
			pRes->iSID = Vals[i + 1];
			// pRes->sType="null";//Vals[i+2]
			pRes->iNoActive = Vals[i + 3];
			for (j = 4; j < 193; j++) {
				if ((j == 4) || (j == 25) || (j == 46) || (j == 67) || (j == 88) || (j == 109) || (j == 130) || (j == 151) || (j == 172)) {
					pRes->v[j - 4] = Vals[i + j];
				} else {
					pRes->v[j - 4] = *(float*) &Vals[i + j];
				}
			}
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 68)) // CPENTA LIN STRESS
	{
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 21;
		ResultsSets[iNoRes]->lab[4 - 4] = "GRID0 ID";
		ResultsSets[iNoRes]->lab[25 - 4] = "GRID1 ID";
		ResultsSets[iNoRes]->lab[46 - 4] = "GRID2 ID";
		ResultsSets[iNoRes]->lab[67 - 4] = "GRID3 ID";
		ResultsSets[iNoRes]->lab[88 - 4] = "GRID4 ID";
		ResultsSets[iNoRes]->lab[109 - 4] = "GRID5 ID";
		ResultsSets[iNoRes]->lab[130 - 4] = "GRID6 ID";
		ResultsSets[iNoRes]->lab[1] = "Normal in x";
		ResultsSets[iNoRes]->lab[2] = "Shear in xy";
		ResultsSets[iNoRes]->lab[3] = "First principal stress";
		ResultsSets[iNoRes]->lab[4] = "First principal x cosine";
		ResultsSets[iNoRes]->lab[5] = "Second principal x cosine";
		ResultsSets[iNoRes]->lab[6] = "Third principal x cosine";
		ResultsSets[iNoRes]->lab[7] = "Mean pressure";
		ResultsSets[iNoRes]->lab[8] = "Octahedral shear stress";
		ResultsSets[iNoRes]->lab[9] = "Normal in y";
		ResultsSets[iNoRes]->lab[10] = "Shear in yz";
		ResultsSets[iNoRes]->lab[11] = "Second principal stress";
		ResultsSets[iNoRes]->lab[12] = "First principal y cosine";
		ResultsSets[iNoRes]->lab[13] = "Second principal y cosine";
		ResultsSets[iNoRes]->lab[14] = "Third principal y cosine";
		ResultsSets[iNoRes]->lab[15] = "Normal in z";
		ResultsSets[iNoRes]->lab[16] = "Shear in zx";
		ResultsSets[iNoRes]->lab[17] = "Third principal stress";
		ResultsSets[iNoRes]->lab[18] = "First principal z cosine";
		ResultsSets[iNoRes]->lab[19] = "Second principal z cosine";
		ResultsSets[iNoRes]->lab[20] = "Third principal z cosine";
		int j;
		for (i = 10; i < iCnt; i += 151) {
			Res147* pRes = new Res147;
			pRes->ID = Vals[i] / 10;
			pRes->iSID = Vals[i + 1];
			// pRes->sType="null";//Vals[i+2]
			pRes->iNoActive = Vals[i + 3];
			for (j = 4; j < 151; j++) {
				if ((j == 4) || (j == 25) || (j == 46) || (j == 67) || (j == 88) || (j == 109) || (j == 130)) {
					pRes->v[j - 4] = Vals[i + j];
				} else {
					pRes->v[j - 4] = *(float*) &Vals[i + j];
				}
			}
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 39)) // CTETRA LIN STRESS
	{
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 21;
		ResultsSets[iNoRes]->lab[4 - 4] = "GRID0 ID";
		ResultsSets[iNoRes]->lab[25 - 4] = "GRID1 ID";
		ResultsSets[iNoRes]->lab[46 - 4] = "GRID2 ID";
		ResultsSets[iNoRes]->lab[67 - 4] = "GRID3 ID";
		ResultsSets[iNoRes]->lab[88 - 4] = "GRID4 ID";
		ResultsSets[iNoRes]->lab[1] = "Normal in x";
		ResultsSets[iNoRes]->lab[2] = "Shear in xy";
		ResultsSets[iNoRes]->lab[3] = "First principal stress";
		ResultsSets[iNoRes]->lab[4] = "First principal x cosine";
		ResultsSets[iNoRes]->lab[5] = "Second principal x cosine";
		ResultsSets[iNoRes]->lab[6] = "Third principal x cosine";
		ResultsSets[iNoRes]->lab[7] = "Mean pressure";
		ResultsSets[iNoRes]->lab[8] = "Octahedral shear stress";
		ResultsSets[iNoRes]->lab[9] = "Normal in y";
		ResultsSets[iNoRes]->lab[10] = "Shear in yz";
		ResultsSets[iNoRes]->lab[11] = "Second principal stress";
		ResultsSets[iNoRes]->lab[12] = "First principal y cosine";
		ResultsSets[iNoRes]->lab[13] = "Second principal y cosine";
		ResultsSets[iNoRes]->lab[14] = "Third principal y cosine";
		ResultsSets[iNoRes]->lab[15] = "Normal in z";
		ResultsSets[iNoRes]->lab[16] = "Shear in zx";
		ResultsSets[iNoRes]->lab[17] = "Third principal stress";
		ResultsSets[iNoRes]->lab[18] = "First principal z cosine";
		ResultsSets[iNoRes]->lab[19] = "Second principal z cosine";
		ResultsSets[iNoRes]->lab[20] = "Third principal z cosine";
		int j;
		for (i = 10; i < iCnt; i += 109) {
			Res105* pRes = new Res105;
			pRes->ID = Vals[i] / 10;
			pRes->iSID = Vals[i + 1];
			// pRes->sType="null";//Vals[i+2]
			pRes->iNoActive = Vals[i + 3];
			for (j = 4; j < 109; j++) {
				if ((j == 4) || (j == 25) || (j == 46) || (j == 67) || (j == 88)) {
					pRes->v[j - 4] = Vals[i + j];
				} else {
					pRes->v[j - 4] = *(float*) &Vals[i + j];
				}
			}
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	iNoRes++;
}

void ME_Object::AddOES1ResF(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName, double dF) {
	char s80[80];
	int i;
	int iWID = -1;
	int iFC = -1;
	ResultsSets[iNoRes] = new ResSet();
	ResultsSets[iNoRes]->sFile = inName;
	ResultsSets[iNoRes]->sTitle = sTitle;
	ResultsSets[iNoRes]->sSubTitle = sSubTitle;
	ResultsSets[iNoRes]->ACODE = Vals[0];
	ResultsSets[iNoRes]->TCODE = Vals[1];
	ResultsSets[iNoRes]->TYPE = Vals[2];
	ResultsSets[iNoRes]->LC = Vals[3];
	ResultsSets[iNoRes]->WID = Vals[6];
	iWID = ResultsSets[iNoRes]->WID;
	ResultsSets[iNoRes]->FCODE = Vals[7];
	iFC = ResultsSets[iNoRes]->FCODE;
	ResultsSets[iNoRes]->SCODE = Vals[8];
	CString sEL;
	BOOL isGood = FALSE;
	// Just reading shell element for now CQUAD and CTRIA
	if (Vals[2] == 33) {
		isGood = TRUE;
		sEL = "STRESS CENTRE CQUAD4";
	} else if (Vals[2] == 74) {
		isGood = TRUE;
		sEL = "STRESS CENTRE CTRIA3";
	} else {
		isGood = FALSE;
	}
	if ((iCnt > 10) && (isGood)) {
		sprintf_s(s80, "%s %g %s", sEL, dF, "Hz");
		ResultsSets[iNoRes]->sName = s80;
		ResultsSets[iNoRes]->iNoV = iWID - 1;
		if (iFC == 2) // Real and Imaginary
		{
			ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[1] = "(Re) Normal in x at Z1";
			ResultsSets[iNoRes]->lab[2] = "(Im) Normal in x at Z1";
			ResultsSets[iNoRes]->lab[3] = "(Re) Normal in y at Z1";
			ResultsSets[iNoRes]->lab[4] = "(Im) Normal in y at Z1";
			ResultsSets[iNoRes]->lab[5] = "(Re) Shear in xy at Z1";
			ResultsSets[iNoRes]->lab[6] = "(Im) Shear in xy at Z1";
			ResultsSets[iNoRes]->lab[7] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[8] = "(Re) Normal in x at Z2";
			ResultsSets[iNoRes]->lab[9] = "(Im) Normal in x at Z2";
			ResultsSets[iNoRes]->lab[10] = "(Re) Normal in y at Z2";
			ResultsSets[iNoRes]->lab[11] = "(Im)Normal in y at Z2";
			ResultsSets[iNoRes]->lab[12] = "(Re) Shear in xy at Z2";
			ResultsSets[iNoRes]->lab[13] = "(Im)Shear in xy at Z2";
		} else if (iFC == 3) // Magnitude and Phase
		{
			ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[1] = "(Mag) Normal in x at Z1";
			ResultsSets[iNoRes]->lab[2] = "(Phi) Normal in x at Z1";
			ResultsSets[iNoRes]->lab[3] = "(Mag) Normal in y at Z1";
			ResultsSets[iNoRes]->lab[4] = "(Phi) Normal in y at Z1";
			ResultsSets[iNoRes]->lab[5] = "(Re) Shear in xy at Z1";
			ResultsSets[iNoRes]->lab[6] = "(Phi) Shear in xy at Z1";
			ResultsSets[iNoRes]->lab[7] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[8] = "(Mag) Normal in x at Z2";
			ResultsSets[iNoRes]->lab[9] = "(Phi) Normal in x at Z2";
			ResultsSets[iNoRes]->lab[10] = "(Mag) Normal in y at Z2";
			ResultsSets[iNoRes]->lab[11] = "(Phi)Normal in y at Z2";
			ResultsSets[iNoRes]->lab[12] = "(Mag) Shear in xy at Z2";
			ResultsSets[iNoRes]->lab[13] = "(Phi)Shear in xy at Z2";
		}
		for (i = 10; i < iCnt; i += iWID) {
			Res13* pRes = new Res13;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			pRes->v[8] = *(float*) &Vals[i + 9];
			pRes->v[9] = *(float*) &Vals[i + 10];
			pRes->v[10] = *(float*) &Vals[i + 11];
			pRes->v[11] = *(float*) &Vals[i + 12];
			pRes->v[12] = *(float*) &Vals[i + 13];
			pRes->v[13] = *(float*) &Vals[i + 14];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	iNoRes++;
}

void ME_Object::AddOSTRResF(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName, double dF) {
	char s80[80];
	int i;
	int iWID = -1;
	int iFC = -1;
	ResultsSets[iNoRes] = new ResSet();
	ResultsSets[iNoRes]->sFile = inName;
	ResultsSets[iNoRes]->sTitle = sTitle;
	ResultsSets[iNoRes]->sSubTitle = sSubTitle;
	ResultsSets[iNoRes]->ACODE = Vals[0];
	ResultsSets[iNoRes]->TCODE = Vals[1];
	ResultsSets[iNoRes]->TYPE = Vals[2];
	ResultsSets[iNoRes]->LC = Vals[3];
	ResultsSets[iNoRes]->WID = Vals[6];
	iWID = ResultsSets[iNoRes]->WID;
	ResultsSets[iNoRes]->FCODE = Vals[7];
	iFC = ResultsSets[iNoRes]->FCODE;
	ResultsSets[iNoRes]->SCODE = Vals[8];
	CString sEL;
	BOOL isGood = FALSE;
	// Just reading shell element for now CQUAD and CTRIA
	if (Vals[2] == 33) {
		isGood = TRUE;
		sEL = "STRAIN CENTRE CQUAD4";
	} else if (Vals[2] == 74) {
		isGood = TRUE;
		sEL = "STRAIN CENTRE CTRIA3";
	} else {
		isGood = FALSE;
	}
	if ((iCnt > 10) && (isGood)) {
		sprintf_s(s80, "%s %g %s", sEL, dF, "Hz");
		ResultsSets[iNoRes]->sName = s80;
		ResultsSets[iNoRes]->iNoV = iWID - 1;
		if (iFC == 2) // Real and Imaginary
		{
			ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[1] = "(Re) Normal in x at Z1";
			ResultsSets[iNoRes]->lab[2] = "(Im) Normal in x at Z1";
			ResultsSets[iNoRes]->lab[3] = "(Re) Normal in y at Z1";
			ResultsSets[iNoRes]->lab[4] = "(Im) Normal in y at Z1";
			ResultsSets[iNoRes]->lab[5] = "(Re) Shear in xy at Z1";
			ResultsSets[iNoRes]->lab[6] = "(Im) Shear in xy at Z1";
			ResultsSets[iNoRes]->lab[7] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[8] = "(Re) Normal in x at Z2";
			ResultsSets[iNoRes]->lab[9] = "(Im) Normal in x at Z2";
			ResultsSets[iNoRes]->lab[10] = "(Re) Normal in y at Z2";
			ResultsSets[iNoRes]->lab[11] = "(Im)Normal in y at Z2";
			ResultsSets[iNoRes]->lab[12] = "(Re) Shear in xy at Z2";
			ResultsSets[iNoRes]->lab[13] = "(Im)Shear in xy at Z2";
		} else if (iFC == 3) // Magnitude and Phase
		{
			ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[1] = "(Mag) Normal in x at Z1";
			ResultsSets[iNoRes]->lab[2] = "(Phi) Normal in x at Z1";
			ResultsSets[iNoRes]->lab[3] = "(Mag) Normal in y at Z1";
			ResultsSets[iNoRes]->lab[4] = "(Phi) Normal in y at Z1";
			ResultsSets[iNoRes]->lab[5] = "(Re) Shear in xy at Z1";
			ResultsSets[iNoRes]->lab[6] = "(Phi) Shear in xy at Z1";
			ResultsSets[iNoRes]->lab[7] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[8] = "(Mag) Normal in x at Z2";
			ResultsSets[iNoRes]->lab[9] = "(Phi) Normal in x at Z2";
			ResultsSets[iNoRes]->lab[10] = "(Mag) Normal in y at Z2";
			ResultsSets[iNoRes]->lab[11] = "(Phi)Normal in y at Z2";
			ResultsSets[iNoRes]->lab[12] = "(Mag) Shear in xy at Z2";
			ResultsSets[iNoRes]->lab[13] = "(Phi)Shear in xy at Z2";
		}
		for (i = 10; i < iCnt; i += iWID) {
			Res13* pRes = new Res13;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			pRes->v[8] = *(float*) &Vals[i + 9];
			pRes->v[9] = *(float*) &Vals[i + 10];
			pRes->v[10] = *(float*) &Vals[i + 11];
			pRes->v[11] = *(float*) &Vals[i + 12];
			pRes->v[12] = *(float*) &Vals[i + 13];
			pRes->v[13] = *(float*) &Vals[i + 14];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	iNoRes++;
}

void ME_Object::AddOSTRRes(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName) {
	int i;

	ResultsSets[iNoRes] = new ResSet();
	ResultsSets[iNoRes]->sFile = inName;
	ResultsSets[iNoRes]->sTitle = sTitle;
	ResultsSets[iNoRes]->sSubTitle = sSubTitle;
	ResultsSets[iNoRes]->ACODE = Vals[0];
	ResultsSets[iNoRes]->TCODE = Vals[1];
	ResultsSets[iNoRes]->TYPE = Vals[2];
	ResultsSets[iNoRes]->LC = Vals[3];
	ResultsSets[iNoRes]->WID = Vals[6];
	ResultsSets[iNoRes]->FCODE = Vals[7];
	ResultsSets[iNoRes]->SCODE = Vals[8];
	CString sEL;
	BOOL isGood = FALSE;

	if (Vals[2] == 33) {
		isGood = TRUE;
		sEL = "STRAIN CQUAD4";
	} else if (Vals[2] == 74) {
		isGood = TRUE;
		sEL = "STRAIN CTRIA3";
	} else if (Vals[2] == 1) {
		sEL = "STRAIN CROD";
	} else if (Vals[2] == 102) {
		sEL = "STRAIN CBUSH";
	} else if (Vals[2] == 34) {
		sEL = "STRAIN CBAR";
	} else if (Vals[2] == 67) {
		sEL = "STRAIN CHEXA";
	} else if (Vals[2] == 39) {
		sEL = "STRAIN CTETRA";
	} else if (Vals[2] == 68) {
		sEL = "STRAIN CPENTA";
	} else if (Vals[2] == 95) {
		sEL = "STRAIN CQUAD LAYERED";
	} else if (Vals[2] == 97) {
		sEL = "STRAIN CTRIA LAYERED";
	}
	if ((iCnt > 10) && (isGood)) {
		double dX;
		double dY;
		double dXY;
		double vm;
		bool isLayered = FALSE;
		for (i = 10; i < iCnt; i += 17) {
			Res18* pRes = new Res18;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			if (i == 7) // Determine if data is Layered or Centre
			{
				if (pRes->v[0] != 0)
					isLayered = TRUE;
			}
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4] * 0.5;
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			// Derive VM stress from principles
			dX = *(float*) &Vals[i + 2];
			dY = *(float*) &Vals[i + 3];
			dXY = *(float*) &Vals[i + 4];
			vm = pow(0.44444444 * (dX * dX + dY * dY - dX * dY) + 0.33333333 * (dXY * dXY), 0.5);
			pRes->v[8] = vm;
			pRes->v[9] = *(float*) &Vals[i + 9];
			pRes->v[10] = *(float*) &Vals[i + 10];
			pRes->v[11] = *(float*) &Vals[i + 11];
			pRes->v[12] = *(float*) &Vals[i + 12] * 0.5;
			pRes->v[13] = *(float*) &Vals[i + 13];
			pRes->v[14] = *(float*) &Vals[i + 14];
			pRes->v[15] = *(float*) &Vals[i + 15];
			pRes->v[16] = *(float*) &Vals[i + 16];
			dX = *(float*) &Vals[i + 10];
			dY = *(float*) &Vals[i + 11];
			dXY = *(float*) &Vals[i + 12];
			vm = pow(0.44444444 * (dX * dX + dY * dY - dX * dY) + 0.33333333 * (dXY * dXY), 0.5);
			pRes->v[17] = vm;
			ResultsSets[iNoRes]->Add(pRes);
		}
		// Headers
		if (isLayered) {
			ResultsSets[iNoRes]->sName = sEL;
			ResultsSets[iNoRes]->iNoV = 18;
			ResultsSets[iNoRes]->lab[0] = "(Z1 Dist)";
			ResultsSets[iNoRes]->lab[1] = "(Z1) Normal in x";
			ResultsSets[iNoRes]->lab[2] = "(Z1) Normal in y";
			ResultsSets[iNoRes]->lab[3] = "(Z1) Shear in xy";
			ResultsSets[iNoRes]->lab[4] = "(Z1) Theta (Shear Angle)";
			ResultsSets[iNoRes]->lab[5] = "(Z1) Major Principal";
			ResultsSets[iNoRes]->lab[6] = "(Z1) Minor Principal";
			ResultsSets[iNoRes]->lab[7] = "(Z1) Maximum Shear";
			ResultsSets[iNoRes]->lab[8] = "(Z1) VM Strain";
			ResultsSets[iNoRes]->lab[9] = "(Z2 Dist)";
			ResultsSets[iNoRes]->lab[10] = "(Z2) Normal in x";
			ResultsSets[iNoRes]->lab[11] = "(Z2) Normal in y";
			ResultsSets[iNoRes]->lab[12] = "(Z2) Shear in xy";
			ResultsSets[iNoRes]->lab[13] = "(Z2) Theta (Shear Angle)";
			ResultsSets[iNoRes]->lab[14] = "(Z2) Major Principal";
			ResultsSets[iNoRes]->lab[15] = "(Z2) Minor Principal";
			ResultsSets[iNoRes]->lab[16] = "(Z2) Maximum Shear";
			ResultsSets[iNoRes]->lab[17] = "(Z2) VM Strain";
		} else {
			ResultsSets[iNoRes]->sName = sEL;
			ResultsSets[iNoRes]->iNoV = 18;
			ResultsSets[iNoRes]->lab[0] = "(Dist)";
			ResultsSets[iNoRes]->lab[1] = "(Mid) Normal in x";
			ResultsSets[iNoRes]->lab[2] = "(Mid) Normal in y";
			ResultsSets[iNoRes]->lab[3] = "(Mid) Shear in xy";
			ResultsSets[iNoRes]->lab[4] = "(Mid) Theta (Shear Angle)";
			ResultsSets[iNoRes]->lab[5] = "(Mid) Major Principal";
			ResultsSets[iNoRes]->lab[6] = "(Mid) Minor Principal";
			ResultsSets[iNoRes]->lab[7] = "(Mid) Maximum Shear";
			ResultsSets[iNoRes]->lab[8] = "(Mid) VM Strain";
			ResultsSets[iNoRes]->lab[9] = "(Dist)";
			ResultsSets[iNoRes]->lab[10] = "(Mid Curvature) Normal in x";
			ResultsSets[iNoRes]->lab[11] = "(Mid Curvature) Normal in y";
			ResultsSets[iNoRes]->lab[12] = "(Mid Curvature) Shear in xy";
			ResultsSets[iNoRes]->lab[13] = "(Mid Curvature) Theta (Shear Angle)";
			ResultsSets[iNoRes]->lab[14] = "(Mid Curvature) Major Principal";
			ResultsSets[iNoRes]->lab[15] = "(Mid Curvature) Minor Principal";
			ResultsSets[iNoRes]->lab[16] = "(Mid Curvature) Maximum Shear";
			ResultsSets[iNoRes]->lab[17] = "(Mid Curvature) VM Strain";
		}
		// Results vector definition
		ResDef* pVT;
		pVT = new ResDef();
		if (isLayered)
			pVT->sResType = "(Z1) 2d STRAIN";
		else
			pVT->sResType = "(Mid) 2d STRAIN";
		pVT->iResType = 3; // 2d Tensor
		pVT->iLoc = 1; // Element Centroid(cys global)
		pVT->iComponents[0] = 1;
		pVT->iComponents[1] = 2;
		pVT->iComponents[2] = 3;
		pVT->iComponents[3] = 5;
		pVT->iComponents[4] = 6;
		pVT->iCompNo = 5;
		pVT->GenDefualtHeaders();
		ResultsSets[iNoRes]->AddResDef(pVT);
		pVT = new ResDef();
		if (isLayered)
			pVT->sResType = "(Z2) 2d STRAIN";
		else
			pVT->sResType = "(Mid Curvature) 2d STRAIN";
		pVT->iResType = 3; // 2d Tensor
		pVT->iLoc = 1; // Element Centroid(cys global)
		pVT->iComponents[0] = 10;
		pVT->iComponents[1] = 11;
		pVT->iComponents[2] = 12;
		pVT->iComponents[3] = 14;
		pVT->iComponents[4] = 15;
		pVT->iCompNo = 5;
		pVT->GenDefualtHeaders();
		ResultsSets[iNoRes]->AddResDef(pVT);
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 34)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 15;
		ResultsSets[iNoRes]->lab[0] = "SA1";
		ResultsSets[iNoRes]->lab[1] = "SA2";
		ResultsSets[iNoRes]->lab[2] = "SA3";
		ResultsSets[iNoRes]->lab[3] = "SA4";
		ResultsSets[iNoRes]->lab[4] = "Axial";
		ResultsSets[iNoRes]->lab[5] = "SA maximum";
		ResultsSets[iNoRes]->lab[6] = "SA minimum";
		ResultsSets[iNoRes]->lab[7] = "Safety margin in tension*";
		ResultsSets[iNoRes]->lab[8] = "SB1";
		ResultsSets[iNoRes]->lab[9] = "SB2";
		ResultsSets[iNoRes]->lab[10] = "SB3";
		ResultsSets[iNoRes]->lab[11] = "SB4";
		ResultsSets[iNoRes]->lab[12] = "SB maximum";
		ResultsSets[iNoRes]->lab[13] = "SB minimum";
		ResultsSets[iNoRes]->lab[14] = "Safety margin in comp*";
		for (i = 10; i < iCnt; i += 16) {
			Res15* pRes = new Res15;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			pRes->v[8] = *(float*) &Vals[i + 9];
			pRes->v[9] = *(float*) &Vals[i + 10];
			pRes->v[10] = *(float*) &Vals[i + 11];
			pRes->v[11] = *(float*) &Vals[i + 12];
			pRes->v[12] = *(float*) &Vals[i + 13];
			pRes->v[13] = *(float*) &Vals[i + 14];
			pRes->v[14] = *(float*) &Vals[i + 15];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && ((ResultsSets[iNoRes]->TYPE == 95) || (ResultsSets[iNoRes]->TYPE == 97))) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 10;
		ResultsSets[iNoRes]->sOpName = "Layer ";
		ResultsSets[iNoRes]->iDefID = 1;
		ResultsSets[iNoRes]->iSecondaryID = 0;
		ResultsSets[iNoRes]->lab[0] = "Lamina Number";
		ResultsSets[iNoRes]->lab[1] = "Normal-1";
		ResultsSets[iNoRes]->lab[2] = "Normal-2";
		ResultsSets[iNoRes]->lab[3] = "Shear-12";
		ResultsSets[iNoRes]->lab[4] = "Shear-1Z";
		ResultsSets[iNoRes]->lab[5] = "Shear-2Z";
		ResultsSets[iNoRes]->lab[6] = "Shear angle";
		ResultsSets[iNoRes]->lab[7] = "Major principal*";
		ResultsSets[iNoRes]->lab[8] = "Minor principal";
		ResultsSets[iNoRes]->lab[9] = "von Mises or Maximum shear";
		for (i = 10; i < iCnt; i += 11) {
			Res15* pRes = new Res15;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			pRes->v[8] = *(float*) &Vals[i + 9];
			pRes->v[9] = *(float*) &Vals[i + 10];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 102)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 6;
		ResultsSets[iNoRes]->lab[0] = "Translation x";
		ResultsSets[iNoRes]->lab[1] = "Translation y";
		ResultsSets[iNoRes]->lab[2] = "Translation z";
		ResultsSets[iNoRes]->lab[3] = "Rotation x";
		ResultsSets[iNoRes]->lab[4] = "Rotation y";
		ResultsSets[iNoRes]->lab[5] = "Rotation z";
		for (i = 10; i < iCnt; i += 7) {
			Res6* pRes = new Res6;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 1)) {
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 4;
		ResultsSets[iNoRes]->lab[0] = "Axial strain";
		ResultsSets[iNoRes]->lab[1] = "Axial safety margin*";
		ResultsSets[iNoRes]->lab[2] = "Torsional strain";
		ResultsSets[iNoRes]->lab[3] = "Torsional safety margin*";

		for (i = 10; i < iCnt; i += 5) {
			Res4* pRes = new Res4;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = *(float*) &Vals[i + 1];
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 67)) // CHEXA LIN STRESS
	{
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 189;
		ResultsSets[iNoRes]->lab[4 - 4] = "GRID0 ID";
		ResultsSets[iNoRes]->lab[25 - 4] = "GRID1 ID";
		ResultsSets[iNoRes]->lab[46 - 4] = "GRID2 ID";
		ResultsSets[iNoRes]->lab[67 - 4] = "GRID3 ID";
		ResultsSets[iNoRes]->lab[88 - 4] = "GRID4 ID";
		ResultsSets[iNoRes]->lab[109 - 4] = "GRID5 ID";
		ResultsSets[iNoRes]->lab[130 - 4] = "GRID6 ID";
		ResultsSets[iNoRes]->lab[151 - 4] = "GRID7 ID";
		ResultsSets[iNoRes]->lab[172 - 4] = "GRID8 ID";

		ResultsSets[iNoRes]->lab[1] = "Normal in x";
		ResultsSets[iNoRes]->lab[2] = "Shear in xy";
		ResultsSets[iNoRes]->lab[3] = "First principal strain";
		ResultsSets[iNoRes]->lab[4] = "First principal x cosine";
		ResultsSets[iNoRes]->lab[5] = "Second principal x cosine";
		ResultsSets[iNoRes]->lab[6] = "Third principal x cosine";
		ResultsSets[iNoRes]->lab[7] = "Mean pressure";
		ResultsSets[iNoRes]->lab[8] = "Octahedral shear strain";
		ResultsSets[iNoRes]->lab[9] = "Normal in y";
		ResultsSets[iNoRes]->lab[10] = "Shear in yz";
		ResultsSets[iNoRes]->lab[11] = "Second principal strain";
		ResultsSets[iNoRes]->lab[12] = "First principal y cosine";
		ResultsSets[iNoRes]->lab[13] = "Second principal y cosine";
		ResultsSets[iNoRes]->lab[14] = "Third principal y cosine";
		ResultsSets[iNoRes]->lab[15] = "Normal in z";
		ResultsSets[iNoRes]->lab[16] = "Shear in zx";
		ResultsSets[iNoRes]->lab[17] = "Third principal strain";
		ResultsSets[iNoRes]->lab[18] = "First principal z cosine";
		ResultsSets[iNoRes]->lab[19] = "Second principal z cosine";
		ResultsSets[iNoRes]->lab[20] = "Third principal z cosine";
		int j;
		for (i = 10; i < iCnt; i += 193) {
			Res189* pRes = new Res189;
			pRes->ID = Vals[i] / 10;
			pRes->iSID = Vals[i + 1];
			// pRes->sType="null";//Vals[i+2]
			pRes->iNoActive = Vals[i + 3];
			for (j = 4; j < 193; j++) {
				if ((j == 4) || (j == 25) || (j == 46) || (j == 67) || (j == 88) || (j == 109) || (j == 130) || (j == 151) || (j == 172)) {
					pRes->v[j - 4] = Vals[i + j];
				} else {
					pRes->v[j - 4] = *(float*) &Vals[i + j];
				}
			}
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 68)) // CPENTA LIN STRESS
	{
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 21;
		ResultsSets[iNoRes]->lab[4 - 4] = "GRID0 ID";
		ResultsSets[iNoRes]->lab[25 - 4] = "GRID1 ID";
		ResultsSets[iNoRes]->lab[46 - 4] = "GRID2 ID";
		ResultsSets[iNoRes]->lab[67 - 4] = "GRID3 ID";
		ResultsSets[iNoRes]->lab[88 - 4] = "GRID4 ID";
		ResultsSets[iNoRes]->lab[109 - 4] = "GRID5 ID";
		ResultsSets[iNoRes]->lab[130 - 4] = "GRID6 ID";
		ResultsSets[iNoRes]->lab[1] = "Normal in x";
		ResultsSets[iNoRes]->lab[2] = "Shear in xy";
		ResultsSets[iNoRes]->lab[3] = "First principal strain";
		ResultsSets[iNoRes]->lab[4] = "First principal x cosine";
		ResultsSets[iNoRes]->lab[5] = "Second principal x cosine";
		ResultsSets[iNoRes]->lab[6] = "Third principal x cosine";
		ResultsSets[iNoRes]->lab[7] = "Mean pressure";
		ResultsSets[iNoRes]->lab[8] = "Octahedral shear strain";
		ResultsSets[iNoRes]->lab[9] = "Normal in y";
		ResultsSets[iNoRes]->lab[10] = "Shear in yz";
		ResultsSets[iNoRes]->lab[11] = "Second principal strain";
		ResultsSets[iNoRes]->lab[12] = "First principal y cosine";
		ResultsSets[iNoRes]->lab[13] = "Second principal y cosine";
		ResultsSets[iNoRes]->lab[14] = "Third principal y cosine";
		ResultsSets[iNoRes]->lab[15] = "Normal in z";
		ResultsSets[iNoRes]->lab[16] = "Shear in zx";
		ResultsSets[iNoRes]->lab[17] = "Third principal strain";
		ResultsSets[iNoRes]->lab[18] = "First principal z cosine";
		ResultsSets[iNoRes]->lab[19] = "Second principal z cosine";
		ResultsSets[iNoRes]->lab[20] = "Third principal z cosine";
		int j;
		for (i = 10; i < iCnt; i += 151) {
			Res147* pRes = new Res147;
			pRes->ID = Vals[i] / 10;
			pRes->iSID = Vals[i + 1];
			// pRes->sType="null";//Vals[i+2]
			pRes->iNoActive = Vals[i + 3];
			for (j = 4; j < 151; j++) {
				if ((j == 4) || (j == 25) || (j == 46) || (j == 67) || (j == 88) || (j == 109) || (j == 130)) {
					pRes->v[j - 4] = Vals[i + j];
				} else {
					pRes->v[j - 4] = *(float*) &Vals[i + j];
				}
			}
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	if ((iCnt > 7) && (ResultsSets[iNoRes]->TYPE == 39)) // CTETRA LIN STRESS
	{
		ResultsSets[iNoRes]->sName = sEL;
		ResultsSets[iNoRes]->iNoV = 21;
		ResultsSets[iNoRes]->lab[4 - 4] = "GRID0 ID";
		ResultsSets[iNoRes]->lab[25 - 4] = "GRID1 ID";
		ResultsSets[iNoRes]->lab[46 - 4] = "GRID2 ID";
		ResultsSets[iNoRes]->lab[67 - 4] = "GRID3 ID";
		ResultsSets[iNoRes]->lab[88 - 4] = "GRID4 ID";
		ResultsSets[iNoRes]->lab[1] = "Normal in x";
		ResultsSets[iNoRes]->lab[2] = "Shear in xy";
		ResultsSets[iNoRes]->lab[3] = "First principal strain";
		ResultsSets[iNoRes]->lab[4] = "First principal x cosine";
		ResultsSets[iNoRes]->lab[5] = "Second principal x cosine";
		ResultsSets[iNoRes]->lab[6] = "Third principal x cosine";
		ResultsSets[iNoRes]->lab[7] = "Mean pressure";
		ResultsSets[iNoRes]->lab[8] = "Octahedral shear strain";
		ResultsSets[iNoRes]->lab[9] = "Normal in y";
		ResultsSets[iNoRes]->lab[10] = "Shear in yz";
		ResultsSets[iNoRes]->lab[11] = "Second principal strain";
		ResultsSets[iNoRes]->lab[12] = "First principal y cosine";
		ResultsSets[iNoRes]->lab[13] = "Second principal y cosine";
		ResultsSets[iNoRes]->lab[14] = "Third principal y cosine";
		ResultsSets[iNoRes]->lab[15] = "Normal in z";
		ResultsSets[iNoRes]->lab[16] = "Shear in zx";
		ResultsSets[iNoRes]->lab[17] = "Third principal strain";
		ResultsSets[iNoRes]->lab[18] = "First principal z cosine";
		ResultsSets[iNoRes]->lab[19] = "Second principal z cosine";
		ResultsSets[iNoRes]->lab[20] = "Third principal z cosine";
		int j;
		for (i = 10; i < iCnt; i += 109) {
			Res105* pRes = new Res105;
			pRes->ID = Vals[i] / 10;
			pRes->iSID = Vals[i + 1];
			// pRes->sType="null";//Vals[i+2]
			pRes->iNoActive = Vals[i + 3];
			for (j = 4; j < 109; j++) {
				if ((j == 4) || (j == 25) || (j == 46) || (j == 67) || (j == 88)) {
					pRes->v[j - 4] = Vals[i + j];
				} else {
					pRes->v[j - 4] = *(float*) &Vals[i + j];
				}
			}
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	iNoRes++;
}

void ME_Object::AddONRGRes(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName) {
	int i;
	if (iCnt > 5) {
		ResultsSets[iNoRes] = new ResSet();
		ResultsSets[iNoRes]->sFile = inName;
		ResultsSets[iNoRes]->sTitle = sTitle;
		ResultsSets[iNoRes]->sSubTitle = sSubTitle;
		ResultsSets[iNoRes]->ACODE = Vals[0];
		ResultsSets[iNoRes]->TCODE = Vals[1];
		ResultsSets[iNoRes]->TYPE = Vals[2];
		ResultsSets[iNoRes]->LC = Vals[3];
		ResultsSets[iNoRes]->WID = Vals[6];
		ResultsSets[iNoRes]->FCODE = Vals[7];
		ResultsSets[iNoRes]->SCODE = Vals[8];
		CString sEL;
		BOOL isGood = FALSE;
		if (Vals[2] == 90) {
			isGood = TRUE;
			sEL = "STRAIN ENERGY CQUAD4";
		} else if (Vals[2] == 88) {
			isGood = TRUE;
			sEL = "STRAIN ENERGY CTRIA3";
		}

		isGood = TRUE;
		sEL = "STRAIN ENERGY";

		if ((iCnt > 10) && (isGood)) {
			ResultsSets[iNoRes]->sName = sEL;
			ResultsSets[iNoRes]->iNoV = 3;
			ResultsSets[iNoRes]->lab[0] = "Energy";
			ResultsSets[iNoRes]->lab[1] = "Energy % Tot";
			ResultsSets[iNoRes]->lab[2] = "Energy Density";
			for (i = 10; i < iCnt; i += 4) {
				Res3* pRes = new Res3;
				pRes->ID = Vals[i] / 10;
				pRes->v[0] = *(float*) &Vals[i + 1];
				pRes->v[1] = *(float*) &Vals[i + 2];
				pRes->v[2] = *(float*) &Vals[i + 3];
				ResultsSets[iNoRes]->Add(pRes);
			}
		}
		iNoRes++;
	}
}

void ME_Object::AddOESNRes(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName) {
	int i;
	if (iCnt > 5) {
		ResultsSets[iNoRes] = new ResSet();
		ResultsSets[iNoRes]->sFile = inName;
		ResultsSets[iNoRes]->sTitle = sTitle;
		ResultsSets[iNoRes]->sSubTitle = sSubTitle;
		ResultsSets[iNoRes]->ACODE = Vals[0];
		ResultsSets[iNoRes]->TCODE = Vals[1];
		ResultsSets[iNoRes]->TYPE = Vals[2];
		ResultsSets[iNoRes]->LC = Vals[3];
		ResultsSets[iNoRes]->WID = Vals[6];
		ResultsSets[iNoRes]->FCODE = Vals[7];
		ResultsSets[iNoRes]->SCODE = Vals[8];
		CString sEL;
		BOOL isGood = FALSE;
		if (Vals[2] == 90) {
			isGood = TRUE;
			sEL = "STRESS NONLIN CENTRE CQUAD4";
		} else if (Vals[2] == 88) {
			isGood = TRUE;
			sEL = "STRESS NONLIN CENTRE CTRIA3";
		}

		if ((iCnt > 10) && (isGood)) {
			ResultsSets[iNoRes]->sName = sEL;
			ResultsSets[iNoRes]->iNoV = 24;
			ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[1] = "Stress in x at Z1";
			ResultsSets[iNoRes]->lab[2] = "Stress in y at Z1";
			ResultsSets[iNoRes]->lab[3] = "UNDEF";
			ResultsSets[iNoRes]->lab[4] = "Shear stress in xy at Z1";
			ResultsSets[iNoRes]->lab[5] = "Equivalent stress at Z1";
			ResultsSets[iNoRes]->lab[6] = "Effective plastic/nlelastic strain at Z1";
			ResultsSets[iNoRes]->lab[7] = "Effective creep strain at Z1";
			ResultsSets[iNoRes]->lab[8] = "Strain in x at Z1";
			ResultsSets[iNoRes]->lab[9] = "Strain in y at Z1";
			ResultsSets[iNoRes]->lab[10] = "UNDEF";
			ResultsSets[iNoRes]->lab[11] = "Shear strain in xy at Z1";
			ResultsSets[iNoRes]->lab[12] = "Z2 = Fibre distance";
			ResultsSets[iNoRes]->lab[13] = "Stress in x at Z2";
			ResultsSets[iNoRes]->lab[14] = "Stress in y at Z2";
			ResultsSets[iNoRes]->lab[15] = "UNDEF";
			ResultsSets[iNoRes]->lab[16] = "Shear stress in xy at Z2";
			ResultsSets[iNoRes]->lab[17] = "Equivalent stress at Z2";
			ResultsSets[iNoRes]->lab[18] = "Effective plastic/nlelastic strain at Z2";
			ResultsSets[iNoRes]->lab[19] = "Effective creep strain at Z2";
			ResultsSets[iNoRes]->lab[20] = "Strain in x at Z2";
			ResultsSets[iNoRes]->lab[21] = "Strain in y at Z2";
			ResultsSets[iNoRes]->lab[22] = "UNDEF";
			ResultsSets[iNoRes]->lab[23] = "Shear strain in xy at Z2";
			for (i = 10; i < iCnt; i += 25) {
				Res24* pRes = new Res24;
				pRes->ID = Vals[i] / 10;
				pRes->v[0] = *(float*) &Vals[i + 1];
				pRes->v[1] = *(float*) &Vals[i + 2];
				pRes->v[2] = *(float*) &Vals[i + 3];
				pRes->v[3] = *(float*) &Vals[i + 4];
				pRes->v[4] = *(float*) &Vals[i + 5];
				pRes->v[5] = *(float*) &Vals[i + 6];
				pRes->v[6] = *(float*) &Vals[i + 7];
				pRes->v[7] = *(float*) &Vals[i + 8];
				pRes->v[8] = *(float*) &Vals[i + 9];
				pRes->v[9] = *(float*) &Vals[i + 10];
				pRes->v[10] = *(float*) &Vals[i + 11];
				pRes->v[11] = *(float*) &Vals[i + 12];
				pRes->v[12] = *(float*) &Vals[i + 13];
				pRes->v[13] = *(float*) &Vals[i + 14];
				pRes->v[14] = *(float*) &Vals[i + 15];
				pRes->v[15] = *(float*) &Vals[i + 16];
				pRes->v[16] = *(float*) &Vals[i + 17];
				pRes->v[17] = *(float*) &Vals[i + 18];
				pRes->v[18] = *(float*) &Vals[i + 19];
				pRes->v[19] = *(float*) &Vals[i + 20];
				pRes->v[20] = *(float*) &Vals[i + 21];
				pRes->v[21] = *(float*) &Vals[i + 22];
				pRes->v[22] = *(float*) &Vals[i + 23];
				pRes->v[23] = *(float*) &Vals[i + 24];
				ResultsSets[iNoRes]->Add(pRes);
			}
		}
		iNoRes++;
	}
}

void ME_Object::AddOESResR(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName) {
	int i;
	double ds11;
	double ds22;
	double ds12;
	double dvmMax;
	double dvm;
	if (iCnt > 5) {
		ResultsSets[iNoRes] = new ResSet();
		ResultsSets[iNoRes]->sFile = inName;
		ResultsSets[iNoRes]->sTitle = sTitle;
		ResultsSets[iNoRes]->sSubTitle = sSubTitle;
		ResultsSets[iNoRes]->ACODE = Vals[0];
		ResultsSets[iNoRes]->TCODE = Vals[1];
		ResultsSets[iNoRes]->TYPE = Vals[2];
		ResultsSets[iNoRes]->LC = Vals[3];
		ResultsSets[iNoRes]->WID = Vals[6];
		ResultsSets[iNoRes]->FCODE = Vals[7];
		ResultsSets[iNoRes]->SCODE = Vals[8];
		CString sEL;
		BOOL isGood = FALSE;
		if (Vals[2] == 33) {
			isGood = TRUE;
			sEL = "RMS STRESS CENTRE CQUAD4";
		} else if (Vals[2] == 74) {
			isGood = TRUE;
			sEL = "RMS STRESS CENTRE CTRIA3";
		}

		if ((iCnt > 10) && (isGood)) {
			ResultsSets[iNoRes]->sName = sEL;
			ResultsSets[iNoRes]->iNoV = 11;
			ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[1] = "Normal X at Z1";
			ResultsSets[iNoRes]->lab[2] = "Normal Y at Z1";
			ResultsSets[iNoRes]->lab[3] = "Shear stress in xy at Z1";
			ResultsSets[iNoRes]->lab[4] = "Thales VM at Z1";
			ResultsSets[iNoRes]->lab[5] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[6] = "Normal X at Z2";
			ResultsSets[iNoRes]->lab[7] = "Normal Y at Z2";
			ResultsSets[iNoRes]->lab[8] = "Shear stress in xy at Z2";
			ResultsSets[iNoRes]->lab[9] = "Thales VM at Z2";
			ResultsSets[iNoRes]->lab[10] = "Thales Max VM at Z1 & Z2";
			for (i = 10; i < iCnt; i += 9) {
				Res11* pRes = new Res11;
				pRes->ID = Vals[i] / 10;
				pRes->v[0] = *(float*) &Vals[i + 1];
				pRes->v[1] = *(float*) &Vals[i + 2];
				pRes->v[2] = *(float*) &Vals[i + 3];
				pRes->v[3] = *(float*) &Vals[i + 4];
				ds11 = pRes->v[1];
				ds22 = pRes->v[2];
				ds12 = pRes->v[3];
				// For proper RMS VM see Pitoiset e.a. [1]
				// dvm = pow((ds11 * ds11 - ds11 * ds22 + ds22 * ds22 + 3 * ds12 * ds12), 0.5);
				// Note the + where - would be but this is Thales method for
				// RMS VM note all values are +ve
				dvm = pow((ds11 * ds11 + ds11 * ds22 + ds22 * ds22 + 3 * ds12 * ds12), 0.5);
				pRes->v[4] = dvm;
				pRes->v[5] = *(float*) &Vals[i + 5];
				pRes->v[6] = *(float*) &Vals[i + 6];
				pRes->v[7] = *(float*) &Vals[i + 7];
				pRes->v[8] = *(float*) &Vals[i + 8];
				ds11 = pRes->v[6];
				ds22 = pRes->v[7];
				ds12 = pRes->v[8];
				dvmMax = dvm;
				dvm = pow((ds11 * ds11 + ds11 * ds22 + ds22 * ds22 + 3 * ds12 * ds12), 0.5);
				pRes->v[9] = dvm;
				if (dvm > dvmMax)
					dvmMax = dvm;
				pRes->v[10] = dvmMax;
				ResultsSets[iNoRes]->Add(pRes);
			}
		}
		iNoRes++;
	}
}

void ME_Object::AddOSTRResR(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName, double dFreq) {
	int i;
	double ds11;
	double ds22;
	double ds12;
	double dvmMax;
	double dvm;
	if (iCnt > 5) {
		ResultsSets[iNoRes] = new ResSet();
		ResultsSets[iNoRes]->sFile = inName;
		ResultsSets[iNoRes]->sTitle = sTitle;
		ResultsSets[iNoRes]->sSubTitle = sSubTitle;
		ResultsSets[iNoRes]->ACODE = Vals[0];
		ResultsSets[iNoRes]->TCODE = Vals[1];
		ResultsSets[iNoRes]->TYPE = Vals[2];
		ResultsSets[iNoRes]->LC = Vals[3];
		ResultsSets[iNoRes]->WID = Vals[6];
		ResultsSets[iNoRes]->FCODE = Vals[7];
		ResultsSets[iNoRes]->SCODE = Vals[8];
		CString sEL;
		BOOL isGood = FALSE;
		if (Vals[2] == 33) {
			isGood = TRUE;
			sEL = "RMS STRAIN CENTRE CQUAD4";
		} else if (Vals[2] == 74) {
			isGood = TRUE;
			sEL = "RMS STRAIN CENTRE CTRIA3";
		}

		if ((iCnt > 10) && (isGood)) {
			if (ResultsSets[iNoRes]->SCODE == 10) {
				// Strain curvature maximum shear or octahedral
				ResultsSets[iNoRes]->sName = sEL;
				ResultsSets[iNoRes]->iNoV = 11;
				ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
				ResultsSets[iNoRes]->lab[1] = "Normal X at Z0";
				ResultsSets[iNoRes]->lab[2] = "Normal Y at Z0";
				ResultsSets[iNoRes]->lab[3] = "Shear strain in xy at Z0";
				ResultsSets[iNoRes]->lab[4] = "void";
				ResultsSets[iNoRes]->lab[5] = "Z2 = Fibre distance";
				ResultsSets[iNoRes]->lab[6] = "Curvature X at Z0";
				ResultsSets[iNoRes]->lab[7] = "Curvature Y at Z0";
				ResultsSets[iNoRes]->lab[8] = "Curvature in xy at Z0";
				ResultsSets[iNoRes]->lab[9] = "void";
				ResultsSets[iNoRes]->lab[10] = "void";
			} else if (ResultsSets[iNoRes]->SCODE == 14) {
				// Strain fiber maimum shear or octahedral
				ResultsSets[iNoRes]->sName = sEL;
				ResultsSets[iNoRes]->iNoV = 11;
				ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
				ResultsSets[iNoRes]->lab[1] = "Normal X at Z1";
				ResultsSets[iNoRes]->lab[2] = "Normal Y at Z1";
				ResultsSets[iNoRes]->lab[3] = "Shear strain in xy at Z1";
				ResultsSets[iNoRes]->lab[4] = "Thales VM at Z1";
				ResultsSets[iNoRes]->lab[5] = "Z1 = Fibre distance";
				ResultsSets[iNoRes]->lab[6] = "Normal X at Z2";
				ResultsSets[iNoRes]->lab[7] = "Normal Y at Z2";
				ResultsSets[iNoRes]->lab[8] = "Shear strain in xy at Z2";
				ResultsSets[iNoRes]->lab[9] = "Thales VM at Z2";
				ResultsSets[iNoRes]->lab[10] = "Thales Max VM at Z1 & Z2";
			} else {
				ResultsSets[iNoRes]->sName = sEL;
				ResultsSets[iNoRes]->iNoV = 11;
				ResultsSets[iNoRes]->lab[0] = "error void";
				ResultsSets[iNoRes]->lab[1] = "error void";
				ResultsSets[iNoRes]->lab[2] = "error void";
				ResultsSets[iNoRes]->lab[3] = "error void";
				ResultsSets[iNoRes]->lab[4] = "error void";
				ResultsSets[iNoRes]->lab[5] = "error void";
				ResultsSets[iNoRes]->lab[6] = "error void";
				ResultsSets[iNoRes]->lab[7] = "error void";
				ResultsSets[iNoRes]->lab[8] = "error void";
				ResultsSets[iNoRes]->lab[9] = "error void";
				ResultsSets[iNoRes]->lab[10] = "error void";
			}
			for (i = 10; i < iCnt; i += 9) {
				Res11* pRes = new Res11;
				pRes->ID = Vals[i] / 10;
				pRes->v[0] = *(float*) &Vals[i + 1];
				pRes->v[1] = *(float*) &Vals[i + 2];
				pRes->v[2] = *(float*) &Vals[i + 3];
				pRes->v[3] = *(float*) &Vals[i + 4];
				ds11 = pRes->v[1];
				ds22 = pRes->v[2];
				ds12 = pRes->v[3];
				// For proper RMS VM see Pitoiset e.a. [1]
				// dvm = pow((ds11 * ds11 - ds11 * ds22 + ds22 * ds22 + 3 * ds12 * ds12), 0.5);
				// Note the + where - would be but this is Thales method for
				// GRMS VM note all values are +ve
				dvm = pow((ds11 * ds11 + ds11 * ds22 + ds22 * ds22 + 3 * ds12 * ds12), 0.5);
				pRes->v[4] = dvm;
				pRes->v[5] = *(float*) &Vals[i + 5];
				pRes->v[6] = *(float*) &Vals[i + 6];
				pRes->v[7] = *(float*) &Vals[i + 7];
				pRes->v[8] = *(float*) &Vals[i + 8];
				ds11 = pRes->v[6];
				ds22 = pRes->v[7];
				ds12 = pRes->v[8];
				dvmMax = dvm;
				dvm = pow((ds11 * ds11 + ds11 * ds22 + ds22 * ds22 + 3 * ds12 * ds12), 0.5);
				pRes->v[9] = dvm;
				if (dvm > dvmMax)
					dvmMax = dvm;
				pRes->v[10] = dvmMax;
				ResultsSets[iNoRes]->Add(pRes);
			}
		}
		iNoRes++;
	}
}

void ME_Object::AddOSTRFCPXRes(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName, double dFreq) {
	int i;

	if (iCnt > 5) {
		ResultsSets[iNoRes] = new ResSet();
		ResultsSets[iNoRes]->sFile = inName;
		ResultsSets[iNoRes]->sTitle = sTitle;
		ResultsSets[iNoRes]->sSubTitle = sSubTitle;
		ResultsSets[iNoRes]->ACODE = Vals[0];
		ResultsSets[iNoRes]->TCODE = Vals[1];
		ResultsSets[iNoRes]->TYPE = Vals[2];
		ResultsSets[iNoRes]->LC = Vals[3];
		ResultsSets[iNoRes]->WID = Vals[6];
		ResultsSets[iNoRes]->FCODE = Vals[7];
		ResultsSets[iNoRes]->SCODE = Vals[8];
		CString sEL;
		char s30[30];
		BOOL isGood = FALSE;
		// FCODE = 2  Real/imaginary
		// FCODE = 3  Magnitude/phase
		if (Vals[2] == 33) {
			isGood = TRUE;
			if (Vals[0] / 10 == 5) // It's a frequency results
			{
				sprintf_s(s30, "%g %s", dFreq, "Hz STRAIN CQUAD4");
				sEL = s30;
			} else {
				sEL = "STRAIN GRMS CQUAD4";
			}
		}

		if ((iCnt > 10) && (isGood)) {
			ResultsSets[iNoRes]->sName = sEL;
			ResultsSets[iNoRes]->iNoV = 14;
			ResultsSets[iNoRes]->lab[0] = "Z1 = Fibre distance";
			ResultsSets[iNoRes]->lab[1] = "Re Normal X at Z1";
			ResultsSets[iNoRes]->lab[2] = "Im Normal X at Z1";
			ResultsSets[iNoRes]->lab[3] = "Re Normal Y at Z1";
			ResultsSets[iNoRes]->lab[4] = "Im Normal Y at Z1";
			ResultsSets[iNoRes]->lab[5] = "Re Shear XY at Z1";
			ResultsSets[iNoRes]->lab[6] = "Im Shear XY at Z1";
			ResultsSets[iNoRes]->lab[7] = "Z2 = Fibre distance";
			ResultsSets[iNoRes]->lab[8] = "Re Normal X at Z2";
			ResultsSets[iNoRes]->lab[9] = "Im Normal X at Z2";
			ResultsSets[iNoRes]->lab[10] = "Re Normal Y at Z2";
			ResultsSets[iNoRes]->lab[11] = "Im Normal Y at Z2";
			ResultsSets[iNoRes]->lab[12] = "Re Shear XY at Z2";
			ResultsSets[iNoRes]->lab[13] = "Im Shear XY at Z2";
			for (i = 10; i < iCnt; i += 15) {
				Res15* pRes = new Res15;
				pRes->ID = Vals[i] / 10;
				pRes->v[0] = *(float*) &Vals[i + 1];
				pRes->v[1] = *(float*) &Vals[i + 2];
				pRes->v[2] = *(float*) &Vals[i + 3];
				pRes->v[3] = *(float*) &Vals[i + 4];
				pRes->v[4] = *(float*) &Vals[i + 5];
				pRes->v[5] = *(float*) &Vals[i + 6];
				pRes->v[6] = *(float*) &Vals[i + 7];
				pRes->v[7] = *(float*) &Vals[i + 8];
				pRes->v[8] = *(float*) &Vals[i + 9];
				pRes->v[9] = *(float*) &Vals[i + 10];
				pRes->v[10] = *(float*) &Vals[i + 11];
				pRes->v[11] = *(float*) &Vals[i + 12];
				pRes->v[12] = *(float*) &Vals[i + 13];
				pRes->v[13] = *(float*) &Vals[i + 14];
				ResultsSets[iNoRes]->Add(pRes);
			}
		}
		iNoRes++;
	}
}

void ME_Object::AddOAG1Res(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName, double dF) {
	int i;
	char s30[30];
	// BuildNodeList();
	C3dVector vT;
	C3dVector vR;

	ResultsSets[iNoRes] = new ResSet();
	//***********************************************
	ResultsSets[iNoRes]->sFile = inName;
	ResultsSets[iNoRes]->sTitle = sTitle;
	ResultsSets[iNoRes]->sSubTitle = sSubTitle;
	ResultsSets[iNoRes]->ACODE = Vals[0];
	ResultsSets[iNoRes]->TCODE = Vals[1];
	ResultsSets[iNoRes]->TYPE = Vals[2];
	ResultsSets[iNoRes]->LC = Vals[3];
	ResultsSets[iNoRes]->WID = Vals[6];
	ResultsSets[iNoRes]->FCODE = Vals[7];
	ResultsSets[iNoRes]->SCODE = Vals[8];
	// ModeNo = *(float*)& Vals[4];
	// ModeFreq = *(float*)&Vals[5];
	// ModeFreq = pow(ModeFreq, 0.5) / (3.14159265359 * 2);
	ResultsSets[iNoRes]->i1 = 0;
	ResultsSets[iNoRes]->dFreq = dF;
	ResultsSets[iNoRes]->WID = Vals[6];

	if (iCnt > 10) {
		sprintf_s(s30, "%s %g %s", "ACCEL", dF, "Hz");
		ResultsSets[iNoRes]->sName = s30;
		ResultsSets[iNoRes]->iNoV = 13;
		if (ResultsSets[iNoRes]->FCODE == 3) {
			// MAG / PHASE
			ResultsSets[iNoRes]->lab[0] = "Freq";
			ResultsSets[iNoRes]->lab[1] = "TX";
			ResultsSets[iNoRes]->lab[2] = "TY";
			ResultsSets[iNoRes]->lab[3] = "TZ";
			ResultsSets[iNoRes]->lab[4] = "RX";
			ResultsSets[iNoRes]->lab[5] = "RY";
			ResultsSets[iNoRes]->lab[6] = "RZ";
			ResultsSets[iNoRes]->lab[7] = "(Phi) X";
			ResultsSets[iNoRes]->lab[8] = "(Phi) Y";
			ResultsSets[iNoRes]->lab[9] = "(Phi) Z";
			ResultsSets[iNoRes]->lab[10] = "(Phi) RX";
			ResultsSets[iNoRes]->lab[11] = "(Phi) RY";
			ResultsSets[iNoRes]->lab[12] = "(Phi) RZ";
			//**********Define the Vector********************
			ResDef* pVT = new ResDef();
			pVT->sResType = "ACCEL TRANS MAG VEC";
			pVT->iResType = 1; // Vector Forec Magnitude Translation
			pVT->iLoc = 0; // Element
			pVT->iComponents[0] = 1;
			pVT->iComponents[1] = 2;
			pVT->iComponents[2] = 3;
			pVT->iComponents[3] = -1;
			pVT->iCompNo = 4;
			pVT->GenDefualtHeaders();
			ResultsSets[iNoRes]->AddResDef(pVT);
		} else // REAL - IMAGINARY
		{
			ResultsSets[iNoRes]->lab[0] = "Freq";
			ResultsSets[iNoRes]->lab[1] = "TX";
			ResultsSets[iNoRes]->lab[2] = "TY";
			ResultsSets[iNoRes]->lab[3] = "TZ";
			ResultsSets[iNoRes]->lab[4] = "RX";
			ResultsSets[iNoRes]->lab[5] = "RY";
			ResultsSets[iNoRes]->lab[6] = "RZ";
			ResultsSets[iNoRes]->lab[7] = "(j) X";
			ResultsSets[iNoRes]->lab[8] = "(j) Y";
			ResultsSets[iNoRes]->lab[9] = "(j) Z";
			ResultsSets[iNoRes]->lab[10] = "(j) RX";
			ResultsSets[iNoRes]->lab[11] = "(j) RY";
			ResultsSets[iNoRes]->lab[12] = "(j) RZ";
		}
		for (i = 10; i < iCnt; i += 14) {
			Res13* pRes = new Res13;
			pRes->ID = Vals[i] / 10;
			pRes->v[0] = dF;
			pRes->v[1] = *(float*) &Vals[i + 2];
			pRes->v[2] = *(float*) &Vals[i + 3];
			pRes->v[3] = *(float*) &Vals[i + 4];
			pRes->v[4] = *(float*) &Vals[i + 5];
			pRes->v[5] = *(float*) &Vals[i + 6];
			pRes->v[6] = *(float*) &Vals[i + 7];
			pRes->v[7] = *(float*) &Vals[i + 8];
			pRes->v[8] = *(float*) &Vals[i + 9];
			pRes->v[9] = *(float*) &Vals[i + 10];
			pRes->v[10] = *(float*) &Vals[i + 11];
			pRes->v[11] = *(float*) &Vals[i + 12];
			pRes->v[12] = *(float*) &Vals[i + 13];
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	// DeleteNodeList();
	iNoRes++;
}

void ME_Object::AddOQMRes(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName, double dF) {
	int i;
	char s30[30];
	// BuildNodeList();
	C3dVector vT;
	C3dVector vR;

	ResultsSets[iNoRes] = new ResSet();
	//***********************************************
	ResultsSets[iNoRes]->sFile = inName;
	ResultsSets[iNoRes]->sTitle = sTitle;
	ResultsSets[iNoRes]->sSubTitle = sSubTitle;
	ResultsSets[iNoRes]->ACODE = Vals[0];
	ResultsSets[iNoRes]->TCODE = Vals[1];
	ResultsSets[iNoRes]->TYPE = Vals[2];
	ResultsSets[iNoRes]->LC = Vals[3];
	ResultsSets[iNoRes]->WID = Vals[6];
	ResultsSets[iNoRes]->FCODE = Vals[7];
	ResultsSets[iNoRes]->SCODE = Vals[8];
	// ModeNo = *(float*)& Vals[4];
	// ModeFreq = *(float*)&Vals[5];
	// ModeFreq = pow(ModeFreq, 0.5) / (3.14159265359 * 2);
	ResultsSets[iNoRes]->i1 = 0;
	ResultsSets[iNoRes]->dFreq = dF;
	ResultsSets[iNoRes]->WID = Vals[6];

	if (iCnt > 10) {
		if (ResultsSets[iNoRes]->ACODE / 10 == 5) // Frequency
		{
			sprintf_s(s30, "%s %g %s", "MPCF", dF, "Hz");
			ResultsSets[iNoRes]->sName = s30;
			ResultsSets[iNoRes]->iNoV = 13;
			if (ResultsSets[iNoRes]->FCODE == 3) {
				// MAG / PHASE
				ResultsSets[iNoRes]->lab[0] = "Freq";
				ResultsSets[iNoRes]->lab[1] = "TX";
				ResultsSets[iNoRes]->lab[2] = "TY";
				ResultsSets[iNoRes]->lab[3] = "TZ";
				ResultsSets[iNoRes]->lab[4] = "RX";
				ResultsSets[iNoRes]->lab[5] = "RY";
				ResultsSets[iNoRes]->lab[6] = "RZ";
				ResultsSets[iNoRes]->lab[7] = "(Phi) X";
				ResultsSets[iNoRes]->lab[8] = "(Phi) Y";
				ResultsSets[iNoRes]->lab[9] = "(Phi) Z";
				ResultsSets[iNoRes]->lab[10] = "(Phi) RX";
				ResultsSets[iNoRes]->lab[11] = "(Phi) RY";
				ResultsSets[iNoRes]->lab[12] = "(Phi) RZ";
				//**********Define the Vector********************
				ResDef* pVT = new ResDef();
				pVT->sResType = "MPC FORCE TRANS MAG VEC";
				pVT->iResType = 1; // Vector Forec Magnitude Translation
				pVT->iLoc = 0; // Node
				pVT->iComponents[0] = 1;
				pVT->iComponents[1] = 2;
				pVT->iComponents[2] = 3;
				pVT->iComponents[3] = -1;
				pVT->iCompNo = 4;
				pVT->GenDefualtHeaders();
				ResultsSets[iNoRes]->AddResDef(pVT);
			} else // REAL - IMAGINARY
			{
				ResultsSets[iNoRes]->lab[0] = "Freq";
				ResultsSets[iNoRes]->lab[1] = "TX";
				ResultsSets[iNoRes]->lab[2] = "TY";
				ResultsSets[iNoRes]->lab[3] = "TZ";
				ResultsSets[iNoRes]->lab[4] = "RX";
				ResultsSets[iNoRes]->lab[5] = "RY";
				ResultsSets[iNoRes]->lab[6] = "RZ";
				ResultsSets[iNoRes]->lab[7] = "(j) X";
				ResultsSets[iNoRes]->lab[8] = "(j) Y";
				ResultsSets[iNoRes]->lab[9] = "(j) Z";
				ResultsSets[iNoRes]->lab[10] = "(j) RX";
				ResultsSets[iNoRes]->lab[11] = "(j) RY";
				ResultsSets[iNoRes]->lab[12] = "(j) RZ";
			}
			for (i = 10; i < iCnt; i += 14) {
				Res13* pRes = new Res13;
				pRes->ID = Vals[i] / 10;
				pRes->v[0] = dF;
				pRes->v[1] = *(float*) &Vals[i + 2];
				pRes->v[2] = *(float*) &Vals[i + 3];
				pRes->v[3] = *(float*) &Vals[i + 4];
				pRes->v[4] = *(float*) &Vals[i + 5];
				pRes->v[5] = *(float*) &Vals[i + 6];
				pRes->v[6] = *(float*) &Vals[i + 7];
				pRes->v[7] = *(float*) &Vals[i + 8];
				pRes->v[8] = *(float*) &Vals[i + 9];
				pRes->v[9] = *(float*) &Vals[i + 10];
				pRes->v[10] = *(float*) &Vals[i + 11];
				pRes->v[11] = *(float*) &Vals[i + 12];
				pRes->v[12] = *(float*) &Vals[i + 13];
				ResultsSets[iNoRes]->Add(pRes);
			}
		} else if (ResultsSets[iNoRes]->ACODE / 10 == 1) // Static
		{
			sprintf_s(s30, "%s", "MPCF");
			ResultsSets[iNoRes]->sName = s30;
			ResultsSets[iNoRes]->iNoV = 6;
			ResultsSets[iNoRes]->lab[0] = "TX";
			ResultsSets[iNoRes]->lab[1] = "TY";
			ResultsSets[iNoRes]->lab[2] = "TZ";
			ResultsSets[iNoRes]->lab[3] = "RX";
			ResultsSets[iNoRes]->lab[4] = "RY";
			ResultsSets[iNoRes]->lab[5] = "RZ";
			for (i = 10; i < iCnt; i += 8) {
				Res6* pRes = new Res6;
				pRes->ID = Vals[i] / 10;
				pRes->v[0] = *(float*) &Vals[i + 2];
				pRes->v[1] = *(float*) &Vals[i + 3];
				pRes->v[2] = *(float*) &Vals[i + 4];
				pRes->v[3] = *(float*) &Vals[i + 5];
				pRes->v[4] = *(float*) &Vals[i + 6];
				pRes->v[5] = *(float*) &Vals[i + 7];
				ResultsSets[iNoRes]->Add(pRes);
			}
		}
	}
	// DeleteNodeList();
	iNoRes++;
}

void ME_Object::AddOUGRes(int Vals[], int iCnt, CString sTitle, CString sSubTitle, CString inName) {
	int i;
	char s30[30];
	int ModeNo;
	float ModeFreq;
	BuildNodeList();
	C3dVector vT;
	C3dVector vR;
	Node* pND;
	int iRID;
	ResultsSets[iNoRes] = new ResSet();
	//**********Define the Vector********************
	ResDef* pVT = new ResDef();
	pVT->sResType = "DISP TRANS VEC";
	pVT->iResType = 1; // Vector Translation
	pVT->iLoc = 0; // Nodal
	pVT->iComponents[0] = 0;
	pVT->iComponents[1] = 1;
	pVT->iComponents[2] = 2;
	pVT->iComponents[3] = -1;
	pVT->iCompNo = 4;
	pVT->GenDefualtHeaders();
	ResDef* pVR = new ResDef();
	pVR->sResType = "DISP ROTA VEC";
	pVR->iResType = 1; // Vector Rotation
	pVR->iLoc = 0; // Nodal
	pVR->iComponents[0] = 3;
	pVR->iComponents[1] = 4;
	pVR->iComponents[2] = 5;
	pVR->iComponents[3] = -1;
	pVT->iCompNo = 4;
	pVT->GenDefualtHeaders();
	ResultsSets[iNoRes]->AddResDef(pVT);
	ResultsSets[iNoRes]->AddResDef(pVR);
	//***********************************************
	ResultsSets[iNoRes]->sFile = inName;
	ResultsSets[iNoRes]->sTitle = sTitle;
	ResultsSets[iNoRes]->sSubTitle = sSubTitle;
	ResultsSets[iNoRes]->ACODE = Vals[0];
	ResultsSets[iNoRes]->TCODE = Vals[1];
	ResultsSets[iNoRes]->TYPE = Vals[2];
	ResultsSets[iNoRes]->LC = Vals[3];
	ResultsSets[iNoRes]->WID = Vals[6];
	ResultsSets[iNoRes]->FCODE = Vals[7];
	ResultsSets[iNoRes]->SCODE = Vals[8];
	ModeNo = Vals[4];
	ModeFreq = *(float*) &Vals[5];
	ModeFreq = pow(ModeFreq, 0.5) / (3.14159265359 * 2);
	ResultsSets[iNoRes]->i1 = ModeNo;
	ResultsSets[iNoRes]->d1 = ModeFreq;
	ResultsSets[iNoRes]->WID = Vals[6];

	if (iCnt > 10) {
		if (ResultsSets[iNoRes]->ACODE == 22) // Modes
			sprintf_s(s30, "DISP MODE %g", ResultsSets[iNoRes]->d1);
		else
			sprintf_s(s30, "%s", "DISPLACEMENT");
		ResultsSets[iNoRes]->sName = s30;
		ResultsSets[iNoRes]->iNoV = 6;
		ResultsSets[iNoRes]->lab[0] = "TX";
		ResultsSets[iNoRes]->lab[1] = "TY";
		ResultsSets[iNoRes]->lab[2] = "TZ";
		ResultsSets[iNoRes]->lab[3] = "RX";
		ResultsSets[iNoRes]->lab[4] = "RY";
		ResultsSets[iNoRes]->lab[5] = "RZ";
		for (i = 10; i < iCnt; i += 8) {
			Res6* pRes = new Res6;
			pRes->ID = Vals[i] / 10;
			if (pRes->ID < 99999999)
				pND = (Node*) TempList->Objs[pRes->ID];
			else
				pND = GetNode(pRes->ID);
			iRID = 0;
			if (pND == NULL) {
				pND = GetNode(pRes->ID);
			}
			if (pND != NULL) {
				iRID = pND->OutSys;
			}
			vT.x = *(float*) &Vals[i + 2];
			vT.y = *(float*) &Vals[i + 3];
			vT.z = *(float*) &Vals[i + 4];
			vR.x = *(float*) &Vals[i + 5];
			vR.y = *(float*) &Vals[i + 6];
			vR.z = *(float*) &Vals[i + 7];

			if (iRID != 0) {
				// do
				//{
				iRID = VecToGlobal(pND, vT, iRID);
				iRID = VecToGlobal(pND, vR, iRID);
				// iRID=NodeToGlobal(vR,iRID);
				// } while (iRID > 0);
			}

			pRes->v[0] = vT.x;
			pRes->v[1] = vT.y;
			pRes->v[2] = vT.z;
			pRes->v[3] = vR.x;
			pRes->v[4] = vR.y;
			pRes->v[5] = vR.z;
			ResultsSets[iNoRes]->Add(pRes);
		}
	}
	DeleteNodeList();
	iNoRes++;
}

void ME_Object::ListResSets() {
	int i;
	char buff[80];
	outtext1("RESULTS LISTING:-");
	for (i = 0; i < iNoRes; i++) {
		sprintf_s(buff, "%3i%s%8i%s%s", i, " : LC ", ResultsSets[i]->LC, " ", ResultsSets[i]->sName);
		outtext1(buff);
	}
}

void ME_Object::ListVecSets() {
	int i;
	int j;
	char buff[80];
	outtext1("AVAILABLE RESULTS VECTOR:-");
	for (i = 0; i < iNoRes; i++) {
		sprintf_s(buff, "%s%8i%s%8i%s%s", "RES SET ", i, " LC ", ResultsSets[i]->LC, " ", ResultsSets[i]->sName);
		outtext1(buff);
		if (ResultsSets[i]->iNoResDef > 0) {
			for (j = 0; j < ResultsSets[i]->iNoResDef; j++) {
				sprintf_s(buff, "   %i,%i : %s", i, j, ResultsSets[i]->ResDefintion[j]->sResType);
				outtext1(buff);
			}
		}
	}
}

void ME_Object::ListResSet() {
	int i;
	char buff[80];
	outtext1("CURRENT RESULTS LISTING:-");
	if ((iCurResSet < iNoRes) && (iCurResSet >= 0)) {
		sprintf(buff, "%3i%s%8i%s%s", iCurResSet, " : LC ", ResultsSets[iCurResSet]->LC, " ",
		        ResultsSets[iCurResSet]->sName);
		outtext1(buff);
		outtext1("Variable:-");
		for (i = 0; i < ResultsSets[iCurResSet]->iNoV; i++) {
			sprintf_s(buff, "%3i%s%s", i, " : ", ResultsSets[iCurResSet]->lab[i]);
			outtext1(buff);
		}
		sprintf_s(buff, "%s%s", "Current variable : ", ResultsSets[iCurResSet]->lab[iResVal]);
		outtext1(buff);
		sprintf_s(buff, "%s%f", "Max Value : ", fMaxRes);
		outtext1(buff);
		sprintf_s(buff, "%s%f", "Min Value : ", fMinRes);
		outtext1(buff);
	} else {
		outtext1("WARNING: No Results Selected.");
	}
}

void ME_Object::SetCurrentResSet(int iRS, int iRV, int iOPT) {
	if ((iRS < iNoRes) && (iRV >= 0)) {
		iCurResSet = iRS;
		iResVal = 0;

		if ((iRV < ResultsSets[iCurResSet]->iNoV) && (iRV >= 0)) {
			iResVal = iRV;
			PostContourVals(ResultsSets[iCurResSet], iResVal, iOPT, fMaxRes, fMinRes);
		} else {
			outtext1("WARNING: Invalid Variable ID.");
			PostContourVals(ResultsSets[iCurResSet], iResVal, iOPT, fMaxRes, fMinRes);
		}
	} else {
		outtext1("WARNING: Invalid LC ID.");
	}
}

void ME_Object::WriteResHead(int iDspFlgs, float dW, float dH) {
	char sLab[200];
	if ((iCurResSet > -1) && (CResSet != NULL)) {
		sprintf_s(sLab, "%s", ResultsSets[iCurResSet]->sName);
		OglString(iDspFlgs, -dW + 0.02 * dW, dH - 0.1 * dH, 100, &sLab[0]);
		sprintf_s(sLab, "%s %i %s", "Solution :", ResultsSets[iCurResSet]->LC, ResultsSets[iCurResSet]->sTitle);
		OglString(iDspFlgs, -dW + 0.02 * dW, dH - 0.2 * dH, 100, &sLab[0]);
		if (ResultsSets[iCurResSet]->ACODE == 22)
			sprintf_s(sLab, "%s %i %g Hz", "MODE :", ResultsSets[iCurResSet]->i1, ResultsSets[iCurResSet]->d1);
		else
			sprintf_s(sLab, "%s %i %s", "Step :", ResultsSets[iCurResSet]->LC, ResultsSets[iCurResSet]->sSubTitle);
		OglString(iDspFlgs, -dW + 0.02 * dW, dH - 0.3 * dH, 100, &sLab[0]);
		sprintf_s(sLab, "%s %s %s %i", "Variable  :", ResultsSets[iCurResSet]->lab[iResVal],
		          ResultsSets[iCurResSet]->sOpName, iPostOpt);
		OglString(iDspFlgs, -dW + 0.02 * dW, dH - 0.4 * dH, 100, &sLab[0]);
		sprintf_s(sLab, "%s %f", "Max Value :", ResultsSets[iCurResSet]->fMaxV);
		OglString(iDspFlgs, -dW + 0.02 * dW, dH - 0.5 * dH, 100, &sLab[0]);
		sprintf_s(sLab, "%s %f", "Min Value :", ResultsSets[iCurResSet]->fMinV);
		OglString(iDspFlgs, -dW + 0.02 * dW, dH - 0.6 * dH, 100, &sLab[0]);
	}
}

//*************************************************************
//  LIST RESPONSE DATA FOR FREQUENCY ANALYSIS
//  List respose for loadcase LC
//  and for node or element iEnt
void ME_Object::ResListRespData(int iEnt) {
	int i;
	int j;
	char buff[200];
	ResSet* pRS;
	Res* pR;
	CString sDL;
	BOOL bFirst = TRUE;
	outtext1("RESPONSE LISTING:-");
	int iTCode = -1;
	int iLC2 = -1;
	iTCode = ResultsSets[iCurResSet]->TCODE;
	iLC2 = ResultsSets[iCurResSet]->LC;
	for (i = 0; i < iNoRes; i++) {
		if ((ResultsSets[i]->LC == iLC2) && (iTCode == ResultsSets[i]->TCODE)) {
			pRS = ResultsSets[i];
			if (pRS->ACODE / 10 == 5) // Frequncy data
			{
				if (bFirst) {
					outtext1(pRS->sTitle);
					outtext1(pRS->sSubTitle);
					sprintf_s(buff, "%s%i	%s%i", "LC", pRS->LC, "ID", iEnt);
					outtext1(buff);
					// sDL = pRS->ToStringHead();
					sprintf_s(buff, "%s	%s", pRS->lab[0], pRS->lab[iResVal]);
					outtext1(buff);
					bFirst = FALSE;
				}

				pR = pRS->Head;
				for (j = 0; j < pRS->iCnt; j++) {
					if (pR->ID == iEnt) {
						// sDL = pRS->ToStringDL(pR);
						sprintf_s(buff, "%g	%g", *pR->GetAddress(0), *pR->GetAddress(iResVal));
						outtext1(buff);
						break;
					}
					pR = pR->next;
				}
			}
		}
	}
}

//*************************************************************
//  Label nodes and elements where response data can be plotted
//*************************************************************
void ME_Object::ResLabRespItems() {
	int i;
	int j;
	char buff[200];
	ResSet* pRS = NULL;
	Res* pR = NULL;
	int iTCode = -1;
	int iLC = -1;
	Node* oND = NULL;
	E_Object* oEl = NULL;
	NEList* LCGp = new NEList();
	NEList* oIDS = new NEList();
	LCGp->iNo = 0;
	for (i = 0; i < iNoRes; i++) {
		iLC = ResultsSets[i]->LC;
		iTCode = ResultsSets[i]->TCODE;
		// TCODE 1039 Node MPC
		if ((iTCode == 1039) && (!LCGp->IsIn(iLC))) {
			LCGp->Add(iLC, 1);
			sprintf_s(buff, "%s %i %s", "CHECKING LC", iLC, "MPC FORCE FOR RESPONSE NODES");
			outtext1(buff);
			pRS = ResultsSets[i];
			pR = pRS->Head;
			for (j = 0; j < pRS->iCnt; j++) {
				if (!oIDS->IsIn(pR->ID))
					oIDS->Add(pR->ID, 1);
				pR = pR->next;
			}
		}
	}

	LCGp->iNo = 0;
	for (i = 0; i < iNoRes; i++) {
		iLC = ResultsSets[i]->LC;
		iTCode = ResultsSets[i]->TCODE;
		// TCODE 1039 Node MPC
		if ((iTCode == 1011) && (!LCGp->IsIn(iLC))) {
			LCGp->Add(iLC, 1);
			sprintf_s(buff, "%s %i %s", "CHECKING LC", iLC, "ACCEL FOR RESPONSE NODES");
			outtext1(buff);
			pRS = ResultsSets[i];
			pR = pRS->Head;
			for (j = 0; j < pRS->iCnt; j++) {
				if (!oIDS->IsIn(pR->ID))
					oIDS->Add(pR->ID, 1);
				pR = pR->next;
			}
		}
	}
	// Print node where response data has been found,
	outtext1("Available Response Nodes:-");
	for (i = 0; i < oIDS->iNo; i++) {
		if (oIDS->iNo < 50) {
			sprintf_s(buff, "NODE	%i", oIDS->ids[i]);
			outtext1(buff);
		}
		oND = this->GetNode(oIDS->ids[i]);
		if (oND != NULL)
			oND->bDrawLab = !oND->bDrawLab;
	}

	LCGp->iNo = 0;
	oIDS->iNo = 0;
	for (i = 0; i < iNoRes; i++) {
		iLC = ResultsSets[i]->LC;
		iTCode = ResultsSets[i]->TCODE;
		// TCODE 1039 Node MPC
		if ((iTCode == 1004) && (!LCGp->IsIn(iLC))) {
			LCGp->Add(iLC, 1);
			sprintf_s(buff, "%s %i %s", "CHECKING LC", iLC, "FORCES FOR RESPONSE ELEMENTS");
			outtext1(buff);
			pRS = ResultsSets[i];
			pR = pRS->Head;
			for (j = 0; j < pRS->iCnt; j++) {
				if (!oIDS->IsIn(pR->ID))
					oIDS->Add(pR->ID, 1);
				pR = pR->next;
			}
		}
	}
	outtext1("Available Response Elements:-");
	for (i = 0; i < oIDS->iNo; i++) {
		if (oIDS->iNo < 50) {
			sprintf_s(buff, "ELEMENT	%i", oIDS->ids[i]);
			outtext1(buff);
		}
		oEl = this->GetElement(oIDS->ids[i]);
		if (oEl != NULL)
			oEl->bDrawLab = !oEl->bDrawLab;
	}

	delete (LCGp);
	delete (oIDS);
}

//*************************************************************
//  LIST RESPONSE DATA FOR FREQUENCY ANALYSIS
//  LC and Type to list are taken from the active LC
//  For node or element iEnt
void ME_Object::ResListRespDataFull(int iEnt) {
	int i;
	int j;
	char buff[200];
	ResSet* pRS;
	Res* pR;
	CString sDL;
	BOOL bFirst = TRUE;
	outtext1("RESPONSE LISTING:-");
	int iTCode = -1;
	int iLC2 = -1;
	iTCode = ResultsSets[iCurResSet]->TCODE;
	iLC2 = ResultsSets[iCurResSet]->LC;
	for (i = 0; i < iNoRes; i++) {
		if ((ResultsSets[i]->LC == iLC2) && (iTCode == ResultsSets[i]->TCODE)) {
			pRS = ResultsSets[i];
			if (pRS->ACODE / 10 == 5) // Frequncy data
			{
				if (bFirst) {
					outtext1(pRS->sTitle);
					outtext1(pRS->sSubTitle);
					sprintf_s(buff, "%s	%i	%s	%i	", "LC", pRS->LC, "ID", iEnt);
					outtext1(buff);
					sDL = pRS->ToStringHead();
					outtext1(sDL);
					bFirst = FALSE;
				}

				pR = pRS->Head;
				for (j = 0; j < pRS->iCnt; j++) {
					if (pR->ID == iEnt) {
						sDL = pRS->ToStringDL(pR);
						outtext1(sDL);
						break;
					}
					pR = pR->next;
				}
			}
		}
	}
}

void ME_Object::SetDefScale(double dS) {
	dScale = dS;
}

void ME_Object::SetDefScaleVec(double dS) {
	dScaleVec = dS;
}

void ME_Object::SetCurrentResSetDef(int iRS, int iRV) {
	if ((iRS < iNoRes) && (iRS > -1) && (iRV >= -1)) {
		iCurResSetDef = iRS;
		iResValDef = -1;
		if ((iRV < ResultsSets[iCurResSetDef]->iNoV) && (iRV >= -1)) {
			iResValDef = iRV;
			PostElResDef(ResultsSets[iCurResSetDef], iResValDef, fMaxRes, fMinRes);
		}
	} else {
		outtext1("WARNING: Invalid LC ID.");
	}
}

// void  ME_Object::SolveLidCav()
//{
// int i,j;
// double dt=0.001;
// double dX;
// double dY;
// dList X;
// dList Y;
// int indi;
// int indj;
// int iNJ;
// int iNI;
////Mesh building
// for (i=0;i<iNdNo;i++)
//{
//   X.AddEx(pNodes[i]->Pt_Point->x);
//   Y.AddEx(pNodes[i]->Pt_Point->y);
// }
// X.Sort();
// Y.Sort();
//
// iNJ = 2 * Y.iNo - 1
// iNI = 2 * X.iNo - 1
//
// Matrix <int> A(X.iNo,Y.iNo);
// for(i=0;i<A.m;i++){for(j=0;j<A.n;j++){A(i,j) = 0;}}
//
////Store the pressure point node IDs
// for (i=0;i<iNdNo;i++)
//{
//   indj=X.IsIn(pNodes[i]->Pt_Point->x);
//   indi=Y.IsIn(pNodes[i]->Pt_Point->y);
//   A(indi,indj)=pNodes[i]->iLabel;
// }
//
// Matrix <double> Sol(Y.iNo+2,X.iNo);
// Matrix <double> Diff(Y.iNo+2,X.iNo);
//
// for(i=0;i<Sol.m;i++){for(j=0;j<Sol.n;j++){Sol(i,j) = 0;}}
// for(i=0;i<Sol.m;i++){for(j=0;j<Sol.n;j++){Diff(i,j) = 0;}}
////Test Case BD
// Pt_Object* pNd;
// pNd=this->GetNode(78);
// indj=X.IsIn(pNd->Pt_Point->x);
// indi=Y.IsIn(pNd->Pt_Point->y);
// int isUCalc=-1;
////Begin of solution
// int k;
////This is the cavity lid driven test case
//
////
// for (k=0;k<5000;k++)
//{
//
//   BCCavLid2(Sol);
//   BCCavLid(Sol);
//   isUCalc=-1;
//   //Sol.elem(indi+1,indj+1)=30;
//   for (i=2;i<Y.iNo;i++)
//   {
//     for (j=2;j<X.iNo;j++)
//     {
//       if (isUCalc==-1)
//       {
//         if (j%2!=0)
//         {
//           CalcU2(Sol,i,j);
//         }
//
//       }
//       else
//       {
//         if (j%2==0)
//         {
//           CalcV2(Sol,i,j);
//         }
//       }
//     }
//     isUCalc*=-1;
//   }
//  //Presures and velocity Corrections Diff
//
//   int il;
//   for(i=0;i<Diff.m;i++){for(j=0;j<Diff.n;j++){Diff(i,j) = 0;}}
//   for (il=0;il<50;il++)
//   {
//     for (i=2;i<Y.iNo-1;i++)
//     {
//       for (j=2;j<X.iNo-1;j++)
//       {
//           if ((j%2==0) && (i%2==0))
//           {
//             CalcP(Sol,Diff,i,j);
//           }
//       }
//     }
//   }
//   int isUCalc=-1;
//   //Velocity Corretions
//   /*for (i=2;i<Diff.m-2;i++)
//   {
//     for (j=2;j<Diff.n-2;j++)
//     {
//       if (isUCalc==-1)
//       {
//         if (j%2!= 0)
//         {
//           Diff.elem(i,j)=(Diff.elem(i,j+1)-Diff.elem(i,j-1))/(dX*dt);
//         }
//
//       }
//       else
//       {
//         if (j%2==0)
//         {
//           Diff.elem(i,j)=(Diff.elem(i+1,j)-Diff.elem(i-1,j))/(dY*dt);
//         }
//       }
//     }
//     isUCalc*=-1;
//   }*/
//   for(i=0;i<A.m;i++)
//   {
//     for(j=0;j<A.n;j++)
//     {
//          Sol(i,j) += 0.1*Diff(i,j);
//     }
//   }
// }
////DiagNostics
// Sol.diag();
// Diff.diag();
// A.DeleteAll();
// Sol.DeleteAll();
//
//----------------------------------------------------------------------------
//     E L E M E N T   O B J E C T
//----------------------------------------------------------------------------

//*********************************************
// String extration procedures for build WG Proc
//*********************************************

int ExtractRad(CString inS, double* dRad) {
	int iRet = 1;
	int i1;
	int i2;

	CString sR;
	CString sVec;

	i1 = inS.Find("Bend Rad=");
	sVec = inS.Right(inS.GetLength() - i1 - 9);
	i2 = sVec.Find("(Angle");
	sVec = sVec.Left(i2);
	*dRad = atof(sVec) / 1000;
	return (iRet);
}

int ExtractTwistLen(CString inS, double* dTw) {
	int iRet = 1;
	int i1;
	int i2;

	CString sR;
	CString sVec;

	i1 = inS.Find("MM");
	if (i1 < 0) {
		i1 = inS.Find("mm");
	}
	sVec = inS.Left(i1);
	i2 = sVec.ReverseFind('_');
	sVec = sVec.Right(sVec.GetLength() - i2 - 1);
	*dTw = atof(sVec) / 1000;
	return (iRet);
}

int ExtractTwistAng(CString inS, double* dA) {
	int iRet = 1;
	int i1;
	int i2;

	CString sR;
	CString sVec;

	i1 = inS.Find("DEG");
	if (i1 < 0) {
		i1 = inS.Find("deg");
	}
	sVec = inS.Left(i1);
	i2 = sVec.ReverseFind('_');
	sVec = sVec.Right(sVec.GetLength() - i2 - 1);
	*dA = atof(sVec);
	return (iRet);
}

int ExtractWG(CString inS, int* iW, double* dW, int* iW2, double* dW2, BOOL* bQ1, BOOL* bQ2) {
	int iRet = 1;
	int i1;
	int i2;

	CString sR;
	CString sVec;
	CString sWG2;
	CString sWG1;

	sWG1 = inS;
	i1 = inS.Find(",");
	if (i1 > -1) {
		sWG1 = sWG1.Left(i1);
	}
	i1 = sWG1.Find("_WR");
	sVec = sWG1.Right(sWG1.GetLength() - i1 - 3);
	i2 = sVec.Find("_");
	sR = sVec.Left(i2);
	*iW = atoi(sVec);
	sVec = sVec.Right(sVec.GetLength() - i2);
	i2 = sVec.Find("MM");
	sR = sVec.Left(i2);
	i1 = sR.Find("_Q_");
	if (i1 > -1) {
		*bQ1 = TRUE;
		sR = sR.Right(sR.GetLength() - 3);
	} else {
		sR = sR.Right(sR.GetLength() - 1);
	}
	*dW = atof(sR);
	i1 = inS.Find(",");
	if (i1 > -1) {
		sWG2 = inS.Right(inS.GetLength() - i1 - 1);
		i1 = sWG2.Find("_WR");
		sVec = sWG2.Right(sWG2.GetLength() - i1 - 3);
		i2 = sVec.Find("_");
		sR = sVec.Left(i2);
		*iW2 = atoi(sVec);
		sVec = sVec.Right(sVec.GetLength() - i2);
		i2 = sVec.Find("MM");
		sR = sVec.Left(i2);
		i1 = sR.Find("_Q_");
		if (i1 > -1) {
			*bQ2 = TRUE;
			sR = sR.Right(sR.GetLength() - 3);
		} else {
			sR = sR.Right(sR.GetLength() - 1);
		}
		*dW2 = atof(sR);
	}

	return (iRet);
}

int ExtractPt(CString inS, C3dVector* inVec) {
	int iRet = 1;
	int i1;
	double dx;
	double dy;
	double dz;
	CString sX;
	CString sY;
	CString sVec;
	i1 = inS.Find(":");
	sVec = inS.Right(inS.GetLength() - i1 - 1);
	i1 = sVec.Find(",");
	sX = sVec.Left(i1);
	sVec = sVec.Right(sVec.GetLength() - i1 - 1);
	i1 = sVec.Find(",");
	sY = sVec.Left(i1);
	sVec = sVec.Right(sVec.GetLength() - i1 - 1);
	i1 = sVec.Find(".");
	sVec = sVec.Left(i1 + 3);
	dx = atof(sX);
	dy = atof(sY);
	dz = atof(sVec);
	inVec->Set(dx / 1000, dy / 1000, dz / 1000);
	return (iRet);
}

int ExtractPtS(CString inS, C3dVector* inVec) {
	int iRet = 1;
	int i1;
	double dx;
	double dy;
	double dz;
	CString sX;
	CString sY;
	CString sVec;
	i1 = inS.Find("(");
	sVec = inS.Right(inS.GetLength() - i1 - 1);
	i1 = sVec.Find(",");
	sX = sVec.Left(i1);
	sVec = sVec.Right(sVec.GetLength() - i1 - 1);
	i1 = sVec.Find(",");
	sY = sVec.Left(i1);
	sVec = sVec.Right(sVec.GetLength() - i1 - 1);
	i1 = sVec.Find(")");
	sVec = sVec.Left(i1);
	dx = atof(sX);
	dy = atof(sY);
	dz = atof(sVec);
	inVec->Set(dx / 1000, dy / 1000, dz / 1000);
	return (iRet);
}

int ExtractName(CString inS, CString* sName) {
	int iRet = 1;
	CString S;
	int i1;

	S = inS.Right(inS.GetLength() - 57);
	i1 = S.Find(" ");
	*sName = S.Left(i1);
	return (iRet);
}

int ExtractOPt(CString inS, C3dVector* inVec)

{
	int iRet = 1;
	int i1;
	double dx;
	double dy;
	double dz;
	CString sX;
	CString sY;
	CString sVec;

	sVec = inS;
	i1 = sVec.Find(",");
	sX = sVec.Left(i1);
	sVec = sVec.Right(sVec.GetLength() - i1 - 1);
	i1 = sVec.Find(",");
	sY = sVec.Left(i1);
	sVec = sVec.Right(sVec.GetLength() - i1 - 1);
	dx = atof(sX);
	dy = atof(sY);
	dz = atof(sVec);
	inVec->Set(dx / 1000, dy / 1000, dz / 1000);
	return (iRet);
}

int ExtractOOPt(CString inS, C3dVector* inVec)

{
	int iRet = 1;
	int i1;
	double dx;
	double dy;
	double dz;
	CString sX;
	CString sY;
	CString sVec;
	i1 = inS.Find(":");
	sVec = inS.Right(inS.GetLength() - i1 - 1);
	i1 = sVec.Find(",");
	sX = sVec.Left(i1);
	sVec = sVec.Right(sVec.GetLength() - i1 - 1);
	i1 = sVec.Find(",");
	sY = sVec.Left(i1);
	sVec = sVec.Right(sVec.GetLength() - i1 - 1);
	dx = atof(sX);
	dy = atof(sY);
	dz = atof(sVec);
	inVec->Set(dx / 1000, dy / 1000, dz / 1000);
	return (iRet);
}

//*********************************************
// END String extraction procedure s
//*********************************************

IMPLEMENT_DYNAMIC(Section, CObject)

Section::~Section() {
	int i;
	for (i = 0; i < iLnCnt; i++) {
		delete (pLn[i]);
		pLn[i] = NULL;
	}
}

void Section::Create(int iLab, int inPID, int inPID2, int inSec, int inCol, G_Object* Parrent) {
	TMat.MakeUnit();
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 200;
	iLabel = iLab;
	iColour = inCol;
	iLnCnt = 0;
	iSec = inSec;
	iPID = inPID;
	iPID2 = inPID2;
	pParent = Parrent;
}

void Section::Serialize(CArchive& ar, int iV) {
	int i;
	int iT;
	if (ar.IsStoring()) {
		// TODO: add storing code here

		G_Object::Serialize(ar, iV);
		ar << iSec;
		ar << iPID;
		ar << iPID2;
		ar << TMat.m_00;
		ar << TMat.m_01;
		ar << TMat.m_02;
		ar << TMat.m_03;
		ar << TMat.m_10;
		ar << TMat.m_11;
		ar << TMat.m_12;
		ar << TMat.m_13;
		ar << TMat.m_20;
		ar << TMat.m_21;
		ar << TMat.m_22;
		ar << TMat.m_23;
		ar << TMat.m_30;
		ar << TMat.m_31;
		ar << TMat.m_32;
		ar << TMat.m_33;
		inPt.Serialize(ar, iV);
		ar << iLnCnt;
		for (i = 0; i < iLnCnt; i++) {
			ar << NoSegs[i];
			ar << pLn[i]->iObjType;
			pLn[i]->Serialize(ar, iV);
			;
		}
	} else {
		G_Object::Serialize(ar, iV);
		ar >> iSec;
		ar >> iPID;
		ar >> iPID2;
		ar >> TMat.m_00;
		ar >> TMat.m_01;
		ar >> TMat.m_02;
		ar >> TMat.m_03;
		ar >> TMat.m_10;
		ar >> TMat.m_11;
		ar >> TMat.m_12;
		ar >> TMat.m_13;
		ar >> TMat.m_20;
		ar >> TMat.m_21;
		ar >> TMat.m_22;
		ar >> TMat.m_23;
		ar >> TMat.m_30;
		ar >> TMat.m_31;
		ar >> TMat.m_32;
		ar >> TMat.m_33;
		inPt.Serialize(ar, iV);
		ar >> iLnCnt;
		for (i = 0; i < iLnCnt; i++) {
			ar >> NoSegs[i];
			ar >> iT;
			if (iT == 8) {
				pLn[i] = new NCircle;
				pLn[i]->Serialize(ar, iV);
			} else {
				pLn[i] = new NLine;
				pLn[i]->Serialize(ar, iV);
			}
		}
	}
}

G_Object* Section::Copy(G_Object* Parrent) {
	int i;
	Section* NewSec = new Section;
	NewSec->Create(iLabel, iPID, iPID2, iSec, iColour, NULL);
	for (i = 0; i < iLnCnt; i++) {
		NewSec->pLn[i] = (NCurve*) pLn[i]->Copy(this);
		NewSec->NoSegs[i] = NoSegs[i];
	}
	NewSec->iLnCnt = iLnCnt;
	NewSec->pParent = Parrent;
	return (NewSec);
}

// Draw Object line
void Section::Draw(CDC* pDC, int iDrawmode) {
	int j = 0;
	if (iLnCnt != 0) {
		for (j = 0; j < iLnCnt; j++) {
			pLn[j]->HighLight(pDC);
		}
	}
}

void Section::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	OglDraw(iDspFlgs, dS1, dS2);
}

void Section::OglDraw(int iDspFlgs, double dS1, double dS2) {
	int j = 0;
	if (iLnCnt != 0) {
		for (j = 0; j < iLnCnt; j++) {
			pLn[j]->OglDraw(iDspFlgs, dS1, dS2);
		}
	}
}

void Section::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	int j;
	if (iLnCnt != 0) {
		for (j = 0; j < iLnCnt; j++) {
			pLn[j]->SetToScr(pModMat, pScrTran);
		}
	}
}

void Section::Transform(C3dMatrix inTMat) {
	TMat = inTMat;
	int j = 0;
	if (iLnCnt != 0) {
		for (j = 0; j < iLnCnt; j++) {
			pLn[j]->Transform(inTMat);
		}
	}
}

C3dVector Section::Get_Centroid() {
	C3dVector vT;
	vT.x = 0; // to be done
	vT.y = 0;
	vT.z = 0;
	return (vT);
}

void Section::HighLight(CDC* pDC) {
	Draw(pDC, 4);
}

G_ObjectD Section::SelDist(CPoint InPT, Filter FIL) {
	G_ObjectD Ret;
	Ret.Dist = 1000;
	Ret.pObj = this;
	return (Ret);
}

void Section::ChangeCol(int iCOl) {
	int i;
	for (i = 0; i < iLnCnt; i++) {
		pLn[i]->iColour = iCOl;
	}
}

void Section::AddLine(double X1, double Y1,
                      double X2, double Y2,
                      int NoDivs) {
	C3dVector pt1;
	pt1.Set(X1, Y1, 0);
	C3dVector pt2;
	pt2.Set(X2, Y2, 0);
	if (iLnCnt < 50) {
		NLine* pL = new NLine();

		pL->Create(pt1, pt2, iLnCnt, this);
		pL->pParent = this;
		pLn[iLnCnt] = pL;
		NoSegs[iLnCnt] = NoDivs;
		iLnCnt++;
	}
}

void Section::MakeSpace(int iPos) {
	int i;
	if (iLnCnt < 50) {
		for (i = iLnCnt; i > iPos; i--) {
			NoSegs[i] = NoSegs[i - 1];
			pLn[i] = pLn[i - 1];
		}
		pLn[iPos] = NULL;
		iLnCnt++;
	}
}

void Section::FilletCrns(double dR) {
	NCircle* pC;
	NoSegs[0] -= 2;
	NoSegs[1] -= 2;
	NoSegs[2] -= 2;
	NoSegs[3] -= 2;

	pC = NFillet((NLine*) pLn[0], (NLine*) pLn[1], dR);
	MakeSpace(1);
	pLn[1] = (NCircle*) pC;
	pLn[1]->pParent = this;
	NoSegs[1] = 2;
	pC = NFillet((NLine*) pLn[2], (NLine*) pLn[3], dR);
	MakeSpace(3);
	pLn[3] = (NCircle*) pC;
	pLn[3]->pParent = this;
	NoSegs[3] = 2;
	pC = NFillet((NLine*) pLn[4], (NLine*) pLn[5], dR);
	MakeSpace(5);
	pLn[5] = (NCircle*) pC;
	pLn[5]->pParent = this;
	NoSegs[5] = 2;
	pC = NFillet((NLine*) pLn[6], (NLine*) pLn[0], dR);
	MakeSpace(7);
	pLn[7] = (NCircle*) pC;
	pLn[7]->pParent = this;
	NoSegs[7] = 2;
}

int Section::GetNoLines() {
	return (iLnCnt);
}

int Section::GetDivs(int iL) {
	return (NoSegs[iL]);
}

C3dVector Section::GetPt(int iSeg, int iPos) {
	C3dVector vRet;

	double dw;
	double dPos;
	dPos = iPos;
	dw = dPos / NoSegs[iSeg];
	if ((pLn[iSeg]->iObjType == 7) && (pLn[iSeg]->iType == 3)) {
		dw *= 0.25;
	}

	vRet = pLn[iSeg]->GetPt(dw);
	return (vRet);
}

BOOL Section::isClosedSec() {
	BOOL brc = FALSE;
	double dDist;
	double dw = 1;
	C3dVector S;
	C3dVector E;
	S = pLn[0]->GetPt(0);
	if ((pLn[iLnCnt - 1]->iObjType == 7) && (pLn[iLnCnt - 1]->iType == 3)) {
		dw *= 0.25;
	}
	E = pLn[iLnCnt - 1]->GetPt(dw);
	dDist = S.Dist(E);
	if (dDist < 0.00001) {
		brc = TRUE;
	}
	return (brc);
}

C3dVector Section::NLnInt(NCurve* L1, NCurve* L2) {
	int i = 0;
	double MinDist = 10000000;
	double dDist = 0;
	double dDistB = 0;
	const double dTol = 0.00001;
	C3dVector P1;
	C3dVector P2;
	int iMaxIt = 0;
	P1 = L1->GetPt(0);

	do {
		P2 = L2->MinPt(P1);
		P1 = L1->MinPt(P2);
		dDist = P2.Dist(P1);
		iMaxIt++;
	} while ((dDist > dTol) && (iMaxIt < 100000));
	return (P2);
}

// This is taken from DBase
NCircle* Section::NFillet(NLine* Ln, NLine* Ln1, double dR) {
	C3dVector PNear1;
	C3dVector PNear2;
	double R;
	R = dR;
	C3dVector p1;
	C3dVector p2;
	C3dVector p3;
	C3dVector pT;
	C3dVector vL1Dir;
	C3dVector* pLT1;
	C3dVector* pLT2;
	C3dVector v1;
	C3dVector v2;
	C3dVector v3;
	C3dVector vRef;
	C3dVector vDir;
	// The intersection of the lines

	v1 = Ln->GetDir(0.5);

	v2 = Ln1->GetDir(0.5);
	;
	p1 = Ln->GetPt(0);
	pLT1 = Ln->cPts[1]->Pt_Point;
	p2 = NLnInt(Ln, Ln1);
	// p2=pLT1;
	p3 = Ln1->GetPt(1);
	pLT2 = Ln1->cPts[0]->Pt_Point;
	C3dVector vn;
	vn = v1.Cross(v2);
	vn.Normalize();
	C3dVector v1o;
	C3dVector v2o;

	v1o = v1.Cross(vn);
	v2o = v2.Cross(vn);
	v1o.Normalize();
	v2o.Normalize();
	v1o *= R;
	v2o *= R;
	if (v1o.Dot(v2) < 0)
		v1o *= -1;
	if (v2o.Dot(v1) > 0)
		v2o *= -1;
	C3dVector p1o;
	C3dVector p2o;
	C3dVector p3o;
	C3dVector p4o;

	p1o = p1;
	p1o += v1o;
	p2o = p2;
	p2o += v1o;
	p3o = p2;
	p3o += v2o;
	p4o = p3;
	p4o += v2o;
	NLine* Ln2 = new NLine;
	Ln2->Create(p1o, p2o, 1, NULL);
	NLine* Ln3 = new NLine;
	Ln3->Create(p3o, p4o, 1, NULL);
	C3dVector IntPt;
	IntPt = NLnInt(Ln2, Ln3);

	C3dVector IntPt1;
	IntPt1 = Ln->MinPt(IntPt);
	vRef = IntPt1;
	vRef -= IntPt;
	vRef.Normalize();

	NCircle* cCir = new NCircle();
	cCir->Create2(vn, IntPt, vRef, R, -1, NULL);
	cCir->vNorm = vn; // Note the transform method in Create2 changes the normal
	// so set it back
	pLT1->Set(IntPt1.x, IntPt1.y, IntPt1.z); // trim the end point
	C3dVector IntPt2;
	IntPt2 = Ln1->MinPt(IntPt);
	pLT2->Set(IntPt2.x, IntPt2.y, IntPt2.z); // trim the end point

	// d1q=cCir->MinWPt(IntPt1);

	// vRef=IntPt1;
	// vDir=cCir->GetDir(d1q);
	// vDir.Normalize();
	// vRef-=cCir->vCent;
	// vRef.Normalize();
	// if (vDir.Dot(vL1Dir)<0)
	//{
	//   vn*=-1;
	// }
	// delete (cCir);
	// cCir = new NCircle();
	// cCir->Create2(vn,IntPt,vRef,R,-1,NULL);
	// d1q=cCir->MinWPt(IntPt1);
	double d2q;
	d2q = cCir->MinWPt(IntPt2);
	cCir->we = d2q;

	delete (Ln2);
	delete (Ln3);

	return (cCir);
}

void Section::SetInPt(C3dVector Pt) {
	inPt = Pt;
}

IMPLEMENT_DYNAMIC(Sweep, CObject)

Sweep::Sweep() {
	pPath = NULL;
	pBaseSec = NULL;
	Mesh = NULL;
	iSecCnt = 0;
	Twist = 0;
	isVoid = FALSE;
	pParent = NULL;
	iMeshCnt = 0;
	isStart = FALSE;
	isEnd = FALSE;
	iObjType = 603;
}

void Sweep::PreCreate(int iLab, CString inName, double dT) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iLabel = iLab;
	iColour = 2;
	iSecCnt = 0;
	Name = inName;
	Twist = dT;
}

void Sweep::Create(int iLab, G_Object* inPath,
                   Section* inSec, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iLabel = iLab;
	iColour = 2;
	iSecCnt = 0;
	Mesh = NULL;
	isVoid = FALSE;
	pPath = inPath->Copy(this);
	pBaseSec = (Section*) inSec->Copy(this);
	pPath->pParent = this;
	pBaseSec->pParent = this;
	pParent = Parrent;
}

void Sweep::Serialize(CArchive& ar, int iV) {
	int i;
	int iTp;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << iMeshCnt;
		ar << iSecCnt;
		ar << Twist;
		ar << isVoid;
		ar << isStart;
		ar << isEnd;
		ar << dElLength;
		ar << pPath->iObjType;
		pPath->Serialize(ar, iV);
		pBaseSec->Serialize(ar, iV);
		for (i = 0; i < iSecCnt; i++) {
			pAllSecs[i]->Serialize(ar, iV);
		}
		int iISMesh = 0;
		if (Mesh != NULL) {
			iISMesh = 1;
			ar << iISMesh;
			Mesh->Serialize(ar, iV);
		} else {
			iISMesh = 0;
			ar << iISMesh;
		}
	} else {
		G_Object::Serialize(ar, iV);
		ar >> iMeshCnt;
		ar >> iSecCnt;
		ar >> Twist;
		ar >> isVoid;
		ar >> isStart;
		ar >> isEnd;
		ar >> dElLength;
		ar >> iTp;
		if (iTp == 9) {
			pPath = new NLine;
		} else if (iTp == 7) {
			pPath = new NCurve;
		} else if (iTp == 8) {
			pPath = new NCircle;
		}
		pPath->Serialize(ar, iV);
		pPath->pParent = this;
		pBaseSec = new Section;
		pBaseSec->Serialize(ar, iV);
		pBaseSec->pParent = this;
		for (i = 0; i < iSecCnt; i++) {
			pAllSecs[i] = new Section;
			pAllSecs[i]->Serialize(ar, iV);
			pAllSecs[i]->pParent = this;
		}
		int iISMesh = 0;
		ar >> iISMesh;
		if (iISMesh == 1) {
			Mesh = new ME_Object();
			Mesh->Serialize(ar, iV);
			Mesh->pParent = this;
		}
	}
}

C3dVector Sweep::GetInPt() {
	C3dVector vRet;
	return (vRet);
}

C3dVector Sweep::GetDir(double w) {
	C3dVector vN;
	vN = pPath->GetDir(w);
	return (vN);
}

C3dVector Sweep::MinPt(C3dVector inPt) {
	C3dVector vRet(0, 0, 0);
	if (pPath != NULL) {
		vRet = pPath->GetPt(0.5);
	}
	return (vRet);
}

// Draw Object line
void Sweep::Draw(CDC* pDC, int iDrawmode) {
	int j = 0;
	if (iSecCnt != 0) {
		for (j = 0; j < iSecCnt; j++) {
			pAllSecs[j]->Draw(pDC, iDrawmode);
		}
	}
	if (pPath != NULL) {
		pPath->Draw(pDC, iDrawmode);
	}
	if (Mesh != NULL) {
		Mesh->Draw(pDC, iDrawmode);
	}
}

void Sweep::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	int j = 0;
	if (iSecCnt != 0) {
		for (j = 0; j < iSecCnt; j++) {
			pAllSecs[j]->OglDrawW(iDspFlgs, dS1, dS2);
		}
	}
	if (pPath != NULL) {
		pPath->OglDrawW(iDspFlgs, dS1, dS2);
	}
	if (Mesh != NULL) {
		Mesh->OglDrawW(iDspFlgs, dS1, dS2);
	}
}

void Sweep::OglDraw(int iDspFlgs, double dS1, double dS2) {
	int j = 0;
	if (iSecCnt != 0) {
		for (j = 0; j < iSecCnt; j++) {
			pAllSecs[j]->OglDraw(iDspFlgs, dS1, dS2);
		}
	}
	if (pPath != NULL) {
		pPath->OglDraw(iDspFlgs, dS1, dS2);
	}
	if (Mesh != NULL) {
		Mesh->OglDraw(iDspFlgs, dS1, dS2);
	}
}

void Sweep::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	int j = 0;
	if (iSecCnt != 0) {
		for (j = 0; j < iSecCnt; j++) {
			pAllSecs[j]->SetToScr(pModMat, pScrTran);
		}
	}
	if (pPath != NULL) {
		pPath->SetToScr(pModMat, pScrTran);
	}
	if (Mesh != NULL) {
		Mesh->SetToScr(pModMat, pScrTran);
	}
}

void Sweep::Transform(C3dMatrix inTMat) {
	int j = 0;
	if (iSecCnt != 0) {
		for (j = 0; j < iSecCnt; j++) {
			pAllSecs[j]->Transform(inTMat);
		}
	}
	if (pPath != NULL) {
		pPath->Transform(inTMat);
	}
}

C3dVector Sweep::Get_Centroid() {
	C3dVector vT;
	if (pPath != NULL) {
		vT = pPath->Get_Centroid();
	}
	return (vT);
}

void Sweep::HighLight(CDC* pDC) {
	int j = 0;
	if (iSecCnt != 0) {
		for (j = 0; j < iSecCnt; j++) {
			pAllSecs[j]->Draw(pDC, 4);
		}
	}
	if (pPath != NULL) {
		pPath->Draw(pDC, 4);
	}
}

G_ObjectD Sweep::SelDist(CPoint InPT, Filter FIL) {
	G_ObjectD Ret;
	double dS = 10000;
	if ((pPath != NULL) && (Mesh == NULL)) {
		Ret = pPath->SelDist(InPT, FIL);
		Ret.pObj = this;
	} else if (Mesh != NULL) {
		Ret = Mesh->SelDist(InPT, FIL);
	} else {
		Ret.pObj = this;
	}
	return (Ret);
}

void Sweep::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	if (Mesh != NULL) {
		Mesh->S_Box(P1, P2, pSel);
	}
}

void Sweep::DeleteSections() {
	int i;
	for (i = 0; i < iSecCnt; i++) {
		// pAllSecs[i]->~Section();
		delete (pAllSecs[i]);
	}
	iSecCnt = 0;
}

double Sweep::GetSecSpacing() {
	double dRet = 0;
	C3dVector p1, p2;
	if (iSecCnt > 1) {
		p1 = pAllSecs[0]->GetPt(0, 0);
		p2 = pAllSecs[1]->GetPt(0, 0);
		dRet = p1.Dist(p2);
	}

	return (dRet);
}

void Sweep::CutBack(BOOL bEA, BOOL bEB, ME_Object* MeshA, ME_Object* MeshB) {
	double cBW;
	double dDist;
	C3dVector pCPt;
	C3dVector p1;
	C3dVector vDirO;
	C3dVector vDirN;
	Node* pCN1;
	Node* pCN2;
	C3dMatrix mUp = GetFirstYMap();
	NLine* pL;
	pL = (NLine*) pPath;
	vDirO = pL->GetDir(0);
	double dD = GetSecSpacing();
	DeleteSections();
	double dLen = pL->getLen();
	cBW = 0.75 * dD / dLen;
	if ((MeshA != NULL) && (bEA == TRUE)) {
		// Cutback nodes in standaard parts definition
		pCN1 = MeshA->GetNode(1);
		pCN2 = MeshA->GetNode(2);
		if (pCN1 != NULL) {
			pCPt = pCN1->GetCoords();
			dDist = pL->MinDist(pCPt);
			if (dDist < 0.001) {
				pL->cPts[0]->Pt_Point->Set(pCPt.x, pCPt.y, pCPt.z);
			}
		}
		if (pCN2 != NULL) {
			pCPt = pCN2->GetCoords();
			dDist = pL->MinDist(pCPt);
			if (dDist < 0.001) {
				pL->cPts[0]->Pt_Point->Set(pCPt.x, pCPt.y, pCPt.z);
			}
		}
	} else if ((MeshA == NULL) && (bEA == TRUE)) {
		p1 = pL->GetPt(cBW);
		pL->cPts[0]->Pt_Point->Set(p1.x, p1.y, p1.z);
	}

	if ((MeshB != NULL) && (bEB == TRUE)) {
		// Cutback nodes in standaard parts definition
		pCN1 = MeshB->GetNode(1);
		pCN2 = MeshB->GetNode(2);
		if (pCN1 != NULL) {
			pCPt = pCN1->GetCoords();
			dDist = pL->MinDist(pCPt);
			if (dDist < 0.001) {
				pL->cPts[1]->Pt_Point->Set(pCPt.x, pCPt.y, pCPt.z);
			}
		}
		if (pCN2 != NULL) {
			pCPt = pCN2->GetCoords();
			dDist = pL->MinDist(pCPt);
			if (dDist < 0.001) {
				pL->cPts[1]->Pt_Point->Set(pCPt.x, pCPt.y, pCPt.z);
			}
		}
	} else if ((MeshB == NULL) && (bEB == TRUE)) {
		p1 = pL->GetPt(1 - cBW);
		pL->cPts[1]->Pt_Point->Set(p1.x, p1.y, p1.z);
	}
	vDirN = pL->GetDir(0);
	double dDot;
	dDot = vDirO.Dot(vDirN);
	if (dDot < 0) {
		isVoid = TRUE;
	}
	Generate(mUp, dElLength);
}

void Sweep::Generate(C3dMatrix mUp, double dElLen) {
#ifdef _DEBUG
	CMemoryState oldMemState, newMemState, diffMemState;
#endif
	dElLength = dElLen;
	C3dVector Loc;
	C3dVector Dir;
	C3dMatrix TMat;
	C3dMatrix OMat;
	double dAng;
	double dA = 0;
	int i;
	int k = 0;
	double w;
	double dInc;
	double dRem;
	int iSteps;
	double dSteps;
	double dLen;
#ifdef _DEBUG
	oldMemState.Checkpoint();
#endif
	if (isVoid == FALSE) {
		if (dElLen <= 0) {
			dElLen = 0.005;
		}
		if (pPath->iObjType == 7) {
			dLen = pPath->getLen();
			dSteps = dLen / dElLen;
			iSteps = (int) dSteps;

			dRem = dSteps - iSteps;

			if (iSteps == 0) {
				iSteps = 1;
			}
			if (dRem > 0.5) {
				iSteps += 1;
			}

			dSteps = (double) iSteps;
			dInc = 1 / dSteps;

			w = 0;
			for (i = 0; i < iSteps + 1; i++) {
				Dir = pPath->GetDir(w);
				TMat = TMat.CalcTran(Dir);
				Loc = pPath->GetPt(w);
				// Calculate the sections
				// orientation
				if (i > 0) {
					// Get last sections orientation
					mUp = GetLastYMap();
					dA = Twist / iSteps;
				}
				dAng = TMat.GetZRot(mUp);
				dAng += dA;
				OMat.MakeUnit();
				OMat.Rotate(0, 0, dAng);
				TMat = TMat * OMat;
				TMat.Translate2(Loc.x, Loc.y, Loc.z);
				pAllSecs[iSecCnt] = (Section*) pBaseSec->Copy(this);
				pAllSecs[iSecCnt]->SetInPt(Loc);
				pAllSecs[iSecCnt]->Transform(TMat);

				iSecCnt++;
				w += dInc;
				if (w > 1) {
					w = 1;
				}
			}
		}
		// DeleteSections();

#ifdef _DEBUG
		newMemState.Checkpoint();
		if (diffMemState.Difference(oldMemState, newMemState)) {
			TRACE("Memory leaked!\n");
			diffMemState.DumpStatistics();
		}

#endif
	}
}

void Sweep::GenMesh(int iDim, PSHELL* pS, PBARL* pB) {
	int i;
	int j;
	int k;
	Node* S1[500][100];
	Node* E1[MaxSelNodes];
	Node* pNd;
	C3dVector Nd;
	int iCnt1 = 0;
	int iNlab = 1;
	int iPID;
	int iSecT;
	int iCol;
	BOOL isClosed = FALSE;
	Property* Prop;
	E_Object* pE;
	if (isVoid == FALSE) {
		if (pAllSecs[0] != NULL) {
			isClosed = pAllSecs[0]->isClosedSec();
			if (iDim == 1) {
				Prop = pB;
				iPID = pBaseSec->iPID2;
			} else {
				Prop = pS;
				iPID = pBaseSec->iPID;
			}
			iSecT = pBaseSec->iSec;
			iCol = pBaseSec->iColour;
		}
		if (this->pPath->getLen() > 0.000001) {
			if (iDim == 2) {
				Mesh = new ME_Object();
				Mesh->Create("", this, iMeshCnt);
				for (i = 0; i < iSecCnt; i++) {
					iCnt1 = 0;
					for (j = 0; j < pAllSecs[i]->GetNoLines(); j++) {
						for (k = 0; k < pAllSecs[i]->GetDivs(j); k++) {
							Nd = pAllSecs[i]->GetPt(j, k);
							pNd = Mesh->AddNode(Nd, iNlab, 0, 0, 11, 0, 0);
							iNlab++;
							S1[i][iCnt1] = pNd;
							iCnt1++;
							if ((j == pAllSecs[i]->GetNoLines() - 1) &&
							    (k == pAllSecs[i]->GetDivs(j) - 1)) {
								if (isClosed == FALSE) {
									Nd = pAllSecs[i]->GetPt(j, pAllSecs[i]->GetDivs(j));
									pNd = Mesh->AddNode(Nd, iNlab, 0, 0, 11, 0, 0);
									iNlab++;
									S1[i][iCnt1] = pNd;
									iCnt1++;
								} else {
									S1[i][iCnt1] = S1[i][0];
									iCnt1++;
								}
							}
						}
					}
				}
				int iECnt = 1;
				for (i = 0; i < iSecCnt - 1; i++) {
					for (j = 0; j < iCnt1 - 1; j++) {
						E1[0] = S1[i + 1][j];
						E1[1] = S1[i][j];
						E1[2] = S1[i][j + 1];
						E1[3] = S1[i + 1][j + 1];
						pE = Mesh->AddEl(E1, iECnt, 152, 94, Prop->iID, 1, 4, 0, 0, 1, FALSE, -1, 0);
						pE->PIDunv = iPID;
						pE->pPr = Prop;
						iECnt++;
					}
				}
			} else if (iDim == 1) {
				Mesh = new ME_Object();
				Mesh->Create("", this, iMeshCnt);
				for (i = 0; i < iSecCnt; i++) {
					Nd = pAllSecs[i]->inPt;
					pNd = Mesh->AddNode(Nd, i + 1, 0, 0, 11, 0, 0);
					iNlab++;
					S1[i][0] = pNd;
				}
				for (i = 0; i < iSecCnt - 1; i++) {
					E1[0] = S1[i][0];
					E1[1] = S1[i + 1][0];
					pE = Mesh->AddEl(E1, i + 1, 152, 21, Prop->iID, 1, 2, 0, 1, 1, FALSE, -1, 0);
					pE->pPr = Prop;
					pE->PIDunv = iPID;
					E_Object2* pE1 = (E_Object2*) pE;
					C3dVector vv;
					vv = pAllSecs[i]->TMat.GetUpVec();
					pE1->SetUpVec(vv);
					pE1->B = iSecT;
					pE1->C = iSecT;
				}
			}
		}
		if (iDim == 1) {
			S1[0][0]->iColour = 160;
			S1[iSecCnt - 1][0]->iColour = 160;
		} else if (iDim == 2) {
			for (j = 0; j < iCnt1 - 1; j++) {
				S1[0][j]->iColour = 160;
			}
			for (j = 0; j < iCnt1 - 1; j++) {
				S1[iSecCnt - 1][j]->iColour = 160;
			}
		}
	}
}

ME_Object* Sweep::GetMesh() {
	return (Mesh);
}

C3dMatrix Sweep::GetLastYMap() {
	C3dMatrix mRet;
	if (iSecCnt > 0) {
		mRet = pAllSecs[iSecCnt - 1]->TMat;
	}
	return (mRet);
}

C3dMatrix Sweep::GetFirstYMap() {
	C3dMatrix mRet;
	if (iSecCnt > 0) {
		mRet = pAllSecs[0]->TMat;
	}
	return (mRet);
}

IMPLEMENT_DYNAMIC(SweepF, CObject)

SweepF::SweepF() {
	Sweep::Sweep();
	iObjType = 606;
	pParent = NULL;
	isStart = TRUE;
	isEnd = TRUE;
}

void SweepF::PreCreate(int iLab, CString inName, double dT) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iLabel = iLab;
	iColour = 2;
	iSecCnt = 0;
	Name = inName;
	Twist = dT;
}

void SweepF::Generate(C3dMatrix mUp, double dElLen, double dLenFR) {
	C3dVector Loc;
	C3dVector Dir;
	C3dMatrix TMat;
	C3dMatrix OMat;
	dElLength = dElLen;
	double dAng;
	double dA = 0;
	dFR = dLenFR;
	int i;
	int k = 0;
	double w;
	double dInc;
	double dRem;
	int iSteps;
	double dSteps;
	double dLen;
	double dS = 0;
	double dF = 1;
	if (isVoid == FALSE) {
		if (dElLen <= 0) {
			dElLen = 0.005;
		}
		if (dLenFR <= 0) {
			dLenFR = 0.001;
		}
		if (pPath->iObjType == 7) {
			dLen = pPath->getLen();
			if (isStart == TRUE) {
				// dLen=dLen-dLenFR;
				dS = dLenFR / dLen;
			}
			if (isEnd == TRUE) {
				// dLen=dLen-dLenFR;
				dF = 1 - dLenFR / dLen;
			}
			dSteps = dLen / dElLen;
			iSteps = (int) dSteps;

			dRem = dSteps - iSteps;

			if (iSteps == 0) {
				iSteps = 1;
			}
			if (dRem > 0.5) {
				iSteps += 1;
			}

			dSteps = (double) iSteps;
			dInc = (dF - dS) / dSteps;

			if (isStart == TRUE) {
				Dir = pPath->GetDir(0);
				TMat = TMat.CalcTran(Dir);
				Loc = pPath->GetPt(0);
				dAng = TMat.GetZRot(mUp);
				dAng += dA;
				OMat.MakeUnit();
				OMat.Rotate(0, 0, dAng);
				TMat = TMat * OMat;
				TMat.Translate2(Loc.x, Loc.y, Loc.z);
				pAllSecs[iSecCnt] = (Section*) pBaseSec->Copy(this);
				pAllSecs[iSecCnt]->ChangeCol(4);
				pAllSecs[iSecCnt]->SetInPt(Loc);
				pAllSecs[iSecCnt]->Transform(TMat);
				iSecCnt++;
			}

			w = dS;
			for (i = 0; i < iSteps + 1; i++) {
				Dir = pPath->GetDir(w);
				TMat = TMat.CalcTran(Dir);
				Loc = pPath->GetPt(w);
				// Calculate the sections
				// orientation
				if (i > 0) {
					// Get last sections orientation
					mUp = GetLastYMap();
					dA = Twist / iSteps;
				}
				dAng = TMat.GetZRot(mUp);
				dAng += dA;
				OMat.MakeUnit();
				OMat.Rotate(0, 0, dAng);
				TMat = TMat * OMat;
				TMat.Translate2(Loc.x, Loc.y, Loc.z);
				pAllSecs[iSecCnt] = (Section*) pBaseSec->Copy(this);
				pAllSecs[iSecCnt]->ChangeCol(55);
				pAllSecs[iSecCnt]->SetInPt(Loc);
				pAllSecs[iSecCnt]->Transform(TMat);

				iSecCnt++;
				w += dInc;
				if (w > 1) {
					w = 1;
				}
			}
		}
		if (isEnd == TRUE) {
			Dir = pPath->GetDir(1);
			TMat = TMat.CalcTran(Dir);
			Loc = pPath->GetPt(1);
			// Calculate the sections
			// orientation
			if (i > 0) {
				// Get last sections orientation
				mUp = GetLastYMap();
				dA = Twist / iSteps;
			}
			dAng = TMat.GetZRot(mUp);
			dAng += dA;
			OMat.MakeUnit();
			OMat.Rotate(0, 0, dAng);
			TMat = TMat * OMat;
			TMat.Translate2(Loc.x, Loc.y, Loc.z);
			pAllSecs[iSecCnt] = (Section*) pBaseSec->Copy(this);
			pAllSecs[iSecCnt]->ChangeCol(4);
			pAllSecs[iSecCnt]->SetInPt(Loc);
			pAllSecs[iSecCnt]->Transform(TMat);
			iSecCnt++;
		}
	}
}

void SweepF::CutBack(BOOL bEA, BOOL bEB, ME_Object* MeshA, ME_Object* MeshB) {
	double cBW;
	double dDist;
	C3dVector pCPt;
	C3dVector p1;
	C3dVector vDirO;
	C3dVector vDirN;
	Node* pCN1;
	Node* pCN2;
	C3dMatrix mUp = GetFirstYMap();
	NLine* pL;
	pL = (NLine*) pPath;
	vDirO = pL->GetDir(0);
	double dD = GetSecSpacing();
	DeleteSections();
	double dLen = pL->getLen();
	cBW = 0.75 * dD / dLen;
	if ((MeshA != NULL) && (bEA == TRUE)) {
		// Cutback nodes in standaard parts definition
		pCN1 = MeshA->GetNode(1);
		pCN2 = MeshA->GetNode(2);
		if (pCN1 != NULL) {
			pCPt = pCN1->GetCoords();
			dDist = pL->MinDist(pCPt);
			if (dDist < 0.001) {
				pL->cPts[0]->Pt_Point->Set(pCPt.x, pCPt.y, pCPt.z);
			}
		}
		if (pCN2 != NULL) {
			pCPt = pCN2->GetCoords();
			dDist = pL->MinDist(pCPt);
			if (dDist < 0.001) {
				pL->cPts[0]->Pt_Point->Set(pCPt.x, pCPt.y, pCPt.z);
			}
		}
	} else if ((MeshA == NULL) && (bEA == TRUE)) {
		p1 = pL->GetPt(cBW);
		pL->cPts[0]->Pt_Point->Set(p1.x, p1.y, p1.z);
	}

	if ((MeshB != NULL) && (bEB == TRUE)) {
		// Cutback nodes in standaard parts definition
		pCN1 = MeshB->GetNode(1);
		pCN2 = MeshB->GetNode(2);
		if (pCN1 != NULL) {
			pCPt = pCN1->GetCoords();
			dDist = pL->MinDist(pCPt);
			if (dDist < 0.001) {
				pL->cPts[1]->Pt_Point->Set(pCPt.x, pCPt.y, pCPt.z);
			}
		}
		if (pCN2 != NULL) {
			pCPt = pCN2->GetCoords();
			dDist = pL->MinDist(pCPt);
			if (dDist < 0.001) {
				pL->cPts[1]->Pt_Point->Set(pCPt.x, pCPt.y, pCPt.z);
			}
		}
	} else if ((MeshB == NULL) && (bEB == TRUE)) {
		p1 = pL->GetPt(1 - cBW);
		pL->cPts[1]->Pt_Point->Set(p1.x, p1.y, p1.z);
	}
	vDirN = pL->GetDir(0);
	double dDot;
	dDot = vDirO.Dot(vDirN);
	if (dDot < 0) {
		isVoid = TRUE;
	}
	Generate(mUp, dElLength, dFR);
}

BOOL isCorner(Node* P1, Node* P2, Node* P3, Node* P4) {
	BOOL brc = FALSE;
	if ((P1->iColour == 3) &&
	    (P2->iColour == 3) &&
	    (P3->iColour == 3) &&
	    (P4->iColour == 3)) {
		brc = TRUE;
	}

	return (brc);
}

void SweepF::GenMesh(int iDim, PSHELL* pS1, PSHELL* pS2, PSHELL* pS3, PSHELL* pS4, PBARL* pB1, PBARL* pB2) {
	int i;
	int j;
	int k;
	Node* S1[500][100];
	Node* E1[MaxSelNodes];
	Node* pNd;
	C3dVector Nd;
	int iCnt1 = 0;
	int iNlab = 1;
	int iPID;

	BOOL isClosed = FALSE;
	Property* Prop;
	E_Object* pE;
	if (isVoid == FALSE) {
		if (pAllSecs[0] != NULL) {
			isClosed = pAllSecs[0]->isClosedSec();
		}

		if (iDim == 2) {
			Mesh = new ME_Object();
			Mesh->Create("", this, iMeshCnt);

			for (i = 0; i < iSecCnt; i++) {
				iCnt1 = 0;
				for (j = 0; j < pAllSecs[i]->GetNoLines(); j++) {
					int iNoD;
					iNoD = pAllSecs[i]->GetDivs(j);
					for (k = 0; k < iNoD; k++) {
						Nd = pAllSecs[i]->GetPt(j, k);
						if ((pAllSecs[i]->pLn[j]->iObjType == 8) || (k == 0)) {
							pNd = Mesh->AddNode(Nd, iNlab, 0, 0, 3, 0, 0);
						} else {
							pNd = Mesh->AddNode(Nd, iNlab, 0, 0, 55, 0, 0);
						}
						iNlab++;
						S1[i][iCnt1] = pNd;
						iCnt1++;
						if ((j == pAllSecs[i]->GetNoLines() - 1) &&
						    (k == pAllSecs[i]->GetDivs(j) - 1)) {
							if (isClosed == FALSE) {
								Nd = pAllSecs[i]->GetPt(j, pAllSecs[i]->GetDivs(j));
								pNd = Mesh->AddNode(Nd, iNlab, 0, 0, 11, 0, 0);
								iNlab++;
								S1[i][iCnt1] = pNd;
								iCnt1++;
							} else {
								S1[i][iCnt1] = S1[i][0];
								iCnt1++;
							}
						}
					}
				}
			}
			int iECnt = 1;
			int iELCol;
			for (i = 0; i < iSecCnt - 1; i++) {
				for (j = 0; j < iCnt1 - 1; j++) {
					E1[0] = S1[i + 1][j];
					E1[1] = S1[i][j];
					E1[2] = S1[i][j + 1];
					E1[3] = S1[i + 1][j + 1];

					if (((i == 0) && (isStart == TRUE)) &&
					    (isCorner(E1[0], E1[1], E1[2], E1[3]) == FALSE)) {
						iELCol = 153;
						Prop = pS1;
						iPID = pS1->iID;
					} else if (((i == iSecCnt - 2) && (isEnd == TRUE)) &&
					           (isCorner(E1[0], E1[1], E1[2], E1[3]) == FALSE)) {
						iELCol = 153;
						Prop = pS1;
						iPID = pS1->iID;
					} else if (((i == 0) && (isStart == TRUE)) &&
					           (isCorner(E1[0], E1[1], E1[2], E1[3]) == TRUE)) {
						iELCol = 162;
						Prop = pS2;
						iPID = pS2->iID;
					} else if (((i == iSecCnt - 2) && (isEnd == TRUE)) &&
					           (isCorner(E1[0], E1[1], E1[2], E1[3]) == TRUE)) {
						iELCol = 162;
						Prop = pS2;
						iPID = pS2->iID;
					} else if (isCorner(E1[0], E1[1], E1[2], E1[3]) == TRUE) {
						iELCol = 3;
						Prop = pS4;
						iPID = pS4->iID;
					} else {
						iELCol = 55;
						Prop = pS3;
						iPID = pS3->iID;
					}
					pE = Mesh->AddEl(E1, iECnt, iELCol, 94, iPID, 1, 4, 0, 0, 1, FALSE, -1, 0);
					pE->PIDunv = iPID;
					pE->pPr = Prop;
					iECnt++;
				}
			}
		} else if (iDim == 1) {
			Mesh = new ME_Object();
			Mesh->Create("", this, iMeshCnt);
			for (i = 0; i < iSecCnt; i++) {
				Nd = pAllSecs[i]->inPt;
				pNd = Mesh->AddNode(Nd, i + 1, 0, 0, 11, 0, 0);
				iNlab++;
				S1[i][0] = pNd;
			}
			int iELCol;
			for (i = 0; i < iSecCnt - 1; i++) {
				E1[0] = S1[i][0];
				E1[1] = S1[i + 1][0];
				if ((i == 0) && (isStart == TRUE)) {
					iELCol = 153;
					Prop = pB1;
					iPID = pB1->iID;
				} else if ((i == iSecCnt - 2) && (isEnd == TRUE)) {
					iELCol = 153;
					Prop = pB1;
					iPID = pB1->iID;
				} else {
					iELCol = 55;
					Prop = pB2;
					iPID = pB2->iID;
				}
				pE = Mesh->AddEl(E1, i + 1, iELCol, 21, iPID, 1, 2, 0, 1, 1, FALSE, -1, 0);
				pE->pPr = Prop;
				pE->PIDunv = iPID;
				E_Object2* pE1 = (E_Object2*) pE;
				C3dVector vv;
				vv = pAllSecs[i]->TMat.GetUpVec();
				if (vv.Mag() == 0) {
					int ff = 0;
					ff++;
				}
				pE1->SetUpVec(vv);
			}
		}
	}
	for (i = 0; i < iSecCnt; i++) {
		Nd = pAllSecs[i]->inPt;
		pNd = Mesh->AddNode(Nd, i + 1, 0, 0, 11, 0, 0);
		iNlab++;
		S1[i][0] = pNd;
	}
	if (iDim == 1) {
		S1[0][0]->iColour = 160;
		S1[iSecCnt - 1][0]->iColour = 160;
	} else if (iDim == 2) {
		for (j = 0; j < iCnt1 - 1; j++) {
			S1[0][j]->iColour = 160;
		}
		for (j = 0; j < iCnt1 - 1; j++) {
			S1[iSecCnt - 1][j]->iColour = 160;
		}
	}
}

IMPLEMENT_DYNAMIC(SweepFB, CObject)

SweepFB::SweepFB() {
	SweepB::SweepB();
	iObjType = 607;
	pParent = NULL;
}

void SweepFB::PreCreate(int iLab, CString inName,
                        C3dVector inP, double dR, int EH, double dT) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iLabel = iLab;
	iColour = 2;
	iSecCnt = 0;
	Name = inName;
	dRad = dR;
	Twist = dT;
	if (inPt != NULL) {
		delete (inPt);
	}
	inPt = new CvPt_Object;
	inPt->Create(inP, 0, -1, 0, 0, 11, this);
	isHBend = EH;
}

void SweepFB::GenMesh(int iDim, PSHELL* pS1, PSHELL* pS2, PSHELL* pS3, PSHELL* pS4, PBARL* pB1, PBARL* pB2) {
	int i;
	int j;
	int k;
	Node* S1[500][100];
	Node* E1[MaxSelNodes];
	Node* pNd;
	C3dVector Nd;
	int iCnt1 = 0;
	int iNlab = 1;
	int iPID;

	BOOL isClosed = FALSE;
	Property* Prop;
	E_Object* pE;
	if (isVoid == FALSE) {
		if (pAllSecs[0] != NULL) {
			isClosed = pAllSecs[0]->isClosedSec();
		}

		if (iDim == 2) {
			Mesh = new ME_Object();
			Mesh->Create("", this, iMeshCnt);

			for (i = 0; i < iSecCnt; i++) {
				iCnt1 = 0;
				for (j = 0; j < pAllSecs[i]->GetNoLines(); j++) {
					int iNoD;
					iNoD = pAllSecs[i]->GetDivs(j);
					for (k = 0; k < iNoD; k++) {
						Nd = pAllSecs[i]->GetPt(j, k);
						if ((pAllSecs[i]->pLn[j]->iObjType == 8) || (k == 0)) {
							pNd = Mesh->AddNode(Nd, iNlab, 0, 0, 3, 0, 0);
						} else {
							pNd = Mesh->AddNode(Nd, iNlab, 0, 0, 55, 0, 0);
						}
						iNlab++;
						S1[i][iCnt1] = pNd;
						iCnt1++;
						if ((j == pAllSecs[i]->GetNoLines() - 1) &&
						    (k == pAllSecs[i]->GetDivs(j) - 1)) {
							if (isClosed == FALSE) {
								Nd = pAllSecs[i]->GetPt(j, pAllSecs[i]->GetDivs(j));
								pNd = Mesh->AddNode(Nd, iNlab, 0, 0, 11, 0, 0);
								iNlab++;
								S1[i][iCnt1] = pNd;
								iCnt1++;
							} else {
								S1[i][iCnt1] = S1[i][0];
								iCnt1++;
							}
						}
					}
				}
			}
			int iECnt = 1;
			int iELCol;
			for (i = 0; i < iSecCnt - 1; i++) {
				for (j = 0; j < iCnt1 - 1; j++) {
					E1[0] = S1[i + 1][j];
					E1[1] = S1[i][j];
					E1[2] = S1[i][j + 1];
					E1[3] = S1[i + 1][j + 1];
					if (isCorner(E1[0], E1[1], E1[2], E1[3]) == TRUE) {
						iELCol = 3;
						Prop = pS4;
						iPID = pS4->iID;
					} else {
						iELCol = 55;
						Prop = pS3;
						iPID = pS3->iID;
					}
					pE = Mesh->AddEl(E1, iECnt, iELCol, 94, iPID, 1, 4, 0, 0, 1, FALSE, -1, 0);
					pE->PIDunv = iPID;
					pE->pPr = Prop;
					iECnt++;
				}
			}
		} else if (iDim == 1) {
			Mesh = new ME_Object();
			Mesh->Create("", this, iMeshCnt);
			for (i = 0; i < iSecCnt; i++) {
				Nd = pAllSecs[i]->inPt;
				pNd = Mesh->AddNode(Nd, i + 1, 0, 0, 11, 0, 0);
				iNlab++;
				S1[i][0] = pNd;
			}
			int iELCol;
			for (i = 0; i < iSecCnt - 1; i++) {
				E1[0] = S1[i][0];
				E1[1] = S1[i + 1][0];

				iELCol = 55;
				Prop = pB2;
				iPID = pB2->iID;

				pE = Mesh->AddEl(E1, i + 1, iELCol, 21, iPID, 1, 2, 0, 1, 1, FALSE, -1, 0);
				pE->pPr = Prop;
				pE->PIDunv = iPID;
				E_Object2* pE1 = (E_Object2*) pE;
				C3dVector vv;
				vv = pAllSecs[i]->TMat.GetUpVec();
				pE1->SetUpVec(vv);
			}
		}
	}
	if (iDim == 1) {
		S1[0][0]->iColour = 160;
		S1[iSecCnt - 1][0]->iColour = 160;
	} else if (iDim == 2) {
		for (j = 0; j < iCnt1 - 1; j++) {
			S1[0][j]->iColour = 160;
		}
		for (j = 0; j < iCnt1 - 1; j++) {
			S1[iSecCnt - 1][j]->iColour = 160;
		}
	}
}

IMPLEMENT_DYNAMIC(SweepB, CObject)

SweepB::SweepB() {
	Sweep::Sweep();
	iObjType = 604;
	dRad = 0;
	isHBend = 0;
	inPt = NULL;
	pParent = NULL;
}

void SweepB::Create(int iLab, NCurve* inPath,
                    Section* inSec, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iLabel = iLab;
	iColour = 2;
	iSecCnt = 0;
	pPath = (NCurve*) inPath->Copy(this);
	pBaseSec = (Section*) inSec->Copy(this);
	pPath->pParent = this;
	pBaseSec->pParent = this;
	pParent = Parrent;
}

void SweepB::PreCreate(int iLab, CString inName,
                       C3dVector inP, double dR, int EH, double dT) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 604;
	iLabel = iLab;
	iColour = 2;
	iSecCnt = 0;
	Name = inName;
	dRad = dR;
	Twist = dT;
	if (inPt != NULL) {
		delete (inPt);
	}
	inPt = new CvPt_Object;
	inPt->Create(inP, 0, -1, 0, 0, 11, this);
	isHBend = EH;
}

void SweepB::Serialize(CArchive& ar, int iV) {
	Sweep::Serialize(ar, iV);
	if (ar.IsStoring()) {
		ar << dRad;
		ar << isHBend;
		inPt->Serialize(ar, iV);
	} else {
		ar >> dRad;
		ar >> isHBend;
		inPt = new CvPt_Object;
		inPt->Serialize(ar, iV);
	}
}

// Draw Object line
void SweepB::Draw(CDC* pDC, int iDrawmode) {
	Sweep::Draw(pDC, iDrawmode);
	inPt->Draw(pDC, iDrawmode);
}

void SweepB::OglDraw(int iDspFlgs, double dS1, double dS2) {
	Sweep::OglDraw(iDspFlgs, dS1, dS2);
	inPt->OglDraw(iDspFlgs, dS1, dS2);
}

void SweepB::Generate(C3dMatrix mUp, double dElLen) {
	C3dVector Loc;
	C3dVector Dir;
	C3dMatrix TMat;
	C3dMatrix TMat2;
	C3dMatrix OMat;
	dElLength = dElLen;
	double dAng;
	double dS;
	double dE;
	double dInc;
	NCurve* C = (NCurve*) pPath;
	dS = C->ws;
	dE = C->we;

	int i;
	double w;
	int iSteps;
	double dDegStep = dElLen; // 10degrees
	double dT;
	double dRem;
	dT = ((dE - dS)) * 360 / dDegStep;
	iSteps = (int) dT;
	dRem = dT - iSteps;
	if (dRem > 0) {
		iSteps += 1;
	}
	if (iSteps == 0) {
		iSteps = 1;
	}
	dInc = (dE - dS) / iSteps;
	if (pPath->iObjType == 7) {
		w = dS;
		for (i = 0; i < iSteps + 1; i++) {
			// Twist
			// TMat2.Rotate(0,0,5);
			Dir = pPath->GetDir(w);
			TMat = TMat.CalcTran(Dir);
			Loc = pPath->GetPt(w);
			// Calculate the sections
			// orientation
			if (i > 0) {
				// Get last sections orientation
				mUp = GetLastYMap();
			}
			dAng = TMat.GetZRot(mUp);
			OMat.MakeUnit();
			OMat.Rotate(0, 0, dAng);
			TMat = TMat * OMat;
			TMat.Translate2(Loc.x, Loc.y, Loc.z);
			pAllSecs[iSecCnt] = (Section*) pBaseSec->Copy(this);
			// pAllSecs[iSecCnt]->Transform(TMat2);
			// pAllSecs[iSecCnt]->Transform(OMat);
			pAllSecs[iSecCnt]->SetInPt(Loc);
			pAllSecs[iSecCnt]->Transform(TMat);
			iSecCnt++;
			w += dInc;
		}
	}
}

void SweepB::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	Sweep::SetToScr(pModMat, pScrTran);
	inPt->SetToScr(pModMat, pScrTran);
}

void SweepB::Transform(C3dMatrix inTMat) {
	Sweep::Transform(inTMat);
	inPt->Transform(inTMat);
}

C3dVector SweepB::GetNVec() {
	C3dVector vN;
	NCircle* C = (NCircle*) pPath;
	vN.x = C->vNorm.x;
	vN.y = C->vNorm.y;
	vN.z = C->vNorm.z;
	return (vN);
}

C3dVector SweepB::GetSVec() {
	C3dVector vN;
	NCircle* C = (NCircle*) pPath;
	vN = C->GetDir(0);
	vN.Normalize();
	return (vN);
}

C3dVector SweepB::GetInPt() {
	C3dVector vR;
	vR.x = inPt->Pt_Point->x;
	vR.y = inPt->Pt_Point->y;
	vR.z = inPt->Pt_Point->z;
	return (vR);
}

IMPLEMENT_DYNAMIC(PartsCat, CObject)

// int iNo;
// int iCurDsp;
// ME_Object* P_Obj[100];

PartsCat::PartsCat(int iLab) {
	iLabel = iLab;
	iNo = 0;
	iCurDsp = -1;
}

PartsCat::~PartsCat() {
	int i;
	for (i = 0; i < iNo; i++) {
		delete (P_Obj[i]);
	}
}

void PartsCat::Create(int iLab) {
	iLabel = iLab;
	iNo = 0;
	iCurDsp = -1;
}

void PartsCat::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
	} else {
	}
}

void PartsCat::Info() {
	char S1[80];
	CString OutT;
	sprintf_s(S1, "%s%i%s%i%s%i", "Type ", iObjType, "; Label ", iLabel, " Col; ", iColour);
	OutT += S1;
	outtext1("PARTS CAT");
	outtext1(OutT);
	outtext1("    ****");
}

void PartsCat::Draw(CDC* pDC, int iDrawmode) {
	if ((iCurDsp >= 0) && (iCurDsp < iNo)) {
		if (P_Obj[iCurDsp] != NULL) {
			P_Obj[iCurDsp]->Draw(pDC, iDrawmode);
			pDC->TextOut(20, 20, P_Obj[iCurDsp]->sName);
		}
	}
}

void PartsCat::OglDraw(int iDspFlgs, double dS1, double dS2) {
	char sLab[200];
	C3dVector pCent;
	if ((iCurDsp >= 0) && (iCurDsp < iNo)) {
		if (P_Obj[iCurDsp] != NULL) {
			sprintf_s(sLab, "%s", P_Obj[iCurDsp]->sName);
			pCent = P_Obj[iCurDsp]->Get_Centroid();
			OglString(iDspFlgs, pCent.x, pCent.y, pCent.z, &sLab[0]);
			P_Obj[iCurDsp]->OglDraw(iDspFlgs, dS1, dS2);
		}
	}
}

void PartsCat::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[200];
	C3dVector pCent;
	if ((iCurDsp >= 0) && (iCurDsp < iNo)) {
		if (P_Obj[iCurDsp] != NULL) {
			sprintf_s(sLab, "%s", P_Obj[iCurDsp]->sName);
			pCent = P_Obj[iCurDsp]->Get_Centroid();
			OglString(iDspFlgs, pCent.x, pCent.y, pCent.z, &sLab[0]);
			P_Obj[iCurDsp]->OglDrawW(iDspFlgs, dS1, dS2);
		}
	}
}

void PartsCat::HighLight(CDC* pDC) {
	if ((iCurDsp >= 0) && (iCurDsp < iNo)) {
		if (P_Obj[iCurDsp] != NULL) {
			P_Obj[iCurDsp]->HighLight(pDC);
		}
	}
}

void PartsCat::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	if ((iCurDsp >= 0) && (iCurDsp < iNo)) {
		if (P_Obj[iCurDsp] != NULL) {
			P_Obj[iCurDsp]->SetToScr(pModMat, pScrTran);
		}
	}
}

void PartsCat::Next() {
	if (iCurDsp < iNo - 1) {
		iCurDsp++;
	}
}

void PartsCat::Previous() {
	if (iCurDsp > 0) {
		iCurDsp--;
	}
}

void PartsCat::Transform(C3dMatrix TMat) {
}

G_ObjectD PartsCat::SelDist(CPoint InPT, Filter FIL) {
	double d;
	G_Object* pO;
	G_ObjectD Ret;
	d = 1e36;
	pO = this;
	pO->pParent = NULL;
	Ret.Dist = d;
	Ret.pObj = pO;
	return (Ret);
}

void PartsCat::Add(ME_Object* inMesh) {
	if (iNo < MaxPrtNo) {
		P_Obj[iNo] = inMesh;
		iNo++;
		iCurDsp = 0;
	}
}

ME_Object* PartsCat::Get(CString inName) {
	ME_Object* pRet;
	pRet = NULL;
	int i;
	for (i = 0; i < iNo; i++) {
		if (P_Obj[i]->sName == inName) {
			pRet = (ME_Object*) P_Obj[i]->Copy(this);
			break;
		}
	}

	return (pRet);
}

ME_Object* PartsCat::GetCur() {
	ME_Object* pRet;
	pRet = NULL;
	if (iCurDsp != -1) {
		pRet = (ME_Object*) P_Obj[iCurDsp]->Copy(this);
		pRet->pParent = NULL;
	}
	return (pRet);
}

IMPLEMENT_DYNAMIC(pRecord, CObject)

pRecord::pRecord(int iIndex, int iType) {
	iT = iType;
	iID = iIndex;
	iCnt = 0;
}

pRecord::~pRecord() {
	int i;
	for (i = 0; i < iCnt; i++) {
		delete (propVals[i]);
	}
}

void pRecord::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		ar << iID;
		ar << iT;
		ar << iCnt;
		for (i = 0; i < iCnt; i++) {
			propVals[i]->Serialize(ar, iV);
		}
	} else {
		ar >> iID;
		ar >> iT;
		ar >> iCnt;
		for (i = 0; i < iCnt; i++) {
			if (iT == 1) {
				propVals[i] = new piVal;
			} else if (iT == 2) {
				propVals[i] = new pdVal;
			} else if (iT == 3) {
				propVals[i] = new psVal;
			}
			propVals[i]->Serialize(ar, iV);
		}
	}
}

void pRecord::Add(pVal* inP) {
	if (iCnt < 50) {
		propVals[iCnt] = inP;
		iCnt++;
	}
}

IMPLEMENT_DYNAMIC(pVal, CObject)

void pVal::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
	} else {
	}
}

IMPLEMENT_DYNAMIC(piVal, CObject)

void piVal::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		ar << iVal;
	} else {
		ar >> iVal;
	}
}

IMPLEMENT_DYNAMIC(pdVal, CObject)

void pdVal::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		ar << dVal;
	} else {
		ar >> dVal;
	}
}

IMPLEMENT_DYNAMIC(psVal, CObject)

void psVal::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		ar << sVal;
	} else {
		ar >> sVal;
	}
}

IMPLEMENT_DYNAMIC(Prop, CObject)

Prop::Prop(int inD, int inT,
           int inN, int inP, CString inName) {
	iCnt = 0;
	iD = inD;
	iT = inT;
	iN = inN;
	iP = inP;
	Name = inName;
}

Prop::Prop() {
	iCnt = 0;
	iD = -1;
	iT = -1;
	iN = -1;
	iP = -1;
	Name = "ROYBLOWS";
}

Prop::~Prop() {
	int i;
	for (i = 0; i < iCnt; i++) {
		delete (pRecs[i]);
	}
}

void Prop::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		ar << iCnt;
		ar << iD;
		ar << iT;
		ar << iN;
		ar << iP;
		ar << Name;
	} else {
		ar >> iCnt;
		ar >> iD;
		ar >> iT;
		ar >> iN;
		ar >> iP;
		ar >> Name;
	}
	for (i = 0; i < iCnt; i++) {
		pRecs[i]->Serialize(ar, iV);
	}
}

void Prop::Add(pRecord* inRec) {
	if (iCnt < MaxRec) {
		pRecs[iCnt] = inRec;
		iCnt++;
	}
}

IMPLEMENT_DYNAMIC(Entity, CObject)

Entity::Entity() {
	iFile = -1;
	sTitle = "";
	iID = -1;
	iType = -1;
}

void Entity::Create(CString inTitle,
                    int inPid,
                    int inType) {
	sTitle = inTitle;
	iID = inPid;
	iType = inType;
}

void Entity::List() {
	char S1[200];
	CString OutT;
	sprintf_s(S1, "%s %i %s %i", "ID", iID, "TYPE", iType);
	OutT = S1;
	outtext1(OutT);
}

// Saeed_Material_SaveBugV1_05_20_2025_Start
/*
//Saeed_Material_SaveBugV1_05_20_2025_End
void Entity::ListShort()
//Saeed_Material_SaveBugV1_05_20_2025_Start
*/
void Entity::ListShort(int iRow)
// Saeed_Material_SaveBugV1_05_20_2025_End
{
	char S1[200];
	// Saeed_Material_SaveBugV1_05_20_2025_Start
	/*
	//Saeed_Material_SaveBugV1_05_20_2025_End
	sprintf_s(S1, "%s %i %s %i %s %i  %s", "FNO", iFile, "ID", iID, "TYPE", iType, this->sTitle);
	//Saeed_Material_SaveBugV1_05_20_2025_Start
	*/
	sprintf_s(S1, "%i >> %s %i %s %i %s %i  %s", iRow, "FNO", iFile, "Material ID", iID, "TYPE", iType, this->sTitle);
	// Saeed_Material_SaveBugV1_05_20_2025_End
	outtext1(_T(S1));
}

void Entity::ExportNAS(FILE* pFile) {
}

Entity* Entity::Copy() {
	Entity* pREt = new Entity();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	return (pREt);
}

void Entity::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		ar << iType;
		ar << sTitle;
		ar << iID;
		ar << iFile;
	} else {
		ar >> iType;
		ar >> sTitle;
		ar >> iID;
		if (iV < -62)
			ar >> iFile;
	}
}

int Entity::GetVarHeaders(CString sVar[]) {
	sVar[0] = "Hello";
	sVar[1] = "Hello2";
	return (2);
}

int Entity::GetVarValues(CString sVar[]) {
	sVar[0] = "Hello";
	sVar[1] = "Hello2";
	return (2);
}

void Entity::PutVarValues(int iNo, CString sVar[]) {
}

IMPLEMENT_DYNAMIC(Property, CObject)

BOOL Property::HasMat(int inMID) {
	return (FALSE);
}

int Property::GetMat() {
	return (-1);
}

double Property::GetThk() {
	return (0);
}

BSec* Property::GetSec() {
	return (NULL);
}

void Property::UpdateMats(NEList* newMats) {
}

int Property::GetDefMatID() {
	return (-1);
}

void Property::ChangeMat(int thisMat, int inMID) {
}

// MAT
IMPLEMENT_DYNAMIC(Material, CObject)

Mat Material::DeeMEM() {
	Mat Dee;
	return (Dee);
}

Mat Material::DeeBM() {
	Mat Dee;
	return (Dee);
}

Mat Material::DeeSH() {
	Mat Dee;
	return (Dee);
}

void Material::Info() {
}

double Material::GetDensity() {
	return (1.0);
}

double Material::GetCTE() {
	return (0.0);
}

double Material::GetE() {
	return (0.0);
}

double Material::GetV() {
	return (0.0);
}

IMPLEMENT_DYNAMIC(PMASS, CObject)

PMASS::PMASS() {
	sTitle = "";
	iID = -1;
	iType = 161;
	dM = 0;
}

PMASS* PMASS::Copy() {
	PMASS* pREt = new PMASS();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->dM = dM;
	return (pREt);
}

void PMASS::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << dM;
	} else {
		Entity::Serialize(ar, iV);
		ar >> dM;
	}
}

void PMASS::List() {
	char S1[200];
	CString OutT;
	outtext1("PROPERTY LISTING:-");
	sprintf_s(S1, "%s %i %s %s", "PID", iID, "TYPE ", "LUMPED MASS");
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %s", "TITLE : ", sTitle);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "M    : ", dM);
	OutT = S1;
	outtext1(OutT);
}

int PMASS::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Point Mass (M)";
	return (2);
}

int PMASS::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sVar[iNo] = "";
	iNo++;
	sprintf_s(S1, "%g", dM);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void PMASS::PutVarValues(int iNo, CString sVar[]) {
	dM = atof(sVar[1]);
}

IMPLEMENT_DYNAMIC(PSPRINGT, CObject)

PSPRINGT::PSPRINGT() {
	sTitle = "";
	iID = -1;
	iType = 136;
	dkx = 1000;
	dky = 1000;
	dkz = 1000;
	dkcoeff = 0;
}

PSPRINGT* PSPRINGT::Copy() {
	PSPRINGT* pREt = new PSPRINGT();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->dkx = dkx;
	pREt->dky = dky;
	pREt->dkz = dkz;
	pREt->dkcoeff = dkcoeff;
	return (pREt);
}

void PSPRINGT::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << dkx;
		ar << dky;
		ar << dkz;
		ar << dkcoeff;
	} else {
		Entity::Serialize(ar, iV);
		ar >> dkx;
		ar >> dky;
		ar >> dkz;
		ar >> dkcoeff;
	}
}

void PSPRINGT::List() {
	char S1[200];
	CString OutT;
	outtext1("PROPERTY LISTING:-");
	sprintf_s(S1, "%s %i %s %s", "PID", iID, "TYPE ", "TRANSLATION SPRING");
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %s", "TITLE : ", sTitle);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "kx    : ", dkx);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "ky    : ", dky);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "kz    : ", dkz);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "kCoeff: ", dkcoeff);
	OutT = S1;
	outtext1(OutT);
}

int PSPRINGT::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Translational Stiffness in X (Kx)";
	sVar[2] = "Translational Stiffness in Y (Ky)";
	sVar[3] = "Translational Stiffness in Z (Kz)";
	sVar[4] = "Conduction Coefficeint (kcoeff)";
	return (5);
}

int PSPRINGT::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = "";
	iNo++;
	sprintf_s(S1, "%g", dkx);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dky);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dkz);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dkcoeff);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void PSPRINGT::PutVarValues(int iNo, CString sVar[]) {
	iFile = atoi(sVar[0]);
	dkx = atof(sVar[1]);
	dky = atof(sVar[2]);
	dkz = atof(sVar[3]);
	dkcoeff = atof(sVar[4]);
}

void PSPRINGT::ExportNAS(FILE* pFile) {
	fprintf(pFile, "$%s\n", sTitle);
	fprintf(pFile, "%8s%8i%8s%8s%8s%8s\n", "PBUSH   ", iID, "       K", e8(dkx), e8(dky), e8(dkz));
}

IMPLEMENT_DYNAMIC(PSPRINGR, CObject)

PSPRINGR::PSPRINGR() {
	sTitle = "";
	iID = -1;
	iType = 137;
	dkx = 1000;
	dky = 1000;
	dkz = 1000;
	dkcoeff = 0;
}

void PSPRINGR::List() {
	char S1[200];
	CString OutT;
	outtext1("PROPERTY LISTING:-");
	sprintf_s(S1, "%s %i %s %s", "PID", iID, "TYPE ", "ROTATION SPRING");
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %s", "TITLE : ", sTitle);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "kx    : ", dkx);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "ky    : ", dky);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "kz    : ", dkz);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "kCoeff: ", dkcoeff);
	OutT = S1;
	outtext1(OutT);
}

int PSPRINGR::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Rotational Stiffness in X (Rx)";
	sVar[2] = "Rotational Stiffness in Y (Ry)";
	sVar[3] = "Rotational Stiffness in Z (Rz)";
	sVar[4] = "Conduction Coefficeint (kcoePBUSHff)";
	return (5);
}

void PSPRINGR::ExportNAS(FILE* pFile) {
	fprintf(pFile, "$%s\n", sTitle);
	fprintf(pFile, "%8s%8i%8s%8s%8s%8s%8s%8s%8s\n", "PBUSH   ", iID, "       K", "        ", "       K", "       K",
	        e8(dkx), e8(dky), e8(dkz));
}

//***************************************************************************
// P B U S H
//***************************************************************************
IMPLEMENT_DYNAMIC(PBUSH, CObject)

PBUSH::PBUSH() {
	sTitle = "";
	iID = -1;
	iType = 138;
	sFlg = "K";
	dK1 = 0.0;
	dK2 = 0.0;
	dK3 = 0.0;
	dK4 = 0.0;
	dK5 = 0.0;
	dK6 = 0.0;
	dkcoeff = 0;
}

PBUSH* PBUSH::Copy() {
	PBUSH* pREt = new PBUSH();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->sFlg = sFlg;
	pREt->dK1 = dK1;
	pREt->dK2 = dK2;
	pREt->dK3 = dK3;
	pREt->dK4 = dK4;
	pREt->dK5 = dK5;
	pREt->dK6 = dK6;
	return (pREt);
}

void PBUSH::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << sFlg;
		ar << dK1;
		ar << dK2;
		ar << dK3;
		ar << dK4;
		ar << dK5;
		ar << dK6;
		ar << dkcoeff;
	} else {
		Entity::Serialize(ar, iV);
		ar >> sFlg;
		ar >> dK1;
		ar >> dK2;
		ar >> dK3;
		ar >> dK4;
		ar >> dK5;
		ar >> dK6;
		ar >> dkcoeff;
	}
}

void PBUSH::List() {
	char S1[200];
	CString OutT;
	outtext1("PROPERTY LISTING:-");
	sprintf_s(S1, "%s %i %s %s", "PID", iID, "TYPE ", "CBUSH SPRING");
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %s", "TITLE : ", sTitle);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "Kx    : ", dK1);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "Ky    : ", dK2);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "Kz    : ", dK3);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "Krx    : ", dK4);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "Kry    : ", dK5);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "Krz    : ", dK6);
	OutT = S1;
	outtext1(OutT);
}

int PBUSH::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Flag";
	sVar[2] = "K1";
	sVar[3] = "K2";
	sVar[4] = "K3";
	sVar[5] = "K4";
	sVar[6] = "K5";
	sVar[7] = "K6";
	sVar[8] = "Conduction Coefficeint (kcoePBUSHff)";
	return (9);
}

int PBUSH::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sVar[iNo] = sFlg;
	iNo++;
	sprintf_s(S1, "%g", dK1);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dK2);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dK3);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dK4);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dK5);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dK6);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dkcoeff);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void PBUSH::PutVarValues(int iNo, CString sVar[]) {
	iFile = atoi(sVar[0]);
	sFlg = sVar[1];
	dK1 = atof(sVar[2]);
	dK2 = atof(sVar[3]);
	dK3 = atof(sVar[4]);
	dK4 = atof(sVar[5]);
	dK5 = atof(sVar[6]);
	dK6 = atof(sVar[7]);
	dkcoeff = atof(sVar[8]);
}

void PBUSH::ExportNAS(FILE* pFile) {
	fprintf(pFile, "$%s\n", sTitle);
	fprintf(pFile, "%8s%8i%8s%8s%8s%8s%8s%8s%8s\n", "PBUSH   ", iID, sFlg, e8(dK1).GetString(), e8(dK2).GetString(),
	        e8(dK3).GetString(), e8(dK4).GetString(), e8(dK5).GetString(), e8(dK6).GetString());
}

IMPLEMENT_DYNAMIC(PSOLID, CObject)

PSOLID::PSOLID() {
	sTitle = "";
	iID = -1;
	iType = 3;
	iMID = -1;
	iCORDM = -1;
	sIN = "TWO     ";
	sSTRESS = "GRID    ";
	sISOP = "REDUCED ";
	sFCTN = "        ";
}

void PSOLID::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << iMID;
		ar << iCORDM;
		ar << sIN;
		ar << sSTRESS;
		ar << sISOP;
		ar << sFCTN;
	} else {
		Entity::Serialize(ar, iV);
		ar >> iMID;
		ar >> iCORDM;
		ar >> sIN;
		ar >> sSTRESS;
		ar >> sISOP;
		ar >> sFCTN;
	}
}

void PSOLID::List() {
	char S1[200];
	CString OutT;
	outtext1("PROPERTY LISTING:-");
	sprintf_s(S1, "%s %i %s %s", "PID", iID, "TYPE ", "SOLID");
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %s", "TITLE : ", sTitle);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %i", "MAT1  : ", iMID);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %i", "CSYS  : ", iCORDM);
	outtext1(_T(S1));
}

int PSOLID::GetMat() {
	return (iMID);
}

BOOL PSOLID::HasMat(int inMID) {
	BOOL brc = FALSE;
	if (iMID == inMID) {
		brc = TRUE;
	}
	return (brc);
}

void PSOLID::UpdateMats(NEList* newMats) {
	iMID = newMats->Get(iMID);
}

void PSOLID::ChangeMat(int thisMat, int inMID) {
	if (iMID == thisMat)
		iMID = inMID;
}

int PSOLID::GetDefMatID() {
	return (iMID);
}

void PSOLID::ExportNAS(FILE* pFile) {
	fprintf(pFile, "$%s\n", sTitle.GetString());
	fprintf(pFile, "%8s%8i%8i%8i\n", "PSOLID  ", iID, iMID, iCORDM);
}

PSOLID* PSOLID::Copy() {
	PSOLID* pREt = new PSOLID();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->iMID = iMID;
	pREt->iCORDM = iCORDM;
	pREt->sIN = sIN;
	pREt->sSTRESS = sSTRESS;
	pREt->sISOP = sISOP;
	pREt->sFCTN = sFCTN;
	return (pREt);
}

int PSOLID::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Material ID (MID)";
	sVar[2] = "Material coord system (MCID) ";
	return (3);
}

int PSOLID::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[0] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMID);
	sVar[1] = S1;
	iNo++;
	sprintf_s(S1, "%i", iCORDM);
	sVar[2] = S1;
	iNo++;
	return (iNo);
}

void PSOLID::PutVarValues(int iNo, CString sVar[]) {
	iFile = atoi(sVar[0]);
	iMID = atoi(sVar[1]);
	iCORDM = atoi(sVar[2]);
}

IMPLEMENT_DYNAMIC(PBAR, CObject)

PBAR::PBAR() {
	sTitle = "";
	iID = -1;
	iType = 4;
	iMID = -1;
	dA = 0;
	dI1 = 0;
	dI2 = 0;
	dJ = 0;
	dNSM = 0;
	dC1 = 0;
	dC2 = 0;
	dD1 = 0;
	dD2 = 0;
	dE1 = 0;
	dE2 = 0;
	dF1 = 0;
	dF2 = 0;
	dK1 = 0;
	dK2 = 0;
	dI12 = 0;
	DspSec.Clear();
}

void PBAR::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << iMID;
		ar << dA;
		ar << dI1;
		ar << dI2;
		ar << dJ;
		ar << dNSM;
		ar << dC1;
		ar << dC2;
		ar << dD1;
		ar << dD2;
		ar << dE1;
		ar << dE2;
		ar << dF1;
		ar << dF2;
		ar << dK1;
		ar << dK2;
		ar << dI12;
		DspSec.Serialize(ar, iV);
	} else {
		Entity::Serialize(ar, iV);
		ar >> iMID;
		ar >> dA;
		ar >> dI1;
		ar >> dI2;
		ar >> dJ;
		ar >> dNSM;
		ar >> dC1;
		ar >> dC2;
		ar >> dD1;
		ar >> dD2;
		ar >> dE1;
		ar >> dE2;
		ar >> dF1;
		ar >> dF2;
		ar >> dK1;
		ar >> dK2;
		ar >> dI12;
		DspSec.Serialize(ar, iV);
	}
}

void PBAR::UpdateMats(NEList* newMats) {
	iMID = newMats->Get(iMID);
}

void PBAR::ChangeMat(int thisMat, int inMID) {
	if (iMID == thisMat)
		iMID = inMID;
}

int PBAR::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Material ID (MID)";
	sVar[2] = "Area (A)";
	sVar[3] = "Second Moment of Inertia (I1 (Izz))";
	sVar[4] = "Second Moment of Inertia (I2 (Iyy))";
	sVar[5] = "Torsional Constant (J)";
	sVar[6] = "Non Strut Mass";
	return (7);
}

int PBAR::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sVar[iNo] = "";
	iNo++;
	sprintf_s(S1, "%i", iMID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dA);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dI1);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dI2);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dJ);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dNSM);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void PBAR::PutVarValues(int iNo, CString sVar[]) {
	iMID = atoi(sVar[1]);
	dA = atof(sVar[2]);
	dI1 = atof(sVar[3]);
	dI2 = atof(sVar[4]);
	dJ = atof(sVar[5]);
	dNSM = atof(sVar[6]);
	CreateSec();
}

void PBAR::CreateSec() {
	double dSize = 0.01;
	double dH;
	double dW;
	if ((dA > 0) && (dI1 > 0) && (dI2 > 0)) {
		if (dI1 == dI2) // Assume circular for display
		{
			dSize = sqrt(dA);
			DspSec.CreateDefSec(dSize / 2, 55);
		} else // Assume rectangle for display
		{
			// dH = sqrt(12 * dI1 / dA);
			// dW = dA / dH;
			dW = pow((144 * dI1 * dI1 * dI1 / dI2), 0.125);
			dH = pow((144 * dI2 * dI2 * dI2 / dI1), 0.125);
			DspSec.CreateBar(dW, dH);
		}
	} else {
		DspSec.CreateDefSec(dSize / 2, 55);
	}
}

int PBAR::GetMat() {
	return (iMID);
}

int PBAR::GetDefMatID() {
	return (iMID);
}

BOOL PBAR::HasMat(int inMID) {
	BOOL brc = FALSE;
	if (iMID == inMID) {
		brc = TRUE;
	}
	return (brc);
}

void PBAR::ExportNAS(FILE* pFile) {
	fprintf(pFile, "$%s\n", sTitle);
	fprintf(pFile, "%-8s%8i%8i%8s%8s%8s%8s%8s\n", "PBAR    ", iID, iMID, e8(dA), e8(dI1), e8(dI2), e8(dJ), e8(dNSM));
	fprintf(pFile, "%-8s%8s%8s%8s%8s%8s%8s%8s%8s\n", "        ", e8(dC1), e8(dC2), e8(dD1), e8(dD2), e8(dE1), e8(dE2),
	        e8(dF1), e8(dF2));
	fprintf(pFile, "%-8s%8s%8s%8s\n", "        ", e8(dK1), e8(dK2), e8(dI12));
}

PBAR* PBAR::Copy() {
	int i;
	PBAR* pREt = new PBAR();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->iMID = iMID;

	pREt->dA = dA;
	pREt->dI1 = dI1;
	pREt->dI2 = dI2;
	pREt->dJ = dJ;
	pREt->dNSM = dNSM;
	pREt->dC1 = dC1;
	pREt->dC2 = dC2;
	pREt->dD1 = dD1;
	pREt->dD2 = dD2;
	pREt->dE1 = dE1;
	pREt->dE2 = dE2;
	pREt->dF1 = dF1;
	pREt->dF2 = dF2;
	pREt->dK1 = dK1;
	pREt->dK2 = dK2;
	pREt->dI12 = dI12;
	pREt->DspSec.iLnCnt1 = DspSec.iLnCnt1;
	pREt->DspSec.iLnCnt2 = DspSec.iLnCnt2;
	for (i = 0; i < DspSec.iLnCnt1; i++) {
		pREt->DspSec.pLnLoop1[i] = DspSec.pLnLoop1[i];
	}
	for (i = 0; i < DspSec.iLnCnt2; i++) {
		pREt->DspSec.pLnLoop2[i] = DspSec.pLnLoop2[i];
	}
	return (pREt);
}

BSec* PBAR::GetSec() {
	return (&DspSec);
}

IMPLEMENT_DYNAMIC(PBEAM, CObject)

PBEAM::PBEAM() {
	sTitle = "";
	iID = -1;
	iType = 6;
	iMID = -1;

	iNo = 1;
	A[0] = 0.0001;

	K1 = DBL_MAX;
	K2 = DBL_MAX;
	S1 = DBL_MAX;
	S2 = DBL_MAX;
	NSIA = DBL_MAX;
	NSIB = DBL_MAX;
	CWA = DBL_MAX;
	CWB = DBL_MAX;
	M1A = DBL_MAX;
	M2A = DBL_MAX;
	M1B = DBL_MAX;
	M2B = DBL_MAX;
	N1A = DBL_MAX;
	N2A = DBL_MAX;
	N1B = DBL_MAX;
	N2B = DBL_MAX;
	DspSec.Clear();
}

void PBEAM::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << iMID;
		ar << iNo;
		for (i = 0; i < iNo; i++) {
			ar << A[i];
			ar << I1[i];
			ar << I2[i];
			ar << I12[i];
			ar << J[i];
			ar << NSM[i];
			ar << C1[i];
			ar << C2[i];
			ar << D1[i];
			ar << D2[i];
			ar << E1[i];
			ar << E2[i];
			ar << F1[i];
			ar << F2[i];
			ar << SO[i];
			ar << XXB[i];
		}
		ar << K1;
		ar << K2;
		ar << S1;
		ar << S2;
		ar << NSIA;
		ar << NSIB;
		ar << CWA;
		ar << CWB;
		ar << M1A;
		ar << M2A;
		ar << M1B;
		ar << M2B;
		ar << N1A;
		ar << N2A;
		ar << N1B;
		ar << N2B;
		DspSec.Serialize(ar, iV);
	} else {
		Entity::Serialize(ar, iV);
		ar >> iMID;
		ar >> iNo;
		for (i = 0; i < iNo; i++) {
			ar >> A[i];
			ar >> I1[i];
			ar >> I2[i];
			ar >> I12[i];
			ar >> J[i];
			ar >> NSM[i];
			ar >> C1[i];
			ar >> C2[i];
			ar >> D1[i];
			ar >> D2[i];
			ar >> E1[i];
			ar >> E2[i];
			ar >> F1[i];
			ar >> F2[i];
			ar >> SO[i];
			ar >> XXB[i];
		}
		ar >> K1;
		ar >> K2;
		ar >> S1;
		ar >> S2;
		ar >> NSIA;
		ar >> NSIB;
		ar >> CWA;
		ar >> CWB;
		ar >> M1A;
		ar >> M2A;
		ar >> M1B;
		ar >> M2B;
		ar >> N1A;
		ar >> N2A;
		ar >> N1B;
		ar >> N2B;
		DspSec.Serialize(ar, iV);
	}
}

void PBEAM::UpdateMats(NEList* newMats) {
	iMID = newMats->Get(iMID);
}

void PBEAM::ChangeMat(int thisMat, int inMID) {
	if (iMID == thisMat)
		iMID = inMID;
}

int PBEAM::GetMat() {
	return (iMID);
}

void PBEAM::CreateSec() {
	double dSize;
	if (A[0] > 0) {
		dSize = sqrt(A[0]);
	} else {
		dSize = 0.01;
	}
	DspSec.CreateDefSec(dSize / 2, 55);
}

BOOL PBEAM::HasMat(int inMID) {
	BOOL brc = FALSE;
	if (iMID == inMID) {
		brc = TRUE;
	}
	return (brc);
}

void PBEAM::ExportNAS(FILE* pFile) {
	int i;
	fprintf(pFile, "$%s\n", sTitle);
	fprintf(pFile, "%8s%8i%8i%8s%8s%8s%8s%8s%8s\n", "PBEAM   ", iID, iMID, e8(A[0]), e8(I1[0]), e8(I2[0]), e8(I12[0]),
	        e8(J[0]), e8(NSM[0]));
	fprintf(pFile, "%8s%8s%8s%8s%8s%8s%8s%8s%8s\n", "        ", e8(C1[0]), e8(C2[0]), e8(D1[0]), e8(D2[0]), e8(E1[0]),
	        e8(E2[0]), e8(F1[0]), e8(F2[0]));
	for (i = 1; i < iNo; i++) {
		fprintf(pFile, "%8s%8s%8s%8s%8s%8s%8s%8s%8s\n", "        ", SO[i], e8(XXB[i]), e8(A[i]), e8(I1[i]), e8(I2[i]),
		        e8(I12[i]), e8(J[i]), e8(NSM[i]));
		if ((SO[i].Find("YESA") > -1) || (SO[i].Find("NO") > -1)) {
		} else {
			fprintf(pFile, "%8s%8s%8s%8s%8s%8s%8s%8s%8s\n", "        ", e8(C1[i]), e8(C2[i]), e8(D1[i]), e8(D2[i]),
			        e8(E1[i]), e8(E2[i]), e8(F1[i]), e8(F2[i]));
		}
	}

	fprintf(pFile, "%8s%8s%8s%8s%8s%8s%8s%8s%8s\n", "        ", e8(K1), e8(K2), e8(S1), e8(S2), e8(NSIA), e8(NSIB),
	        e8(CWA), e8(CWB));
	fprintf(pFile, "%8s%8s%8s%8s%8s%8s%8s%8s%8s\n", "        ", e8(M1A), e8(M2A), e8(M1B), e8(M2B), e8(N1A), e8(N2A),
	        e8(N1B), e8(N2B));

	// fprintf(pFile,"%-8s%-8s%-8s%-8s\n","        ",e8(dK1),e8(dK2),e8(dI12));
}

PBEAM* PBEAM::Copy() {
	int i;
	PBEAM* pREt = new PBEAM();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->iMID = iMID;

	for (i = 0; i < 9; i++) {
		pREt->A[i] = A[i];
		pREt->I1[i] = I1[i];
		pREt->I2[i] = I2[i];
		pREt->I12[i] = I12[i];
		pREt->J[i] = J[i];
		pREt->NSM[i] = NSM[i];
		pREt->C1[i] = C1[i];
		pREt->C2[i] = C2[i];
		pREt->D1[i] = D1[i];
		pREt->D2[i] = D2[i];
		pREt->E1[i] = E1[i];
		pREt->E2[i] = E2[i];
		pREt->F1[i] = F1[i];
		pREt->F2[i] = F2[i];
		pREt->SO[i] = SO[i];
		pREt->XXB[i] = XXB[i];
	}
	pREt->K1 = K1;
	pREt->K2 = K2;
	pREt->S1 = S1;
	pREt->S2 = S2;
	pREt->NSIA = NSIA;
	pREt->NSIB = NSIB;
	pREt->CWA = CWA;
	pREt->CWB = CWB;
	pREt->M1A = M1A;
	pREt->M2A = M2A;
	pREt->M1B = M1B;
	pREt->M2B = M2B;
	pREt->N1A = N1A;
	pREt->N2A = N2A;
	pREt->N1B = N1B;
	pREt->N2B = N2B;
	pREt->DspSec.iLnCnt1 = DspSec.iLnCnt1;
	pREt->DspSec.iLnCnt2 = DspSec.iLnCnt2;
	for (i = 0; i < DspSec.iLnCnt1; i++) {
		pREt->DspSec.pLnLoop1[i] = DspSec.pLnLoop1[i];
	}
	for (i = 0; i < DspSec.iLnCnt2; i++) {
		pREt->DspSec.pLnLoop2[i] = DspSec.pLnLoop2[i];
	}
	return (pREt);
}

BSec* PBEAM::GetSec() {
	return (&DspSec);
}

IMPLEMENT_DYNAMIC(PBARL, CObject)

PBARL::PBARL() {
	sTitle = "";
	iID = -1;
	iType = 5;
	iMID = -1;
	iNoDims = 0;
	sSecType = "";
	DspSec.Clear();
	sGROUP = "MSCBML0";
	dNSM = 0;
	A = 0;
	Izz = 0;
	Iyy = 0;
	J = 0;
	ybar = 0;
	zbar = 0;
}

int PBARL::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	int i;
	char S1[8] = "";
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "Material ID (MID)";
	iNo++;
	sVar[iNo] = "Section";
	iNo++;
	for (i = 0; i < iNoDims; i++) {
		sprintf_s(S1, "DIM %i", i + 1);
		sVar[iNo] = S1;
		iNo++;
	}
	sVar[iNo] = "Non Strut Mass";
	iNo++;

	return (iNo);
}

int PBARL::GetVarValues(CString sVar[]) {
	int iNo = 0;
	int i;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMID);
	sVar[iNo] = S1;
	iNo++;
	sVar[iNo] = sSecType;
	iNo++;
	for (i = 0; i < iNoDims; i++) {
		sprintf_s(S1, "%g", dDIMs[i]);
		sVar[iNo] = S1;
		iNo++;
	}
	sprintf_s(S1, "%g", dNSM);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void PBARL::PutVarValues(int iNo, CString sVar[]) {
	int iC = 1;
	int i;
	iFile = atoi(sVar[0]);
	iMID = atoi(sVar[iC]);
	iC++;
	iC++;
	for (i = 0; i < iNoDims; i++) {
		dDIMs[i] = atof(sVar[iC]);
		iC++;
	}
	iC++;
	dNSM = atof(sVar[iC]);
	CreateSec();
}

void PBARL::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << iMID;
		ar << sGROUP;
		ar << sSecType;
		ar << iNoDims;
		ar << dNSM;
		for (i = 0; i < iNoDims; i++) {
			ar << dDIMs[i];
		}
		DspSec.Serialize(ar, iV);
	} else {
		Entity::Serialize(ar, iV);
		ar >> iMID;
		ar >> sGROUP;
		ar >> sSecType;
		ar >> iNoDims;
		ar >> dNSM;
		for (i = 0; i < iNoDims; i++) {
			ar >> dDIMs[i];
		}
		DspSec.Serialize(ar, iV);
		CalcProps();
	}
}

void PBARL::List() {
	char S1[200];
	CString OutT;
	outtext1("PROPERTY LISTING:-");
	sprintf_s(S1, "%s %i %s %s", "PID", iID, "TYPE ", "BEAM");
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %s", "TITLE : ", sTitle);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %s", "TYPE  : ", sSecType);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %s", "GRP   : ", sGROUP);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %i", "MAT1  : ", iMID);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %g", "A     : ", A);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %g", "Iyy   : ", Iyy);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %g", "Izz   : ", Izz);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %g", "J     : ", J);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %f", "yBar     : ", ybar);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %f", "zBar     : ", zbar);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %f", "NSM   : ", dNSM);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %i", "IDIMS : ", iNoDims);
	outtext1(_T(S1));
	int i;
	for (i = 0; i < iNoDims; i++) {
		sprintf_s(S1, "DIM: %i : %f", i, dDIMs[i]);
		outtext1(_T(S1));
	}
}

void PBARL::CreateSec() {
	this->CalcProps();
	if (sSecType.Find("BOX") > -1) {
		DspSec.CreateBox(dDIMs[0], dDIMs[1], dDIMs[2], dDIMs[3]);
	}
	if (sSecType.Find("L ") > -1) {
		DspSec.CreateL(dDIMs[0], dDIMs[1], dDIMs[2], dDIMs[3], ybar, zbar);
	} else if (sSecType.Find("BAR") > -1) {
		DspSec.CreateBar(dDIMs[0], dDIMs[1]);
	} else if (sSecType.Find("ROD") > -1) {
		DspSec.CreateRod(dDIMs[0]);
	} else if (sSecType.Find("TUBE") > -1) {
		DspSec.CreateTube(dDIMs[0], dDIMs[1]);
	} else if (sSecType.Find("T2") > -1) {
		DspSec.CreateT2(dDIMs[0], dDIMs[1], dDIMs[2], dDIMs[3], ybar);
	} else if (sSecType.Find("CHAN2") > -1) {
		DspSec.CreateCHAN2(dDIMs[0], dDIMs[1], dDIMs[2], dDIMs[3], ybar);
	} else if (sSecType.Find("I ") > -1) {
		DspSec.CreateI2(dDIMs[0], dDIMs[1], dDIMs[2], dDIMs[3], dDIMs[4], dDIMs[5], ybar);
	}
}

int PBARL::GetMat() {
	return (iMID);
}

BOOL PBARL::HasMat(int inMID) {
	BOOL brc = FALSE;
	if (iMID == inMID) {
		brc = TRUE;
	}
	return (brc);
}

int PBARL::GetNoDims() {
	int iRet = -1;
	if (sSecType.Find("BOX") > -1) {
		iRet = 4;
	} else if (sSecType.Find("BAR") > -1) {
		iRet = 2;
	} else if (sSecType.Find("ROD") > -1) {
		iRet = 1;
	} else if (sSecType.Find("TUBE") > -1) {
		iRet = 2;
	} else if (sSecType.Find("I   ") > -1) {
		iRet = 6;
	}
	return iRet;
}

void PBARL::ExportNAS(FILE* pFile) {
	int i;
	fprintf(pFile, "$%s\n", sTitle);
	fprintf(pFile, "%8s%8i%8i%8s%8s%8s\n", "PBARL   ", iID, iMID, sGROUP, ncr(sSecType), " ");
	fprintf(pFile, "%8s", " ");
	for (i = 0; i < iNoDims; i++) {
		fprintf(pFile, "%8s", e8(dDIMs[i]));
	}
	fprintf(pFile, "%8s\n", e8(dNSM));
}

PBARL* PBARL::Copy() {
	int i;
	PBARL* pREt = new PBARL();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->iMID = iMID;
	pREt->sGROUP = sGROUP;
	pREt->sSecType = sSecType;
	pREt->iNoDims = iNoDims;
	pREt->dNSM = dNSM;
	for (i = 0; i < iNoDims; i++) {
		pREt->dDIMs[i] = dDIMs[i];
	}
	pREt->DspSec.iLnCnt1 = DspSec.iLnCnt1;
	pREt->DspSec.iLnCnt2 = DspSec.iLnCnt2;
	for (i = 0; i < DspSec.iLnCnt1; i++) {
		pREt->DspSec.pLnLoop1[i] = DspSec.pLnLoop1[i];
	}
	for (i = 0; i < DspSec.iLnCnt2; i++) {
		pREt->DspSec.pLnLoop2[i] = DspSec.pLnLoop2[i];
	}
	return (pREt);
}

BSec* PBARL::GetSec() {
	return (&DspSec);
}

void PBARL::UpdateMats(NEList* newMats) {
	iMID = newMats->Get(iMID);
}

void PBARL::ChangeMat(int thisMat, int inMID) {
	if (iMID == thisMat)
		iMID = inMID;
}

int PBARL::GetDefMatID() {
	return (iMID);
}

void PBARL::CalcProps() {
	if (sSecType.Find("ROD") != -1) {
		double R = dDIMs[0];
		A = Pi * R * R;
		Izz = Pi * R * R * R * R / 4;
		Iyy = Izz;
		J = Pi * R * R * R * R / 2;
	} else if (sSecType.Find("TUBE") != -1) {
		double Do = 2 * dDIMs[0];
		double Di = 2 * dDIMs[1];
		A = Pi * (Do * Do - Di * Di) / 4;
		Izz = Pi * (Do * Do * Do * Do - Di * Di * Di * Di) / 64;
		Iyy = Izz;
		J = Pi * (Do * Do * Do * Do - Di * Di * Di * Di) / 32;
	} else if (sSecType.Find("BAR") != -1) {
		double W = dDIMs[0];
		double H = dDIMs[1];
		double a, b;
		a = W;
		b = H;
		if (a < b) {
			a = H;
			b = W;
		}
		A = W * H;
		Iyy = H * W * W * W / 12;
		Izz = W * H * H * H / 12;
		J = a * b * b * b * (0.333333333 - 0.21 * b / a * (1 - b * b * b * b / (12 * a * a * a * a)));
	} else if (sSecType.Find("BOX") != -1) {
		double Wo = dDIMs[0];
		double Ho = dDIMs[1];
		double Wi = Wo - 2 * dDIMs[2];
		double Hi = Ho - 2 * dDIMs[3];
		double wt = dDIMs[2];
		double ht = dDIMs[3];
		A = Wo * Ho - Wi * Hi;
		Iyy = Ho * Wo * Wo * Wo / 12 - Hi * Wi * Wi * Wi / 12;
		Izz = Wo * Ho * Ho * Ho / 12 - Wi * Hi * Hi * Hi / 12;
		J = 2 * wt * ht * (Wo - wt) * (Wo - wt) * (Ho - ht) * (Ho - ht);
		J /= (Wo * wt + Ho * ht - wt * wt - ht * ht);
	} else if (sSecType.Find("T2") != -1) {
		double h = dDIMs[1];
		double b = dDIMs[0];
		double tw = dDIMs[3];
		double tf = dDIMs[2];
		double Ayc = 0;
		double yc = 0;
		double Iyo = 0;
		A = b * tf + (h - tf) * tw;
		Ayc = tw * h * h * 0.5 + (b - tw) * tf * tf * 0.5;
		yc = Ayc / A;
		ybar = yc;
		Iyo = tw * h * h * h / 3 + (b - tw) * tf * tf * tf / 3;
		Izz = Iyo - A * yc * yc;
		Iyy = (h - tf) * tw * tw * tw / 12 + tf * b * b * b / 12;
		double dd;
		dd = h - tf / 2;

		J = (b * tf * tf * tf + dd * tw * tw * tw) / 3;
	} else if (sSecType.Find("CHAN2") != -1) {
		double h = dDIMs[2];
		double w = dDIMs[3];
		double wt = dDIMs[1];
		double ft = dDIMs[0];
		double AI = 0; // First moment of area
		double c = 0;

		A = w * h - (w - 2 * ft) * (h - wt);
		AI = h * ft * h + (w - 2 * ft) * wt * wt / 2;
		ybar = AI / A;
		Iyy = h * w * w * w / 12 - (h - wt) * (w - 2 * ft) * (w - 2 * ft) * (w - 2 * ft) / 12;
		Izz = ft * h * h * h / 6 + 2 * h * ft * (h / 2 - ybar) * (h / 2 - ybar);
		c = w - 2 * ft;
		Izz += c * wt * wt * wt / 12 + c * wt * (ybar - wt / 2) * (ybar - wt / 2);
		double bb;
		double dd;
		// https://www.projectengineer.net/what-is-the-torsion-constant/
		bb = h - wt / 2;
		dd = w - ft;
		J = (2 * bb * ft * ft * ft + dd * wt * w * wt) / 3;
	} else if (sSecType.Find("I ") != -1) {
		double h = dDIMs[0];
		double wb = dDIMs[1];
		;
		double wt = dDIMs[2];
		;
		double tw = dDIMs[3];
		;
		double tbf = dDIMs[4];
		;
		double ttf = dDIMs[5];
		;
		double fh;
		double AY;
		fh = h - tbf - ttf;
		A = wb * tbf + wt * ttf + fh * tw;
		AY = wb * tbf * tbf / 2 + wt * ttf * (h - ttf / 2) + fh * tw * (fh / 2 + tbf);
		ybar = AY / A;
		Iyy = tbf * wb * wb * wb / 12 + ttf * wt * wt * wt / 12 + fh * tw * tw * tw / 12;
		Izz = wb * tbf * tbf * tbf / 12 + wb * tbf * (ybar - tbf / 2) * (ybar - tbf / 2);
		Izz += wt * ttf * ttf * ttf / 12 + wt * ttf * (h - ttf / 2 - ybar) * (h - ttf / 2 - ybar);
		Izz += tw * fh * fh * fh / 12 + tw * fh * (fh / 2 + tbf - ybar) * (fh / 2 + tbf - ybar);
		double dd;
		dd = h - (ttf + tbf) / 0.5;
		J = (wt * ttf * ttf * ttf + wb * tbf * tbf * tbf + dd * tw * tw * tw) / 3;
	} else if (sSecType.Find("L ") != -1) {
		double w = dDIMs[0];
		double h = dDIMs[1];
		;
		double ht = dDIMs[2];
		;
		double wt = dDIMs[3];
		;
		A = w * ht + (h - ht) * wt;
		ybar = w * ht * ht / 2 + (h - ht) * wt * ((h - ht) / 2 + ht);
		ybar /= A;
		zbar = h * wt * wt / 2 + (w - wt) * ht * ((w - wt) / 2 + wt);
		zbar /= A;
		Iyy = wt * h * h * h / 12 + wt * h * (h / 2 - ybar) * (h / 2 - ybar);
		Iyy += (w - wt) * ht * ht * ht / 12 + (w - wt) * ht * (ybar - ht / 2) * (ybar - ht / 2);

		Izz = ht * w * w * w / 12 + ht * w * (w / 2 - zbar) * (w / 2 - zbar);
		Izz += (h - ht) * wt * wt * wt / 12 + (h - ht) * wt * (zbar - wt / 2) * (zbar - wt / 2);
		J = (w * w * w * ht + (h - ht) * (h - ht) * (h - ht) * wt) / 3;
	} else {
		outtext1("ERROR: Unable to Calculate Beam Properties.");
	}
}

//************************************************
IMPLEMENT_DYNAMIC(PROD, CObject)

PROD::PROD() {
	sTitle = "PROD";
	iID = -1;
	iType = 11;
	iMID = -1;
	sSecType = "VIEW";
	DspSec.Clear();
	A = 0;
	J = 0;
}

void PROD::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << iMID;
		ar << sGROUP;
		ar << sSecType;
		ar << A;
		ar << J;
		DspSec.Serialize(ar, iV);
	} else {
		Entity::Serialize(ar, iV);
		ar >> iMID;
		ar >> sGROUP;
		ar >> sSecType;
		ar >> A;
		ar >> J;
		DspSec.Serialize(ar, iV);
	}
}

void PROD::CreateSec() {
	double W;
	W = pow(A, 0.5);
	W *= 1 / Pi;
	DspSec.CreateDefSec(W, 4);
}

BOOL PROD::HasMat(int inMID) {
	BOOL brc = FALSE;
	if (iMID == inMID) {
		brc = TRUE;
	}
	return (brc);
}

PROD* PROD::Copy() {
	int i;
	PROD* pREt = new PROD();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->iMID = iMID;
	pREt->sGROUP = sGROUP;
	pREt->sSecType = sSecType;

	pREt->DspSec.iLnCnt1 = DspSec.iLnCnt1;
	pREt->DspSec.iLnCnt2 = DspSec.iLnCnt2;
	for (i = 0; i < DspSec.iLnCnt1; i++) {
		pREt->DspSec.pLnLoop1[i] = DspSec.pLnLoop1[i];
	}
	for (i = 0; i < DspSec.iLnCnt2; i++) {
		pREt->DspSec.pLnLoop2[i] = DspSec.pLnLoop2[i];
	}
	return (pREt);
}

void PROD::List() {
	char S1[200];
	CString OutT;
	outtext1("PROPERTY LISTING:-");
	sprintf_s(S1, "%s %i %s %s", "PID", iID, "TYPE ", "ROD");
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %s", "TITLE : ", sTitle);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %s", "TYPE  : ", sSecType);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %s", "GRP   : ", sGROUP);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %i", "MAT1  : ", iMID);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %f", "A     : ", A);
	outtext1(_T(S1));
	sprintf_s(S1, "%s %f", "J     : ", J);
	outtext1(_T(S1));
}

BSec* PROD::GetSec() {
	return (&DspSec);
}

int PROD::GetMat() {
	return (iMID);
}

void PROD::UpdateMats(NEList* newMats) {
	iMID = newMats->Get(iMID);
}

void PROD::ChangeMat(int thisMat, int inMID) {
	if (iMID == thisMat)
		iMID = inMID;
}

int PROD::GetDefMatID() {
	return (iMID);
}

void PROD::CalcProps() {
}

void PROD::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8i%8s%8s\n", "PROD    ", iID, iMID, e8(A), e8(J));
}

//***************************************************

int PROD::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Material ID (MID)";
	sVar[2] = "Secton area (A)";
	sVar[3] = "Torsional constant (J)";
	return (4);
}

int PROD::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", A);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", J);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void PROD::PutVarValues(int iNo, CString sVar[]) {
	iFile = atoi(sVar[0]);
	iMID = atoi(sVar[1]);
	A = atof(sVar[2]);
	J = atof(sVar[3]);
	CreateSec();
}

IMPLEMENT_DYNAMIC(PSHELL, CObject)

void PSHELL::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << iMID1;
		ar << dT;
		ar << iMID2;
		ar << d12IT3;
		ar << iMID3;
		ar << dTST;
		ar << dNSM;
		ar << dZ1;
		ar << dZ2;
		ar << iMID4;
	} else {
		Entity::Serialize(ar, iV);
		ar >> iMID1;
		ar >> dT;
		ar >> iMID2;
		ar >> d12IT3;
		ar >> iMID3;
		ar >> dTST;
		ar >> dNSM;
		ar >> dZ1;
		ar >> dZ2;
		ar >> iMID4;
	}
}

int PSHELL::GetMat() {
	return (iMID1);
}

BOOL PSHELL::HasMat(int inMID) {
	BOOL brc = FALSE;
	if (iMID1 == inMID) {
		brc = TRUE;
	}
	return (brc);
}

void PSHELL::List() {
	char S1[200];
	CString OutT;
	outtext1("PROPERTY LISTING:-");
	sprintf_s(S1, "%s %i %s %s", "PID", iID, "TYPE ", "SHELL");
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %s", "TITLE : ", sTitle);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %i", "MAT1  : ", iMID1);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "THK   : ", dT);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %i", "MAT2  : ", iMID2);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "12IT3 : ", d12IT3);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %i", "MAT3  : ", iMID3);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "TST   : ", dTST);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s %f", "NSM   : ", dNSM);
	OutT = S1;
	outtext1(OutT);
	if ((dZ1 != DBL_MAX) || (dZ2 != DBL_MAX) || (iMID4 > 0)) {
		sprintf_s(S1, "%s %f", "Z1    : ", dZ1);
		OutT = S1;
		outtext1(OutT);
		sprintf_s(S1, "%s %f", "Z2    : ", dZ2);
		OutT = S1;
		outtext1(OutT);
	}
}

double PSHELL::GetThk() {
	return (dT);
}

void PSHELL::UpdateMats(NEList* newMats) {
	iMID1 = newMats->Get(iMID1);
	iMID2 = newMats->Get(iMID2);
	iMID3 = newMats->Get(iMID3);
	iMID4 = newMats->Get(iMID4);
}

void PSHELL::ChangeMat(int thisMat, int inMID) {
	if (iMID1 == thisMat) {
		iMID1 = inMID;
	}
	if (iMID2 == thisMat) {
		iMID2 = inMID;
	}
	if (iMID3 == thisMat) {
		iMID3 = inMID;
	}
}

int PSHELL::GetDefMatID() {
	return (iMID1);
}

PSHELL* PSHELL::Copy() {
	PSHELL* pREt = new PSHELL();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->iMID1 = iMID1;
	pREt->dT = dT;
	pREt->iMID2 = iMID2;
	pREt->d12IT3 = d12IT3;
	pREt->iMID3 = iMID3;
	pREt->dTST = dTST;
	pREt->dNSM = dNSM;
	pREt->dZ1 = dZ1;
	pREt->dZ2 = dZ2;
	return (pREt);
}

void PSHELL::ExportNAS(FILE* pFile) {
	fprintf(pFile, "$%s\n", sTitle);
	fprintf(pFile, "%s", ToString());
}

CString PSHELL::ToString() {
	char S[200] = "";
	CString src = "";
	sprintf_s(S, "%8s%8i%8i%8s%8i", "PSHELL  ", iID, iMID1, e8(dT), iMID2);
	src = S;
	if (d12IT3 == 0)
		sprintf_s(S, "%8s", "        ");
	else
		sprintf_s(S, "%8s", e8(d12IT3));
	src += S;
	if (iMID3 == 0)
		sprintf_s(S, "%8s", "        ");
	else
		sprintf_s(S, "%8i", iMID3);
	src += S;
	if (dTST == 0)
		sprintf_s(S, "%8s", "        ");
	else
		sprintf_s(S, "%8s", e8(dTST));
	src += S;
	sprintf_s(S, "%8s\n", e8(dNSM));
	src += S;
	if ((dZ1 != 0) || (dZ2 != 0) || (iMID4 != 0)) {
		src += "        ";
		if (dZ1 == 0)
			sprintf_s(S, "%8s", "        ");
		else
			sprintf_s(S, "%8s", e8(dZ1));
		src += S;
		if (dZ2 == 0)
			sprintf_s(S, "%8s", "        ");
		else
			sprintf_s(S, "%8s", e8(dZ2));
		src += S;
		if (iMID4 == 0)
			sprintf_s(S, "%8s\n", "        ");
		else
			sprintf_s(S, "%8i\n", iMID4);
		src += S;
	}
	return (src);
}

PSHELL::PSHELL() {
	sTitle = "";
	iID = -1;
	iType = 1;
	iMID1 = -1;
	dT = 0;
	iMID2 = -1;
	d12IT3 = 1.0;
	iMID3 = -1;
	dTST = .833333;
	dNSM = 0;
	dZ1 = 0;
	dZ2 = 0;
	iMID4 = 0;
}

int PSHELL::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Material ID 1 (MID)";
	sVar[2] = "Thickness (T)";
	sVar[3] = "Material ID 2 (MID2)";
	sVar[4] = "Bending stiffness parameter (12IT3)";
	sVar[5] = "Material transverse shear (MID3)";
	sVar[6] = "Transverse shear ratio  (TS/T)";
	sVar[7] = "Non structural mass  (NSM)";
	sVar[8] = "Fibre dist for stresses (Z1)";
	sVar[9] = "Fibre dist for stresses (Z2)";
	sVar[10] = "Material membrane-bending coupling (MID4)";
	return (11);
}

int PSHELL::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMID1);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dT);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMID2);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", d12IT3);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMID3);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dTST);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dNSM);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dZ1);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dZ2);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMID4);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void PSHELL::PutVarValues(int iNo, CString sVar[]) {
	iFile = atoi(sVar[0]);
	iMID1 = atoi(sVar[1]);
	dT = atof(sVar[2]);
	iMID2 = atoi(sVar[3]);
	d12IT3 = atof(sVar[4]);
	iMID3 = atoi(sVar[5]);
	dTST = atof(sVar[6]);
	dNSM = atof(sVar[7]);
	dZ1 = atof(sVar[8]);
	dZ2 = atof(sVar[9]);
	iMID4 = atoi(sVar[10]);
}

// MAt1
IMPLEMENT_DYNAMIC(MAT1, CObject)

MAT1* MAT1::Copy() {
	MAT1* pREt = new MAT1();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;
	pREt->dE = dE;
	pREt->dG = dG;
	pREt->dNU = dNU;
	pREt->dRHO = dRHO;
	pREt->dA = dA;
	pREt->dTREF = dTREF;
	pREt->dGE = dGE;
	pREt->dST = dST;
	pREt->dSC = dSC;
	pREt->dSS = dSS;
	pREt->iMCSID = iMCSID;
	return (pREt);
}

double MAT1::GetDensity() {
	return (dRHO);
}

double MAT1::GetCTE() {
	return (dA);
}

double MAT1::GetE() {
	return (dE);
}

double MAT1::GetV() {
	return (dNU);
}

void MAT1::Info() {
	char S1[200] = "";
	// Saeed_Material_SaveBugV1_05_20_2025_Start
	/*
	//Saeed_Material_SaveBugV1_05_20_2025_End
	outtext1("MATERIAL LISTING:-");
	//Saeed_Material_SaveBugV1_05_20_2025_Start
	*/
	outtext1("MATERIAL LISTING:");
	// Saeed_Material_SaveBugV1_05_20_2025_End
	sprintf_s(S1, "LAB: %i TITLE: %s", iID, sTitle);
	outtext1(S1);
	sprintf_s(S1, "E    : %f", dE);
	outtext1(S1);
	if (dG != DBL_MAX)
		sprintf_s(S1, "G    : %s", float8NAS(dG));
	else
		sprintf_s(S1, "G    : %s", "");
	outtext1(S1);
	sprintf_s(S1, "NU   : %s", float8NAS(dNU));
	outtext1(S1);
	sprintf_s(S1, "RHO  : %s", float8NAS(dRHO));
	outtext1(S1);
	sprintf_s(S1, "CTE  : %s", float8NAS(dA));
	outtext1(S1);
	sprintf_s(S1, "MCID : %i", iMCSID);
	outtext1(S1);
	sprintf_s(S1, "k    : %s", float8NAS(dk));
	outtext1(S1);
}

int MAT1::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Young Modulus (E)";
	sVar[2] = "Shear Modulus (G)";
	sVar[3] = "Poisions Ratio )NU)";
	sVar[4] = "Density (RHO)";
	sVar[5] = "Coeff Thermal Expansion (CTE)";
	sVar[6] = "Reference Temperatue (TREF)";
	sVar[7] = "Material Coordinate Sys (MCID)";
	sVar[8] = "Thermal Conductivity (k)";
	return (9);
}

int MAT1::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dE);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dG);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dNU);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dRHO);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dA);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dTREF);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iMCSID);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dk);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void MAT1::PutVarValues(int iNo, CString sVar[]) {
	iFile = atoi(sVar[0]);
	dE = atof(sVar[1]);
	dG = atof(sVar[2]);
	dNU = atof(sVar[3]);
	dRHO = atof(sVar[4]);
	dA = atof(sVar[5]);
	dTREF = atof(sVar[6]);
	iMCSID = atoi(sVar[7]);
	dk = atof(sVar[8]);
}

Mat MAT1::DeeMEM() {
	double C, G;
	Mat dee(3, 3);
	if (dG > 0) // G has been specified
		G = dG;
	else
		G = dE / (2 * (1 + dNU));
	C = dE / (1 - dNU * dNU);
	*dee.mn(1, 1) = C;
	*dee.mn(2, 2) = C;
	*dee.mn(3, 3) = G; // 0.5 * (1 - dNU) * C; //this should be G not sure is correct??
	*dee.mn(1, 2) = dNU * C;
	*dee.mn(2, 1) = dNU * C;

	return (dee);
}

// SHELL_D matrix for bending coeffients for Dee Matrix
Mat MAT1::DeeBM() {
	Mat EBM(3, 3);
	double G = 0;
	double DEN1 = 0;
	double E0 = 0;
	if (dG > 0)
		G = dG;
	else
		G = dE / (2 * (1 + dNU));
	DEN1 = 1 - dNU * dNU;
	if (abs(DEN1) < 0.01)
		outtext1("ERROR: Material Property Error 1-v*v very small.");
	EBM.MakeZero();
	E0 = dE / DEN1;
	*EBM.mn(1, 1) = E0;
	*EBM.mn(2, 2) = *EBM.mn(1, 1);
	*EBM.mn(3, 3) = G;
	*EBM.mn(1, 2) = E0 * dNU;
	*EBM.mn(2, 1) = *EBM.mn(1, 2);
	return (EBM);
}

Mat MAT1::DeeSH() {
	Mat ESH(2, 2);
	double G = 0;
	if (dG > 0)
		G = dG;
	else
		G = dE / (2 * (1 + dNU));
	ESH.MakeZero();
	*ESH.mn(1, 1) = G;
	*ESH.mn(2, 2) = G;
	return (ESH);
}

void MAT1::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << dE;
		ar << dG;
		ar << dNU;
		ar << dRHO;
		ar << dA;
		ar << dk;
		ar << dTREF;
		ar << dGE;
		ar << dST;
		ar << dSC;
		ar << dSS;
		ar << iMCSID;
	} else {
		Entity::Serialize(ar, iV);
		ar >> dE;
		ar >> dG;
		ar >> dNU;
		ar >> dRHO;
		ar >> dA;
		ar >> dk;
		ar >> dTREF;
		ar >> dGE;
		ar >> dST;
		ar >> dSC;
		ar >> dSS;
		ar >> iMCSID;
	}
}

void MAT1::ExportNAS(FILE* pFile) {
	fprintf(pFile, "$%s\n", sTitle.GetString());
	CString sG = "        ";
	CString sV = "        ";
	CString CTE;
	if (dG > 0) {
		sG = e8(dG);
	} else {
		sV = e8(dNU);
	}
	CTE = e8(dA);
	fprintf(pFile, "%8s%8i%8s%8s%8s%8s%8s%8s%8s\n", "MAT1    ", iID, e8(dE), sG, sV, e8(dRHO), e8(dA), e8(dTREF),
	        e8(dGE));
	// fprintf(pFile,"%8s%8s%8s%8s%8i\n","        ",e8(dST),e8(dSC),e8(dSS),iMCSID);
}

MAT1::MAT1() {
	sTitle = "";
	iID = -1;
	iType = 7;
	dE = 210e9;
	dG = 0;
	dNU = 0.29;
	dRHO = 0;
	dA = 0;
	dk = 0;
	dTREF = 0;
	dGE = 0;
	dST = 0;
	dSC = 0;
	dSS = 0;
	iMCSID = -1;
}

// MAt8
IMPLEMENT_DYNAMIC(MAT8, CObject)

MAT8* MAT8::Copy() {
	MAT8* pREt = new MAT8();
	pREt->iType = iType;
	pREt->sTitle = sTitle;
	pREt->iID = iID;
	pREt->dE1 = dE1;
	pREt->dE2 = dE2;
	pREt->dNU12 = dNU12;
	pREt->dG12 = dG12;
	pREt->dG1Z = dG1Z;
	pREt->dG2Z = dG2Z;
	pREt->dRHO = dRHO;

	pREt->dA1 = dA1;
	pREt->dA2 = dA2;
	pREt->dTREF = dTREF;
	pREt->dXt = dXt;
	pREt->dXc = dXc;
	pREt->dYt = dYt;
	pREt->dYc = dYc;

	pREt->dS = dS;
	pREt->dGE = dGE;
	pREt->F12 = F12;
	pREt->STRN = STRN;
	return (pREt);
}

double MAT8::GetDensity() {
	return (dRHO);
}

void MAT8::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << dE1;
		ar << dE2;
		ar << dNU12;
		ar << dG12;
		ar << dG1Z;
		ar << dG2Z;
		ar << dRHO;

		ar << dA1;
		ar << dA2;
		ar << dTREF;
		ar << dXt;
		ar << dXc;
		ar << dYt;
		ar << dYc;

		ar << dS;
		ar << dGE;
		ar << F12;
		ar << STRN;
	} else {
		Entity::Serialize(ar, iV);
		ar >> dE1;
		ar >> dE2;
		ar >> dNU12;
		ar >> dG12;
		ar >> dG1Z;
		ar >> dG2Z;
		ar >> dRHO;

		ar >> dA1;
		ar >> dA2;
		ar >> dTREF;
		ar >> dXt;
		ar >> dXc;
		ar >> dYt;
		ar >> dYc;

		ar >> dS;
		ar >> dGE;
		ar >> F12;
		ar >> STRN;
	}
}

void MAT8::ExportNAS(FILE* pFile) {
	fprintf(pFile, "$%s\n", sTitle.GetString());
	fprintf(pFile, "%s", ToString().GetString());
	// fprintf(pFile,"%8s%8i%8s%8s%8s%8s%8s%8s%8s\n","MAT8    ",iID,e8(dE1),e8(dE2),e8(dNU12),e8(dG12),e8(dG1Z),e8(dG2Z),e8(dRHO));
	// fprintf(pFile,"%8s%8s%8s%8s%8s%8s%8s%8s%8s\n","        ",e8(dA1),e8(dA2),e8(dTREF),e8(dXt),e8(dXc),e8(dYt),e8(dYc),e8(dS));
	// fprintf(pFile,"%8s%8s%8s\n","        ",e8(dGE),e8(F12),e8(STRN));
}

CString MAT8::ToString() {
	char S[200] = "";
	CString src = "";
	sprintf_s(S, "%8s%8i%8s%8s%8s%8s%8s%8s%8s\n", "MAT8    ", iID, e8(dE1).GetString(), e8(dE2).GetString(),
	          e8(dNU12).GetString(), e8(dG12).GetString(), e8(dG1Z).GetString(), e8(dG2Z).GetString(),
	          e8(dRHO).GetString());
	src = S;
	sprintf_s(S, "        %8s%8s", e8(dA1).GetString(), e8(dA2).GetString());
	src += S;
	if (dTREF == 0)
		sprintf_s(S, "%8s", "        ");
	else
		sprintf_s(S, "%8s", e8(dTREF).GetString());
	src += S;
	if (dXt == 0)
		sprintf_s(S, "%8s", "        ");
	else
		sprintf_s(S, "%8s", e8(dXt).GetString());
	src += S;
	if (dXc == 0)
		sprintf_s(S, "%8s", "        ");
	else
		sprintf_s(S, "%8s", e8(dXc).GetString());
	src += S;
	if (dYt == 0)
		sprintf_s(S, "%8s", "        ");
	else
		sprintf_s(S, "%8s", e8(dYt).GetString());
	src += S;
	if (dYc == 0)
		sprintf_s(S, "%8s", "        ");
	else
		sprintf_s(S, "%8s", e8(dYc).GetString());
	src += S;
	if (dS == 0)
		sprintf_s(S, "%8s\n", "        ");
	else
		sprintf_s(S, "%8s\n", e8(dS).GetString());
	src += S;
	if (dGE == 0)
		sprintf_s(S, "        %8s", "        ");
	else
		sprintf_s(S, "        %8s", e8(dGE).GetString());
	src += S;
	if (F12 == 0)
		sprintf_s(S, "%8s", "        ");
	else
		sprintf_s(S, "%8s", e8(F12).GetString());
	src += S;
	if (STRN == 0)
		sprintf_s(S, "%8s\n", "        ");
	else
		sprintf_s(S, "%8s\n", e8(STRN).GetString());
	src += S;
	return (src);
}

MAT8::MAT8() {
	sTitle = "";
	iID = -1;
	iType = 8;
	dE1 = 0;
	dE2 = 0;
	dNU12 = 0;
	dG12 = 0;
	dG1Z = 0;
	dG2Z = 0;
	dRHO = 0;

	dA1 = 0;
	dA2 = 0;
	dTREF = 0;
	dXt = 0;
	dXc = 0;
	dYt = 0;
	dYc = 0;

	dS = 0;
	dGE = 0;
	F12 = 0;
	STRN = 0;
}

int MAT8::GetVarHeaders(CString sVar[]) {
	sVar[0] = "File No";
	sVar[1] = "Young Modulus longitudinal (E1)";
	sVar[2] = "Young Modulus lateral (E2)";
	sVar[3] = "Poisions ratio (NU12)";
	sVar[4] = "In-plane shear modulus(G12)";
	sVar[5] = "Transverse shear modulus 1-Z plane.(G1Z)";
	sVar[6] = "Transverse shear modulus 2-Z plane.(G2Z)";
	sVar[7] = "Density (RHO)";
	sVar[8] = "Coeff thermal expansion 1 Dir (A1)";
	sVar[9] = "Coeff thermal expansion 2 Dir (A2)";
	sVar[10] = "Reference Temperatue (TREF)";
	sVar[11] = "Allow tensile stress 1 Dir (dXt)";
	sVar[12] = "Allow compressive stress 1 Dir (dXc)";
	sVar[13] = "Allow tensile stress 2 Dir (dYt)";
	sVar[14] = "Allow compressive stress 2 Dir (dYc)";
	sVar[15] = "Allow stress/strain in-plane shear (S)";
	sVar[16] = "Structural damping coefficient (GE)";
	sVar[17] = "Tsai-Wu interactive term (F12)";
	sVar[18] = "Xt,Xc,Yt,Yc are STRN if 1 (STRN)";
	// sVar[7] = "Thermal Conductivity (k)";
	return (19);
}

int MAT8::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dE1);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dE2);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dNU12);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dG12);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dG1Z);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dG2Z);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dRHO);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dA1);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dA2);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dTREF);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dXt);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dXc);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dYt);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dYc);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dS);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dGE);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", F12);
	sVar[iNo] = S1;
	iNo++;
	if (STRN == 0)
		sprintf_s(S1, "%s", "        ");
	else
		sprintf_s(S1, "%g", STRN);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void MAT8::PutVarValues(int iNo, CString sVar[]) {
	iFile = atoi(sVar[0]);
	dE1 = atof(sVar[1]);
	dE2 = atof(sVar[2]);
	dNU12 = atof(sVar[3]);
	dG12 = atof(sVar[4]);
	dG1Z = atof(sVar[5]);
	dG2Z = atof(sVar[6]);
	dRHO = atof(sVar[7]);

	dA1 = atof(sVar[8]);
	dA2 = atof(sVar[9]);
	dTREF = atof(sVar[10]);
	dXt = atof(sVar[11]);
	dXc = atof(sVar[12]);
	dYt = atof(sVar[13]);
	dYc = atof(sVar[14]);

	dS = atof(sVar[15]);
	dGE = atof(sVar[16]);
	F12 = atof(sVar[17]);
	STRN = atof(sVar[18]);
}

//*************************************************************************
//                               P C O M P G
//*************************************************************************
IMPLEMENT_DYNAMIC(PCOMPG, CObject)

PCOMPG::PCOMPG() {
	sTitle = "";
	iID = -1;
	iType = 222;
	dZ0 = -0.5;
	dNSM = 0;
	dSB = 0;
	FT = 4;
	dRefT = 0;
	dGE = 0;
	bLAM = FALSE;
	iNoLays = 0;
}

void PCOMPG::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << dZ0;
		ar << dNSM;
		ar << dSB;
		ar << FT;
		ar << dRefT;
		ar << dGE;
		ar << bLAM;
		ar << iNoLays;
		for (i = 0; i < iNoLays; i++) {
			ar << GPLYID[i];
			ar << MID[i];
			ar << T[i];
			ar << Theta[i];
			ar << sOut[i];
		}
	} else {
		Entity::Serialize(ar, iV);
		ar >> dZ0;
		ar >> dNSM;
		ar >> dSB;
		ar >> FT;
		ar >> dRefT;
		ar >> dGE;
		ar >> bLAM;
		ar >> iNoLays;
		for (i = 0; i < iNoLays; i++) {
			ar >> GPLYID[i];
			ar >> MID[i];
			ar >> T[i];
			ar >> Theta[i];
			ar >> sOut[i];
		}
	}
}

void PCOMPG::AddLayer(int inPLYID, int inMID, double inT, double inThe, BOOL inSo) {
	if (iNoLays < MAX_LAYERS) {
		GPLYID[iNoLays] = inPLYID;
		MID[iNoLays] = inMID;
		T[iNoLays] = inT;
		Theta[iNoLays] = inThe;
		sOut[iNoLays] = inSo;
		iNoLays++;
	} else {
		outtext1("ERROR: Max No of Layers Exceeded.");
	}
}

double PCOMPG::GetThk() {
	int i;
	double dRet = 0;
	for (i = 0; i < iNoLays; i++) {
		dRet += T[i];
	}
	if (bLAM == TRUE)
		dRet *= 2;
	return (dRet);
}

int PCOMPG::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	int i;
	char S1[80] = "";
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "Dist to bottom surf (Z0)";
	iNo++;
	sVar[iNo] = "Non structural mass (NSM)";
	iNo++;
	sVar[iNo] = "Allow shear stress (SB)";
	iNo++;
	sVar[iNo] = "Failure theory (FT)";
	iNo++;
	sVar[iNo] = "Reference temperature (TREF)";
	iNo++;
	sVar[iNo] = "Damping coefficient  (GE)";
	iNo++;
	sVar[iNo] = "Laminate options.  (LAM)";
	iNo++;
	sVar[iNo] = "No Off Layers ";
	iNo++;
	sVar[iNo] = "Total Thickness ";
	iNo++;
	for (i = 0; i < iNoLays; i++) {
		sprintf_s(S1, "Layer %i", i + 1);
		sVar[iNo] = S1;
		iNo++;
	}
	return (iNo);
}

int PCOMPG::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dZ0);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dNSM);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dSB);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", FT);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dRefT);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dGE);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", bLAM);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iNoLays);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", GetThk());
	sVar[iNo] = S1;
	iNo++;
	int i;
	for (i = 0; i < iNoLays; i++) {
		sprintf_s(S1, "%i %i,%g,%g,%i", GPLYID[i], MID[i], T[i], Theta[i], sOut[i]);
		sVar[iNo] = S1;
		iNo++;
	}
	return (iNo);
}

void PCOMPG::PutVarValues(int iNo, CString sVar[]) {
	int i;
	int iLay;
	int iMID;
	double dThk;
	double dTheta;
	int iOut;
	CString sFT;
	CString sSYM;
	iFile = atoi(sVar[0]);
	dZ0 = atof(sVar[1]);
	dNSM = atof(sVar[2]);
	dSB = atof(sVar[3]);
	sFT = ExtractSubString2(1, sVar[4]);
	FT = 0;
	if (sFT == "HILL")
		FT = 1;
	else if (sFT == "HOFF")
		FT = 2;
	else if (sFT == "TSAI")
		FT = 3;
	else if (sFT == "STRESS")
		FT = 4;
	else if (sFT == "STRN")
		FT = 5;
	else if (sFT == "LARCO2")
		FT = 6;
	else if (sFT == "PUCK")
		FT = 7;
	else if (sFT == "MCT")
		FT = 8;
	dRefT = atof(sVar[5]);
	dGE = atof(sVar[6]);
	sSYM = ExtractSubString2(1, sVar[7]);

	if (sSYM == "SYM")
		bLAM = TRUE;
	else
		bLAM = FALSE;
	iNoLays = atoi(sVar[8]);
	int iP = 0;
	for (i = 10; i < 10 + iNoLays; i++) {
		iLay = atoi(ExtractSubString2(1, sVar[i]));
		iMID = atoi(ExtractSubString2(2, sVar[i]));
		dThk = atof(ExtractSubString2(3, sVar[i]));
		dTheta = atof(ExtractSubString2(4, sVar[i]));
		iOut = atoi(ExtractSubString2(5, sVar[i]));
		GPLYID[iP] = iLay;
		MID[iP] = iMID;
		T[iP] = dThk;
		Theta[iP] = dTheta;
		if (iOut == 0)
			sOut[iP] = FALSE;
		else
			sOut[iP] = TRUE;
		iP++;
	}
}

IMPLEMENT_DYNAMIC(PCOMP, CObject)

void PCOMP::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		Entity::Serialize(ar, iV);
		ar << dZ0;
		ar << dNSM;
		ar << dSB;
		ar << FT;
		ar << dRefT;
		ar << dGE;
		ar << bLAM;
		ar << iNoLays;
		for (i = 0; i < iNoLays; i++) {
			ar << MID[i];
			ar << T[i];
			ar << Theta[i];
			ar << sOut[i];
		}
	} else {
		Entity::Serialize(ar, iV);
		ar >> dZ0;
		ar >> dNSM;
		ar >> dSB;
		ar >> FT;
		ar >> dRefT;
		ar >> dGE;
		ar >> bLAM;
		ar >> iNoLays;
		for (i = 0; i < iNoLays; i++) {
			ar >> MID[i];
			ar >> T[i];
			ar >> Theta[i];
			ar >> sOut[i];
		}
	}
}

void PCOMP::List() {
	int i;
	char S1[200];
	CString OutT;
	outtext1("PCOMP LISTING:-");
	Property::List();
	outtext1("Mat,Thk,Theta");
	for (i = 0; i < iNoLays; i++) {
		sprintf_s(S1, "%i,%f,%f", MID[i], T[i], Theta[i]);
		OutT = S1;
		outtext1(OutT);
	}
	if (bLAM == TRUE)
		outtext1("- - - - - - - - -S Y M E T R I C- - - - - - - - -");
	double dthk = GetThk();
	sprintf_s(S1, "%s,%f", "Total thickness= ", dthk);
	OutT = S1;
	outtext1(OutT);
	sprintf_s(S1, "%s,%f", "Z0= ", dZ0);
	OutT = S1;
	outtext1(OutT);
}

double PCOMP::GetThk() {
	int i;
	double dRet = 0;
	for (i = 0; i < iNoLays; i++) {
		dRet += T[i];
	}
	if (bLAM == TRUE)
		dRet *= 2;
	return (dRet);
}

void PCOMP::UpdateMats(NEList* newMats) {
	int i;
	for (i = 0; i < iNoLays; i++) {
		MID[i] = newMats->Get(MID[i]);
	}
}

void PCOMP::ChangeMat(int thisMat, int inMID) {
	int i;
	for (i = 0; i < iNoLays; i++) {
		if (MID[i] == inMID) {
			MID[i] = inMID;
		}
	}
}

BOOL PCOMP::HasMat(int inMID) {
	int i;
	BOOL brc = FALSE;
	for (i = 0; i < iNoLays; i++) {
		if (MID[i] == inMID) {
			brc = TRUE;
			break;
		}
	}
	return (brc);
}

CString PCOMP::ToString() {
	int i;
	char S[200] = "";
	CString src = "";
	CString sSB;
	if (dSB != 0)
		sSB = e8(dSB);
	else
		sSB = "        ";
	CString sFT = "        ";
	if (FT == 0)
		sFT = "        ";
	if (FT == 1)
		sFT = "    HILL";
	else if (FT == 2)
		sFT = "    HOFF";
	else if (FT == 3)
		sFT = "    TSAI";
	else if (FT == 4)
		sFT = "  STRESS";
	else if (FT == 5)
		sFT = "    STRN";
	else if (FT == 6)
		sFT = "  LARCO2";
	else if (FT == 7)
		sFT = "   PUCK ";
	else if (FT == 8)
		sFT = "     MCT";
	CString sLAM = "        ";
	if (bLAM)
		sLAM = "SYM     ";
	sprintf_s(S, "%8s%8i%8s%8s%8s%8s%8s%8s%8s\n", "PCOMP   ", iID, e8(dZ0).GetString(), e8(dNSM).GetString(),
	          sSB.GetString(), sFT.GetString(), e8(dRefT).GetString(), e8(dGE), sLAM.GetString());
	src = S;
	int iLcnt = 0;
	for (i = 0; i < iNoLays; i++) {
		if (iLcnt == 0)
			src += "        ";
		CString sO = "      NO";
		if (sOut[i] == TRUE)
			sO = "     YES";
		if (iLcnt == 0) {
			sprintf_s(S, "%8i%8s%8s%8s", MID[i], e8(T[i]).GetString(), e8(Theta[i]).GetString(), sO);
			src += S;
			iLcnt = 1;
		} else {
			sprintf_s(S, "%8i%8s%8s%8s\n", MID[i], e8(T[i]), e8(Theta[i]), sO);
			src += S;
			iLcnt = 0;
		}
	}
	if (iLcnt == 1)
		src += "\n";
	return (src);
}

void PCOMP::ExportNAS(FILE* pFile) {
	fprintf(pFile, "$%s\n", sTitle.GetString());
	fprintf(pFile, "%s", ToString().GetString());
}

PCOMP* PCOMP::Copy() {
	int i;
	PCOMP* pREt = new PCOMP();
	pREt->iID = iID;
	pREt->sTitle = sTitle;
	pREt->iType = iType;

	pREt->dZ0 = dZ0;
	pREt->dNSM = dNSM;
	pREt->dSB = dSB;
	pREt->FT = FT;
	pREt->dRefT = dRefT;
	pREt->dGE = dGE;
	pREt->bLAM = bLAM;
	pREt->iNoLays = iNoLays;
	for (i = 0; i < iNoLays; i++) {
		pREt->MID[i] = MID[i];
		pREt->T[i] = T[i];
		pREt->Theta[i] = Theta[i];
		pREt->sOut[i] = sOut[i];
	}
	return (pREt);
}

// Add a layer to the pcomp stack
void PCOMP::AddLayer(int inMID, double inT, double inThe, BOOL inSo) {
	if (iNoLays < MAX_LAYERS) {
		MID[iNoLays] = inMID;
		T[iNoLays] = inT;
		Theta[iNoLays] = inThe;
		sOut[iNoLays] = inSo;
		iNoLays++;
		dZ0 = -0.5 * GetThk();
	} else {
		outtext1("ERROR: Max No of Layers Exceeded.");
	}
}

PCOMP::PCOMP() {
	sTitle = "";
	iID = -1;
	iType = 2;
	dZ0 = -0.5;
	dNSM = 0;
	dSB = 0;
	FT = 0;
	dRefT = 0;
	dGE = 0;
	bLAM = FALSE;
	iNoLays = 0;
}

int PCOMP::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	int i;
	char S1[80] = "";
	sVar[iNo] = "File No";
	iNo++;
	sVar[iNo] = "Dist to bottom surf (Z0)";
	iNo++;
	sVar[iNo] = "Non structural mass (NSM)";
	iNo++;
	sVar[iNo] = "Allow shear stress (SB)";
	iNo++;
	sVar[iNo] = "Failure theory (FT)";
	iNo++;
	sVar[iNo] = "Reference temperature (TREF)";
	iNo++;
	sVar[iNo] = "Damping coefficient  (GE)";
	iNo++;
	sVar[iNo] = "Laminate options.  (LAM)";
	iNo++;
	sVar[iNo] = "No Off Layers ";
	iNo++;
	sVar[iNo] = "Total Thickness ";
	iNo++;
	for (i = 0; i < iNoLays; i++) {
		sprintf_s(S1, "Layer %i", i + 1);
		sVar[iNo] = S1;
		iNo++;
	}
	return (iNo);
}

int PCOMP::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dZ0);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dNSM);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dSB);
	sVar[iNo] = S1;
	iNo++;
	if (FT == 0)
		sVar[iNo] = "";
	if (FT == 1)
		sVar[iNo] = "HILL";
	else if (FT == 2)
		sVar[iNo] = "HOFF";
	else if (FT == 3)
		sVar[iNo] = "TSAI";
	else if (FT == 4)
		sVar[iNo] = "STRESS";
	else if (FT == 5)
		sVar[iNo] = "STRN";
	else if (FT == 6)
		sVar[iNo] = "LARCO2";
	else if (FT == 7)
		sVar[iNo] = "PUCK";
	else if (FT == 8)
		sVar[iNo] = "MCT";
	iNo++;
	sprintf_s(S1, "%g", dRefT);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dGE);
	sVar[iNo] = S1;
	iNo++;
	if (bLAM)
		sprintf_s(S1, "%s", "SYM");
	else
		sprintf_s(S1, "%s", "");
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iNoLays);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", GetThk());
	sVar[iNo] = S1;
	iNo++;
	int i;
	for (i = 0; i < iNoLays; i++) {
		sprintf_s(S1, "%i,%g,%g,%i", MID[i], T[i], Theta[i], sOut[i]);
		sVar[iNo] = S1;
		iNo++;
	}
	return (iNo);
}

void PCOMP::PutVarValues(int iNo, CString sVar[]) {
	int i;
	int iMID;
	double dThk;
	double dTheta;
	int iOut;
	CString sFT;
	CString sSYM;
	iFile = atoi(sVar[0]);
	dZ0 = atof(sVar[1]);
	dNSM = atof(sVar[2]);
	dSB = atof(sVar[3]);
	sFT = ExtractSubString2(1, sVar[4]);
	FT = 0;
	if (sFT == "HILL")
		FT = 1;
	else if (sFT == "HOFF")
		FT = 2;
	else if (sFT == "TSAI")
		FT = 3;
	else if (sFT == "STRESS")
		FT = 4;
	else if (sFT == "STRN")
		FT = 5;
	else if (sFT == "LARCO2")
		FT = 6;
	else if (sFT == "PUCK")
		FT = 7;
	else if (sFT == "MCT")
		FT = 8;
	dRefT = atof(sVar[5]);
	dGE = atof(sVar[6]);
	sSYM = ExtractSubString2(1, sVar[7]);

	if (sSYM == "SYM")
		bLAM = TRUE;
	else
		bLAM = FALSE;
	iNoLays = atoi(sVar[8]);
	int iP = 0;
	for (i = 10; i < 10 + iNoLays; i++) {
		iMID = atoi(ExtractSubString2(1, sVar[i]));
		dThk = atof(ExtractSubString2(2, sVar[i]));
		dTheta = atof(ExtractSubString2(3, sVar[i]));
		iOut = atoi(ExtractSubString2(4, sVar[i]));
		MID[iP] = iMID;
		T[iP] = dThk;
		Theta[iP] = dTheta;
		if (iOut == 0)
			sOut[iP] = FALSE;
		else
			sOut[iP] = TRUE;
		iP++;
	}
	// dZ0 = -0.5 * GetThk();
}

IMPLEMENT_DYNAMIC(Moment, CObject)

void Moment::Create(G_Object* pInNode,
                    G_Object* Parrent,
                    C3dVector inF,
                    int inSetID) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 323;
	iLabel = pInNode->iLabel;
	iColour = 4;
	pParent = Parrent;
	pObj = pInNode;
	Node* pNode = (Node*) pInNode;
	SetID = inSetID;
	F = inF;
	Point[0].x = pNode->Pt_Point->x;
	Point[0].y = pNode->Pt_Point->y;
	Point[0].z = pNode->Pt_Point->z;
	Point[1] = F;
	Point[1].Normalize();
	Point[1] += Point[0];
}

void Moment::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void Moment::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	int i;
	double X, Y, Z;
	C3dVector Pts[7]; // Arrow Head
	C3dMatrix mT;
	C3dVector vOff;
	C3dVector vOffA2;
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		Point[1] = F;
		Point[1].Normalize();
		mT = Point[1].GetTMat();
		vOffA2 = Point[1];
		Point[1] *= dS1;
		vOffA2 *= 0.75 * dS1;
		Point[1] += Point[0];
		vOffA2 += Point[0];
		vOff.Set(AHead[0][0], AHead[0][1], AHead[0][2]);
		for (i = 0; i < 7; i++) {
			Pts[i].Set(AHead[i][0], AHead[i][1], AHead[i][2]);
			Pts[i] -= vOff;
			Pts[i] = mT.Mult(Pts[i]);
			Pts[i] *= 0.2 * dS1;
		}
		X = Point[1].x;
		Y = Point[1].y;
		Z = Point[1].z;

		glLineWidth(2);
		glColor3fv(cols[iColour]);
		glBegin(GL_LINES);
		glVertex3f((float) Point[0].x, (float) Point[0].y, (float) Point[0].z);
		glVertex3f((float) Point[1].x, (float) Point[1].y, (float) Point[1].z);
		glEnd();
		glPointSize(10.0f);
		glBegin(GL_POINTS);
		glVertex3f((float) 0.5 * (Point[0].x + Point[1].x), (float) 0.5 * (Point[0].y + Point[1].y),
		           (float) 0.5 * (Point[0].z + Point[1].z));
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
		glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
		glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
		glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
		glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
		glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
		glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
		glEnd();
		X = vOffA2.x;
		Y = vOffA2.y;
		Z = vOffA2.z;

		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
		glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
		glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
		glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
		glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
		glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
		glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
		glEnd();
		char sLab[20];
		sprintf_s(sLab, "%3.0f", F.Mag());
		OglString(iDspFlgs, Point[1].x, Point[1].y, Point[1].z, &sLab[0]);
	} else {
		Selectable = 0;
	}
}

void Moment::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8i%8s%8s%8s%8s%8s\n", "MOMENT  ", SetID, pObj->iLabel, "       0", "     1.0", e8(F.x),
	        e8(F.y), e8(F.z));
}

CString Moment::GetName() {
	return ("Moment (MOMENT)");
}

IMPLEMENT_DYNAMIC(Pressure, CObject)

void Pressure::Create(E_Object* pInEl,
                      G_Object* Parrent,
                      C3dVector inF,
                      int inSetID) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 324;
	iLabel = pInEl->iLabel;
	iColour = 4;
	pParent = Parrent;
	pObj = pInEl;
	SetID = inSetID;
	F = inF;
	Point[0] = pInEl->Get_Centroid();
	Point[1] = pInEl->Get_Normal();
	Point[1].Normalize();
	Point[1] += Point[0];
}

void Pressure::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	int i;
	double X, Y, Z;
	C3dVector Pts[7]; // Arrow Head
	C3dMatrix mT;
	C3dVector vOff;

	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		E_Object* pE = (E_Object*) pObj;
		Point[0] = pE->Get_Centroid();
		Point[1] = pE->Get_Normal();
		if (F.x < 0)
			Point[1] *= -1;

		Point[1].Normalize();
		mT = Point[1].GetTMat();
		Point[1] *= -dS1;
		Point[1] += Point[0];
		vOff.Set(AHead[0][0], AHead[0][1], AHead[0][2]);
		for (i = 0; i < 7; i++) {
			Pts[i].Set(AHead[i][0], AHead[i][1], AHead[i][2]);
			Pts[i] -= vOff;
			Pts[i] = mT.Mult(Pts[i]);
			Pts[i] *= 0.2 * dS1;
		}
		X = Point[0].x;
		Y = Point[0].y;
		Z = Point[0].z;
		glLineWidth(2);
		glColor3fv(cols[iColour]);
		glBegin(GL_LINES);
		glVertex3f((float) Point[0].x, (float) Point[0].y, (float) Point[0].z);
		glVertex3f((float) Point[1].x, (float) Point[1].y, (float) Point[1].z);
		glEnd();
		glPointSize(10.0f);
		glBegin(GL_POINTS);
		glVertex3f((float) 0.5 * (Point[0].x + Point[1].x), (float) 0.5 * (Point[0].y + Point[1].y),
		           (float) 0.5 * (Point[0].z + Point[1].z));
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
		glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
		glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
		glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
		glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
		glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
		glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
		glEnd();
		char sLab[20];
		sprintf_s(sLab, "%3.0f", F.Mag());
		OglString(iDspFlgs, Point[1].x, Point[1].y, Point[1].z, &sLab[0]);
	} else {
		Selectable = 0;
	}
}

void Pressure::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	G_Object::SetToScr(pModMat, pScrTran);
	E_Object* pE = (E_Object*) pObj;
	Point[0] = pE->Get_Centroid();

	C3dVector V;
	C3dVector R;
	R.x = Point[0].x;
	R.y = Point[0].y;
	R.z = Point[0].z;
	V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
	V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
	V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;
	R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
	R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
	R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;
	DSP_Point[0].x = R.x;
	DSP_Point[0].y = R.y;
	DSP_Point[0].z = 0;

	R.x = Point[1].x;
	R.y = Point[1].y;
	R.z = Point[1].z;
	V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
	V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
	V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;
	R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
	R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
	R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;
	DSP_Point[1].x = R.x;
	DSP_Point[1].y = R.y;
	DSP_Point[1].z = 0;
}

void Pressure::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iEL;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		F.Serialize(ar, iV);
		ar << pObj->iLabel;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		F.Serialize(ar, iV);
		ar >> iEL;
		pObj = MESH->GetElement(iEL);
		pParent = MESH;
	}
}

void Pressure::ExportNAS(FILE* pFile) {
	E_Object* pE;
	if (pObj != NULL) {
		pE = (E_Object*) pObj;
		if (pE->iNoNodes == 3) {
			fprintf(pFile, "%8s%8i%8s%8i%8i%8i\n", "PLOAD   ", SetID, e8(F.x), pE->GetNode(0)->iLabel,
			        pE->GetNode(1)->iLabel, pE->GetNode(2)->iLabel);
		} else if (pE->iNoNodes == 4) {
			fprintf(pFile, "%8s%8i%8s%8i%8i%8i%8i\n", "PLOAD   ", SetID, e8(F.x), pE->GetNode(0)->iLabel,
			        pE->GetNode(1)->iLabel, pE->GetNode(2)->iLabel, pE->GetNode(3)->iLabel);
		}
	}
}

CString Pressure::GetName() {
	return ("Presure (PLOAD)");
}

int Pressure::GetVarHeaders(CString sVar[]) {
	int iNo = 0;

	sVar[iNo] = "P";
	iNo++;

	return (iNo);
}

int Pressure::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%g", F.x);
	sVar[iNo] = S1;
	iNo++;

	return (iNo);
}

void Pressure::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	double dP;

	ME_Object* pMe = (ME_Object*) this->pParent;
	dP = atof(sVar[0]);
	F.Normalize();
	F.x = dP;
}

//*********************************************************************************
//***************         START OF TEMPERATUE           ***************************
//*********************************************************************************

IMPLEMENT_DYNAMIC(Temperature, CObject)

Temperature::Temperature() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 325;
	iLabel = -1;
	iColour = 55;
	pParent = NULL;
	pObj = NULL;
	SetID = -1;
	dV = 0;
}

Temperature::~Temperature() {
	SetID = -1;
	pObj = nullptr;
}

void Temperature::Create(G_Object* pInN,
                         G_Object* Parrent,
                         double inV,
                         int inSetID) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 325;
	iLabel = pInN->iLabel;
	iColour = 4;
	pParent = Parrent;
	pObj = pInN;
	SetID = inSetID;
	dV = inV;
	if (pObj != NULL)
		Point = pObj->Get_Centroid();
}

void Temperature::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	C3dVector V;
	C3dVector R;
	G_Object::SetToScr(pModMat, pScrTran);
	if (pObj != NULL) {
		Point = pObj->Get_Centroid();
		R.x = Point.x;
		R.y = Point.y;
		R.z = Point.z;
		V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
		V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
		V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;
		R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
		R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
		R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;
		DSP_Point.x = R.x;
		DSP_Point.y = R.y;
		DSP_Point.z = 0;
	}
}

void Temperature::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iE;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		ar << dV;
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar << pObj->iLabel;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		ar >> dV;
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar >> iE;
		if (iV <= -73) // have moved to temps on node
			pObj = MESH->GetNode(iE);
		else
			pObj = MESH->GetElement(iE);
		pParent = MESH;
	}
}

void Temperature::ExportUNV(FILE* pFile) {
}

void Temperature::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8i%8s\n", "TEMP    ", SetID, pObj->iLabel, e8(dV));
}

C3dVector Temperature::Get_Centroid() {
	C3dVector vT;
	if (pObj != NULL)
		vT = pObj->Get_Centroid();
	return (vT);
}

void Temperature::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void Temperature::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		glColor3fv(cols[iColour]);
		glLineWidth(4.0);
		glBegin(GL_LINES);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glEnd();
		glLineWidth(2.0);
		char sLab[20];
		sprintf_s(sLab, "%3.0f", dV);
		OglString(iDspFlgs, Point.x, Point.y, Point.z, &sLab[0]);
	} else {
		Selectable = 0;
	}
}

void Temperature::Info() {
	char S1[80];
	CString OutT;

	G_Object::Info();
	sprintf_s(S1, "%s%i%s%i%s%f", "SETID ", iObjType, "; NODE ", pObj->iLabel, " Val; ", dV);
	OutT += S1;
}

//*********************************************************************************
//***************         END OF TEMPERATUE           *****************************
//*********************************************************************************

//*********************************************************************************
//***************         START OF ACELERATION LOADING           ******************
//*********************************************************************************

IMPLEMENT_DYNAMIC(AccelLoad, CObject)

AccelLoad::AccelLoad() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 328;
	iLabel = -1;
	iColour = 28;
	pParent = NULL;
	pObj = NULL;
	SetID = -1;
	vA.Set(0, 0, 0);
}

AccelLoad::~AccelLoad() {
	SetID = -1;
	pObj = NULL;
}

void AccelLoad::Create(G_Object* pInE,
                       G_Object* Parrent,
                       C3dVector inV,
                       int inSetID) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 328;
	iLabel = pInE->iLabel;
	iColour = 23;
	pParent = Parrent;
	pObj = pInE;
	SetID = inSetID;
	vA = inV;
	if (pObj != NULL)
		Point = pObj->Get_Centroid();
}

void AccelLoad::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	C3dVector V;
	C3dVector R;
	G_Object::SetToScr(pModMat, pScrTran);
	if (pObj != NULL) {
		Point = pObj->Get_Centroid();
		R.x = Point.x;
		R.y = Point.y;
		R.z = Point.z;
		V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
		V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
		V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;
		R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
		R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
		R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;
		DSP_Point.x = R.x;
		DSP_Point.y = R.y;
		DSP_Point.z = 0;
	}
}

void AccelLoad::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iE;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		vA.Serialize(ar, iV);
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar << pObj->iLabel;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		vA.Serialize(ar, iV);
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar >> iE;
		pObj = MESH->GetElement(iE);
		pParent = MESH;
	}
}

void AccelLoad::ExportUNV(FILE* pFile) {
}

void AccelLoad::ExportNAS(FILE* pFile) {
	// fprintf(pFile,"%8s%8s%8i%8s%8s%8s%8s%8s\n","FORCE   ","       1",pObj->iLabel,"       0","     1.0",e8(F.x),e8(F.y),e8(F.z));
}

C3dVector AccelLoad::Get_Centroid() {
	C3dVector vT;
	if (pObj != NULL)
		vT = pObj->Get_Centroid();
	return (vT);
}

void AccelLoad::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void AccelLoad::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		glColor3fv(cols[iColour]);
		glLineWidth(4.0);
		glBegin(GL_LINES);
		glVertex3f((float) Point.x - 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y - 0.5 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y - 0.5 * dS1, (float) Point.z);
		glVertex3f((float) Point.x - 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glEnd();
		glLineWidth(2.0);
		// sprintf_s(sLab,"%3.0f",dV);
		// OglString(iDspFlgs,Point.x,Point.y,Point.z,&sLab[0]);
	} else {
		Selectable = 0;
	}
}

void AccelLoad::Info() {
	char S1[80];
	CString OutT;
	G_Object::Info();
	sprintf_s(S1, "ACCEL VECTOR %8i X %s Y %s Z %s", iLabel, float8NAS(vA.x), float8NAS(vA.y), float8NAS(vA.z));
	outtext1(S1);
}

//*********************************************************************************
//***************         START OF ACELERATION LOADING           ******************
//*********************************************************************************

IMPLEMENT_DYNAMIC(RotationLoad, CObject)

RotationLoad::RotationLoad() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 329;
	iLabel = -1;
	iColour = 60;
	pParent = NULL;
	pObj = NULL;
	SetID = -1;
	vAxisD.Set(0, 0, 0);
	vAxisC.Set(0, 0, 0);
	w = 0;
}

RotationLoad::~RotationLoad() {
	SetID = -1;
	pObj = NULL;
}

void RotationLoad::Create(G_Object* pInE,
                          G_Object* Parrent,
                          C3dVector inD,
                          C3dVector inC,
                          double dW,
                          int inSetID) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 329;
	iLabel = pInE->iLabel;
	iColour = 60;
	pParent = Parrent;
	pObj = pInE;
	SetID = inSetID;
	vAxisD = inD;
	vAxisC = inD;
	w = dW;
	if (pObj != NULL)
		Point = pObj->Get_Centroid();
}

void RotationLoad::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	C3dVector V;
	C3dVector R;
	G_Object::SetToScr(pModMat, pScrTran);
	if (pObj != NULL) {
		Point = pObj->Get_Centroid();
		R.x = Point.x;
		R.y = Point.y;
		R.z = Point.z;
		V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
		V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
		V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;
		R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
		R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
		R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;
		DSP_Point.x = R.x;
		DSP_Point.y = R.y;
		DSP_Point.z = 0;
	}
}

void RotationLoad::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iE;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		vAxisD.Serialize(ar, iV);
		vAxisC.Serialize(ar, iV);
		ar << w;
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar << pObj->iLabel;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		vAxisD.Serialize(ar, iV);
		vAxisC.Serialize(ar, iV);
		ar >> w;
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar >> iE;
		pObj = MESH->GetElement(iE);
		pParent = MESH;
	}
}

C3dVector RotationLoad::Get_Centroid() {
	C3dVector vT;
	if (pObj != NULL)
		vT = pObj->Get_Centroid();
	return (vT);
}

void RotationLoad::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void RotationLoad::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		glColor3fv(cols[iColour]);
		glLineWidth(4.0);
		glBegin(GL_LINES);
		glVertex3f((float) Point.x - 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y - 0.5 * dS1, (float) Point.z);
		// glVertex3f((float)Point.x, (float)Point.y - 0.5*dS1, (float)Point.z);
		// glVertex3f((float)Point.x - 0.15*dS1, (float)Point.y + 0.2*dS1, (float)Point.z);
		glEnd();
		glLineWidth(2.0);
		// sprintf_s(sLab,"%3.0f",dV);
		// OglString(iDspFlgs,Point.x,Point.y,Point.z,&sLab[0]);
	} else {
		Selectable = 0;
	}
}

void RotationLoad::Info() {
	char S1[80];
	CString OutT;
	G_Object::Info();
	sprintf_s(S1, "AXIS CENTRE %8i X %s Y %s Z %s", iLabel, float8NAS(vAxisC.x), float8NAS(vAxisC.y),
	          float8NAS(vAxisC.z));
	outtext1(S1);
	sprintf_s(S1, "AXIS VECTOR %8i X %s Y %s Z %s w %f", iLabel, float8NAS(vAxisD.x), float8NAS(vAxisD.y),
	          float8NAS(vAxisD.z), w);
	outtext1(S1);
}

//*********************************************************************************
//***************         END OF ACCELERATION LOADING           *******************
//*********************************************************************************

//****************************************************************************
//****************************************************************************
//                       For thermal analysis
//****************************************************************************
//****************************************************************************
IMPLEMENT_DYNAMIC(TemperatureBC, CObject)

TemperatureBC::TemperatureBC() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 327;
	iLabel = -1;
	iColour = 4;
	pParent = NULL;
	pObj = NULL;
	SetID = -1;
	dV = 0;
}

TemperatureBC::~TemperatureBC() {
	SetID = -1;
	pObj = NULL;
}

void TemperatureBC::Create(G_Object* pInNode,
                           G_Object* Parrent,
                           double inV,
                           int inSetID) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 327;
	iLabel = pInNode->iLabel;
	iColour = 4;
	pParent = Parrent;
	pObj = pInNode;
	SetID = inSetID;
	dV = inV;
	if (pObj != NULL)
		Point = pObj->Get_Centroid();
}

void TemperatureBC::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		glColor3fv(cols[iColour]);
		glLineWidth(4.0);
		glBegin(GL_LINES);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glEnd();
		glLineWidth(2.0);
		char sLab[20];
		sprintf_s(sLab, "%g", dV);
		OglString(iDspFlgs, Point.x, Point.y, Point.z, &sLab[0]);
	} else {
		Selectable = 0;
	}
}

void TemperatureBC::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iN;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		ar << dV;
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar << pObj->iLabel;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		ar >> dV;
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar >> iN;
		pObj = MESH->GetNode(iN);
		pParent = MESH;
	}
}

//***************           NET FLUX             *****************************
IMPLEMENT_DYNAMIC(FluxLoad, CObject)

FluxLoad::FluxLoad() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 326;
	iLabel = -1;
	iColour = 54;
	pParent = NULL;
	pObj = NULL;
	SetID = -1;
	dV = 0;
}

FluxLoad::~FluxLoad() {
	SetID = -1;
	pObj = NULL;
}

void FluxLoad::Create(G_Object* pInNode,
                      G_Object* Parrent,
                      double inV,
                      int inSetID) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 326;
	iLabel = pInNode->iLabel;
	iColour = 54;
	pParent = Parrent;
	pObj = pInNode;
	SetID = inSetID;
	dV = inV;
	if (pObj != NULL)
		Point = pObj->Get_Centroid();
}

void FluxLoad::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		glColor3fv(cols[iColour]);
		glLineWidth(4.0);
		glBegin(GL_LINES);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glEnd();
		glLineWidth(2.0);
		char sLab[20];
		sprintf_s(sLab, "%3.0f", dV);
		OglString(iDspFlgs, Point.x, Point.y, Point.z, &sLab[0]);
	} else {
		Selectable = 0;
	}
}

void FluxLoad::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iN;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		ar << dV;
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar << pObj->iLabel;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		ar >> dV;
		DSP_Point.Serialize(ar, iV);
		Point.Serialize(ar, iV);
		ar >> iN;
		pObj = MESH->GetNode(iN);
		pParent = MESH;
	}
}

//*********************************************************************************
//***************         END OF THERMAL              *****************************
//*********************************************************************************

IMPLEMENT_DYNAMIC(Force, CObject)

void Force::Create(G_Object* pInNode,
                   G_Object* Parrent,
                   C3dVector inF,
                   int inSetID) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 321;
	iLabel = pInNode->iLabel;
	iColour = 55;
	pParent = Parrent;
	pObj = pInNode;
	SetID = inSetID;
	F = inF;
	// Pt_Object* pNode = (Pt_Object*) pInNode;
	Point[0] = pObj->Get_Centroid();
	Point[1] = F;
	Point[1].Normalize();
	Point[1] += Point[0];
}

void Force::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		F.Serialize(ar, iV);
		ar << pObj->iLabel;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		F.Serialize(ar, iV);
		ar >> iNd;
		pObj = MESH->GetNode(iNd);
		pParent = MESH;
	}
}

Force::~Force() {
	SetID = -1;
	pObj = NULL;
}

void Force::ExportUNV(FILE* pFile) {
}

void Force::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8i%8s%8s%8s%8s%8s\n", "FORCE   ", SetID, pObj->iLabel, "       0", "     1.0", e8(F.x),
	        e8(F.y), e8(F.z));
}

C3dVector Force::Get_Centroid() {
	C3dVector vT;
	vT = Point[0];
	vT += Point[1];
	vT *= 0.5;
	return (vT);
}

void Force::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	G_Object::SetToScr(pModMat, pScrTran);
	Node* pNode = (Node*) pObj;
	Point[0].x = pNode->Pt_Point->x;
	Point[0].y = pNode->Pt_Point->y;
	Point[0].z = pNode->Pt_Point->z;
	// Point[1]=F;
	// Point[1].Normalize();
	// Point[1]*=0.05;
	// Point[1]+=Point[0];
	C3dVector V;
	C3dVector R;
	R.x = Point[0].x;
	R.y = Point[0].y;
	R.z = Point[0].z;
	V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
	V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
	V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;
	R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
	R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
	R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;
	DSP_Point[0].x = R.x;
	DSP_Point[0].y = R.y;
	DSP_Point[0].z = 0;

	R.x = Point[1].x;
	R.y = Point[1].y;
	R.z = Point[1].z;
	V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
	V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
	V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;
	R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
	R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
	R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;
	DSP_Point[1].x = R.x;
	DSP_Point[1].y = R.y;
	DSP_Point[1].z = 0;
}

void Force::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) DSP_Point[0].x, (int) DSP_Point[0].y);
	pDC->LineTo((int) DSP_Point[1].x, (int) DSP_Point[1].y);
}

void Force::HighLight(CDC* pDC) {
	this->Draw(pDC, 4);
}

void Force::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void Force::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	int i;
	double X, Y, Z;
	C3dVector Pts[7]; // Arrow Head
	C3dMatrix mT;
	C3dVector vOff;
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		Point[1] = F;
		Point[1].Normalize();
		mT = Point[1].GetTMat();
		Point[1] *= dS1;
		Point[1] += Point[0];
		vOff.Set(AHead[0][0], AHead[0][1], AHead[0][2]);
		for (i = 0; i < 7; i++) {
			Pts[i].Set(AHead[i][0], AHead[i][1], AHead[i][2]);
			Pts[i] -= vOff;
			Pts[i] = mT.Mult(Pts[i]);
			Pts[i] *= 0.2 * dS1;
		}
		X = Point[1].x;
		Y = Point[1].y;
		Z = Point[1].z;

		glLineWidth(2);
		glColor3fv(cols[iColour]);
		glBegin(GL_LINES);
		glVertex3f((float) Point[0].x, (float) Point[0].y, (float) Point[0].z);
		glVertex3f((float) Point[1].x, (float) Point[1].y, (float) Point[1].z);
		glEnd();
		glPointSize(10.0f);
		glBegin(GL_POINTS);
		glVertex3f((float) 0.5 * (Point[0].x + Point[1].x), (float) 0.5 * (Point[0].y + Point[1].y),
		           (float) 0.5 * (Point[0].z + Point[1].z));
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
		glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
		glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
		glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
		glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
		glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
		glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
		glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
		glEnd();
		char sLab[20];
		sprintf_s(sLab, "%3.0f", F.Mag());
		OglString(iDspFlgs, Point[1].x, Point[1].y, Point[1].z, &sLab[0]);
	} else {
		Selectable = 0;
	}
}

G_ObjectD Force::SelDist(CPoint InPT, Filter FIL) {
	CPoint cPt2;
	double dt;
	double d;
	G_ObjectD Ret;

	dt = 0.5 * (DSP_Point[0].x + DSP_Point[1].x) - InPT.x;
	cPt2.x = long(dt);
	dt = 0.5 * (DSP_Point[0].y + DSP_Point[1].y) - InPT.y;
	cPt2.y = long(dt);
	d = (cPt2.x * cPt2.x + cPt2.y * cPt2.y);
	Ret.Dist = d;
	Ret.pObj = this;
	return (Ret);
}

void Force::Info() {
	char S1[80];
	CString OutT;
	G_Object::Info();
	outtext1("FORCE VECTOR");
	sprintf_s(S1, "%s%8.5f,%8.5f,%8.5f", "FORCE: ", F.x, F.y, F.z);
	OutT = S1;
	outtext1(OutT);
}

CString Force::GetName() {
	return ("Force (FORCE)");
}

int Force::GetVarHeaders(CString sVar[]) {
	int iNo = 0;

	sVar[iNo] = "FX";
	iNo++;
	sVar[iNo] = "FY";
	iNo++;
	sVar[iNo] = "FZ";
	iNo++;
	return (iNo);
}

int Force::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";

	sprintf_s(S1, "%g", F.x);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", F.y);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", F.z);
	sVar[iNo] = S1;
	iNo++;

	return (iNo);
}

void Force::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	ME_Object* pMe = (ME_Object*) this->pParent;

	F.x = atof(sVar[0]);
	F.y = atof(sVar[1]);
	F.z = atof(sVar[2]);
}

IMPLEMENT_DYNAMIC(TEMPD, CObject)

void TEMPD::Create(C3dVector vC, G_Object* Parrent, int inSetID, double inDT) {
	Drawn = 0;
	Selectable = 0;
	Visable = 0;
	iObjType = 331;
	iColour = 4;
	iLabel = -1;
	pParent = Parrent;
	pObj = nullptr;
	SetID = inSetID;
	dTempD = inDT;
	Point = vC;
}

void TEMPD::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		ar << dTempD;
		ar << Point.x;
		ar << Point.y;
		ar << Point.z;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		ar >> dTempD;
		ar >> Point.x;
		ar >> Point.y;
		ar >> Point.z;
		pObj = nullptr;
		pParent = MESH;
	}
}

void TEMPD::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8s\n", "TEMPD   ", SetID, e8(dTempD));
}

void TEMPD::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void TEMPD::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	dS1 *= 5;
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		glColor3fv(cols[iColour]);
		glLineWidth(10.0);
		glBegin(GL_LINES);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x - 0.2 * dS1, (float) Point.y - 0.2 * dS1, (float) Point.z);
		glEnd();
		glLineWidth(2.0);
		char sLab[20];
		sprintf_s(sLab, "TEMPD %3.0f", dTempD);
		OglString(iDspFlgs, Point.x, Point.y, Point.z, &sLab[0]);
	} else {
		Selectable = 0;
	}
}

C3dVector TEMPD::Get_Centroid() {
	return (Point);
}

int TEMPD::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo++] = "DEF TEMP";
	return iNo;
}

int TEMPD::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";

	sprintf_s(S1, "%g", dTempD);
	sVar[iNo++] = S1;
	return (iNo);
}

void TEMPD::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	int i = 0;
	dTempD = atof(sVar[i++]);
}

IMPLEMENT_DYNAMIC(GRAV, CObject)

void GRAV::Create(C3dVector vC, G_Object* Parrent, int inSID, int inCID, double indScl, C3dVector invV) {
	Drawn = 0;
	Selectable = 0;
	Visable = 0;
	iObjType = 332;
	iLabel = -1;
	iColour = 66;
	pParent = Parrent; // parent is the set obj
	pObj = nullptr;
	SetID = inSID;
	iCID = inCID;
	dScl = indScl;
	vV = invV;
	Point = vC;
}

void GRAV::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		ar << iCID;
		ar << dScl;
		ar << vV.x;
		ar << vV.y;
		ar << vV.z;
		ar << Point.x;
		ar << Point.y;
		ar << Point.z;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		ar >> iCID;
		ar >> dScl;
		ar >> vV.x;
		ar >> vV.y;
		ar >> vV.z;
		ar >> Point.x;
		ar >> Point.y;
		ar >> Point.z;
		pObj = nullptr;
		pParent = MESH;
	}
}

void GRAV::ExportNAS(FILE* pFile) {
	fprintf(pFile, "%8s%8i%8i%8s%8s%8s%8s\n", "GRAV    ", SetID, iCID, e8(dScl), e8(vV.x), e8(vV.y), e8(vV.z));
}

void GRAV::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void GRAV::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	dS1 *= 5;
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		glColor3fv(cols[iColour]);
		glLineWidth(10.0);
		glBegin(GL_LINES);
		glVertex3f((float) Point.x - 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x + 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y - 0.5 * dS1, (float) Point.z);
		glVertex3f((float) Point.x, (float) Point.y - 0.5 * dS1, (float) Point.z);
		glVertex3f((float) Point.x - 0.15 * dS1, (float) Point.y + 0.2 * dS1, (float) Point.z);
		glEnd();
		glLineWidth(2.0);
		char sLab[20];
		sprintf_s(sLab, "GRAV %3.0f", vV.Mag() * dScl);
		OglString(iDspFlgs, Point.x, Point.y, Point.z, &sLab[0]);
	} else {
		Selectable = 0;
	}
}

C3dVector GRAV::Get_Centroid() {
	return (Point);
}

int GRAV::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo++] = "CID";
	sVar[iNo++] = "ScaleF";
	sVar[iNo++] = "X";
	sVar[iNo++] = "Y";
	sVar[iNo++] = "Z";
	return iNo;
}

int GRAV::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iCID);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", dScl);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", vV.x);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", vV.y);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", vV.z);
	sVar[iNo++] = S1;
	return (iNo);
}

void GRAV::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	int i = 0;
	iCID = atoi(sVar[i++]);
	dScl = atof(sVar[i++]);
	vV.x = atof(sVar[i++]);
	vV.y = atof(sVar[i++]);
	vV.z = atof(sVar[i++]);
}

IMPLEMENT_DYNAMIC(Restraint, CObject)

void Restraint::Create(G_Object* pInNode,
                       G_Object* Parrent,
                       BOOL xon,
                       BOOL yon,
                       BOOL zon,
                       BOOL rxon,
                       BOOL ryon,
                       BOOL rzon,
                       int inSetID) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 322;
	iLabel = pInNode->iLabel;
	iColour = 2;
	pParent = Parrent;
	pObj = pInNode;
	SetID = inSetID;
	REST[0] = xon;
	REST[1] = yon;
	REST[2] = zon;
	REST[3] = rxon;
	REST[4] = ryon;
	REST[5] = rzon;
}

void Restraint::Serialize(CArchive& ar, int iV, ME_Object* MESH)

{
	int iNd;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << SetID;
		ar << pObj->iLabel;
		ar << REST[0];
		ar << REST[1];
		ar << REST[2];
		ar << REST[3];
		ar << REST[4];
		ar << REST[5];
	} else {
		G_Object::Serialize(ar, iV);
		ar >> SetID;
		ar >> iNd;
		pObj = MESH->GetNode(iNd);
		Node* pN = (Node*) pObj;
		Point = pN->GetCoords();
		ar >> REST[0];
		ar >> REST[1];
		ar >> REST[2];
		ar >> REST[3];
		ar >> REST[4];
		ar >> REST[5];
		pParent = MESH;
	}
}

Restraint::~Restraint() {
	SetID = -1;
	pObj = NULL;
}

void Restraint::ExportUNV(FILE* pFile) {
}

void Restraint::ExportNAS(FILE* pFile) {
	C3dVector vCent;
	vCent = Get_Centroid();
	char S1[7];
	sprintf_s(S1, "%s", GetDofStr());

	fprintf(pFile, "%8s%8i%8i%8s%8s\n", "SPC     ", SetID, pObj->iLabel, GetDofStr(), "     0.0");
}

C3dVector Restraint::Get_Centroid() {
	return (Point);
}

void Restraint::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	G_Object::SetToScr(pModMat, pScrTran);
	Node* pNode = (Node*) pObj;
	Point.x = pNode->Pt_Point->x;
	Point.y = pNode->Pt_Point->y;
	Point.z = pNode->Pt_Point->z;
	// Point[1]=F;
	// Point[1].Normalize();
	// Point[1]*=0.05;
	// Point[1]+=Point[0];
	C3dVector V;
	C3dVector R;
	R.x = Point.x;
	R.y = Point.y;
	R.z = Point.z;
	V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
	V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
	V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;
	R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
	R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
	R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;
	DSP_Point.x = R.x;
	DSP_Point.y = R.y;
	DSP_Point.z = 0;
}

void Restraint::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) DSP_Point.x, (int) DSP_Point.y);
	pDC->LineTo((int) DSP_Point.x - 10, (int) DSP_Point.y - 10);
	pDC->LineTo((int) DSP_Point.x - 10, (int) DSP_Point.y + 10);
	pDC->LineTo((int) DSP_Point.x, (int) DSP_Point.y);
}

void Restraint::HighLight(CDC* pDC) {
	this->Draw(pDC, 4);
}

CString Restraint::GetDofStr() {
	CString sRet;
	char sLab[7];
	int i = 0;
	if (REST[0]) {
		sLab[i] = '1';
		i++;
	}
	if (REST[1]) {
		sLab[i] = '2';
		i++;
	}
	if (REST[2]) {
		sLab[i] = '3';
		i++;
	}
	if (REST[3]) {
		sLab[i] = '4';
		i++;
	}
	if (REST[4]) {
		sLab[i] = '5';
		i++;
	}
	if (REST[5]) {
		sLab[i] = '6';
		i++;
	}
	sLab[i] = NULL;
	sRet = sLab;
	return (sRet);
}

void Restraint::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if ((iDspFlgs & DSP_BC) > 0) {
		Selectable = 1;
		glColor3fv(cols[iColour]);
		C3dVector vCent;
		vCent = pObj->Get_Centroid();
		glRasterPos3f((float) vCent.x, (float) vCent.y, (float) vCent.z);
		glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPR);
		char S1[7];
		sprintf_s(S1, "%s", GetDofStr());
		OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &S1[0]);
	} else {
		Selectable = 0;
	}
}

void Restraint::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

// G_ObjectD Restraint::SelDist(CPoint InPT,Filter FIL)
//{
// CPoint cPt2;
// G_ObjectD Ret;
//
// cPt2.x = DSP_Point.x-InPT.x;
// cPt2.y = DSP_Point.y-InPT.y;
// Ret.Dist=(cPt2.x*cPt2.x+cPt2.y*cPt2.y);
// Ret.pObj=this;
// return (Ret);
// }

void Restraint::Info() {
	char S1[80];
	CString OutT;
	G_Object::Info();
	sprintf_s(S1, "%s%i%s%i%s%i", "Type ", iObjType, "; Label ", pObj->iLabel, " Col; ", iColour);
	OutT += S1;
	outtext1("RESTRAINT");
	outtext1(OutT);
	sprintf_s(S1, "%s%s,", "DOF STR: ", GetDofStr());
	OutT = S1;
	outtext1(OutT);
}

CString Restraint::GetName() {
	return ("Restraint (SPC)");
}

int Restraint::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "DOF 1 (0/1)";
	iNo++;
	sVar[iNo] = "DOF 2 (0/1)";
	iNo++;
	sVar[iNo] = "DOF 3 (0/1)";
	iNo++;
	sVar[iNo] = "DOF 4 (0/1)";
	iNo++;
	sVar[iNo] = "DOF 5 (0/1)";
	iNo++;
	sVar[iNo] = "DOF 6 (0/1)";
	iNo++;
	return (iNo);
}

int Restraint::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sVar[iNo] = "0";
	if (REST[0])
		sVar[iNo] = "1";
	iNo++;
	sVar[iNo] = "0";
	if (REST[1])
		sVar[iNo] = "1";
	iNo++;
	sVar[iNo] = "0";
	if (REST[2])
		sVar[iNo] = "1";
	iNo++;
	sVar[iNo] = "0";
	if (REST[3])
		sVar[iNo] = "1";
	iNo++;
	sVar[iNo] = "0";
	if (REST[4])
		sVar[iNo] = "1";
	iNo++;
	sVar[iNo] = "0";
	if (REST[5])
		sVar[iNo] = "1";
	iNo++;
	return (iNo);
}

void Restraint::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	int iDF = atoi(sVar[0]);
	if (iDF != 1)
		REST[0] = FALSE;
	else
		REST[0] = TRUE;
	iDF = atoi(sVar[1]);
	if (iDF != 1)
		REST[1] = FALSE;
	else
		REST[1] = TRUE;
	iDF = atoi(sVar[2]);
	if (iDF != 1)
		REST[2] = FALSE;
	else
		REST[2] = TRUE;
	iDF = atoi(sVar[3]);
	if (iDF != 1)
		REST[3] = FALSE;
	else
		REST[3] = TRUE;
	iDF = atoi(sVar[4]);
	if (iDF != 1)
		REST[4] = FALSE;
	else
		REST[4] = TRUE;
	iDF = atoi(sVar[5]);
	if (iDF != 1)
		REST[5] = FALSE;
	else
		REST[5] = TRUE;
}

IMPLEMENT_DYNAMIC(ResultsVec, CObject)

ResultsVec::ResultsVec(int iD, C3dVector Pt, C3dVector Vec, int iC, int iDf, int iS, int iTyp) {
	Point = Pt;
	Vector = Vec;
	iColour = iC;
	iObjType = 330;
	Selectable = 1;
	iLabel = iD;
	iDof = iD;
	iSign = iS; // SIgn -/+ of the vector
	// Compute the a transform
	iType = iTyp;
}

void ResultsVec::Create(int iD, C3dVector Pt, C3dVector Vec, int iC) {
	Point = Pt;
	Vector = Vec;
	iColour = iC;
	iObjType = 330;
	iLabel = iD;
	// Create Arrow Head
}

C3dVector ResultsVec::Get_Centroid() {
	return (Point);
}

void ResultsVec::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void ResultsVec::DrawVector(int iDspFlgs, double dS1, double dS2, double dS, double dRF) {
	int i;
	C3dVector p2;
	C3dVector vZ;
	vZ = Vector;
	vZ.Normalize();
	C3dMatrix mT;
	mT = vZ.GetTMat();
	C3dVector Pts[7];
	// Create Arrow Head
	for (i = 0; i < 7; i++) {
		Pts[i].Set(AHead[i][0], AHead[i][1], AHead[i][2]);
		Pts[i] = mT.Mult(Pts[i]);
		Pts[i] *= 0.2;
	}
	p2 = Vector;
	p2 *= dS * dRF / VecMaxMag(); // Normalise vector length
	p2 += Point;
	float fCol;
	double X, Y, Z;
	X = Pts[0].x;
	Y = Pts[0].y;
	Z = Pts[0].z;
	if (dRF < 0) // Need to reverse the arrow
	{
		X *= -1;
		Y *= -1;
		Z *= -1;
	}
	glColor3fv(cols[124]); // Texture colours don't work without this
	fCol = GetContourColVec((float) iSign * Vector.Mag() * abs(dRF));
	glEnable(GL_TEXTURE_1D);
	glBegin(GL_LINES);
	glTexCoord1f(fCol);
	glVertex3f((float) Point.x, (float) Point.y, (float) Point.z);
	glTexCoord1f(fCol);
	glVertex3f((float) p2.x, (float) p2.y, (float) p2.z);
	glEnd();
	glLineWidth(1);
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[2].x * dS1 + p2.x, (float) Pts[2].y * dS1 + p2.y, (float) Pts[2].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[1].x * dS1 + p2.x, (float) Pts[1].y * dS1 + p2.y, (float) Pts[1].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[3].x * dS1 + p2.x, (float) Pts[3].y * dS1 + p2.y, (float) Pts[3].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[2].x * dS1 + p2.x, (float) Pts[2].y * dS1 + p2.y, (float) Pts[2].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[4].x * dS1 + p2.x, (float) Pts[4].y * dS1 + p2.y, (float) Pts[4].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[3].x * dS1 + p2.x, (float) Pts[3].y * dS1 + p2.y, (float) Pts[3].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[5].x * dS1 + p2.x, (float) Pts[5].y * dS1 + p2.y, (float) Pts[5].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[4].x * dS1 + p2.x, (float) Pts[4].y * dS1 + p2.y, (float) Pts[4].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[6].x * dS1 + p2.x, (float) Pts[6].y * dS1 + p2.y, (float) Pts[6].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[5].x * dS1 + p2.x, (float) Pts[5].y * dS1 + p2.y, (float) Pts[5].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[1].x * dS1 + p2.x, (float) Pts[1].y * dS1 + p2.y, (float) Pts[1].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[6].x * dS1 + p2.x, (float) Pts[6].y * dS1 + p2.y, (float) Pts[6].z * dS1 + p2.z);
	glEnd();
	glDisable(GL_TEXTURE_1D);
	glLineWidth(2);
	if (((iDspFlgs & DSP_RESLAB) == 0)) {
		char sLab[20];
		sprintf_s(sLab, "%g", iSign * Vector.Mag());
		OglString(iDspFlgs, Point.x, Point.y, Point.z, &sLab[0]);
	}
}

void ResultsVec::DrawTenVector(int iDspFlgs, double dS1, double dS2, double dS, double dRF) {
	int i;
	C3dVector p2; // Positive direction
	C3dVector p3; // Negative direction
	C3dVector vZ;
	vZ = Vector;
	vZ.Normalize();
	C3dMatrix mT;
	mT = vZ.GetTMat();
	C3dVector Pts[7];
	// Create Arrow Head
	for (i = 0; i < 7; i++) {
		Pts[i].Set(AHead[i][0], AHead[i][1], AHead[i][2]);
		Pts[i] = mT.Mult(Pts[i]);
		Pts[i] *= 0.2;
	}
	p2 = Vector;
	p2 *= 0.5 * dS * dRF / VecMaxMag(); // Normalise vector length
	p3 = p2;
	p3 *= -1; // Negative direction
	p2 += Point;
	p3 += Point;
	float fCol;
	double X, Y, Z;
	X = Pts[0].x * iSign;
	Y = Pts[0].y * iSign;
	Z = Pts[0].z * iSign;

	if (dRF < 0) // Need to reverse the arrow
	{
		X *= -1;
		Y *= -1;
		Z *= -1;
	}
	glColor3fv(cols[124]); // Texture colours don't work without this
	fCol = GetContourColVec((float) iSign * Vector.Mag() * abs(dRF));
	glEnable(GL_TEXTURE_1D);
	glBegin(GL_LINES);
	glTexCoord1f(fCol);
	glVertex3f((float) Point.x, (float) Point.y, (float) Point.z);
	glTexCoord1f(fCol);
	glVertex3f((float) p2.x, (float) p2.y, (float) p2.z);

	glTexCoord1f(fCol);
	glVertex3f((float) Point.x, (float) Point.y, (float) Point.z);
	glTexCoord1f(fCol);
	glVertex3f((float) p3.x, (float) p3.y, (float) p3.z);
	glEnd();
	glLineWidth(1);
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[2].x * dS1 + p2.x, (float) Pts[2].y * dS1 + p2.y, (float) Pts[2].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[1].x * dS1 + p2.x, (float) Pts[1].y * dS1 + p2.y, (float) Pts[1].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[3].x * dS1 + p2.x, (float) Pts[3].y * dS1 + p2.y, (float) Pts[3].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[2].x * dS1 + p2.x, (float) Pts[2].y * dS1 + p2.y, (float) Pts[2].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[4].x * dS1 + p2.x, (float) Pts[4].y * dS1 + p2.y, (float) Pts[4].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[3].x * dS1 + p2.x, (float) Pts[3].y * dS1 + p2.y, (float) Pts[3].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[5].x * dS1 + p2.x, (float) Pts[5].y * dS1 + p2.y, (float) Pts[5].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[4].x * dS1 + p2.x, (float) Pts[4].y * dS1 + p2.y, (float) Pts[4].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[6].x * dS1 + p2.x, (float) Pts[6].y * dS1 + p2.y, (float) Pts[6].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[5].x * dS1 + p2.x, (float) Pts[5].y * dS1 + p2.y, (float) Pts[5].z * dS1 + p2.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p2.x, (float) Y * dS1 + p2.y, (float) Z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[1].x * dS1 + p2.x, (float) Pts[1].y * dS1 + p2.y, (float) Pts[1].z * dS1 + p2.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[6].x * dS1 + p2.x, (float) Pts[6].y * dS1 + p2.y, (float) Pts[6].z * dS1 + p2.z);
	glEnd();

	// SECOND ARROW HEAD
	//**************************************************************************************

	X *= -1;
	Y *= -1;
	Z *= -1;
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p3.x, (float) Y * dS1 + p3.y, (float) Z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[2].x * dS1 + p3.x, (float) Pts[2].y * dS1 + p3.y, (float) Pts[2].z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[1].x * dS1 + p3.x, (float) Pts[1].y * dS1 + p3.y, (float) Pts[1].z * dS1 + p3.z);
	glEnd();

	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p3.x, (float) Y * dS1 + p3.y, (float) Z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[3].x * dS1 + p3.x, (float) Pts[3].y * dS1 + p3.y, (float) Pts[3].z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[2].x * dS1 + p3.x, (float) Pts[2].y * dS1 + p3.y, (float) Pts[2].z * dS1 + p3.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p3.x, (float) Y * dS1 + p3.y, (float) Z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[4].x * dS1 + p3.x, (float) Pts[4].y * dS1 + p3.y, (float) Pts[4].z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[3].x * dS1 + p3.x, (float) Pts[3].y * dS1 + p3.y, (float) Pts[3].z * dS1 + p3.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p3.x, (float) Y * dS1 + p3.y, (float) Z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[5].x * dS1 + p3.x, (float) Pts[5].y * dS1 + p3.y, (float) Pts[5].z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[4].x * dS1 + p3.x, (float) Pts[4].y * dS1 + p3.y, (float) Pts[4].z * dS1 + p3.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p3.x, (float) Y * dS1 + p3.y, (float) Z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[6].x * dS1 + p3.x, (float) Pts[6].y * dS1 + p3.y, (float) Pts[6].z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[5].x * dS1 + p3.x, (float) Pts[5].y * dS1 + p3.y, (float) Pts[5].z * dS1 + p3.z);
	glEnd();
	glBegin(GL_POLYGON);
	glTexCoord1f(fCol);
	glVertex3f((float) X * dS1 + p3.x, (float) Y * dS1 + p3.y, (float) Z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[1].x * dS1 + p3.x, (float) Pts[1].y * dS1 + p3.y, (float) Pts[1].z * dS1 + p3.z);
	glTexCoord1f(fCol);
	glVertex3f((float) Pts[6].x * dS1 + p3.x, (float) Pts[6].y * dS1 + p3.y, (float) Pts[6].z * dS1 + p3.z);
	glEnd();

	glDisable(GL_TEXTURE_1D);
	glLineWidth(2);
	if (((iDspFlgs & DSP_RESLAB) == 0)) {
		char sLab[20];
		sprintf_s(sLab, "%g", iSign * Vector.Mag());
		OglString(iDspFlgs, Point.x, Point.y, Point.z, &sLab[0]);
	}
}

void ResultsVec::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	ME_Object* ME = (ME_Object*) this->pParent;
	double dS = 1.0;
	double dRF = 1.0;
	if (ME != NULL) {
		dS = ME->dScaleVec;
		dRF = ME->dResFactor;
	}
	if ((iDspFlgs & DSP_VEC) == 0) {
		Selectable = 1;
		if (iType == 1)
			DrawVector(iDspFlgs, dS1, dS2, dS, dRF);
		else
			DrawTenVector(iDspFlgs, dS1, dS2, dS, dRF);
	} else {
		Selectable = 0;
	}
}

void ResultsVec::Info() {
	char S1[80];
	sprintf_s(S1, "LABEL %8i MAG %g", iLabel, Vector.Mag());
	outtext1(S1);
}

IMPLEMENT_DYNAMIC(Graph, CObject)

Graph::Graph() {
	fx.clear();
	fy.clear();
}

Graph::~Graph() {
	fx.clear();
	fy.clear();
}

float Graph::GetMaxfx() {
	int i;
	float frc;
	frc = 0.0;

	for (i = 0; i < fx.size(); i++) {
		if (fx[i] > frc)
			frc = fx[i];
	}
	return (frc);
}

float Graph::GetMinfx() {
	int i;
	float frc;
	frc = 0.0;
	for (i = 0; i < fx.size(); i++) {
		if (fx[i] < frc)
			frc = fx[i];
	}
	return (frc);
}

float Graph::GetMaxfy() {
	int i;
	float frc;
	frc = 0.0;
	for (i = 0; i < fy.size(); i++) {
		if (fy[i] > frc)
			frc = fy[i];
	}
	return (frc);
}

float Graph::GetMinfy() {
	int i;
	float frc;
	frc = 0.0;
	for (i = 0; i < fy.size(); i++) {
		if (fy[i] < frc)
			frc = fy[i];
	}
	return (frc);
}

void Graph::genMaxMin() {
	GmaxX = GetMaxfx();
	GminX = GetMinfx();
	GmaxY = GetMaxfy();
	GminY = GetMinfy();
}

void Graph::List() {
	int i;
	char buff[200];
	outtext1(sTitle);
	outtext1(sSubTitle);
	sprintf_s(buff, "%s_%s_%s", sResType, sEntID, sVar);
	outtext1(buff);
	for (i = 0; i < fx.size(); i++) {
		sprintf_s(buff, "%g	%g", fx[i], fy[i]);
		outtext1(buff);
	}
}

IMPLEMENT_DYNAMIC(CoordSys, CObject)

void CoordSys::Create(C3dVector Orig, C3dMatrix RMat, int inRID, int inTp, int iLab, int iC, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 12;
	iColour = iC;
	iLabel = iLab;
	mOrientMat = RMat;
	Origin = Orig;
	dScl = 1;
	pParent = Parrent;
	RID = inRID;
	CysType = inTp;
}

C3dMatrix CoordSys::GetTMat() {
	return (mOrientMat);
}

G_Object* CoordSys::Copy(G_Object* Parrent) {
	CoordSys* cSys = new CoordSys;
	cSys->Drawn = Drawn;
	cSys->Selectable = Selectable;
	cSys->Visable = Visable;
	cSys->iColour = iColour;
	cSys->iObjType = iObjType;
	cSys->iLabel = iLabel;
	cSys->mOrientMat = mOrientMat;
	cSys->Origin = Origin;
	cSys->dScl = dScl;
	cSys->RID = RID;
	cSys->CysType = CysType;
	cSys->pParent = Parrent;
	return (cSys);
}

void CoordSys::ExportNAS(FILE* pFile) {
	ME_Object* ME = (ME_Object*) this->pParent;
	C3dVector pB;
	C3dVector pC;
	C3dVector pO;
	C3dMatrix RMat;
	C3dMatrix RMatDEF;
	CString sType;
	CString sRID;
	CoordSys* pSys;
	RMat = mOrientMat;
	RMatDEF.MakeUnit();
	pO = Origin;
	if (CysType == 3) {
		sType = "CORD2S  ";
	} else if (CysType == 2) {
		sType = "CORD2C  ";
	} else {
		sType = "CORD2R  ";
	}
	if (RID == -1) {
		RID = 0;
	} else {
		if (ME != NULL) {
			pSys = ME->GetSys(RID);
			if (pSys != NULL) {
				RMatDEF = pSys->mOrientMat;
				RMatDEF.Transpose();
				// RMat = RMat* RMatDEF;
				pO -= pSys->Origin;
				pO = RMatDEF * pO;
			} else {
				outtext1("ERROR: Co-ordinate System not found. ");
			}
		}
	}
	pB.x = RMat.m_02;
	pB.y = RMat.m_12;
	pB.z = RMat.m_22;
	pC.x = RMat.m_00;
	pC.y = RMat.m_10;
	pC.z = RMat.m_20;
	pB = RMatDEF * pB;
	pC = RMatDEF * pC;
	pB += pO;
	pC += pO;

	fprintf(pFile, "%8s%8i%8i%8s%8s%8s%8s%8s%8s\n", sType.GetString(), iLabel, RID, e8(pO.x).GetString(),
	        e8(pO.y).GetString(), e8(pO.z).GetString(), e8(pB.x).GetString(), e8(pB.y).GetString(),
	        e8(pB.z).GetString());
	fprintf(pFile, "%8s%8s%8s%8s\n", "        ", e8(pC.x).GetString(), e8(pC.y).GetString(), e8(pC.z).GetString());
}

CString CoordSys::ToString() {
	C3dVector pB;
	C3dVector pC;
	CString sType;
	if (CysType == 3) {
		sType = "CORD2S  ";
	} else if (CysType == 2) {
		sType = "CORD2C  ";
	} else {
		sType = "CORD2R  ";
	}
	pB.x = mOrientMat.m_02;
	pB.y = mOrientMat.m_12;
	pB.z = mOrientMat.m_22;
	pC.x = mOrientMat.m_00;
	pC.y = mOrientMat.m_10;
	pC.z = mOrientMat.m_20;
	pB += Origin;
	pC += Origin;
	int iRID = RID;
	if (RID == -1) {
		iRID = 0;
	}

	char S1[200];
	CString OutT;
	sprintf_s(S1, "%8s%8i%8i%8s%8s%8s%8s%8s%8s\n%8s%8s%8s%8s\n", sType, iLabel, iRID, e8(Origin.x), e8(Origin.y),
	          e8(Origin.z), e8(pB.x), e8(pB.y), e8(pB.z), "        ", e8(pC.x), e8(pC.y), e8(pC.z));
	// sprintf_s(S1,"%8s%8s%8s%8s\n","        ",e8(pC.x),e8(pC.y),e8(pC.z));
	OutT = S1;
	return (OutT);
}

void CoordSys::Info() {
	char S1[200];
	CString OutT;
	G_Object::Info();
	// G_Object::Info();
	sprintf_s(S1, "%i,%8.5f,%8.5f,%8.5f,,%8.5f,%8.5f,%8.5f,%8.5f,%8.5f,%8.5f,%8.5f,%8.5f,%8.5f",
	          iLabel, Origin.x, Origin.y, Origin.z,
	          mOrientMat.m_00, mOrientMat.m_10, mOrientMat.m_20,
	          mOrientMat.m_01, mOrientMat.m_11, mOrientMat.m_21,
	          mOrientMat.m_02, mOrientMat.m_12, mOrientMat.m_22);
	OutT = S1;
	outtext1(OutT);
}

CString CoordSys::GetName() {
	return ("Coordinate System");
}

int CoordSys::GetVarHeaders(CString sVar[]) {
	sVar[0] = "Coord System Type";
	sVar[1] = "Definition Coord System";
	return (3);
}

int CoordSys::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", CysType);
	sVar[0] = S1;
	iNo++;
	sprintf_s(S1, "%i", RID);
	sVar[1] = S1;
	iNo++;
	return (iNo);
}

void CoordSys::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	CysType = atoi(sVar[0]);
	RID = atoi(sVar[1]);
}

C3dVector CoordSys::Get_Centroid() {
	C3dVector O;
	O = Origin;
	// int iRID = 0;
	// ME_Object* ME;
	// iRID = this->RID;
	// ME = (ME_Object*)pParent;
	// if ((ME != NULL) && (iRID > 0))
	//{
	//	do
	//	{
	//		iRID = ME->NodeToGlobal(O, iRID);
	//	} while (iRID > 0);
	// }
	return (O);
}

void CoordSys::Translate(C3dVector vIn) {
	Origin.Translate(vIn);
}

void CoordSys::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		mOrientMat.Serialize(ar, iV);
		Origin.Serialize(ar, iV);
		ar << dScl;
		ar << RID;
		ar << CysType;
	} else {
		G_Object::Serialize(ar, iV);
		mOrientMat.Serialize(ar, iV);
		Origin.Serialize(ar, iV);
		ar >> dScl;
		ar >> RID;
		ar >> CysType;
	}
}

void CoordSys::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	C3dVector X;
	C3dVector Y;
	C3dVector Z;
	C3dVector O;

	if ((iDspFlgs & DSP_COORD) > 0) {
		Selectable = 1;

		X.x = mOrientMat.m_00;
		X.y = mOrientMat.m_10;
		X.z = mOrientMat.m_20;

		Y.x = mOrientMat.m_01;
		Y.y = mOrientMat.m_11;
		Y.z = mOrientMat.m_21;

		Z.x = mOrientMat.m_02;
		Z.y = mOrientMat.m_12;
		Z.z = mOrientMat.m_22;

		X *= dS1;
		Y *= dS1;
		Z *= dS1;

		X += Origin;
		Y += Origin;
		Z += Origin;
		O = Origin;
		// int iRID=0;
		// int iN = 0;
		// ME_Object* ME;
		// iRID = this->RID;
		// ME = (ME_Object*)pParent;
		// if ((ME != NULL) && (iRID>0))
		//{
		//	do
		//	{
		//		iN = ME->NodeToGlobal(O, iRID);
		// iN = ME->NodeToGlobal(X, iRID);
		//		iN = ME->NodeToGlobal(Y, iRID);
		//		iRID = ME->NodeToGlobal(Z, iRID);
		//	} while (iRID > 0);
		// }

		glColor3fv(cols[GetCol()]);
		glBegin(GL_LINES);

		glVertex3f((float) O.x, (float) O.y, (float) O.z);
		glVertex3f((float) X.x, (float) X.y, (float) X.z);

		glVertex3f((float) O.x, (float) O.y, (float) O.z);
		glVertex3f((float) Y.x, (float) Y.y, (float) Y.z);

		glVertex3f((float) O.x, (float) O.y, (float) O.z);
		glVertex3f((float) Z.x, (float) Z.y, (float) Z.z);
		glEnd();

		if (iDspFlgs & DSP_BLACK) {
			glColor3fv(cols[124]);
		} else {
			glColor3fv(cols[0]);
		}
		if (CysType == 2) {
			glRasterPos3f((float) X.x, (float) X.y, (float) X.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPR);
			glRasterPos3f((float) Y.x, (float) Y.y, (float) Y.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPT);
			glRasterPos3f((float) Z.x, (float) Z.y, (float) Z.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		} else if (CysType == 3) {
			glRasterPos3f((float) X.x, (float) X.y, (float) X.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPR);
			glRasterPos3f((float) Y.x, (float) Y.y, (float) Y.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPT);
			glRasterPos3f((float) Z.x, (float) Z.y, (float) Z.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPP);
		} else {
			glRasterPos3f((float) X.x, (float) X.y, (float) X.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPX);
			glRasterPos3f((float) Y.x, (float) Y.y, (float) Y.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPY);
			glRasterPos3f((float) Z.x, (float) Z.y, (float) Z.z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}
		char sLab[20];
		// C3dVector vCent;
		// vCent=Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "Cys%i", iLabel);
			OglString(iDspFlgs, O.x, O.y, O.z, &sLab[0]);
		}
	} else {
		Selectable = 0;
	}
}

void CoordSys::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

//*****************************************************************
// BlowsR 14/07/2020
// Text Object added
// linked list of symbols
//*****************************************************************

Symbol* GetSymbol(int iLab) {
	Symbol* pRet = NULL;
	int i;
	if (iNoSymbols > 0) {
		for (i = 0; i < iNoSymbols; i++) {
			if (pSymTable[i]->iLabel == iLab) {
				pRet = pSymTable[i];
				break;
			}
		}
	}

	return (pRet);
}

IMPLEMENT_DYNAMIC(Text, CObject)

Text::Text() {
	pParent = nullptr;
	pSyms = nullptr;
	C3dVector inP;
	inP.Set(0, 0, 0);
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 6;
	iLabel = -1;
	iColour = 100;
	pSyms = new cLinkedList();
	sText = "";
	if (inPt != NULL) {
		delete (inPt);
	}
	inPt = new CvPt_Object;
	inPt->Create(inP, 0, -1, 0, 0, 1, this);
	vNorm.Set(0, 0, 1);
}

Text::Text(C3dVector vInPt, C3dVector vN, C3dVector vTDir, int iLab, CString sT, double dH, G_Object* Parrent) {
	pParent = Parrent;
	pSyms = nullptr;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 6;
	iLabel = iLab;
	iColour = 100;
	sText = "";
	dTextHeight = dH;
	sText = sT;
	vInsPt = vInPt;
	vNorm = vN;
	vDir = vTDir;
	BuildText();
}

Text::~Text() {
	if (inPt != nullptr)
		delete (inPt);
	if (pSyms != nullptr)
		pSyms->DeleteAll();
}

double Text::GetLength() {
	double drc = 0;
	int iL = 0;

	iL = sText.GetLength();
	drc = iL * dAveW * dTextHeight / dAveH;
	return (drc);
}

void Text::BuildText() {
	double dScl = 0;
	int i = 0;
	int iL = 0;
	int iC = 0;
	C3dVector vM;
	C3dMatrix RMat;
	C3dMatrix TMat;
	if (inPt != nullptr)
		delete (inPt);
	inPt = new CvPt_Object;
	// C3dVector inP; inP.Set(0, 0, 0);
	inPt->Create(vInsPt, 0, -1, 0, 0, 20, this);
	if (pSyms == nullptr)
		pSyms = new cLinkedList();
	pSyms->DeleteAll();
	// Text scaling
	if (dTextHeight <= 0)
		dScl = 1;
	else
		dScl = dTextHeight / dAveH;
	// Build the text from the symbols table
	vM.Set(0, 0, 0);
	Symbol* pSym = nullptr;
	Symbol* pSymN = nullptr;
	iL = sText.GetLength();
	for (i = 0; i < iL; i++) {
		iC = sText[i];
		pSym = GetSymbol(iC);
		if (pSym != NULL) {
			pSymN = (Symbol*) pSym->Copy(NULL);
			pSymN->Translate(vM);
			pSymN->pParent = this;
			pSymN->iColour = this->iColour;
			this->pSyms->Add(pSymN);
			vM.x += pSym->w + 0.25 * dAveW;
		}
	}
	// Scale
	RMat.MakeUnit();
	RMat.Scale(dScl);
	dLen = vM.x;
	dLen *= dScl;
	Symbol* pS = (Symbol*) pSyms->Head;
	while (pS != NULL) {
		pS->Transform(RMat);
		pS = (Symbol*) pS->next;
	}
	// Orientate

	C3dVector vX, vY, vZ;
	vX = vDir;
	vX.Normalize();
	vZ = vNorm;
	vZ.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	RMat.MakeUnit();
	RMat.SetColVec(1, vX);
	RMat.SetColVec(2, vY);
	RMat.SetColVec(3, vZ);

	pS = (Symbol*) pSyms->Head;
	while (pS != NULL) {
		pS->Transform(RMat);
		pS = (Symbol*) pS->next;
	}

	// Move to Insertion point
	TMat.Translate(vInsPt.x, vInsPt.y, vInsPt.z);
	pS = (Symbol*) pSyms->Head;
	while (pS != NULL) {
		pS->Transform(TMat);
		pS = (Symbol*) pS->next;
	}
}

void Text::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void Text::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	C3dVector vC;
	Symbol* pS = NULL;
	if ((iDspFlgs & DSP_CURVES) > 0) {
		Selectable = 1;
		pS = (Symbol*) pSyms->Head;
		while (pS != NULL) {
			pS->Selectable = 1;
			pS = (Symbol*) pS->next;
		}
		glColor3fv(cols[GetCol()]);
		inPt->OglDrawW(iDspFlgs, dS1, dS2);
		pSyms->OglDrawW(iDspFlgs, dS1, dS2);

		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			vC = this->Get_Centroid();
			sprintf_s(sLab, "Txt%i", iLabel);
			OglString(iDspFlgs, (float) vC.x, (float) vC.y, (float) vC.z, &sLab[0]);
		}
	} else {
		Selectable = 0;
		pS = (Symbol*) pSyms->Head;
		while (pS != NULL) {
			pS->Selectable = 0;
			pS = (Symbol*) pS->next;
		}
	}
}

G_ObjectD Text::SelDist(CPoint InPT, Filter FIL) {
	G_ObjectD Ret;
	G_ObjectD dist;
	Ret.pObj = NULL;
	Ret.Dist = 1e36;
	;
	Symbol* pS = NULL;
	pS = (Symbol*) pSyms->Head;
	//  IF POINTS ARE SELECTABLE
	if (FIL.isFilter(0)) {
		dist = inPt->SelDist(InPT, FIL);
		if (dist.Dist <= Ret.Dist) {
			Ret.Dist = dist.Dist;
			Ret.pObj = inPt;
		}
	}
	if (FIL.isFilter(6)) {
		while (pS != NULL) {
			dist = pS->SelDist(InPT, FIL);
			if (dist.Dist < Ret.Dist) {
				Ret.Dist = dist.Dist;
				Ret.pObj = this;
			}
			pS = (Symbol*) pS->next;
		}
	}
	return (Ret);
}

void Text::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	G_Object::S_Box(P1, P2, pSel);
}

void Text::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	Symbol* pS = NULL;
	pS = (Symbol*) pSyms->Head;
	while (pS != NULL) {
		pS->SetToScr(pModMat, pScrTran);
		pS = (Symbol*) pS->next;
	}
	inPt->SetToScr(pModMat, pScrTran);

	C3dVector vC;
	vC = Get_Centroid();
	vC.SetToScr(pModMat, pScrTran);
	SelPt = vC;
}

void Text::HighLight(CDC* pDC) {
	Symbol* pS = NULL;
	pS = (Symbol*) pSyms->Head;
	while (pS != NULL) {
		pS->HighLight(pDC);
		pS = (Symbol*) pS->next;
	}
}

void Text::Transform(C3dMatrix TMat) {
	// vInsPt = inPt->Pt_Point;;
	C3dMatrix TMat2;
	TMat2 = TMat;
	TMat2.ClearTranslations();
	vInsPt = TMat * vInsPt;
	inPt->Pt_Point->x = vInsPt.x;
	inPt->Pt_Point->y = vInsPt.y;
	inPt->Pt_Point->z = vInsPt.z;

	vDir = TMat2 * vDir;
	vNorm = TMat2 * vNorm;
	Symbol* pS = (Symbol*) pSyms->Head;
	pS = (Symbol*) pSyms->Head;
	// BuildText();

	while (pS != NULL) {
		pS->Transform(TMat);
		pS = (Symbol*) pS->next;
	}
}

void Text::Translate(C3dVector vIn) {
	vInsPt += vIn;
	inPt->Pt_Point->x = vInsPt.x;
	inPt->Pt_Point->y = vInsPt.y;
	inPt->Pt_Point->z = vInsPt.z;
	// BuildText();
	Symbol* pS = nullptr;
	pS = (Symbol*) pSyms->Head;
	while (pS != NULL) {
		pS->Translate(vIn);
		pS = (Symbol*) pS->next;
	}
}

void Text::Move(C3dVector vM) {
	Symbol* pS = NULL;
	pS = (Symbol*) pSyms->Head;
	while (pS != NULL) {
		pS->Move(vM);
		pS = (Symbol*) pS->next;
	}
}

void Text::Serialize(CArchive& ar, int iV) {
	C3dVector v1;
	C3dVector v2;
	int i;
	int iNo;
	Symbol* pSym = NULL;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		inPt->Serialize(ar, iV); // Insertion Point
		vInsPt.Serialize(ar, iV);
		vDir.Serialize(ar, iV);
		vNorm.Serialize(ar, iV); // Normal
		ar << dLen;
		ar << dTextHeight; // Text Height
		ar << sText;
		ar << pSyms->iCnt;
		pSym = (Symbol*) pSyms->Head;
		while (pSym != NULL) {
			pSym->Serialize(ar, iV);
			pSym = (Symbol*) pSym->next;
		}
	} else {
		G_Object::Serialize(ar, iV);
		inPt->Serialize(ar, iV); // Insertion Point
		if (iV < -69) {
			vInsPt.Serialize(ar, iV); // Insertion point
			vDir.Serialize(ar, iV); // Text Direcyopn
		}
		vNorm.Serialize(ar, iV); // Normal
		if (iV <= -70)
			ar >> dLen;
		ar >> dTextHeight; // Text Height
		ar >> sText;
		ar >> iNo;
		pSym = (Symbol*) pSyms->Head;
		for (i = 0; i < iNo; i++) {
			pSym = new Symbol();
			pSym->pParent = this;
			pSym->Serialize(ar, iV);
			pSyms->Add(pSym);
		}
	}
}

C3dVector Text::Get_Centroid() {
	C3dVector vC;
	vC.Set(inPt->Pt_Point->x, inPt->Pt_Point->y, inPt->Pt_Point->z);
	return (vC);
}

G_Object* Text::Copy(G_Object* Parrent) {
	Symbol* pS = NULL;
	Text* cText = new Text();
	cText->Drawn = Drawn;
	cText->Selectable = Selectable;
	cText->Visable = Visable;
	cText->iColour = iColour;
	cText->iObjType = iObjType;
	cText->iLabel = iLabel;
	cText->pParent = Parrent;
	// Specifics
	cText->vNorm = vNorm;
	cText->vDir = vDir;
	cText->vInsPt = vInsPt;
	cText->dTextHeight = dTextHeight;
	cText->sText = sText;
	cText->BuildText();

	// pS = (Symbol*) pSyms->Head;
	// while (pS != NULL)
	//{
	//	cText->pSyms->Add(pS->Copy(cText));
	//	pS = (Symbol*) pS->next;
	// }

	return (cText);
}

CString Text::GetName() {
	return ("Text");
}

int Text::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "Layer";
	iNo++;
	sVar[iNo] = "Text";
	iNo++;
	sVar[iNo] = "Height";
	iNo++;
	sVar[iNo] = "Insertion Pt";
	iNo++;
	sVar[iNo] = "Text Direction";
	iNo++;
	sVar[iNo] = "Text Normal";
	iNo++;
	return (iNo);
}

int Text::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	sVar[iNo] = sText;
	iNo++;
	sprintf_s(S1, "%g", dTextHeight);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g,%g,%g", vInsPt.x, vInsPt.y, vInsPt.z);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g,%g,%g", vDir.x, vDir.y, vDir.z);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g,%g,%g", vNorm.x, vNorm.y, vNorm.z);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void Text::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	int i = 0;
	int index = 0;
	CString line;
	CString field;
	CArray<CString, CString> v;
	iFile = atoi(sVar[0]);
	sText = sVar[1];
	dTextHeight = atof(sVar[2]);
	line = _T(sVar[3]);
	index = 0;
	while (AfxExtractSubString(field, line, index, _T(',')) ||
	       AfxExtractSubString(field, line, index, _T(' '))) {
		v.Add(field);
		++index;
	}
	if (index == 3) {
		vInsPt.x = atof(v[0]);
		vInsPt.y = atof(v[1]);
		vInsPt.z = atof(v[2]);
	}
	line = _T(sVar[4]);
	index = 0;
	v.RemoveAll();
	while (AfxExtractSubString(field, line, index, _T(',')) ||
	       AfxExtractSubString(field, line, index, _T(' '))) {
		v.Add(field);
		++index;
	}
	if (index == 3) {
		vDir.x = atof(v[0]);
		vDir.y = atof(v[1]);
		vDir.z = atof(v[2]);
	}
	line = _T(sVar[5]);
	index = 0;
	v.RemoveAll();
	while (AfxExtractSubString(field, line, index, _T(',')) ||
	       AfxExtractSubString(field, line, index, _T(' '))) {
		v.Add(field);
		++index;
	}
	if (index == 3) {
		vNorm.x = atof(v[0]);
		vNorm.y = atof(v[1]);
		vNorm.z = atof(v[2]);
	}

	BuildText();
}

void Text::Info() {
	char S1[200];
	G_Object::Info();
	sprintf_s(S1, "Text:- %s ", sText);
	outtext1(S1);
}

void Text::ExportDXF(FILE* pFile) {
	double dAng = 0;
	C3dVector vX(1.0, 0, 0);
	vDir.Normalize();
	dAng = vX.AngSigned(vDir, vNorm);

	fprintf(pFile, "TEXT\n");
	fprintf(pFile, "  8\n%s\n", "All"); // Layer name
	fprintf(pFile, "100\n%s\n", "AcDbText"); // AcDbText(indicates the subclass, specific to text
	fprintf(pFile, " 10\n%.2f\n", vInsPt.x); // X coordinate of the insertion point
	fprintf(pFile, " 20\n%.2f\n", vInsPt.y); // Y coordinate of the insertion point
	fprintf(pFile, " 30\n%.2f\n", vInsPt.z); // Z coordinate of the insertion point
	fprintf(pFile, " 40\n%.2f\n", dTextHeight); // Text height
	fprintf(pFile, "  1\n%s\n", sText); // Text string
	fprintf(pFile, " 50\n%.2f\n", dAng); // Angle (relative to X direction)
	fprintf(pFile, "100\n%s\n", "AcDbText");
	fprintf(pFile, "  0\n");

	// The following print the text as line segments
	// Symbol* pS;
	// pS = (Symbol*)pSyms->Head;
	// while (pS != NULL)
	//{
	//	pS->ExportDXF(pFile);
	//	pS = (Symbol*)pS->next;
	// }
}

//*****************************************************************
// BlowsR 27/11/2023
// Aligned Dimension
//*****************************************************************
IMPLEMENT_DYNAMIC(DIM, CObject)

DIM::DIM() {
	// 0 N/A
	// 1 Aligned Linear
	// 2 H/V Linear
	// 3 Dia
	// 4 Rad
	iObjType = 10;
	iType = 0;
	iLabel = -1;
	iColour = 100;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	iDimOpt = 0;
}

DIM::DIM(C3dVector vPt1,
         C3dVector vPt2,
         C3dVector vInsPt,
         C3dVector vO,
         C3dVector vN,
         C3dVector vD,
         double dDScl,
         int iLab) {
	// 0 N/A
	// 1 Aligned Linear
	// 2 H/V Linear
	// 3 Dia
	// 4 Rad
	iObjType = 10; // Type Dimension
	iType = 0; // Aligned dimension
	iLabel = iLab;
	iColour = 124;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	dDrgScl = 1;
	dDimScl = dDScl;
	iDimOpt = 0;
	vDInsPt = vInsPt; // Ins Point
	vDPt1 = vPt1; // 1st dim point
	vDPt2 = vPt2; // 2nd dim point or null
	vOrig = vO;
	vNorm = vN;
	vDir = vD;
	Build();
}

DIM::~DIM() {
	Clean();
}

void DIM::Clean() {
	if (pInsPt != nullptr) {
		delete (pInsPt);
		pInsPt = nullptr;
	}
}

void DIM::Build() {
	pInsPt = new CvPt_Object();
	pInsPt->Create(vDInsPt, 1, -1, 0, 0, 11, nullptr);
}

void DIM::OglDrawW(int iDspFlgs, double dS1, double dS2) {
}

G_ObjectD DIM::SelDist(CPoint InPT, Filter FIL) {
	CPoint cPt;
	G_ObjectD Ret;
	if (pInsPt != nullptr) {
		Ret = pInsPt->SelDist(InPT, FIL);
		Ret.pObj = this;
	} else {
		Ret.Dist = 100000000000000.0;
		;
		Ret.pObj = this;
	}
	return (Ret);
}

void DIM::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	if (pInsPt != nullptr) {
		if ((pInsPt->DSP_Point->x > P1.x) &&
		    (pInsPt->DSP_Point->x < P2.x) &&
		    (pInsPt->DSP_Point->y > P1.y) &&
		    (pInsPt->DSP_Point->y < P2.y)) {
			pSel->Add(this);
		}
	}
}

void DIM::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	if (pInsPt != nullptr) {
		pInsPt->SetToScr(pModMat, pScrTran);
	}
}

void DIM::HighLight(CDC* pDC) {
	if (pInsPt != nullptr) {
		pInsPt->HighLight(pDC);
	}
}

void DIM::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << dDIM;
		ar << dDimScl;
		ar << dDrgScl; // Drawing scale Height
		ar << iDimOpt;
		ar << vDAngVert.x;
		ar << vDAngVert.y;
		ar << vDAngVert.z;
		ar << vDPt1.x; // 1st dim point
		ar << vDPt1.y;
		ar << vDPt1.z;
		ar << vDPt2.x; // 2nd dim point or null
		ar << vDPt2.y;
		ar << vDPt2.z;
		ar << vDInsPt.x; // Ins Point
		ar << vDInsPt.y;
		ar << vDInsPt.z;
		ar << vOrig.x; // Origin
		ar << vOrig.y;
		ar << vOrig.z;
		ar << vNorm.x; // Normal to dim
		ar << vNorm.y;
		ar << vNorm.z;
		ar << vDir.x; // WP Direction of dim
		ar << vDir.y;
		ar << vDir.z;
		ar << sTextPre;
		ar << sText; // The text on the dim
		ar << sTextPost;
		ar << bTextOverRide;
	} else {
		G_Object::Serialize(ar, iV);
		ar >> dDIM;
		ar >> dDimScl;
		ar >> dDrgScl; // Drawing scale Height
		ar >> iDimOpt;
		ar >> vDAngVert.x;
		ar >> vDAngVert.y;
		ar >> vDAngVert.z;
		ar >> vDPt1.x; // 1st dim point
		ar >> vDPt1.y;
		ar >> vDPt1.z;
		ar >> vDPt2.x; // 2nd dim point or null
		ar >> vDPt2.y;
		ar >> vDPt2.z;
		ar >> vDInsPt.x; // Ins Point
		ar >> vDInsPt.y;
		ar >> vDInsPt.z;
		ar >> vOrig.x; // Origin
		ar >> vOrig.y;
		ar >> vOrig.z;
		ar >> vNorm.x; // Normal to dim
		ar >> vNorm.y;
		ar >> vNorm.z;
		ar >> vDir.x; // WP Direction of dim
		ar >> vDir.y;
		ar >> vDir.z;
		ar >> sTextPre;
		ar >> sText; // The text on the dim
		ar >> sTextPost; // The text on the dim
		ar >> bTextOverRide;
		Build();
	}
}

CString DIM::GetName() {
	return ("Simension");
}

int DIM::GetVarHeaders(CString sVar[]) {
	sVar[0] = "Dim Text Prefix";
	sVar[1] = "Dim Text";
	sVar[2] = "Dim Text Postfix";
	sVar[3] = "Dim Size";
	sVar[4] = "Drawing Scale";
	sVar[5] = "Text Override (0 to Reset)";
	sVar[6] = "Dimension Option (0 to Defualt)";
	// iDimOpt
	return (7);
}

int DIM::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%s", sTextPre);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%s", sText);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%s", sTextPost);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dDimScl);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dDrgScl);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", bTextOverRide);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iDimOpt);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void DIM::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	sTextPre = sVar[0];
	if (sVar[1] != sText) {
		sText = sVar[1];
		bTextOverRide = TRUE;
	} else {
		bTextOverRide = atoi(sVar[5]);
	}
	sTextPost = sVar[2];
	dDimScl = atof(sVar[3]);
	dDrgScl = atof(sVar[4]);
	iDimOpt = atoi(sVar[6]);
	Clean();
	Build();
}

void DIM::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	vDInsPt = inPt;
}

void DIM::ExportDXF(FILE* pFile) {
}

//*****************************************************************
// BlowsR 27/11/2023
// Aligned Dimension
//*****************************************************************
IMPLEMENT_DYNAMIC(DIMA, CObject)

DIMA::DIMA() {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	iObjType = 10;
	iType = 1;
	iLabel = -1;
	iColour = 162;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	pPtV = nullptr;
	pPt1 = nullptr; // 1st dim point
	pPt2 = nullptr; // 2nd dim point or null
	pLeader1 = nullptr;
	pLeader2 = nullptr;
	pDimLine1 = nullptr; // one halve of dim line
	pDimLine2 = nullptr; // other halve
	Text* pText = nullptr;
	pInsPt = nullptr; // Ins Point
	dDimScl = 1;
	dDrgScl = 1;
	vNorm.Set(0.0, 0.0, 1.0); // Normal to dim
	vDir.Set(1.0, 0.0, 0.0); // Direction of dim
}

DIMA::DIMA(C3dVector vPt1,
           C3dVector vPt2,
           C3dVector vInsPt,
           C3dVector vO,
           C3dVector vN,
           C3dVector vD,
           double dDrawingScl,
           double dDScl,
           int iLab) {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	iObjType = 10; // Type Dimension
	iType = 1; // Aligned dimension
	iLabel = iLab;
	iColour = 4;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	pPtV = nullptr;
	pPt1 = nullptr; // 1st dim point
	pPt2 = nullptr; // 2nd dim point or null
	pLeader1 = nullptr;
	pLeader2 = nullptr;
	pDimLine1 = nullptr; // one halve of dim line
	pDimLine2 = nullptr; // other halve
	Text* pText = nullptr;
	pInsPt = nullptr; // Ins Point
	dDrgScl = dDrawingScl; // Drawing scale 2:1
	dDimScl = dDScl;
	vDInsPt = vInsPt; // Ins Point
	vDPt1 = vPt1; // 1st dim point
	vDPt2 = vPt2; // 2nd dim point or null
	vOrig = vO;
	vNorm = vN;
	vDir = vD;
	Build();
}

DIMA::~DIMA() {
	Clean();
}

void DIMA::Clean() {
	if (pPtV != nullptr) {
		delete (pPtV);
		pPtV = nullptr;
	}
	if (pPt1 != nullptr) {
		delete (pPt1);
		pPt1 = nullptr;
	}
	if (pPt2 != nullptr) {
		delete (pPt2);
		pPt2 = nullptr;
	}
	if (pInsPt != nullptr) {
		delete (pInsPt);
		pInsPt = nullptr;
	}
	if (pLeader1 != nullptr) {
		delete (pLeader1);
		pLeader1 = nullptr;
	}
	if (pLeader2 != nullptr) {
		delete (pLeader2);
		pLeader2 = nullptr;
	}
	if (pDimLine1 != nullptr) {
		delete (pDimLine1);
		pDimLine1 = nullptr;
	}
	if (pDimLine2 != nullptr) {
		delete (pDimLine2);
		pDimLine2 = nullptr;
	}
	if (pText != nullptr) {
		delete (pText);
		pText = nullptr;
	}
}

void DIMA::Build() {
	// Transform all to DIM plain (for this is workplane)
	C3dMatrix RMat;
	RMat.MakeUnit();
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;
	vZ = vNorm;
	vX = vDir;
	vZ.Normalize();
	vX.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	RMat.SetColVec(1, vX);
	RMat.SetColVec(2, vY);
	RMat.SetColVec(3, vZ);
	RMat.Transpose();
	vPP1 = vDPt1;
	vPP2 = vDPt2;
	vPP1 -= vOrig;
	vPP2 -= vOrig;
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1.z = 0;
	vPP2.z = 0;
	RMat.Transpose();
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1 += vOrig;
	vPP2 += vOrig;
	dDIM = vPP1.Dist(vPP2);
	dDist = dDIM / dDrgScl;
	char buff[200];
	if (!bTextOverRide) {
		sprintf_s(buff, "%.*f", gDIM_PREC, dDist);
		sText = buff;
	}
	vPP1D = vPP1;
	vPP2D = vPP2;
	;
	vDX = vPP2 - vPP1;
	vDX.Normalize();
	vDY = vNorm.Cross(vDX);
	vDY.Normalize();
	pPt1 = new CvPt_Object();
	pPt1->Create(vDPt1, 1, -1, 0, 0, 11, nullptr);
	pPt2 = new CvPt_Object();
	pPt2->Create(vDPt2, 1, -1, 0, 0, 11, nullptr);
	pInsPt = new CvPt_Object();
	pInsPt->Create(vDInsPt, 1, -1, 0, 0, 11, nullptr);
	// First Leader Line
	pLeader1 = new NLine();
	pLeader1->Create(vPP1, vDInsPt, -1, this);
	pLeader1->iColour = iColour;
	pLeader1->iLnThk = 2;
	pLeader2 = new NLine();
	pLeader2->Create(vPP2, vDInsPt, -1, this);
	pLeader2->iColour = iColour;
	pLeader2->iLnThk = 2;
	NLine* pL;
	pL = new NLine();
	pL->Create(vPP1, vPP2, -1, this);
	pL->iColour = iColour;
	pDimLine1 = pL;
	pL = new NLine();
	pL->Create(vPP1, vPP2, -1, this);
	pL->iColour = iColour;
	pDimLine2 = pL;
	// Text insertion point - need to lift off the dim line slightly
	CString sT;
	sT = sTextPre + sText + sTextPost;
	pText = new Text(vDInsPt, vNorm, vDX, -1, sT, dDimScl, this);
	pText->iColour = iColour;
	C3dMatrix mWP;
	// The call to DragUpdate should probably be called build
	DragUpdate(vDInsPt, mWP);
}

void DIMA::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if (pLeader1 != nullptr)
		pLeader1->OglDrawW(iDspFlgs, dS1, dS2);
	if (pLeader2 != nullptr)
		pLeader2->OglDrawW(iDspFlgs, dS1, dS2);
	if (pDimLine1 != nullptr)
		pDimLine1->OglDrawW(iDspFlgs, dS1, dS2);
	if (pDimLine2 != nullptr)
		pDimLine2->OglDrawW(iDspFlgs, dS1, dS2);
	if (pText != nullptr)
		pText->OglDrawW(iDspFlgs, dS1, dS2);
	if ((iDspFlgs & DSP_CURVES) > 0) {
		if (pPt1 != nullptr)
			pPt1->OglDrawW(iDspFlgs, dS1, dS2);
		if (pPt2 != nullptr)
			pPt2->OglDrawW(iDspFlgs, dS1, dS2);
		if (pInsPt != nullptr)
			pInsPt->OglDrawW(iDspFlgs, dS1, dS2);
		glColor3fv(cols[iColour]);
		// Filled Arrow Heads
		glBegin(GL_POLYGON);
		glVertex3f(vPP1D.x, vPP1D.y, vPP1D.z);
		glVertex3f(vPP1A1.x, vPP1A1.y, vPP1A1.z);
		glVertex3f(vPP1A2.x, vPP1A2.y, vPP1A2.z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f(vPP2D.x, vPP2D.y, vPP2D.z);
		glVertex3f(vPP2A1.x, vPP2A1.y, vPP2A1.z);
		glVertex3f(vPP2A2.x, vPP2A2.y, vPP2A2.z);
		glEnd();
	}
}

void DIMA::Colour(int iCol) {
	this->iColour = iCol;
	if (pPtV != nullptr)
		pPtV->iColour = iCol;
	if (pPt1 != nullptr)
		pPt1->iColour = iCol;
	if (pPt2 != nullptr)
		pPt2->iColour = iCol;
	if (pInsPt != nullptr)
		pInsPt->iColour = iCol;
	if (pLeader1 != nullptr)
		pLeader1->iColour = iCol;
	if (pLeader2 != nullptr)
		pLeader2->iColour = iCol;
	if (pDimLine1 != nullptr)
		pDimLine1->iColour = iCol;
	if (pDimLine2 != nullptr)
		pDimLine2->iColour = iCol;
	if (pText != nullptr)
		pText->iColour = iCol;
}

void DIMA::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	vDInsPt = inPt;
	C3dVector vP1toIns, vT, vOff, vLOff;
	double dExtY = 0;
	vP1toIns = inPt;
	vP1toIns -= vPP1;
	dExtY = vP1toIns.Dot(vDY);
	vPP1D = vPP1;
	vPP1D += vDY * dExtY;
	vPP2D = vPP2;
	vPP2D += vDY * dExtY;
	vOff = vDY * dDimScl * 0.25; // Text Offset
	vLOff = (vPP1D - vPP1);
	vLOff.Normalize();
	vLOff *= dDimScl * 0.5; // Leader offset
	pInsPt->SetTo(inPt);
	// THE LEADERS
	pLeader1->cPts[0]->SetTo(vPP1 + vLOff);
	pLeader2->cPts[0]->SetTo(vPP2 + vLOff);
	pLeader1->cPts[1]->SetTo(vPP1D + vLOff);
	pLeader2->cPts[1]->SetTo(vPP2D + vLOff);

	// THE DIMENSION LINES
	// need to see if lines are in or out and calc end points
	// and arrow heads
	C3dVector vDimDir1;
	C3dVector vInPtDir1;
	C3dVector vDimDir2;
	C3dVector vInPtDir2;
	C3dVector vDimDir;
	C3dVector vExt;
	C3dVector vYPOff;
	double dDotOut1;
	double dDotOut2;
	double dDLen1;
	double dDLen2;
	// check to see if insersion point is outside on vPP1D side
	vDimDir1 = (vPP2D - vPP1D);
	vDimDir1.Normalize();
	vInPtDir1 = (inPt - vPP1D);
	dDLen1 = vInPtDir1.Mag();
	vInPtDir1.Normalize();
	dDotOut1 = vDimDir1.Dot(vInPtDir1);
	// check to see if insersion point is outside on vPP2D side
	vDimDir2 = (vPP1D - vPP2D);
	vDimDir2.Normalize();
	vInPtDir2 = (inPt - vPP2D);
	dDLen2 = vInPtDir2.Mag();
	vInPtDir2.Normalize();
	dDotOut2 = vDimDir2.Dot(vInPtDir2);
	if (dDotOut1 < 0) {
		vExt = vDimDir1;
		vExt *= dDLen1;
		vT = vPP1D;
		vT -= vExt;
		pDimLine1->cPts[0]->SetTo(vPP1D);
		pDimLine1->cPts[1]->SetTo(vT);
		// Arrow points vPP1D
		vDimDir = vDimDir1;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP1A1 = vPP1D - vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP1A2 = vPP1D - vT;

		vExt *= 0.5;
		vT = vPP2D;
		vT += vExt;
		pDimLine2->cPts[0]->SetTo(vPP2D);
		pDimLine2->cPts[1]->SetTo(vT);
		// Arrow points vPP2D
		vDimDir = vDimDir1;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP2A1 = vPP2D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP2A2 = vPP2D + vT;
	} else if (dDotOut2 < 0) {
		// Also need to add length of text
		dDLen2 += pText->GetLength();
		vExt = vDimDir2;
		vExt *= dDLen2;
		vT = vPP2D;
		vT -= vExt;
		pDimLine1->cPts[0]->SetTo(vPP2D);
		pDimLine1->cPts[1]->SetTo(vT);
		// Arrow points vPP1D
		vDimDir = vDimDir2;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP1A1 = vPP1D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP1A2 = vPP1D + vT;

		vExt *= 0.5;
		vT = vPP1D;
		vT += vExt;
		pDimLine2->cPts[0]->SetTo(vPP1D);
		pDimLine2->cPts[1]->SetTo(vT);
		// Arrow points vPP2D
		vDimDir = vDimDir2;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP2A1 = vPP2D - vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP2A2 = vPP2D - vT;
	} else // insertion point is between leaders
	{
		vT = vPP2D;
		vT += vPP1D;
		vT *= 0.5;
		pDimLine1->cPts[0]->SetTo(vPP1D);
		pDimLine1->cPts[1]->SetTo(vT);
		pDimLine2->cPts[0]->SetTo(vPP2D);
		pDimLine2->cPts[1]->SetTo(vT);
		// Arrow points vPP1D
		vDimDir = vPP2D - vPP1D;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP1A1 = vPP1D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP1A2 = vPP1D + vT;
		// Arrow points vPP2D
		vDimDir = vPP1D - vPP2D;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP2A1 = vPP2D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP2A2 = vPP2D + vT;
	}

	// THE TEXT
	C3dVector vTxtTrans;
	vTxtTrans = inPt;
	vTxtTrans += vOff;
	vTxtTrans -= pText->vInsPt;
	pText->Translate(vTxtTrans);
}

void DIMA::ExportDXF(FILE* pFile) {
	C3dVector v1;
	v1.Set(1, 1, 1);
	NLine* ll = new NLine();
	ModLayNo(iFile);
	ll->Create(v1, v1, -1, nullptr);
	if (pPtV != NULL)
		pPtV->ExportDXF(pFile); // 1st dim point
	if (pPt1 != NULL)
		pPt1->ExportDXF(pFile); // 1st dim point
	if (pPt2 != NULL)
		pPt2->ExportDXF(pFile); // 2nd dim point or null
	if (pLeader1 != NULL)
		pLeader1->ExportDXF(pFile);
	if (pLeader2 != NULL)
		pLeader2->ExportDXF(pFile);
	if (pDimLine1 != NULL) {
		pDimLine1->ExportDXF(pFile); // one halve of dim line
		// glVertex3f(vPP1D.x, vPP1D.y, vPP1D.z);
		// glVertex3f(vPP1A1.x, vPP1A1.y, vPP1A1.z);
		// glVertex3f(vPP1A2.x, vPP1A2.y, vPP1A2.z);
		ll->cPts[0]->SetTo(vPP1D);
		ll->cPts[1]->SetTo(vPP1A1);
		ll->iFile = this->iFile;
		ll->ExportDXF(pFile);
		ll->cPts[0]->SetTo(vPP1A1);
		ll->cPts[1]->SetTo(vPP1A2);
		ll->iFile = this->iFile;
		ll->ExportDXF(pFile);
		ll->cPts[0]->SetTo(vPP1A2);
		ll->cPts[1]->SetTo(vPP1D);
		ll->iFile = this->iFile;
		ll->ExportDXF(pFile);
		if (iType == 6) // Second arror head for Ang DIM
		{
			ll->cPts[0]->SetTo(vPP2D);
			ll->cPts[1]->SetTo(vPP2A1);
			ll->iFile = this->iFile;
			ll->ExportDXF(pFile);
			ll->cPts[0]->SetTo(vPP2A1);
			ll->cPts[1]->SetTo(vPP2A2);
			ll->iFile = this->iFile;
			ll->ExportDXF(pFile);
			ll->cPts[0]->SetTo(vPP2A2);
			ll->cPts[1]->SetTo(vPP2D);
			ll->iFile = this->iFile;
			ll->ExportDXF(pFile);
		}
	}
	if (pDimLine2 != NULL) {
		pDimLine2->ExportDXF(pFile); // other halve
		ll->cPts[0]->SetTo(vPP2D);
		ll->cPts[1]->SetTo(vPP2A1);
		ll->iFile = this->iFile;
		ll->ExportDXF(pFile);
		ll->cPts[0]->SetTo(vPP2A1);
		ll->cPts[1]->SetTo(vPP2A2);
		ll->iFile = this->iFile;
		ll->ExportDXF(pFile);
		ll->cPts[0]->SetTo(vPP2A2);
		ll->cPts[1]->SetTo(vPP2D);
		ll->iFile = this->iFile;
		ll->ExportDXF(pFile);
	}
	if (pText != NULL)
		pText->ExportDXF(pFile);
	delete (ll);
}

void DIMA::ModLayNo(int iLay) {
	this->iFile = iLay;
	if (pPtV != NULL)
		pPtV->ModLayNo(iLay); // 1st dim point
	if (pPt1 != NULL)
		pPt1->ModLayNo(iLay); // 1st dim point
	if (pPt2 != NULL)
		pPt2->ModLayNo(iLay); // 2nd dim point or null
	if (pLeader1 != NULL)
		pLeader1->ModLayNo(iLay);
	if (pLeader2 != NULL)
		pLeader2->ModLayNo(iLay);
	if (pDimLine1 != NULL)
		pDimLine1->ModLayNo(iLay); // one halve of dim line
	if (pDimLine2 != NULL)
		pDimLine2->ModLayNo(iLay); // other halve
	if (pText != NULL)
		pText->ModLayNo(iLay);
}

IMPLEMENT_DYNAMIC(DIMANG, CObject)

DIMANG::DIMANG() {
	//*****************************************************************
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	// 5 Dia
	// 6 Ang
	// 7 Leader
	iObjType = 10;
	iType = 6;
	iLabel = -1;
	iColour = 162;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	pPt1 = nullptr; // 1st dim point
	pPt2 = nullptr; // 2nd dim point or null
	pLeader1 = nullptr;
	pLeader2 = nullptr;
	pDimLine1 = nullptr; // one halve of dim line
	pDimLine2 = nullptr; // other halve
	Text* pText = nullptr;
	pInsPt = nullptr; // Ins Point
	dDimScl = 1;
	dDrgScl = 1;
	vNorm.Set(0.0, 0.0, 1.0); // Normal to dim
	vDir.Set(1.0, 0.0, 0.0); // Direction of dim
}

DIMANG::DIMANG(C3dVector vVPt,
               C3dVector vPt1,
               C3dVector vPt2,
               C3dVector vInsPt,
               C3dVector vO,
               C3dVector vN,
               C3dVector vD,
               double dDScl,
               int iLab) {
	//*****************************************************************
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	// 5 Dia
	// 6 Ang
	// 7 Leader
	iObjType = 10; // Type Dimension
	iType = 6; // Aligned dimension
	iLabel = iLab;
	iColour = 4;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	pPtV = nullptr;
	pPt1 = nullptr; // 1st dim point
	pPt2 = nullptr; // 2nd dim point or null
	pLeader1 = nullptr;
	pLeader2 = nullptr;
	pDimLine1 = nullptr; // one halve of dim line
	pDimLine2 = nullptr; // other halve
	Text* pText = nullptr;
	pInsPt = nullptr; // Ins Point
	dDrgScl = 1;
	dDimScl = dDScl;
	vDInsPt = vInsPt; // Ins Point
	vDAngVert = vVPt;
	vDPt1 = vPt1; // 1st dim point
	vDPt2 = vPt2; // 2nd dim point or null
	vOrig = vO;
	vNorm = vN;
	vDir = vD;
	Build();
}

void DIMANG::Build() {
	// Transform all to DIM plain (for this is workplane)
	C3dMatrix RMat;
	RMat.MakeUnit();
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;
	vZ = vNorm;
	vX = vDir;
	vZ.Normalize();
	vX.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	RMat.SetColVec(1, vX);
	RMat.SetColVec(2, vY);
	RMat.SetColVec(3, vZ);
	RMat.Transpose();
	vPPV = vDAngVert;
	vPP1 = vDPt1;
	vPP2 = vDPt2;
	vPPV -= vOrig;
	vPP1 -= vOrig;
	vPP2 -= vOrig;
	vPPV = RMat * vPPV;
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPPV.z = 0;
	vPP1.z = 0;
	vPP2.z = 0;
	RMat.Transpose();
	vPPV = RMat * vPPV;
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPPV += vOrig;
	vPP1 += vOrig;
	vPP2 += vOrig;
	vPP1D = vPP1;
	vPP2D = vPP2;
	// Need to calc angle
	C3dVector v1, v2;
	double dA;
	double dR;

	v1 = vPP1 - vPPV;
	dR = v1.Mag();
	v1.Normalize();
	v2 = vPP2 - vPPV;
	v2.Normalize();
	dA = v1.AngSigned(v2, vNorm);
	dDIM = dA;
	dDist = dDIM;
	char buff[200];
	if (!bTextOverRide) {
		char newCharacter = 1; // Assuming the character 8960 is a TCHAR
		sprintf_s(buff, "%.*f", gDIM_PREC, dDist);
		sText = buff;
		sText += newCharacter;
	}
	vPP1D = vPP1;
	vPP2D = vPP2;
	;
	vDX = vPP1 - vPP2;
	vDX.Normalize();
	vDY = vNorm.Cross(vDX);
	vDY.Normalize();
	// The picked points
	pPtV = new CvPt_Object();
	pPtV->Create(vDAngVert, 1, -1, 0, 0, 11, nullptr);
	pPt1 = new CvPt_Object();
	pPt1->Create(vDPt1, 1, -1, 0, 0, 11, nullptr);
	pPt2 = new CvPt_Object();
	pPt2->Create(vDPt2, 1, -1, 0, 0, 11, nullptr);
	pInsPt = new CvPt_Object();
	pInsPt->Create(vDInsPt, 1, -1, 0, 0, 11, nullptr);
	// First Leader Line
	pLeader1 = new NLine();
	pLeader1->Create(vPP1, vPP1D, -1, this);
	pLeader1->iColour = iColour;
	pLeader1->iLnThk = 2;
	// Second Learder
	pLeader2 = new NLine();
	pLeader2->Create(vPP2, vPP2D, -1, this);
	pLeader2->iColour = iColour;
	// pLeader2->iLnThk = 2;
	NCircle* pC;
	pC = new NCircle();
	pC->Create2(vNorm, vPPV, v1, dR, -1, this);
	pC->iColour = iColour;
	pDimLine1 = pC;
	// used as leader
	pC = new NCircle();
	pC->Create2(vNorm, vPPV, v1, dR, -1, this);
	pC->iColour = iColour;
	pC->we = 0;
	pDimLine2 = pC;
	// Circle end point
	double we;
	// this is a fix as MinWPt was not finding the correct point
	C3dVector fA;
	fA = vPP2 - vPPV;
	fA.Normalize();
	fA *= dR;
	fA += vPPV;
	// end of fix below fA was vPP2
	we = pDimLine1->MinWPt(fA);
	pDimLine1->we = we;
	// pL = new NLine();
	// pL->Create(vPP1, vPP2, -1, this);
	// pL->iColour = iColour;
	// pDimLine2 = pL;
	// Text insertion point - need to lift off the dim line slightly
	CString sT;
	sT = sTextPre + sText + sTextPost;
	pText = new Text(vDInsPt, vNorm, vDX, -1, sT, dDimScl, this);
	pText->iColour = iColour;
	C3dMatrix mWP;
	// The call to DragUpdate should probably be called build
	DragUpdate(vDInsPt, mWP);
}

void DIMANG::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	double w;
	C3dVector vTxtMid, vTxtDir, vTxtOff;
	double txtLen;
	vDInsPt = inPt;
	pInsPt->Pt_Point->Set(vDInsPt.x, vDInsPt.y, vDInsPt.z);

	// update dime circle
	pDimLine1->DragUpdate(vDInsPt, mWP);
	w = pDimLine1->MinWPt(vDInsPt);
	// pDimLine2 is used a leader if neaded
	pDimLine2->ws = 0.0;
	pDimLine2->we = 0.0;
	if (w > pDimLine1->we) {
		if (w > 0.5) {
			pDimLine2->ws = w;
			pDimLine2->we = 1.0;
		} else {
			pDimLine2->ws = 0;
			pDimLine2->we = w;
		}
	}
	pDimLine2->DragUpdate(inPt, mWP);
	// find new text dir

	vTxtDir = pDimLine1->GetDir(w);
	vTxtDir *= -1;
	// find leader end points and update leaders
	vPP1D = pDimLine1->GetPt(pDimLine1->ws);
	vPP2D = pDimLine1->GetPt(pDimLine1->we);
	// Leader offsets
	C3dVector vLOff1, vLOff2;
	vLOff1 = vPP1D - vPP1;
	vLOff1.Normalize();
	vLOff1 *= dDimScl * 0.5;
	pLeader1->cPts[0]->SetTo(vPP1 + vLOff1);
	pLeader1->cPts[1]->SetTo(vPP1D + vLOff1);
	vLOff2 = vPP2D - vPP2;
	vLOff2.Normalize();
	vLOff2 *= dDimScl * 0.5;
	pLeader2->cPts[0]->SetTo(vPP2 + vLOff2);
	pLeader2->cPts[1]->SetTo(vPP2D + vLOff2);

	// THE TEXT
	vTxtMid = vTxtDir;
	vTxtMid.Normalize();
	txtLen = pText->dLen;
	vTxtMid *= 0.5 * txtLen;
	vTxtOff = vDInsPt - vPPV;
	vTxtOff.Normalize();
	vTxtOff *= dDimScl * 0.25;

	C3dVector vTxtTrans;
	vTxtTrans = vDInsPt;
	vTxtTrans -= pText->vInsPt;
	vTxtTrans -= vTxtMid;
	vTxtTrans += vTxtOff;
	pText->vDir = vTxtDir;
	pText->Translate(vTxtTrans);
	pText->BuildText();
	// The Arrow Points
	C3dVector vDimDir, vT;
	vDimDir = pDimLine1->GetDir(0);
	vDimDir.Normalize();
	vLOff1.Normalize();
	vDimDir *= 1.5;
	vLOff1 *= 0.4;
	vT = vDimDir + vLOff1;
	vT *= dDimScl;
	vPP1A1 = vPP1D + vT;
	vT = vDimDir - vLOff1;
	vT *= dDimScl;
	vPP1A2 = vPP1D + vT;
	// Second Arrow
	vDimDir = pDimLine1->GetDir(pDimLine1->we);
	vDimDir.Normalize();
	vLOff2.Normalize();
	vDimDir *= -1.5;
	vLOff2 *= 0.4;
	vT = vDimDir + vLOff2;
	vT *= dDimScl;
	vPP2A1 = vPP2D + vT;
	vT = vDimDir - vLOff2;
	vT *= dDimScl;
	vPP2A2 = vPP2D + vT;
}

void DIMANG::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if (pText != nullptr)
		pText->OglDrawW(iDspFlgs, dS1, dS2);
	if (pDimLine1 != nullptr)
		pDimLine1->OglDrawW(iDspFlgs, dS1, dS2);
	if (pDimLine2 != nullptr) // Used as leader
		pDimLine2->OglDrawW(iDspFlgs, dS1, dS2);
	if (pLeader1 != nullptr)
		pLeader1->OglDrawW(iDspFlgs, dS1, dS2);
	if (pLeader2 != nullptr)
		pLeader2->OglDrawW(iDspFlgs, dS1, dS2);
	if ((iDspFlgs & DSP_CURVES) > 0) {
		if (pPtV != nullptr)
			pPtV->OglDrawW(iDspFlgs, dS1, dS2);
		if (pPt1 != nullptr)
			pPt1->OglDrawW(iDspFlgs, dS1, dS2);
		if (pPt2 != nullptr)
			pPt2->OglDrawW(iDspFlgs, dS1, dS2);
		if (pInsPt != nullptr)
			pInsPt->OglDrawW(iDspFlgs, dS1, dS2);
		glBegin(GL_POLYGON);
		glVertex3f(vPP1D.x, vPP1D.y, vPP1D.z);
		glVertex3f(vPP1A1.x, vPP1A1.y, vPP1A1.z);
		glVertex3f(vPP1A2.x, vPP1A2.y, vPP1A2.z);
		glEnd();
		glBegin(GL_POLYGON);
		glVertex3f(vPP2D.x, vPP2D.y, vPP2D.z);
		glVertex3f(vPP2A1.x, vPP2A1.y, vPP2A1.z);
		glVertex3f(vPP2A2.x, vPP2A2.y, vPP2A2.z);
		glEnd();
	}
}

// Horizontal / Vertical dimension

IMPLEMENT_DYNAMIC(DIMH, CObject)

DIMH::DIMH() {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
}

DIMH::DIMH(C3dVector vPt1,
           C3dVector vPt2,
           C3dVector vInsPt,
           C3dVector vO,
           C3dVector vN,
           C3dVector vD,
           double dDrawingScl,
           double dDScl,
           int iLab) {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	iObjType = 10; // Type Dimension
	iType = 2; // Aligned dimension
	iLabel = iLab;
	iColour = 4;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	pPt1 = nullptr; // 1st dim point
	pPt2 = nullptr; // 2nd dim point or null
	pLeader1 = nullptr;
	pLeader2 = nullptr;
	pDimLine1 = nullptr; // one halve of dim line
	pDimLine2 = nullptr; // other halve
	Text* pText = nullptr;
	pInsPt = nullptr; // Ins Point
	dDrgScl = dDrawingScl;
	dDimScl = dDScl;
	vDInsPt = vInsPt; // Ins Point
	vDPt1 = vPt1; // 1st dim point
	vDPt2 = vPt2; // 2nd dim point or null
	vOrig = vO;
	vNorm = vN;
	vDir = vD;
	Build();
}

void DIMH::Build() {
	// Transform all to DIM plain (for this is workplane)
	C3dMatrix RMat;
	RMat.MakeUnit();
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;
	vZ = vNorm;
	vX = vDir;
	vZ.Normalize();
	vX.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	RMat.SetColVec(1, vX);
	RMat.SetColVec(2, vY);
	RMat.SetColVec(3, vZ);
	RMat.Transpose();
	vPP1 = vDPt1;
	vPP2 = vDPt2;
	vPP1 -= vOrig;
	vPP2 -= vOrig;
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1.z = 0;
	vPP2.z = 0;
	RMat.Transpose();
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1 += vOrig;
	vPP2 += vOrig;

	vPP1D = vPP1;
	vPP2D = vPP2;
	;
	vDX = vX;
	// vDX.Set(1, 0, 0); //Horizontal
	C3dVector vDDD;
	vDDD = vPP2D - vPP1D;
	dDIM = abs(vDDD.Dot(vDX));
	dDist = dDIM / dDrgScl;

	// dDist = vPP1D.Dist(vPP2D) / dDrgScl;
	char buff[200];
	if (!bTextOverRide) {
		sprintf_s(buff, "%.*f", gDIM_PREC, dDist);
		sText = buff;
	}
	vDY = vNorm.Cross(vDX);
	vDY.Normalize();
	pPt1 = new CvPt_Object();
	pPt1->Create(vDPt1, 1, -1, 0, 0, 11, nullptr);
	pPt2 = new CvPt_Object();
	pPt2->Create(vDPt2, 1, -1, 0, 0, 11, nullptr);
	pInsPt = new CvPt_Object();
	pInsPt->Create(vDInsPt, 1, -1, 0, 0, 11, nullptr);
	// First Leader Line
	pLeader1 = new NLine();
	pLeader1->Create(vPP1, vDInsPt, -1, this);
	pLeader1->iColour = iColour;
	pLeader1->iLnThk = 2;
	pLeader2 = new NLine();
	pLeader2->Create(vPP2, vDInsPt, -1, this);
	pLeader2->iColour = iColour;
	pLeader2->iLnThk = 2;
	NLine* pL;
	pL = new NLine();
	pL->Create(vPP1, vPP2, -1, this);
	pL->iColour = iColour;
	pDimLine1 = pL;
	pL = new NLine();
	pL->Create(vPP1, vPP2, -1, this);
	pL->iColour = iColour;
	pDimLine2 = pL;
	// Text insertion point - need to lift off the dim line slightly
	CString sT;
	sT = sTextPre + sText + sTextPost;
	pText = new Text(vDInsPt, vNorm, vDX, -1, sT, dDimScl, this);
	pText->iColour = iColour;
	C3dMatrix mWP;
	// The call to DragUpdate should probably be called build
	DragUpdate(vDInsPt, mWP);
}

void DIMH::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	vDInsPt = inPt;
	C3dVector vP1toIns, vP2toIns, vT, vOff, vLOff;
	double dExtY = 0;
	vP1toIns = inPt;
	vP1toIns -= vPP1;
	dExtY = vP1toIns.Dot(vDY);
	vPP1D = vPP1;
	vPP1D += vDY * dExtY;
	vPP2D = vPP2;

	vP2toIns = inPt;
	vP2toIns -= vPP2;
	dExtY = vP2toIns.Dot(vDY);
	vPP2D = vPP2;
	vPP2D += vDY * dExtY;

	vOff = vDY * dDimScl * 0.25; // Text Offset
	vLOff = (vPP1D - vPP1);
	vLOff.Normalize();
	vLOff *= dDimScl * 0.5; // Leader offset
	pInsPt->SetTo(inPt);
	// THE LEADERS
	pLeader1->cPts[0]->SetTo(vPP1 + vLOff);
	pLeader2->cPts[0]->SetTo(vPP2 + vLOff);
	pLeader1->cPts[1]->SetTo(vPP1D + vLOff);
	pLeader2->cPts[1]->SetTo(vPP2D + vLOff);

	// THE DIMENSION LINES
	// need to see if lines are in or out and calc end points
	// and arrow heads
	C3dVector vDimDir1;
	C3dVector vInPtDir1;
	C3dVector vDimDir2;
	C3dVector vInPtDir2;
	C3dVector vDimDir;
	C3dVector vExt;
	C3dVector vYPOff;
	double dDotOut1;
	double dDotOut2;
	double dDLen1;
	double dDLen2;
	// check to see if insersion point is outside on vPP1D side
	vDimDir1 = (vPP2D - vPP1D);
	vDimDir1.Normalize();
	vInPtDir1 = (inPt - vPP1D);
	dDLen1 = vInPtDir1.Mag();
	vInPtDir1.Normalize();
	dDotOut1 = vDimDir1.Dot(vInPtDir1);
	// check to see if insersion point is outside on vPP2D side
	vDimDir2 = (vPP1D - vPP2D);
	vDimDir2.Normalize();
	vInPtDir2 = (inPt - vPP2D);
	dDLen2 = vInPtDir2.Mag();
	vInPtDir2.Normalize();
	dDotOut2 = vDimDir2.Dot(vInPtDir2);
	if (dDotOut1 < 0) {
		vExt = vDimDir1;
		vExt *= dDLen1;
		vT = vPP1D;
		vT -= vExt;
		pDimLine1->cPts[0]->SetTo(vPP1D);
		pDimLine1->cPts[1]->SetTo(vT);
		// Arrow points vPP1D
		vDimDir = vDimDir1;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP1A1 = vPP1D - vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP1A2 = vPP1D - vT;

		vExt *= 0.5;
		vT = vPP2D;
		vT += vExt;
		pDimLine2->cPts[0]->SetTo(vPP2D);
		pDimLine2->cPts[1]->SetTo(vT);
		// Arrow points vPP2D
		vDimDir = vDimDir1;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP2A1 = vPP2D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP2A2 = vPP2D + vT;
	} else if (dDotOut2 < 0) {
		// Also need to add length of text
		dDLen2 += pText->GetLength();
		vExt = vDimDir2;
		vExt *= dDLen2;
		vT = vPP2D;
		vT -= vExt;
		pDimLine1->cPts[0]->SetTo(vPP2D);
		pDimLine1->cPts[1]->SetTo(vT);
		// Arrow points vPP1D
		vDimDir = vDimDir2;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP1A1 = vPP1D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP1A2 = vPP1D + vT;

		vExt *= 0.5;
		vT = vPP1D;
		vT += vExt;
		pDimLine2->cPts[0]->SetTo(vPP1D);
		pDimLine2->cPts[1]->SetTo(vT);
		// Arrow points vPP2D
		vDimDir = vDimDir2;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP2A1 = vPP2D - vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP2A2 = vPP2D - vT;
	} else // insertion point is between leaders
	{
		vT = vPP2D;
		vT += vPP1D;
		vT *= 0.5;
		pDimLine1->cPts[0]->SetTo(vPP1D);
		pDimLine1->cPts[1]->SetTo(vT);
		pDimLine2->cPts[0]->SetTo(vPP2D);
		pDimLine2->cPts[1]->SetTo(vT);
		// Arrow points vPP1D
		vDimDir = vPP2D - vPP1D;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP1A1 = vPP1D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP1A2 = vPP1D + vT;
		// Arrow points vPP2D
		vDimDir = vPP1D - vPP2D;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP2A1 = vPP2D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP2A2 = vPP2D + vT;
	}

	// THE TEXT
	C3dVector vTxtTrans;
	vTxtTrans = inPt;
	vTxtTrans += vOff;
	vTxtTrans -= pText->vInsPt;
	pText->Translate(vTxtTrans);
}

IMPLEMENT_DYNAMIC(DIMV, CObject)

DIMV::DIMV() {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	iType = 3;
}

DIMV::DIMV(C3dVector vPt1,
           C3dVector vPt2,
           C3dVector vInsPt,
           C3dVector vO,
           C3dVector vN,
           C3dVector vD,
           double dDrawingScale,
           double dDScl,
           int iLab) {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	iObjType = 10; // Type Dimension
	iType = 3; // Aligned dimension
	iLabel = iLab;
	iColour = 4;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	pPt1 = nullptr; // 1st dim point
	pPt2 = nullptr; // 2nd dim point or null
	pLeader1 = nullptr;
	pLeader2 = nullptr;
	pDimLine1 = nullptr; // one halve of dim line
	pDimLine2 = nullptr; // other halve
	Text* pText = nullptr;
	pInsPt = nullptr; // Ins Point
	dDrgScl = 1;
	dDrgScl = dDrawingScale;
	dDimScl = dDScl;
	vDInsPt = vInsPt; // Ins Point
	vDPt1 = vPt1; // 1st dim point
	vDPt2 = vPt2; // 2nd dim point or null
	vOrig = vO;
	vNorm = vN;
	vDir = vD;
	Build();
}

void DIMV::Build() {
	// Transform all to DIM plain (for this is workplane)
	C3dMatrix RMat;
	RMat.MakeUnit();
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;
	vZ = vNorm;
	vX = vDir;
	vZ.Normalize();
	vX.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	RMat.SetColVec(1, vX);
	RMat.SetColVec(2, vY);
	RMat.SetColVec(3, vZ);
	RMat.Transpose();
	vPP1 = vDPt1;
	vPP2 = vDPt2;
	vPP1 -= vOrig;
	vPP2 -= vOrig;
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1.z = 0;
	vPP2.z = 0;
	RMat.Transpose();
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1 += vOrig;
	vPP2 += vOrig;

	vPP1D = vPP1;
	vPP2D = vPP2;
	;
	vDX = vY;
	// vDX.Set(0, 1, 0); //Vertical
	C3dVector vDDD;
	vDDD = vPP2D - vPP1D;
	dDIM = abs(vDDD.Dot(vDX));
	dDist = dDIM / dDrgScl;
	// dDist = vPP1D.Dist(vPP2D) / dDrgScl;
	char buff[200];
	if (!bTextOverRide) {
		sprintf_s(buff, "%.*f", gDIM_PREC, dDist);
		sText = buff;
	}
	vDY = vNorm.Cross(vDX);
	vDY.Normalize();
	pPt1 = new CvPt_Object();
	pPt1->Create(vDPt1, 1, -1, 0, 0, 11, nullptr);
	pPt2 = new CvPt_Object();
	pPt2->Create(vDPt2, 1, -1, 0, 0, 11, nullptr);
	pInsPt = new CvPt_Object();
	pInsPt->Create(vDInsPt, 1, -1, 0, 0, 11, nullptr);
	// First Leader Line
	pLeader1 = new NLine();
	pLeader1->Create(vPP1, vDInsPt, -1, this);
	pLeader1->iColour = iColour;
	pLeader1->iLnThk = 2;
	pLeader2 = new NLine();
	pLeader2->Create(vPP2, vDInsPt, -1, this);
	pLeader2->iColour = iColour;
	pLeader2->iLnThk = 2;
	NLine* pL;
	pL = new NLine();
	pL->Create(vPP1, vPP2, -1, this);
	pL->iColour = iColour;
	pDimLine1 = pL;
	pL = new NLine();
	pL->Create(vPP1, vPP2, -1, this);
	pL->iColour = iColour;
	pDimLine2 = pL;
	// Text insertion point - need to lift off the dim line slightly
	CString sT;
	sT = sTextPre + sText + sTextPost;
	pText = new Text(vDInsPt, vNorm, vDX, -1, sT, dDimScl, this);
	pText->iColour = iColour;
	C3dMatrix mWP;
	// The call to DragUpdate should probably be called build
	DragUpdate(vDInsPt, mWP);
}

void DIMV::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	vDInsPt = inPt;
	C3dVector vP1toIns, vP2toIns, vT, vOff, vLOff;
	double dExtY = 0;
	vP1toIns = inPt;
	vP1toIns -= vPP1;
	dExtY = vP1toIns.Dot(vDY);
	vPP1D = vPP1;
	vPP1D += vDY * dExtY;
	vP2toIns = inPt;
	vP2toIns -= vPP2;
	dExtY = vP2toIns.Dot(vDY);
	vPP2D = vPP2;
	vPP2D += vDY * dExtY;
	// vPP2D.x = vPP1D.x;  //The only change from horizontal
	vOff = vDY * dDimScl * 0.25; // Text Offset
	vLOff = (vPP1D - vPP1);
	vLOff.Normalize();
	vLOff *= dDimScl * 0.5; // Leader offset
	pInsPt->SetTo(inPt);
	// THE LEADERS
	pLeader1->cPts[0]->SetTo(vPP1 + vLOff);
	pLeader2->cPts[0]->SetTo(vPP2 + vLOff);
	pLeader1->cPts[1]->SetTo(vPP1D + vLOff);
	pLeader2->cPts[1]->SetTo(vPP2D + vLOff);

	// THE DIMENSION LINES
	// need to see if lines are in or out and calc end points
	// and arrow heads
	C3dVector vDimDir1;
	C3dVector vInPtDir1;
	C3dVector vDimDir2;
	C3dVector vInPtDir2;
	C3dVector vDimDir;
	C3dVector vExt;
	C3dVector vYPOff;
	double dDotOut1;
	double dDotOut2;
	double dDLen1;
	double dDLen2;
	// check to see if insersion point is outside on vPP1D side
	vDimDir1 = (vPP2D - vPP1D);
	vDimDir1.Normalize();
	vInPtDir1 = (inPt - vPP1D);
	dDLen1 = vInPtDir1.Mag();
	vInPtDir1.Normalize();
	dDotOut1 = vDimDir1.Dot(vInPtDir1);
	// check to see if insersion point is outside on vPP2D side
	vDimDir2 = (vPP1D - vPP2D);
	vDimDir2.Normalize();
	vInPtDir2 = (inPt - vPP2D);
	dDLen2 = vInPtDir2.Mag();
	vInPtDir2.Normalize();
	dDotOut2 = vDimDir2.Dot(vInPtDir2);
	if (dDotOut1 < 0) {
		vExt = vDimDir1;
		vExt *= dDLen1;
		vT = vPP1D;
		vT -= vExt;
		pDimLine1->cPts[0]->SetTo(vPP1D);
		pDimLine1->cPts[1]->SetTo(vT);
		// Arrow points vPP1D
		vDimDir = vDimDir1;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP1A1 = vPP1D - vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP1A2 = vPP1D - vT;

		vExt *= 0.5;
		vT = vPP2D;
		vT += vExt;
		pDimLine2->cPts[0]->SetTo(vPP2D);
		pDimLine2->cPts[1]->SetTo(vT);
		// Arrow points vPP2D
		vDimDir = vDimDir1;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP2A1 = vPP2D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP2A2 = vPP2D + vT;
	} else if (dDotOut2 < 0) {
		// Also need to add length of text
		dDLen2 += pText->GetLength();
		vExt = vDimDir2;
		vExt *= dDLen2;
		vT = vPP2D;
		vT -= vExt;
		pDimLine1->cPts[0]->SetTo(vPP2D);
		pDimLine1->cPts[1]->SetTo(vT);
		// Arrow points vPP1D
		vDimDir = vDimDir2;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP1A1 = vPP1D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP1A2 = vPP1D + vT;

		vExt *= 0.5;
		vT = vPP1D;
		vT += vExt;
		pDimLine2->cPts[0]->SetTo(vPP1D);
		pDimLine2->cPts[1]->SetTo(vT);
		// Arrow points vPP2D
		vDimDir = vDimDir2;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP2A1 = vPP2D - vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP2A2 = vPP2D - vT;
	} else // insertion point is between leaders
	{
		vT = vPP2D;
		vT += vPP1D;
		vT *= 0.5;
		pDimLine1->cPts[0]->SetTo(vPP1D);
		pDimLine1->cPts[1]->SetTo(vT);
		pDimLine2->cPts[0]->SetTo(vPP2D);
		pDimLine2->cPts[1]->SetTo(vT);
		// Arrow points vPP1D
		vDimDir = vPP2D - vPP1D;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP1A1 = vPP1D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP1A2 = vPP1D + vT;
		// Arrow points vPP2D
		vDimDir = vPP1D - vPP2D;
		vDimDir.Normalize(); //
		vDimDir *= 1.5;
		vYPOff = vDY;
		vYPOff *= 0.4;
		vT = vDimDir + vYPOff;
		vT *= dDimScl;
		vPP2A1 = vPP2D + vT;
		vT = vDimDir - vYPOff;
		vT *= dDimScl;
		vPP2A2 = vPP2D + vT;
	}

	// THE TEXT
	C3dVector vTxtTrans;
	vTxtTrans = inPt;
	vTxtTrans += vOff;
	vTxtTrans -= pText->vInsPt;
	pText->Translate(vTxtTrans);
}

IMPLEMENT_DYNAMIC(DIML, CObject)

DIML::DIML() {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	// 5 Dia
	// 6 Ang
	// 7 Leader
	iType = 7;
}

DIML::DIML(CString sLText,
           C3dVector vPt1,
           C3dVector vPt2,
           C3dVector vInsPt,
           C3dVector vO,
           C3dVector vN,
           C3dVector vD,
           double dDScl,
           int iLab) {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	// 5 Dia
	// 6 Ang
	// 7 Leader
	iObjType = 10; // Type Dimension
	iType = 7; // Aligned dimension
	iLabel = iLab;
	iColour = 4;
	sTextPre = "";
	sText = sLText;
	sTextPost = "";
	;
	pPt1 = nullptr; // 1st dim point
	pPt2 = nullptr; // 2nd dim point or null
	pLeader1 = nullptr;
	pLeader2 = nullptr;
	pDimLine1 = nullptr; // one halve of dim line
	pDimLine2 = nullptr; // other halve
	Text* pText = nullptr;
	pInsPt = nullptr; // Ins Point
	dDrgScl = 1;
	dDimScl = dDScl;
	vDInsPt = vInsPt; // Ins Point
	vDPt1 = vPt1; // 1st dim point
	vDPt2 = vPt2; // 2nd dim point or null
	vOrig = vO;
	vNorm = vN;
	vDir = vD;
	Build();
}

void DIML::Build() {
	// Transform all to DIM plain (for this is workplane)
	C3dMatrix RMat;
	RMat.MakeUnit();
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;
	vZ = vNorm;
	vX = vDir;
	vZ.Normalize();
	vX.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	RMat.SetColVec(1, vX);
	RMat.SetColVec(2, vY);
	RMat.SetColVec(3, vZ);
	RMat.Transpose();
	vPP1 = vDPt1;
	vPP2 = vDPt2;
	vPP1 -= vOrig;
	vPP2 -= vOrig;
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1.z = 0;
	vPP2.z = 0;
	RMat.Transpose();
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1 += vOrig;
	vPP2 += vOrig;

	vPP1D = vPP1;
	vPP2D = vPP2;
	;
	vDX.Set(1, 0, 0); // Horizontal

	vDY = vNorm.Cross(vDX);
	vDY.Normalize();
	pPt1 = new CvPt_Object();
	pPt1->Create(vDPt1, 1, -1, 0, 0, 11, nullptr);
	pPt2 = new CvPt_Object();
	pPt2->Create(vDPt2, 1, -1, 0, 0, 11, nullptr);
	pInsPt = new CvPt_Object();
	pInsPt->Create(vDInsPt, 1, -1, 0, 0, 11, nullptr);
	// First Leader Line
	NLine* pL;
	pL = new NLine();
	pL->Create(vPP1, vDInsPt, -1, this);
	pL->iColour = iColour;
	pDimLine1 = pL;
	pLeader1 = new NLine();
	pLeader1->Create(vDInsPt, vDInsPt, -1, this);
	pLeader1->iColour = iColour;
	pLeader1->iLnThk = 2;
	// Text insertion point - need to lift off the dim line slightly
	CString sT;
	sT = sTextPre + sText + sTextPost;
	pText = new Text(vDInsPt, vNorm, vDX, -1, sT, dDimScl, this);
	pText->iColour = iColour;
	C3dMatrix mWP;
	// The call to DragUpdate should probably be called build
	DragUpdate(vDInsPt, mWP);
}

void DIML::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	vDInsPt = inPt;
	C3dVector vP1toIns, vT, vOff, vLOff;
	vOff = vDY * dDimScl * 0.25; // Text Offset
	vLOff = (vPP1D - vPP1);
	vLOff.Normalize();
	vLOff *= dDimScl * 0.5; // Leader offset

	pInsPt->SetTo(inPt);
	// THE LEADERS
	pDimLine1->cPts[0]->SetTo(vPP1);
	pDimLine1->cPts[1]->SetTo(vDInsPt);
	pLeader1->cPts[0]->SetTo(vDInsPt);
	vT = vDInsPt;
	vT.x += pText->GetLength();
	;
	pLeader1->cPts[1]->SetTo(vT);
	// dDLen2 += pText->GetLength();
	// THE TEXT
	C3dVector vTxtTrans;
	vTxtTrans = inPt;
	vTxtTrans += vOff;
	vTxtTrans -= pText->vInsPt;
	pText->Translate(vTxtTrans);

	C3dVector vDimDir, vYPOff, vDArr;
	// Arrow points vPP1D
	vDimDir = vDInsPt - vPP1D;
	vDimDir.Normalize(); //
	vDArr = vDimDir.Cross(vNorm);
	vDArr.Normalize();
	vDimDir *= 1.5;
	vYPOff = vDArr;
	vYPOff *= 0.4;
	vT = vDimDir + vYPOff;
	vT *= dDimScl;
	vPP1A1 = vPP1D + vT;
	vT = vDimDir - vYPOff;
	vT *= dDimScl;
	vPP1A2 = vPP1D + vT;
}

void DIML::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	pDimLine1->OglDrawW(iDspFlgs, dS1, dS2);
	pLeader1->OglDrawW(iDspFlgs, dS1, dS2);
	pText->OglDrawW(iDspFlgs, dS1, dS2);
	glColor3fv(cols[iColour]);
	// Dim attachment points
	if ((iDspFlgs & DSP_CURVES) > 0) {
		pPt1->OglDrawW(iDspFlgs, dS1, dS2);
		pInsPt->OglDrawW(iDspFlgs, dS1, dS2);
		// Filled Arrow Heads
		// Dim attachment points
		glPointSize(5);
		glBegin(GL_POINTS);
		glVertex3f(vPP1.x, vPP1.y, vPP1.z);
		glEnd();
		// Filled Arrow Heads
		glBegin(GL_POLYGON);
		glVertex3f(vPP1D.x, vPP1D.y, vPP1D.z);
		glVertex3f(vPP1A1.x, vPP1A1.y, vPP1A1.z);
		glVertex3f(vPP1A2.x, vPP1A2.y, vPP1A2.z);
		glEnd();
	}
}

void DIML::Colour(int iCol) {
	this->iColour = iCol;
	pInsPt->iColour = iCol;
	pDimLine1->iColour = iCol;
	pLeader1->iColour = iCol;
	pText->iColour = iCol;
}

IMPLEMENT_DYNAMIC(DIMR, CObject)

DIMR::DIMR() {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	// 5 Dia
	// 6 Ang
	// 7 Leader
	iType = 4;
}

DIMR::DIMR(double dRad,
           C3dVector vPt1,
           C3dVector vPt2,
           C3dVector vInsPt,
           C3dVector vO,
           C3dVector vN,
           C3dVector vD,
           double dDrawingScale,
           double dDScl,
           int iLab) {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	// 5 Dia
	// 6 Ang
	// 7 Leader
	iObjType = 10; // Type Dimension
	iType = 4; // Aligned dimension
	iLabel = iLab;
	iColour = 4;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	pPt1 = nullptr; // 1st dim point
	pPt2 = nullptr; // 2nd dim point or null
	pLeader1 = nullptr;
	pLeader2 = nullptr;
	pDimLine1 = nullptr; // one halve of dim line
	pDimLine2 = nullptr; // other halve
	Text* pText = nullptr;
	pInsPt = nullptr; // Ins Point
	dDIM = dRad;
	dDrgScl = dDrawingScale;
	dDimScl = dDScl;
	iDimOpt = 0;
	vDInsPt = vInsPt; // Ins Point
	vDPt1 = vPt1; // 1st dim point
	vDPt2 = vPt2; // 2nd dim point or null
	vOrig = vO;
	vNorm = vN;
	vDir = vD;
	Build();
}

void DIMR::Build() {
	// Transform all to DIM plain (for this is workplane)
	C3dMatrix RMat;
	RMat.MakeUnit();
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;
	vZ = vNorm;
	vX = vDir;
	vZ.Normalize();
	vX.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	RMat.SetColVec(1, vX);
	RMat.SetColVec(2, vY);
	RMat.SetColVec(3, vZ);
	RMat.Transpose();
	vPP1 = vDPt1;
	vPP2 = vDPt2;
	vPP1 -= vOrig;
	vPP2 -= vOrig;
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1.z = 0;
	vPP2.z = 0;
	RMat.Transpose();
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1 += vOrig;
	vPP2 += vOrig;

	vPP1D = vPP1;
	vPP2D = vPP2;
	;
	vDX = vX; // Horizontal

	dDist = dDIM / dDrgScl;
	// dDist = vPP1D.Dist(vPP2D) / dDrgScl;
	char buff[200];
	if (!bTextOverRide) {
		sprintf_s(buff, "%.*f", gDIM_PREC, dDist);
		sText = buff;
	}

	vDY = vNorm.Cross(vDX);
	vDY.Normalize();
	pPt1 = new CvPt_Object();
	pPt1->Create(vDPt1, 1, -1, 0, 0, 11, nullptr);
	pPt2 = new CvPt_Object();
	pPt2->Create(vDPt2, 1, -1, 0, 0, 11, nullptr);
	pInsPt = new CvPt_Object();
	pInsPt->Create(vDInsPt, 1, -1, 0, 0, 11, nullptr);
	// First Leader Line
	NLine* pL;
	pL = new NLine();
	pL->Create(vPP1, vDInsPt, -1, this);
	pL->iColour = iColour;
	pDimLine1 = pL;
	pLeader1 = new NLine();
	pLeader1->Create(vPP1, vDInsPt, -1, this);
	pLeader1->iColour = iColour;
	pLeader1->iLnThk = 2;
	// Text insertion point - need to lift off the dim line slightly
	CString sT;
	sTextPost = 'R';
	sT = sTextPre + sText + sTextPost;
	pText = new Text(vDInsPt, vNorm, vDX, -1, sT, dDimScl, this);
	pText->iColour = iColour;
	C3dMatrix mWP;
	// The call to DragUpdate should probably be called build
	DragUpdate(vDInsPt, mWP);
}

void DIMR::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	BOOL bOutSide = TRUE;
	vDInsPt = inPt;
	C3dVector vP1toIns, vT, vOff, vLOff, vTD, vTD2, vDArr;
	// vPP1, vDInsPt
	vP1toIns = vDInsPt - vPP1;
	double ddddd = vP1toIns.Mag();
	if (vP1toIns.Mag() > dDIM)
		bOutSide = TRUE;
	else
		bOutSide = FALSE;
	vP1toIns.Normalize();
	vTD = vP1toIns;
	vDArr = vTD.Cross(vNorm);
	vDArr.Normalize();
	vOff = -vDArr * dDimScl * 0.25; // Text Offset
	vTD2 = vP1toIns;
	vP1toIns *= dDIM; // point on circu
	vP1toIns += vPP1;
	pInsPt->SetTo(inPt);
	// THE LEADERS	pDimLine1->cPts[0]->SetTo(vPP1);
	vPP1D = vP1toIns;
	pDimLine1->cPts[0]->SetTo(vP1toIns);
	vTD2 *= pText->GetLength();
	if (bOutSide) {
		pLeader1->cPts[1]->SetTo(vDInsPt);
		pDimLine1->cPts[1]->SetTo(vDInsPt + vTD2);
	} else {
		pLeader1->cPts[1]->SetTo(vPP1);
		pDimLine1->cPts[1]->SetTo(vPP1);
	}
	// THE TEXT
	C3dVector vRevText;
	C3dVector vTxtTrans;
	vRevText = vTD;
	vTxtTrans = inPt;
	if (vRevText.Dot(vDX) < 0) {
		vRevText *= -1;
		vTxtTrans += vTD2;
		vTxtTrans -= vOff;
	} else {
		vTxtTrans += vOff;
	}

	vTxtTrans -= pText->vInsPt;
	pText->Translate(vTxtTrans);
	pText->vDir = vRevText;
	pText->BuildText();

	//**************************************************
	// Arrow points vPP1D
	C3dVector vDimDir, vYPOff;
	vDimDir = vTD;
	if (!bOutSide)
		vDimDir *= -1;

	vDimDir *= 1.5;
	vYPOff = vDArr;
	vYPOff *= 0.4;
	vT = vDimDir + vYPOff;
	vT *= dDimScl;
	vPP1A1 = vP1toIns + vT;
	vT = vDimDir - vYPOff;
	vT *= dDimScl;
	vPP1A2 = vP1toIns + vT;
}

void DIMR::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	pDimLine1->OglDrawW(iDspFlgs, dS1, dS2);
	if (iDimOpt == 0)
		pLeader1->OglDrawW(iDspFlgs, dS1, dS2);
	pText->OglDrawW(iDspFlgs, dS1, dS2);
	glColor3fv(cols[iColour]);
	if ((iDspFlgs & DSP_CURVES) > 0) {
		// pPt1->OglDrawW(iDspFlgs, dS1, dS2);
		// pPt2->OglDrawW(iDspFlgs, dS1, dS2);
		pInsPt->OglDrawW(iDspFlgs, dS1, dS2);
		glBegin(GL_POLYGON);
		glVertex3f(vPP1D.x, vPP1D.y, vPP1D.z);
		glVertex3f(vPP1A1.x, vPP1A1.y, vPP1A1.z);
		glVertex3f(vPP1A2.x, vPP1A2.y, vPP1A2.z);
		glEnd();
	}
}

void DIMR::Colour(int iCol) {
	this->iColour = iCol;
	pInsPt->iColour = iCol;
	pDimLine1->iColour = iCol;
	pLeader1->iColour = iCol;
	pText->iColour = iCol;
}

IMPLEMENT_DYNAMIC(DIMD, CObject)

DIMD::DIMD() {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	// 5 Dia
	// 6 Ang
	// 7 Leader
	iType = 5;
}

DIMD::DIMD(double dRad,
           C3dVector vPt1,
           C3dVector vPt2,
           C3dVector vInsPt,
           C3dVector vO,
           C3dVector vN,
           C3dVector vD,
           double dDrawingScale,
           double dDScl,
           int iLab) {
	// 0 N/A
	// 1 Aligned Linear
	// 2 Horizontal Linear
	// 3 Vertical Linear
	// 4 Rad
	// 5 Dia
	// 6 Ang
	// 7 Leader
	iObjType = 10; // Type Dimension
	iType = 5; // Aligned dimension
	iLabel = iLab;
	iColour = 4;
	sTextPre = "";
	sText = "";
	sTextPost = "";
	;
	pPt1 = nullptr; // 1st dim point
	pPt2 = nullptr; // 2nd dim point or null
	pLeader1 = nullptr;
	pLeader2 = nullptr;
	pDimLine1 = nullptr; // one halve of dim line
	pDimLine2 = nullptr; // other halve
	Text* pText = nullptr;
	pInsPt = nullptr; // Ins Point
	dDIM = dRad;
	dDrgScl = dDrawingScale;
	dDimScl = dDScl;
	iDimOpt = 0;
	vDInsPt = vInsPt; // Ins Point
	vDPt1 = vPt1; // 1st dim point
	vDPt2 = vPt2; // 2nd dim point or null
	vOrig = vO;
	vNorm = vN;
	vDir = vD;
	Build();
}

void DIMD::Build() {
	// dDIM = vPP1.Dist(vPP2);
	// dDist = dDIM / dDrgScl;

	// Transform all to DIM plain (for this is workplane)
	C3dMatrix RMat;
	RMat.MakeUnit();
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;
	vZ = vNorm;
	vX = vDir;
	vZ.Normalize();
	vX.Normalize();
	vY = vZ.Cross(vX);
	vY.Normalize();
	RMat.SetColVec(1, vX);
	RMat.SetColVec(2, vY);
	RMat.SetColVec(3, vZ);
	RMat.Transpose();
	vPP1 = vDPt1;
	vPP2 = vDPt2;
	vPP1 -= vOrig;
	vPP2 -= vOrig;
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1.z = 0;
	vPP2.z = 0;
	RMat.Transpose();
	vPP1 = RMat * vPP1;
	vPP2 = RMat * vPP2;
	vPP1 += vOrig;
	vPP2 += vOrig;

	vPP1D = vPP1;
	vPP2D = vPP2;
	;
	vDX = vX; // Horizontal

	dDist = 2 * dDIM / dDrgScl;
	// dDist = vPP1D.Dist(vPP2D) / dDrgScl;
	char buff[200];
	if (!bTextOverRide) {
		sprintf_s(buff, "%.*f", gDIM_PREC, dDist);
		sText = buff;
	}

	vDY = vNorm.Cross(vDX);
	vDY.Normalize();
	pPt1 = new CvPt_Object();
	pPt1->Create(vDPt1, 1, -1, 0, 0, 11, nullptr);
	pPt2 = new CvPt_Object();
	pPt2->Create(vDPt2, 1, -1, 0, 0, 11, nullptr);
	pInsPt = new CvPt_Object();
	pInsPt->Create(vDInsPt, 1, -1, 0, 0, 11, nullptr);
	// First Dim Line
	NLine* pL;
	pL = new NLine();
	pL->Create(vPP1, vDInsPt, -1, this);
	pL->iColour = iColour;
	pDimLine1 = pL;
	// Second Dim Line
	pL = new NLine();
	pL->Create(vPP1, vPP1, -1, this);
	pL->iColour = iColour;
	pDimLine2 = pL;
	// Circle crossing leader line
	pLeader1 = new NLine();
	pLeader1->Create(vPP1, vDInsPt, -1, this);
	pLeader1->iColour = iColour;
	pLeader1->iLnThk = 2;
	// Text insertion point - need to lift off the dim line slightly
	CString sT = sText;
	char newCharacter = 1; // Assuming the character 8960 is a TCHAR
	sT.Insert(0, newCharacter);
	sT = sTextPre + sT + sTextPost;
	pText = new Text(vDInsPt, vNorm, vDX, -1, sT, dDimScl, this);
	pText->iColour = iColour;
	C3dMatrix mWP;
	// The call to DragUpdate should probably be called build
	DragUpdate(vDInsPt, mWP);
}

void DIMD::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	BOOL bOutSide = TRUE;
	vDInsPt = inPt;
	C3dVector vP1toIns, vP1toIns2, vT, vOff, vLOff, vTD, vTD2, vDArr;
	// vPP1, vDInsPt
	vP1toIns = vDInsPt - vPP1;
	double ddddd = vP1toIns.Mag();
	if (vP1toIns.Mag() > dDIM)
		bOutSide = TRUE;
	else
		bOutSide = FALSE;
	vP1toIns.Normalize();
	vP1toIns2 = vP1toIns;
	vTD = vP1toIns;
	vDArr = vTD.Cross(vNorm);
	vDArr.Normalize();
	vOff = -vDArr * dDimScl * 0.25; // Text Offset
	vTD2 = vP1toIns;
	vP1toIns *= dDIM; // point on circu
	vP1toIns += vPP1;
	vP1toIns2 *= -dDIM;
	vP1toIns2 += vPP1;
	pInsPt->SetTo(inPt);
	// THE LEADERS	pDimLine1->cPts[0]->SetTo(vPP1);
	vPP1D = vP1toIns;
	vPP2D = vP1toIns2;
	pDimLine1->cPts[0]->SetTo(vPP1D);
	pDimLine2->cPts[0]->SetTo(vPP2D);
	pLeader1->cPts[0]->SetTo(vPP1D);
	vTD2 *= pText->GetLength();
	if (bOutSide) {
		pLeader1->cPts[1]->SetTo(vPP2D);
		pDimLine1->cPts[1]->SetTo(vDInsPt + vTD2);
		pDimLine2->cPts[1]->SetTo(vPP2D - vTD2);
	} else {
		pLeader1->cPts[0]->SetTo(vPP1);
		pLeader1->cPts[1]->SetTo(vPP1);
		pDimLine1->cPts[1]->SetTo(vPP1);
		pDimLine2->cPts[1]->SetTo(vPP1);
	}
	// THE TEXT
	C3dVector vRevText;
	C3dVector vTxtTrans;
	vRevText = vTD;
	vTxtTrans = inPt;
	if (vRevText.Dot(vDX) < 0) {
		vRevText *= -1;
		vTxtTrans += vTD2;
		vTxtTrans -= vOff;
	} else {
		vTxtTrans += vOff;
	}

	vTxtTrans -= pText->vInsPt;
	pText->Translate(vTxtTrans);
	pText->vDir = vRevText;
	pText->BuildText();

	//**************************************************
	// Arrow points vPP1D
	C3dVector vDimDir, vYPOff;
	vDimDir = vTD;
	if (!bOutSide)
		vDimDir *= -1;

	vDimDir *= 1.5;
	vYPOff = vDArr;
	vYPOff *= 0.4;
	vT = vDimDir + vYPOff;
	vT *= dDimScl;
	vPP1A1 = vPP1D + vT;
	vPP2A1 = vPP2D - vT;
	vT = vDimDir - vYPOff;
	vT *= dDimScl;
	vPP1A2 = vPP1D + vT;
	vPP2A2 = vPP2D - vT;
}

void DIMD::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	// pPt1->OglDrawW(iDspFlgs, dS1, dS2);
	// pPt2->OglDrawW(iDspFlgs, dS1, dS2);
	pDimLine1->OglDrawW(iDspFlgs, dS1, dS2);
	pDimLine2->OglDrawW(iDspFlgs, dS1, dS2);
	if (iDimOpt == 0)
		pLeader1->OglDrawW(iDspFlgs, dS1, dS2);
	pText->OglDrawW(iDspFlgs, dS1, dS2);
	if ((iDspFlgs & DSP_CURVES) > 0) {
		pInsPt->OglDrawW(iDspFlgs, dS1, dS2);
		glColor3fv(cols[iColour]);
		glBegin(GL_POLYGON);
		glVertex3f(vPP1D.x, vPP1D.y, vPP1D.z);
		glVertex3f(vPP1A1.x, vPP1A1.y, vPP1A1.z);
		glVertex3f(vPP1A2.x, vPP1A2.y, vPP1A2.z);
		glEnd();

		glBegin(GL_POLYGON);
		glVertex3f(vPP2D.x, vPP2D.y, vPP2D.z);
		glVertex3f(vPP2A1.x, vPP2A1.y, vPP2A1.z);
		glVertex3f(vPP2A2.x, vPP2A2.y, vPP2A2.z);
		glEnd();
	}
}

void DIMD::Colour(int iCol) {
	this->iColour = iCol;
	pInsPt->iColour = iCol;
	pDimLine1->iColour = iCol;
	pLeader1->iColour = iCol;
	pText->iColour = iCol;
}

// 26/09/2016
// symbol class used for compounds of lines
//  fonts, hatches etc

IMPLEMENT_DYNAMIC(Symbol, CObject)

Symbol::Symbol() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 5;
	iLabel = -1;
	iColour = 2;
	pParent = NULL;
	pL = NULL;
	vCent = NULL; // Centroid
	inPt = NULL;
	iSegs = 0;
}

Symbol::~Symbol() {
	if (inPt != NULL)
		delete (inPt);
	if (vCent != NULL)
		delete (vCent);

	Link* pNext;
	while (pL != NULL) {
		pNext = pL->pNext;
		delete (pL);
		pL = pNext;
	}
}

void Symbol::Create(int iLab, C3dVector inP, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 5;
	iLabel = iLab;
	iColour = 2;
	pParent = Parrent;
	if (inPt != NULL) {
		delete (inPt);
	}
	inPt = new CvPt_Object;
	inPt->Create(inP, 0, -1, 0, 0, 1, this);
	pL = NULL;
	iSegs = 0;
}

void Symbol::addSeg(C3dVector pt1, C3dVector pt2) {
	Link* pSeg = new Link(pt1.x, pt1.y, pt1.z,
	                      pt2.x, pt2.y, pt2.z);

	pSeg->pNext = pL;
	pL = pSeg;
	iSegs++;
}

void Symbol::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void Symbol::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[80];
	if ((iDspFlgs & DSP_CURVES) > 0) {
		Selectable = 1;
		Link* pCL;
		if (this->pParent != NULL)
			glColor3fv(cols[pParent->iColour]);
		else
			glColor3fv(cols[iColour]);
		C3dVector vPt;
		C3dVector vPt2;
		glLineWidth(gTXT_SIZE);
		glBegin(GL_LINES);
		pCL = pL;
		while (pCL != NULL) {
			glVertex3f((float) pCL->p1->Pt_Point->x, (float) pCL->p1->Pt_Point->y, (float) pCL->p1->Pt_Point->z);
			glVertex3f((float) pCL->p2->Pt_Point->x, (float) pCL->p2->Pt_Point->y, (float) pCL->p2->Pt_Point->z);
			pCL = pCL->pNext;
		}
		glEnd();
		glDisable(GL_LINE_STIPPLE);
		C3dVector vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "C%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
	} else {
		Selectable = 0;
	}
}

void Symbol::Draw(CDC* pDC, int iDrawmode) {
	Link* pCL;
	pCL = pL;
	C3dVector p1;
	C3dVector p2;
	if (inPt != NULL)
		inPt->Draw(pDC, iDrawmode);
	if (vCent != NULL)
		vCent->Draw(pDC, iDrawmode);
	while (pCL != NULL) {
		// Points at end of segement
		pDC->MoveTo((int) pCL->p1->DSP_Point->x, (int) pCL->p1->DSP_Point->y);
		pDC->LineTo((int) pCL->p2->DSP_Point->x, (int) pCL->p2->DSP_Point->y);
		pCL = pCL->pNext;
	}
}

void Symbol::CalculateMetrics() {
	// Calculate dimensions of symbol
	Link* pCL = pL;
	double dMinX = 0;
	double dMinY = 0;
	double dMaxX = 0;
	double dMaxY = 0;
	vCent = new CvPt_Object();

	w = 0;
	h = 0;
	if (pCL != NULL) {
		dMinX = pCL->p1->Pt_Point->x;
		dMaxX = dMinX;
		dMinY = pCL->p1->Pt_Point->y;
		dMaxY = dMinY;
		while (pCL != NULL) {
			if (pCL->p1->Pt_Point->x < dMinX)
				dMinX = pCL->p1->Pt_Point->x;
			if (pCL->p2->Pt_Point->x < dMinX)
				dMinX = pCL->p2->Pt_Point->x;
			if (pCL->p1->Pt_Point->x > dMaxX)
				dMaxX = pCL->p1->Pt_Point->x;
			if (pCL->p2->Pt_Point->x > dMaxX)
				dMaxX = pCL->p2->Pt_Point->x;

			if (pCL->p1->Pt_Point->y < dMinY)
				dMinY = pCL->p1->Pt_Point->y;
			if (pCL->p2->Pt_Point->y < dMinY)
				dMinY = pCL->p2->Pt_Point->y;
			if (pCL->p1->Pt_Point->y > dMaxY)
				dMaxY = pCL->p1->Pt_Point->y;
			if (pCL->p2->Pt_Point->y > dMaxY)
				dMaxY = pCL->p2->Pt_Point->y;
			pCL = pCL->pNext;
		}
	}
	w = dMaxX - dMinX;
	h = dMaxY - dMinY;
	vCent->Pt_Point->x = (w) / 2;
	vCent->Pt_Point->y = (h) / 2;
	vCent->Pt_Point->z = 0;
	// Bring to Origin
	inPt->Pt_Point->Set(0, 0, 0);
	pCL = pL;
	while (pCL != NULL) {
		pCL->p1->Pt_Point->x -= dMinX;
		pCL->p2->Pt_Point->x -= dMinX;
		// pCL->p1->Pt_Point->y -= dMinY;
		// pCL->p2->Pt_Point->y -= dMinY;
		pCL = pCL->pNext;
	}
}

C3dVector Symbol::MinPt(C3dVector inPt) {
	return (GetCoords());
}

void Symbol::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	Link* pCL = pL;
	G_Object::SetToScr(pModMat, pScrTran);
	vCent->SetToScr(pModMat, pScrTran);
	inPt->SetToScr(pModMat, pScrTran);
	while (pCL != NULL) // Evaluate  each link coord to screen pixel coords
	{
		pCL->p1->SetToScr(pModMat, pScrTran);
		pCL->p2->SetToScr(pModMat, pScrTran);
		pCL = pCL->pNext;
	}
}

G_Object* Symbol::Copy(G_Object* Parrent) {
	Symbol* nSym = new Symbol();
	C3dVector p1;
	C3dVector p2;
	Link* pCL = pL;
	nSym->Drawn = Drawn;
	nSym->Selectable = Selectable;
	nSym->Visable = Visable;
	nSym->iColour = iColour;
	nSym->iObjType = iObjType;
	nSym->iLabel = iLabel;

	nSym->w = w;
	nSym->h = h;

	nSym->pL = NULL;
	nSym->inPt = (CvPt_Object*) inPt->Copy(NULL);
	nSym->vCent = (CvPt_Object*) vCent->Copy(NULL);

	while (pCL != NULL) // Evaluate  each link coord to screen pixel coords
	{
		p1.x = pCL->p1->Pt_Point->x;
		p1.y = pCL->p1->Pt_Point->y;
		p1.z = pCL->p1->Pt_Point->z;

		p2.x = pCL->p2->Pt_Point->x;
		p2.y = pCL->p2->Pt_Point->y;
		p2.z = pCL->p2->Pt_Point->z;
		nSym->addSeg(p1, p2);
		pCL = pCL->pNext;
	}
	return (nSym);
}

void Symbol::HighLight(CDC* pDC) {
	this->Draw(pDC, 4);
}

G_ObjectD Symbol::SelDist(CPoint InPT, Filter FIL) {
	return (G_Object::SelDist(InPT, FIL));
}

void Symbol::Info() {
	Link* pCL = pL;
	char S1[80];
	sprintf_s(S1, "SYM %8i", iLabel);
	outtext1(S1);
	sprintf_s(S1, "NSEGS %8i W %s H %s", iSegs, float8NAS(w), float8NAS(h));
	outtext1(S1);
	while (pCL != NULL) // Evaluate  each link coord to screen pixel coords
	{
		sprintf_s(S1, "%s %s %s", float8NAS(pCL->p1->Pt_Point->x),
		          float8NAS(pCL->p1->Pt_Point->y),
		          float8NAS(pCL->p1->Pt_Point->z));
		outtext1(S1);
		sprintf_s(S1, "%s %s %s", float8NAS(pCL->p2->Pt_Point->x),
		          float8NAS(pCL->p2->Pt_Point->y),
		          float8NAS(pCL->p2->Pt_Point->z));
		outtext1(S1);
		pCL = pCL->pNext;
	}
}

C3dVector Symbol::GetCoords() {
	C3dVector vRet;
	vRet.Set(vCent->Pt_Point->x, vCent->Pt_Point->y, vCent->Pt_Point->z);
	return (vRet);
}

C3dVector Symbol::Get_Centroid() {
	return (GetCoords());
}

void Symbol::ExportDXF(FILE* pFile) {
	int iLay = 0;
	if (this->pParent != nullptr)
		iLay = this->pParent->iFile;
	if (iLay < 0)
		iLay = 0;

	Link* pCL = pL;
	while (pCL != NULL) {
		pCL->ExportDXF(pFile, iLay);
		pCL = pCL->pNext;
	}
}

//*****************************************************************************************
// SYMBOLS FUNCTIONS
// 14/07/2020
//*****************************************************************************************
void Symbol::Translate(C3dVector vIn) {
	Link* pCL = pL;
	vCent->Move(vIn);
	inPt->Move(vIn);
	pCL = pL;
	while (pCL != NULL) {
		pCL->p1->Move(vIn);
		pCL->p2->Move(vIn);
		pCL = pCL->pNext;
	}
}

void Symbol::Transform(C3dMatrix TMat) {
	Link* pCL = pL;
	vCent->Transform(TMat);
	inPt->Transform(TMat);
	pCL = pL;
	while (pCL != NULL) {
		pCL->p1->Transform(TMat);
		pCL->p2->Transform(TMat);
		pCL = pCL->pNext;
	}
}

void Symbol::Move(C3dVector vM) {
	Link* pCL = pL;
	vCent->Move(vM);
	inPt->Move(vM);
	pCL = pL;
	while (pCL != NULL) {
		pCL->p1->Move(vM);
		pCL->p2->Move(vM);
		pCL = pCL->pNext;
	}
}

void Symbol::Serialize(CArchive& ar, int iV) {
	C3dVector v1;
	C3dVector v2;
	int i;
	int iNo;
	Link* pCL;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		inPt->Serialize(ar, iV);
		vCent->Serialize(ar, iV);
		;
		ar << w;
		ar << h;
		ar << iSegs;
		pCL = pL;
		for (i = 0; i < iSegs; i++) {
			pCL->p1->Pt_Point->Serialize(ar, iV);
			pCL->p2->Pt_Point->Serialize(ar, iV);
			pCL = pCL->pNext;
		}
	} else {
		G_Object::Serialize(ar, iV);
		inPt = new CvPt_Object();
		vCent = new CvPt_Object();
		inPt->Serialize(ar, iV);
		vCent->Serialize(ar, iV);
		;
		ar >> w;
		ar >> h;
		ar >> iNo;
		for (i = 0; i < iNo; i++) {
			v1.Serialize(ar, iV);
			v2.Serialize(ar, iV);
			addSeg(v1, v2);
		}
	}
}

//*****************************************************************************************
// START OF BREP OBJECT DATA STRUCTURE USES
// 10/01/2020
//*****************************************************************************************
IMPLEMENT_DYNAMIC(USE, CObject)

USE::USE() {
	iNo = 0;
	pObj = NULL;
}

BOOL USE::IsIn(G_Object* pUse) {
	int i;
	for (i = 0; i < iNo; i++) {
		if (Use[i] == pUse) {
			return (TRUE);
		}
	}
	return (FALSE);
}

void USE::Add(G_Object* pUse) {
	if (iNo < MAX_USES) {
		Use[iNo] = pUse;
		iNo++;
	} else {
		outtext1("ERROR: Max uses exceeded in class USE. ");
	}
}

void USE::AddEx(G_Object* pUse) {
	if (iNo < MAX_USES) {
		if (!IsIn(pUse)) {
			Use[iNo] = pUse;
			iNo++;
		}
	} else {
		outtext1("ERROR: Max uses exceeded in class USE. ");
	}
}

void USE::Remove(G_Object* pUse) {
	int i;
	for (i = 0; i < iNo; i++) {
		if (Use[i] == pUse) {
			Use[i] = Use[iNo - 1];
			iNo--;
			break;
		}
	}
}

//*****************************************************************************************
// START OF BREP OBJECT DATA STRUCTURE FACE/SHELL/SOLID PART
// 10/01/2020
//*****************************************************************************************
IMPLEMENT_DYNAMIC(Face, CObject)
// Create Object

Face::Face() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 18;
	pParent = NULL;
	pSurf = NULL; // pParent Surface
	bOrient = 1; // Agrees with parent surface
}

Face::Face(NSurf* pS, BOOL bO) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 18;
	pParent = NULL;
	pSurf = pS;
	bOrient = bO;
}

Face::~Face() {
	pSurf = NULL;
	// May have to delete pSurf if it was create as bOrient was = 0
	// need to come back to this
	pParent = NULL;
}

void Face::Serialize(CArchive& ar, int iV) {
	G_Object::Serialize(ar, iV);
}

void Face::Info() {
	char S1[80];
	sprintf_s(S1, "FACE ID: %i ORIENT: %i", iLabel, bOrient);
	outtext1(S1);
}

void Face::OglDraw(int iDspFlgs, double dS1, double dS2) {
	if (pSurf != NULL)
		pSurf->OglDraw(iDspFlgs, dS1, dS2);
}

void Face::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	if (pSurf != NULL)
		pSurf->OglDrawW(iDspFlgs, dS1, dS2);
}

void Face::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	// if (pSurf != NULL)
	//	pSurf->SetToScr(pModMat, pScrTran);
}

void Face::HighLight(CDC* pDC) {
	if (pSurf != NULL)
		pSurf->HighLight(pDC);
}

G_ObjectD Face::SelDist(CPoint InPT, Filter FIL) {
	// Not sure about the behaviout of this yest
	G_ObjectD Ret;
	double dDist = 1e36;
	Ret.Dist = 1e36;
	Ret.pObj = NULL;
	if ((FIL.isFilter(18)) || (FIL.isFilter(19)) || (FIL.isFilter(20))) {
		if (pSurf != NULL) {
			Ret = pSurf->SelDistFace(InPT, FIL);
			Ret.pObj = this;
		}
	}
	return (Ret);
}

void Face::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	if (pSurf != NULL)
		pSurf->S_Box(P1, P2, pSel);
}

void Face::Translate(C3dVector vTVect) {
	if (pSurf != NULL)
		pSurf->Translate(vTVect);
}

void Face::Transform(C3dMatrix TMat) {
	if (pSurf != NULL)
		pSurf->Transform(TMat);
}

C3dVector Face::GetPt(double dU, double dV) {
	C3dVector vRet;
	vRet.Set(0, 0, 0);
	if (pSurf != NULL)
		vRet = pSurf->GetPt(dU, dV);
	return (vRet);
}

C3dVector Face::Get_Normal(double dU, double dV) {
	C3dVector vRet;
	vRet.Set(0, 0, 0);
	if (pSurf != NULL)
		vRet = pSurf->Get_Normal(dU, dV);
	return (vRet);
}

C3dVector Face::Get_Centroid() {
	C3dVector vRet;
	vRet.Set(0, 0, 0);
	if (pSurf != NULL)
		vRet = pSurf->Get_Centroid();
	return (vRet);
}

void Face::RelTo(G_Object* pThis, ObjList* pList, int iType) {
}

//*****************************************************************************************
// START OF BREP OBJECT DATA STRUCTURE THE S H E L L
// 10/01/2020
//*****************************************************************************************
IMPLEMENT_DYNAMIC(Shell, CObject)

Shell::Shell() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 19;
	pParent = NULL; // This will be the parent Part object
	bOrient = 1; // Agrees with parent surface
	bOrient = TRUE; // True = Outer shell False = void
	isOuter = TRUE; // If TRUE is the outer shell
}

Shell::Shell(BOOL isOut, int iLab) {
	Shell();
	isOuter = isOut;
	iLabel = iLab;
}

G_ObjectD Shell::SelDist(CPoint InPT, Filter FIL) {
	G_ObjectD Ret;
	G_ObjectD D;
	double MinDist = 1e36;
	Ret.Dist = 1e36;
	Ret.pObj = NULL;
	Ret.Z = 1e36;
	Face* pNext;
	pNext = (Face*) pFaces.Head;
	while (pNext != NULL) // Search All Faces in Shell
	{
		D = pNext->SelDist(InPT, FIL);
		if (D.Dist < MinDist) {
			MinDist = D.Dist;
			Ret.Dist = D.Dist;
			Ret.Z = D.Z;
			Ret.pObj = (Face*) pNext;
		}
		pNext = (Face*) pNext->next;
	}
	if (!FIL.isFilter(18)) // Faces is not required
		Ret.pObj = this;
	return (Ret);
}

void Shell::HighLight(CDC* pDC) {
	G_Object* pNext;
	pNext = pFaces.Head;
	while (pNext != NULL) {
		pNext->HighLight(pDC);
		pNext = (G_Object*) pNext->next;
	}
}

void Shell::RelTo(G_Object* pThis, ObjList* pList, int iType) {
	// Surface related to face
	if (pThis->iObjType == 18) {
		Face* pF = (Face*) pThis;
		if ((iType == 15) || (iType == 16) || (iType == 17)) {
			if (pF->pSurf != NULL)
				pList->AddEx(pF->pSurf);
		} else if (iType == 7) {
			if (pF->pSurf != NULL)
				pF->pSurf->RelTo(pThis, pList, iType);
		} else if (iType == 19) // Shell
		{
			if (pThis->iObjType == 18) {
				pList->AddEx(this);
			}
		}
	} else if (pThis->iObjType == 19) // Faces Related To Shell
	{
		Face* pNext = (Face*) pFaces.Head;
		while (pNext != NULL) {
			pList->AddEx(pNext);
			pNext = (Face*) pNext->next;
		}
	} else if (pThis->iObjType == 7) //
	{
		pThis->iObjType = 7;
	}
}

void Shell::Info() {
	char S1[80];
	USE* pU;
	Face* pF;
	pF = (Face*) pFaces.Head;
	outtext1("************ FACES IN SHELL **************");
	while (pF != NULL) {
		sprintf_s(S1, "TYPE: %i LAB: %i", pF->iObjType, pF->iLabel);
		outtext1(S1);
		pF = (Face*) pF->next;
	}
	outtext1("************* POINT USES ****************");
	pU = (USE*) PtUSES.Head;
	while (pU != NULL) {
		sprintf_s(S1, "TYPE: %i LAB: %i USES %i", pU->pObj->iObjType, pU->pObj->iLabel, pU->iNo);
		outtext1(S1);
		pU = (USE*) pU->next;
	}
	outtext1("************* CURVE USES ****************");
	pU = (USE*) CurveUSES.Head;
	while (pU != NULL) {
		sprintf_s(S1, "TYPE: %i LAB: %i USES %i", pU->pObj->iObjType, pU->pObj->iLabel, pU->iNo);
		outtext1(S1);
		pU = (USE*) pU->next;
	}
}

void Shell::OglDraw(int iDspFlgs, double dS1, double dS2) {
	G_Object* pNext;
	pNext = pFaces.Head;
	while (pNext != NULL) {
		pNext->OglDraw(iDspFlgs, dS1, dS2);
		pNext = (G_Object*) pNext->next;
	}
}

void Shell::OglDrawW(int iDspFlgs, double dS1, double dS2) {
}

Shell::~Shell() {
	pFaces.DeleteAll(); // Faces used in shell
	cLinkedList CurveUSES; // Curves uses in shells
	USE* pNext;
	pNext = (USE*) CurveUSES.Head;
	while (pNext != NULL) {
		pNext->iNo = 0;
		;
		pNext->pObj = NULL;
		pNext = (USE*) pNext->next;
	}
	// cLinkedList PtUSES;		// Points uses in shells
}

void Shell::Serialize(CArchive& ar, int iV, Part* pP) {
	int i;
	int j;
	int iCnt;
	int iFLab;
	Face* pNext;
	USE* pU;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << bOrient; // Orientatopn of shell wet underlying surfaces TRUE=Agree
		ar << isOuter;
		// All Faces
		ar << pFaces.iCnt;
		ar << pFaces.sTitle;
		pNext = (Face*) pFaces.Head;
		while (pNext != NULL) {
			pNext->Serialize(ar, iV);
			ar << pNext->bOrient;
			ar << pNext->pSurf->iLabel;
			pNext = (Face*) pNext->next;
		}
		// Point Uses
		ar << PtUSES.iCnt;
		ar << PtUSES.sTitle;
		pU = (USE*) PtUSES.Head;
		while (pU != NULL) {
			pU->Serialize(ar, iV);
			ar << pU->iNo;
			ar << pU->pObj->iLabel; // The Space Curve
			for (i = 0; i < pU->iNo; i++) {
				ar << pU->Use[i]->iLabel; // The Face IDs its usd in
			}
			pU = (USE*) pU->next;
		}
		// Curve Uses
		ar << CurveUSES.iCnt;
		ar << CurveUSES.sTitle;
		pU = (USE*) CurveUSES.Head;
		while (pU != NULL) {
			pU->Serialize(ar, iV);
			ar << pU->iNo;
			ar << pU->pObj->iLabel; // The Space Curve
			for (i = 0; i < pU->iNo; i++) {
				ar << pU->Use[i]->iLabel; // The Face IDs its usd in
			}
			pU = (USE*) pU->next;
		}
	} else {
		G_Object::Serialize(ar, iV);
		ar >> bOrient; // Orientatopn of shell wet underlying surfaces TRUE=Agree
		ar >> isOuter;
		// All Faces
		ar >> iCnt;
		ar >> pFaces.sTitle;
		// All Faces
		for (i = 0; i < iCnt; i++) {
			Face* pF = new Face();
			pF->Serialize(ar, iV);
			pF->pParent = this;
			ar >> pF->bOrient;
			ar >> iFLab;
			pF->pSurf = (NSurf*) pP->pPartS.Get(iFLab);
			pFaces.Add(pF);
		}
		// Point Uses
		ar >> iCnt;
		ar >> PtUSES.sTitle;
		for (i = 0; i < iCnt; i++) {
			int iPLab;
			int iC;
			pU = new USE();
			pU->Serialize(ar, iV);
			ar >> pU->iNo;
			ar >> iPLab;
			pU->pObj = (CvPt_Object*) pP->pPartV.Get(iPLab); // The Space Curve
			for (j = 0; j < pU->iNo; j++) {
				ar >> iC;
				pU->Use[j] = (NCurve*) pP->pPartC.Get(iC); // The Face IDs its usd in
			}
			PtUSES.Add(pU);
		}
		// Curve Uses
		ar >> iCnt;
		ar >> CurveUSES.sTitle;
		for (i = 0; i < iCnt; i++) {
			int iCLab;
			int iF;
			pU = new USE();
			pU->Serialize(ar, iV);
			ar >> pU->iNo;
			ar >> iCLab;
			pU->pObj = (NCurve*) pP->pPartC.Get(iCLab); // The Space Curve
			for (j = 0; j < pU->iNo; j++) {
				ar >> iF;
				pU->Use[j] = (Face*) pFaces.Get(iF);
				; // The Face IDs its usd in
			}
			CurveUSES.Add(pU);
		}
	}
}

Face* Shell::GetFace(G_Object* pF) {
	Face* pRet = NULL;
	Face* pFNext;
	pFNext = (Face*) this->pFaces.Head;
	while (pFNext != NULL) {
		if (pFNext == pF) {
			pRet = pFNext;
			break;
		}
		pFNext = (Face*) pFNext->next;
	}
	return (pRet);
}

void Shell::DeleteFace(G_Object* pF) {
	pFaces.Remove2(pF);
}

void Shell::AddFace(Face* pF, BOOL bO, int iLab) {
	CvPt_Object* pS = NULL; // Start Vertex
	CvPt_Object* pE = NULL; // End Vertex
	pF->bOrient = bO;
	pF->pParent = this;
	pF->iLabel = iLab;
	pFaces.Add(pF);
	int i;
	int j;
	USE* pU;
	NSurf* pSurface;
	NCurve* pSC;
	pSurface = (NSurf*) pF->pSurf;
	// Now need to add related space curves
	for (i = 0; i < pSurface->iNoExtCvs; i++) {
		pSC = pSurface->pExtLoop[i]->pSC;
		if (pSC != NULL) {
			pS = pSC->pS;
			if (pS->iLabel == 1)
				pS->iLabel = 1;
			if (pS != NULL) {
				pU = (USE*) PtUSES.Get(pS->iLabel);
				if (pU == NULL) {
					pU = new USE();
					PtUSES.Add(pU);
					pU->iLabel = pS->iLabel;
					pU->pObj = pS; // The underlying space curve
					pU->AddEx(pSC);
				} else {
					pU->AddEx(pSC);
				}
			}
			pE = pSC->pE;
			if (pE->iLabel == 1)
				pE->iLabel = 1;
			if (pE != NULL) {
				pU = (USE*) PtUSES.Get(pE->iLabel);
				if (pU == NULL) {
					pU = new USE();
					PtUSES.Add(pU);
					pU->iLabel = pE->iLabel;
					pU->pObj = pE; // The underlying space curve
					pU->AddEx(pSC);
				} else {
					pU->AddEx(pSC);
				}
			}
			pU = (USE*) CurveUSES.Get(pSC->iLabel);
			if (pU == NULL) {
				pU = new USE();
				CurveUSES.Add(pU);
				pU->iLabel = pSC->iLabel;
				pU->pObj = pSC; // The underlying space curve
				pU->Add(pF); // Curve on surface usage
			} else {
				pU->Add(pF);
			}
		}
	}
	for (i = 0; i < pSurface->iNoIntLoops; i++) {
		for (j = 0; j < pSurface->iNoIntCvs[i]; j++) {
			pSC = pSurface->pIntLoop[i][j]->pSC;
			if (pSC != NULL) {
				pS = pSC->pS;
				if (pS->iLabel == 1)
					pS->iLabel = 1;
				if (pS != NULL) {
					pU = (USE*) PtUSES.Get(pS->iLabel);
					if (pU == NULL) {
						pU = new USE();
						PtUSES.Add(pU);
						pU->iLabel = pS->iLabel;
						pU->pObj = pS; // The underlying space curve
						pU->AddEx(pSC);
					} else {
						pU->AddEx(pSC);
					}
				}
				pE = pSC->pE;
				if (pE->iLabel == 1)
					pE->iLabel = 1;
				if (pE != NULL) {
					pU = (USE*) PtUSES.Get(pE->iLabel);
					if (pU == NULL) {
						pU = new USE();
						PtUSES.Add(pU);
						pU->iLabel = pE->iLabel;
						pU->pObj = pE; // The underlying space curve
						pU->AddEx(pSC);
					} else {
						pU->AddEx(pSC);
					}
				}
				pU = (USE*) CurveUSES.Get(pSC->iLabel);
				if (pU == NULL) {
					pU = new USE();
					CurveUSES.Add(pU);
					pU->iLabel = pSC->iLabel;
					pU->pObj = pSC; // The underlying space curve
					pU->Add(pF); // Curve on surface usage
				} else {
					pU->Add(pF);
				}
			}
		}
	}
}

// Remove Curve Face uses and Pt Curve Uses
void Shell::RemoveFaceUses(Face* pF) {
	int i;
	int j;
	NSurf* pSurface;
	NCurve* pSC;
	pSurface = (NSurf*) pF->pSurf;
	USE* pU;
	if (pF == NULL)
		return;
	for (i = 0; i < pSurface->iNoExtCvs; i++) {
		pSC = pSurface->pExtLoop[i]->pSC;
		// Remove Curves From Pts Uses
		if (pSC != NULL) {
			pU = (USE*) CurveUSES.Get(pSC->iLabel);
			if (pU != NULL)
				pU->Remove(pF);
			if (pU->iNo == 0)
				CurveUSES.Remove2(pU);
		}
	}
	for (i = 0; i < pSurface->iNoIntLoops; i++) {
		for (j = 0; j < pSurface->iNoIntCvs[i]; j++) {
			pSC = pSurface->pIntLoop[i][j]->pSC;
			// Remove Curves From Pts Uses
			if (pSC != NULL) {
				pU = (USE*) CurveUSES.Get(pSC->iLabel);
				if (pU != NULL)
					pU->Remove(pF);
				if (pU->iNo == 0)
					CurveUSES.Remove2(pU);
			}
		}
	}
}

// Remove Curve uses from PtUSES
void Shell::RemoveCurveUses(NCurve* pSC) {
	CvPt_Object* pS = NULL; // Start Vertex
	CvPt_Object* pE = NULL; // End Vertex
	USE* pU;
	if (pSC != NULL) {
		pS = pSC->pS;
		if (pS != NULL) {
			pU = (USE*) PtUSES.Get(pS->iLabel);
			if (pU != NULL) {
				pU->Remove(pSC);
				if (pU->iNo == 0)
					PtUSES.Remove2(pU);
			}
		}
		pE = pSC->pE;
		if (pE != NULL) {
			pU = (USE*) PtUSES.Get(pE->iLabel);
			if (pU != NULL)
				pU->Remove(pSC);
			if (pU->iNo == 0)
				PtUSES.Remove2(pU);
		}
	}
}

//*****************************************************************************************
// START OF BREP OBJECT DATA STRUCTURE THE P A R T  O B J E C T
// 10/01/2020
//*****************************************************************************************
IMPLEMENT_DYNAMIC(Part, CObject)

Part::Part() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 13;
	iLabel = -1;
	iObjType = 20;
	iShellLab = 1;
	iVertexLab = 1;
	iCurveLab = 1;
	iFaceLab = 1;
	iSurfLab = 1;
}

Part::~Part() {
	pShells.DeleteAll(); // Pointer to all Shells forming part
	FaceUSES.DeleteAll(); // Face USES in shells
	pPartS.DeleteAll(); // Space Surfaces used in part
	pPartC.DeleteAll(); // Space curves used in part
	pPartV.DeleteAll(); // Vertices used in Part
}

Part::Part(int iLab) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 13;
	iObjType = 20;
	iShellLab = 1;
	iVertexLab = 1;
	iCurveLab = 1;
	iFaceLab = 1;
	iSurfLab = 1;
	iLabel = iLab;
}

void Part::Serialize(CArchive& ar, int iV) {
	int iT;
	int iST;
	int i;
	int iCnt;
	G_Object* pNext;
	Shell* pS;
	NCurve* pCv;
	NSurf* pSf;
	if (ar.IsStoring()) {
		G_Object::Serialize(ar, iV);
		ar << Alpha;
		ar << sName;
		ar << iShellLab;
		ar << iVertexLab;
		ar << iCurveLab;
		ar << iFaceLab;
		ar << iSurfLab;
		// All verticese
		ar << pPartV.iCnt;
		ar << pPartV.sTitle;
		pNext = pPartV.Head;
		while (pNext != NULL) {
			pNext->Serialize(ar, iV);
			pNext = pNext->next;
		}
		// All Curves
		ar << pPartC.iCnt;
		ar << pPartC.sTitle;
		pNext = pPartC.Head;
		while (pNext != NULL) {
			ar << pNext->iObjType;
			ar << pNext->iType;
			pNext->Serialize(ar, iV);
			pNext = pNext->next;
		}
		// All Surfaces
		ar << pPartS.iCnt;
		ar << pPartS.sTitle;
		pNext = pPartS.Head;
		while (pNext != NULL) {
			ar << pNext->iObjType;
			ar << pNext->iType;
			pNext->Serialize(ar, iV);
			pNext = pNext->next;
		}

		// All Shells
		ar << pShells.iCnt;
		ar << pShells.sTitle;
		pS = (Shell*) pShells.Head;
		while (pS != NULL) {
			pS->Serialize(ar, iV, this);
			pS = (Shell*) pS->next;
		}
	} else {
		G_Object::Serialize(ar, iV);
		ar >> Alpha;
		ar >> sName;
		ar >> iShellLab;
		ar >> iVertexLab;
		ar >> iCurveLab;
		ar >> iFaceLab;
		ar >> iSurfLab;
		// All verticese
		ar >> iCnt;
		ar >> pPartV.sTitle;
		for (i = 0; i < iCnt; i++) {
			CvPt_Object* pCv = new CvPt_Object();
			pCv->pParent = this;
			pCv->Serialize(ar, iV);
			pPartV.Add(pCv);
		}
		// All Curves
		ar >> iCnt;
		ar >> pPartC.sTitle;
		for (i = 0; i < iCnt; i++) {
			ar >> iT;
			ar >> iST;
			if (iST == 3)
				pCv = new NCircle;
			else if (iST == 2)
				pCv = new NLine;
			else
				pCv = new NCurve;
			pCv->pParent = this;
			pCv->Serialize(ar, iV);
			pPartC.Add(pCv);
		}
		// All Surfaces
		ar >> iCnt;
		ar >> pPartS.sTitle;
		for (i = 0; i < iCnt; i++) {
			ar >> iT;
			ar >> iST;
			if (iST == 3)
				pSf = new NSurfR;
			else if (iST == 2)
				pSf = new NSurfE;
			else
				pSf = new NSurf;
			pSf->pParent = this;
			pSf->Serialize(ar, iV);
			pPartS.Add(pSf);
		}
		ReConectCvEndPts(0.000001);
		// All Shells
		ar >> iCnt;
		ar >> pShells.sTitle;
		for (i = 0; i < iCnt; i++) {
			Shell* pSh = new Shell();
			pSh->Serialize(ar, iV, this);
			pSh->pParent = this;
			pShells.Add(pSh);
		}
	}
}

void Part::AddShell(Shell* pShell) {
	pShell->pParent = this; // The shell belongs to this part
	pShell->iLabel = iShellLab;
	iShellLab++;
	pShells.Add(pShell);
}

void Part::ReConectCvEndPts(double dTol) {
	NCurve* pNext;
	pNext = (NCurve*) pPartC.Head;
	while (pNext != NULL) {
		pNext->pS = GetVert(pNext->vS, dTol);
		pNext->pE = GetVert(pNext->vE, dTol);
		pNext = (NCurve*) pNext->next;
	}
}

CvPt_Object* Part::GetVert(C3dVector pPt, double dTol) {
	CvPt_Object* pRet = NULL;
	double dDist;
	CvPt_Object* pNext;
	pNext = (CvPt_Object*) pPartV.Head;
	while (pNext != NULL) {
		dDist = pNext->Pt_Point->Dist(pPt);
		if (dDist < dTol) {
			pRet = pNext;
			break;
		}
		pNext = (CvPt_Object*) pNext->next;
	}
	if (pRet == NULL) {
		CvPt_Object* pNewP = new CvPt_Object();
		pNewP->Create(pPt, 1.0, iVertexLab, -1, -1, 4, this);
		iVertexLab++;
		pPartV.Add(pNewP);
		pRet = pNewP;
	}

	return (pRet);
}

void Part::AddSurf(Face* pF) {
	// Need to exclusively add Face, trim cureve and points
	int i;
	int j;
	G_Object* pS;
	NSurf* pSurface;
	NCurve* pSC;
	pS = pPartS.GetByPtr(pF->pSurf); // Add the underlying trimmed surface
	if (pS == NULL) {
		pSurface = (NSurf*) pF->pSurf;
		pSurface->iLabel = iSurfLab; // we will rely on ID so need to be careful to preserve integrity
		pSurface->pParent = this;
		iSurfLab++;
		pPartS.Add(pSurface);
		// Now need to add related space curves

		for (i = 0; i < pSurface->iNoExtCvs; i++) {
			pSC = pSurface->pExtLoop[i]->pSC;
			if (pSC != NULL) {
				if (pPartC.GetByPtr(pSC) == NULL) {
					pSC->iLabel = iCurveLab;
					pSC->pParent = this;
					iCurveLab++;
					pPartC.Add(pSC);
					// Add The End Points
					pSC->pS = GetVert(pSC->vS, 0.000001);
					pSC->pE = GetVert(pSC->vE, 0.000001);
				}
			}
		}
		for (i = 0; i < pSurface->iNoIntLoops; i++) {
			for (j = 0; j < pSurface->iNoIntCvs[i]; j++) {
				pSC = pSurface->pIntLoop[i][j]->pSC;
				if (pSC != NULL) {
					if (pPartC.GetByPtr(pSC) == NULL) {
						pSC->pParent = this;
						pSC->iLabel = iCurveLab;
						iCurveLab++;
						pPartC.Add(pSC);
						// Add The End Points
						pSC->pS = GetVert(pSC->vS, 0.000001);
						pSC->pE = GetVert(pSC->vE, 0.000001);
					}
				}
			}
		}
	}
}

void Part::CurveColour(int iCol) {
	G_Object* pNext;
	pNext = pPartC.Head;
	while (pNext != NULL) {
		pNext->iColour = iCol;
		pNext = (G_Object*) pNext->next;
	}
}

void Part::SurfColour(int iCol) {
	G_Object* pNext;
	pNext = pPartS.Head;
	while (pNext != NULL) {
		pNext->iColour = iCol;
		pNext = (G_Object*) pNext->next;
	}
}

void Part::OglDraw(int iDspFlgs, double dS1, double dS2) {
	Shell* pShell;
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_SRC_COLOR);
	iShellLab;
	pShell = (Shell*) pShells.Head;
	while (pShell != NULL) {
		pShell->OglDraw(iDspFlgs, dS1, dS2);
		pShell = (Shell*) pShell->next;
	}
	glDisable(GL_BLEND);
}

void Part::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	G_Object* pNext;
	pNext = pPartC.Head;
	while (pNext != NULL) {
		pNext->OglDrawW(iDspFlgs, dS1, dS2);
		pNext = (G_Object*) pNext->next;
	}
	pNext = pPartV.Head;
	while (pNext != NULL) {
		pNext->OglDrawW(iDspFlgs, dS1, dS2);
		pNext = (G_Object*) pNext->next;
	}
}

void Part::GetBoundingBox(C3dVector& vll, C3dVector& vur) {
	int i;
	NCurve* pSC;
	C3dVector vMinXYZ;
	C3dVector vMaxXYZ;
	G_Object* pNext;
	pNext = pPartC.Head;
	BOOL bFirst = TRUE;
	C3dVector vPt;
	while (pNext != NULL) {
		pSC = (NCurve*) pNext;
		for (i = 0; i < pSC->iNoCPts; i++) {
			vPt = pSC->cPts[i]->Pt_Point;
			if (bFirst) {
				vMinXYZ = vPt;
				vMaxXYZ = vPt;
				bFirst = FALSE;
			} else {
				if (vPt.x < vMinXYZ.x)
					vMinXYZ.x = vPt.x;
				if (vPt.y < vMinXYZ.y)
					vMinXYZ.y = vPt.y;
				if (vPt.z < vMinXYZ.z)
					vMinXYZ.z = vPt.z;

				if (vPt.x > vMaxXYZ.x)
					vMaxXYZ.x = vPt.x;
				if (vPt.y > vMaxXYZ.y)
					vMaxXYZ.y = vPt.y;
				if (vPt.z > vMaxXYZ.z)
					vMaxXYZ.z = vPt.z;
			}
		}
		pNext = (G_Object*) pNext->next;
	}
	vll = vMinXYZ;
	vur = vMaxXYZ;
	BBox[0].Pt_Point->Set(vMinXYZ.x, vMinXYZ.y, vMinXYZ.z);
	BBox[1].Pt_Point->Set(vMinXYZ.x, vMaxXYZ.y, vMinXYZ.z);
	BBox[2].Pt_Point->Set(vMaxXYZ.x, vMaxXYZ.y, vMinXYZ.z);
	BBox[3].Pt_Point->Set(vMaxXYZ.x, vMinXYZ.y, vMinXYZ.z);

	BBox[4].Pt_Point->Set(vMinXYZ.x, vMinXYZ.y, vMaxXYZ.z);
	BBox[5].Pt_Point->Set(vMinXYZ.x, vMaxXYZ.y, vMaxXYZ.z);
	BBox[6].Pt_Point->Set(vMaxXYZ.x, vMaxXYZ.y, vMaxXYZ.z);
	BBox[7].Pt_Point->Set(vMaxXYZ.x, vMinXYZ.y, vMaxXYZ.z);
}

void Part::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	GetBoundingBox(vBoxMin, vBoxMax);
	C3dVector V;
	C3dVector R;
	G_Object::SetToScr(pModMat, pScrTran);
	int i;
	for (i = 0; i < 8; i++)
		BBox[i].SetToScr(pModMat, pScrTran);

	CvPt_Object* pNext;
	pNext = (CvPt_Object*) pPartV.Head;
	while (pNext != NULL) {
		pNext->SetToScr(pModMat, pScrTran);
		pNext = (CvPt_Object*) pNext->next;
	}
	NCurve* pNextC;
	pNextC = (NCurve*) pPartC.Head;
	while (pNextC != NULL) {
		pNextC->SetToScr(pModMat, pScrTran);
		pNextC = (NCurve*) pNextC->next;
	}
	NSurf* pNextS;
	pNextS = (NSurf*) pPartS.Head;
	while (pNextS != NULL) {
		pNextS->SetToScr(pModMat, pScrTran);
		pNextS = (NSurf*) pNextS->next;
	}
}

void Part::HighLight(CDC* pDC) {
	int i = 0;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	for (i = 1; i < 4; i++)
		pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 0;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);

	i = 4;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	for (i = 5; i < 8; i++)
		pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 4;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);

	i = 0;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 4;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 1;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 5;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 2;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 6;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 3;
	pDC->MoveTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
	i = 7;
	pDC->LineTo((int) BBox[i].DSP_Point->x, (int) BBox[i].DSP_Point->y);
}

G_ObjectD Part::SelDist(CPoint InPT, Filter FIL) {
	char S1[80] = "";

	G_ObjectD Ret;
	G_ObjectD D;
	Ret.Dist = 1e36;
	Ret.pObj = NULL;
	Ret.Z = 1e36;
	Shell* pShell;
	iShellLab;
	CvPt_Object* pV;
	NCurve* pC;
	NSurf* pS;
	pShell = (Shell*) pShells.Head;
	while (pShell != NULL) {
		D = pShell->SelDist(InPT, FIL);
		if (D.Dist < Ret.Dist) {
			Ret.Dist = D.Dist;
			Ret.Z = D.Z;
			Ret.pObj = D.pObj;
		}
		pShell = (Shell*) pShell->next;
	}
	// sprintf_s(S1, "%s %i", "Z:", Ret.Z);
	// outtext1(S1);

	if (FIL.isFilter(0)) {
		pV = (CvPt_Object*) pPartV.Head;
		while (pV != NULL) {
			D = pV->SelDist(InPT, FIL);
			if (D.Dist < Ret.Dist) {
				Ret.Dist = D.Dist;
				Ret.Z = D.Z;
				Ret.pObj = D.pObj;
			}
			pV = (CvPt_Object*) pV->next;
		}
	}
	if ((FIL.isFilter(7)) || (FIL.isFilter(8)) || (FIL.isFilter(9))) {
		pC = (NCurve*) pPartC.Head;
		while (pC != NULL) {
			D = pC->SelDist(InPT, FIL);
			if (D.Dist < Ret.Dist) {
				Ret.Dist = D.Dist;
				Ret.Z = D.Z;
				Ret.pObj = D.pObj;
			}
			pC = (NCurve*) pC->next;
		}
	}
	if ((FIL.isFilter(15)) || (FIL.isFilter(16)) || (FIL.isFilter(17))) {
		pS = (NSurf*) pPartS.Head;
		while (pS != NULL) {
			D = pS->SelDist(InPT, FIL);
			if (D.Dist < Ret.Dist) {
				Ret.Dist = D.Dist;
				Ret.Z = D.Z;
				Ret.pObj = D.pObj;
			}
			pS = (NSurf*) pS->next;
		}
	}
	if ((!FIL.isFilter(18)) && (!FIL.isFilter(19)) &&
	    (!FIL.isFilter(0)) && (!FIL.isFilter(7)) &&
	    (!FIL.isFilter(15)) && (!FIL.isFilter(16)) && (!FIL.isFilter(17))) {
		Ret.pObj = this;
	}

	return (Ret);
}

int Part::GetVarHeaders(CString sVar[]) {
	sVar[0] = "Name";
	sVar[1] = "Colour ID";
	sVar[2] = "Translucency";
	return (3);
}

int Part::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%s", sName);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%i", iColour);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", Alpha);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void Part::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	sName = sVar[0];
	iColour = atoi(sVar[1]);
	Alpha = atof(sVar[2]);
}

void Part::RelTo(G_Object* pThis, ObjList* pList, int iType) {
	int i;
	USE* pU;

	if (pThis->iObjType == 7) // Its a space curve
	{
		Shell* pShell;
		if (iType == 18) // Face
		{
			pShell = (Shell*) pShells.Head;
			while (pShell != NULL) {
				pU = (USE*) pShell->CurveUSES.Get(pThis->iLabel);
				if (pU != NULL) {
					for (i = 0; i < pU->iNo; i++) {
						if (pU->Use[i] != NULL) {
							pList->AddEx(pU->Use[i]);
						}
					}
				}
				pShell = (Shell*) pShells.next;
			}
		} else if (iType == 0) {
			NCurve* pC = (NCurve*) pThis;
			if (pC->pS != NULL)
				pList->AddEx(pC->pS);
			if (pC->pE != NULL)
				pList->AddEx(pC->pE);
		}
	} else if (pThis->iObjType == 19) // Shell Related
	{
		pThis->RelTo(pThis, pList, iType);
	} else if (pThis->iObjType == 20) // Part Related
	{
		if (iType == 19) // Shells related to Part
		{
			Shell* pShell;
			pShell = (Shell*) pShells.Head;
			while (pShell != NULL) {
				pList->AddEx(pShell);
				pShell = (Shell*) pShell->next;
			}
		}
		if (iType == 7) // Curves related to Part
		{
			NCurve* pC;
			pC = (NCurve*) pPartC.Head;
			while (pC != NULL) {
				pList->AddEx(pC);
				pC = (NCurve*) pC->next;
			}
		}
		if (iType == 15) // Surfaces related to Part
		{
			NSurf* pS;
			pS = (NSurf*) pPartS.Head;
			while (pS != NULL) {
				pList->AddEx(pS);
				pS = (NSurf*) pS->next;
			}
		}
		if (iType == 0) // Vertex related to Part
		{
			CvPt_Object* pP;
			pP = (CvPt_Object*) pPartV.Head;
			while (pP != NULL) {
				pList->AddEx(pP);
				pP = (CvPt_Object*) pP->next;
			}
		}
	}
}

void Part::Info() {
	char S1[80];
	outtext1("******* Vertices *******");
	CvPt_Object* pNext;
	pNext = (CvPt_Object*) pPartV.Head;
	while (pNext != NULL) {
		sprintf_s(S1, "TYPE: %i LAB: %i %g %g %g", pNext->iObjType, pNext->iLabel, pNext->Pt_Point->x,
		          pNext->Pt_Point->y, pNext->Pt_Point->z);
		outtext1(S1);
		pNext = (CvPt_Object*) pNext->next;
	}

	outtext1("******* Curves *******");
	NCurve* pC;
	pC = (NCurve*) pPartC.Head;
	while (pC != NULL) {
		sprintf_s(S1, "TYPE: %i LAB: %i PT1: %i PT2: %i", pC->iObjType, pC->iLabel, pC->pS->iLabel, pC->pE->iLabel);
		outtext1(S1);
		pC = (NCurve*) pC->next;
	}
	outtext1("******* Surfaces *******");
	G_Object* pN = pPartS.Head;
	while (pN != NULL) {
		sprintf_s(S1, "TYPE: %i LAB: %i", pN->iObjType, pN->iLabel);
		outtext1(S1);
		pN = pN->next;
	}

	outtext1("**************");
}

G_Object* Part::GetObj(int iType, int iLab) {
	G_Object* pRet;
	pRet = NULL;
	if (iType == 0) {
		// Vertex
		pRet = pPartV.Get(iLab);
	} else if ((iType == 7) || (iType == 8) || (iType == 9)) {
		// Curve
		pRet = pPartC.Get(iLab);
	} else if ((iType == 15) || (iType == 16) || (iType == 17)) {
		// Surface
		pRet = pPartS.Get(iLab);
	} else if (iType == 19) {
		// Shell
		pRet = pShells.Get(iLab);
	}
	// Also need faces
	return (pRet);
}

void Part::Translate(C3dVector vIn) {
	CvPt_Object* pNext;
	pNext = (CvPt_Object*) pPartV.Head;
	while (pNext != NULL) {
		pNext->Translate(vIn);
		pNext = (CvPt_Object*) pNext->next;
	}

	NCurve* pC;
	pC = (NCurve*) pPartC.Head;
	while (pC != NULL) {
		pC->Translate(vIn);
		pC = (NCurve*) pC->next;
	}

	G_Object* pN = pPartS.Head;
	while (pN != NULL) {
		pN->Translate(vIn);
		pN = pN->next;
	}
}

void Part::Transform(C3dMatrix TMat) {
	CvPt_Object* pNext;
	pNext = (CvPt_Object*) pPartV.Head;
	while (pNext != NULL) {
		pNext->Transform(TMat);
		pNext = (CvPt_Object*) pNext->next;
	}

	NCurve* pC;
	pC = (NCurve*) pPartC.Head;
	while (pC != NULL) {
		pC->Transform(TMat);
		pC = (NCurve*) pC->next;
	}

	G_Object* pN = pPartS.Head;
	while (pN != NULL) {
		pN->Transform(TMat);
		pN = pN->next;
	}
}

CString Part::GetName() {
	return ("Solid Part");
}

void Part::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	// Surfaces in part
	G_Object* pN = pPartS.Head;
	while (pN != NULL) {
		if (pN->isSelectable()) {
			pN->S_Box(P1, P2, pSel);
		}
		pN = pN->next;
	}
	// Vertices
	pN = pPartV.Head;
	while (pN != NULL) {
		if (pN->isSelectable()) {
			pN->S_Box(P1, P2, pSel);
		}
		pN = pN->next;
	}
	// Space curves
	pN = pPartC.Head;
	while (pN != NULL) {
		if (pN->isSelectable()) {
			pN->S_Box(P1, P2, pSel);
		}
		pN = pN->next;
	}
}

void Part::DeleteSurface(G_Object* pS) {
	// find the surface in part to delete
	pPartS.Remove2(pS);
}

void Part::DeletePoint(G_Object* pS) {
	// find the Vertex in part to delete
	pPartV.Remove2(pS);
}

void Part::DeleteCurve(G_Object* pS) {
	// find the Curve in part to delete
	pPartC.Remove2(pS);
}

void Part::DeleteFace(G_Object* pS) {
	BOOL break2 = FALSE;
	Shell* pShell;
	pShell = (Shell*) pShells.Head;
	while (pShell != NULL) {
		Face* pFNext;
		pFNext = (Face*) pShell->pFaces.Head;
		while (pFNext != NULL) {
			if (pFNext == pS) {
				pShell->pFaces.Remove2(pFNext);
				return;
			}
			pFNext = (Face*) pFNext->next;
		}
		pShell = (Shell*) pShell->next;
	}
}

void Part::GetFaceRef(G_Object* pS, ObjList* pFaces) {
	Shell* pShell;
	pShell = (Shell*) pShells.Head;
	while (pShell != NULL) {
		Face* pFNext;
		pFNext = (Face*) pShell->pFaces.Head;
		while (pFNext != NULL) {
			if (pFNext->pSurf == pS) {
				pFaces->AddEx(pFNext);
			}
			pFNext = (Face*) pFNext->next;
		}
		pShell = (Shell*) pShell->next;
	}
}

void Part::GetFace(G_Object* pF, ObjList* pFaces) {
	Shell* pShell;
	pShell = (Shell*) pShells.Head;
	while (pShell != NULL) {
		Face* pFNext;
		pFNext = (Face*) pShell->pFaces.Head;
		while (pFNext != NULL) {
			if (pFNext == pF) {
				pFaces->AddEx(pFNext);
				return;
			}
			pFNext = (Face*) pFNext->next;
		}
		pShell = (Shell*) pShell->next;
	}
}

int Part::GetPointUseCnt(CvPt_Object* pPT) {
	int iRC = 1;
	Shell* pShell;
	pShell = (Shell*) pShells.Head;
	USE* pU;
	while (pShell != NULL) {
		// pShell->CurveUSES.
		pU = (USE*) pShell->PtUSES.Get(pPT->iLabel);
		if (pU != NULL) {
			iRC = pU->iNo;
			if (iRC > 0)
				break;
		} else {
			iRC = 0;
		}
		pShell = (Shell*) pShell->next;
	}
	return (iRC);
}

int Part::GetCurveUseCnt(NCurve* pSC) {
	int iRC = 1;
	Shell* pShell;
	pShell = (Shell*) pShells.Head;
	USE* pU;
	while (pShell != NULL) {
		// pShell->CurveUSES.
		pU = (USE*) pShell->CurveUSES.Get(pSC->iLabel);
		if (pU != NULL) {
			iRC = pU->iNo;
			if (iRC > 0)
				break;
		} else {
			iRC = 0;
		}
		pShell = (Shell*) pShell->next;
	}
	return (iRC);
}

// Remove curve uses on pt for all shells
void Part::RemoveCurveUses(NCurve* pSC) {
	Shell* pShell;
	pShell = (Shell*) pShells.Head;
	while (pShell != NULL) {
		pShell->RemoveCurveUses(pSC);
		pShell = (Shell*) pShell->next;
	}
}

//*****************************************************************************************

IMPLEMENT_DYNAMIC(CvPt_Object, CObject)

CvPt_Object::~CvPt_Object() {
	if (Pt_Point != NULL) {
		delete (Pt_Point);
		Pt_Point = NULL;
	}

	if (DSP_Point != NULL) {
		delete (DSP_Point);
		DSP_Point = NULL;
	}
}

// Create Object
CvPt_Object::CvPt_Object() {
	Pt_Point = new C3dVector();
	DSP_Point = new C3dVector();
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 0;
	iColour = 75;
	iLabel = -1;
	Pt_Point->x = 0;
	Pt_Point->y = 0;
	Pt_Point->z = 0;
	w = 1;
}

void CvPt_Object::Create(C3dVector InPt, double Inw, int iLab, int i2, int i3, int iC, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iObjType = 0;
	iColour = iC;
	iLabel = iLab;
	Pt_Point->x = InPt.x;
	Pt_Point->y = InPt.y;
	Pt_Point->z = InPt.z;
	// Pt_Point = new C3dVector(InPt.x,InPt.y,InPt.z);
	// DSP_Point = new C3dVector();
	pParent = Parrent;
	w = Inw;
}

void CvPt_Object::Info() {
	char S1[80];
	G_Object::Info();
	sprintf_s(S1, "LAB: %i X: %f Y: %f Z: %f W: %f LAYER: %i", iLabel, Pt_Point->x, Pt_Point->y, Pt_Point->z, w, iFile);
	outtext1(_T(S1));
}

C3dVector CvPt_Object::MinPt(C3dVector inPt) {
	C3dVector vRet;
	vRet.Set(Pt_Point->x, Pt_Point->y, Pt_Point->z);
	return (vRet);
}

G_Object* CvPt_Object::Copy(G_Object* Parrent) {
	CvPt_Object* PtRet = new CvPt_Object;
	PtRet->Drawn = Drawn;
	PtRet->Selectable = Selectable;
	PtRet->Visable = Visable;
	PtRet->iColour = iColour;
	PtRet->iObjType = iObjType;
	PtRet->iLabel = iLabel;
	PtRet->Pt_Point = new C3dVector(Pt_Point->x, Pt_Point->y, Pt_Point->z);
	PtRet->DSP_Point = new C3dVector();
	PtRet->pParent = Parrent;
	PtRet->w = w;
	return (PtRet);
}

void CvPt_Object::Serialize(CArchive& ar, int iV) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << Pt_Point->x;
		ar << Pt_Point->y;
		ar << Pt_Point->z;
		ar << w;
	} else {
		G_Object::Serialize(ar, iV);
		Pt_Point = new C3dVector();
		DSP_Point = new C3dVector();
		ar >> Pt_Point->x;
		ar >> Pt_Point->y;
		ar >> Pt_Point->z;
		ar >> w;
	}
}

void CvPt_Object::Clear() {
}

C3dVector CvPt_Object::GetCoords() {
	C3dVector vRet;
	vRet.Set(Pt_Point->x, Pt_Point->y, Pt_Point->z);
	return (vRet);
}

C3dVector CvPt_Object::Get_Centroid() {
	return (GetCoords());
}

// Draw Object line
void CvPt_Object::Draw(CDC* pDC, int iDrawmode) {
	pDC->MoveTo((int) DSP_Point->x - 4, (int) DSP_Point->y + 4);
	pDC->LineTo((int) DSP_Point->x + 4, (int) DSP_Point->y - 4);
	pDC->MoveTo((int) DSP_Point->x + 4, (int) DSP_Point->y + 4);
	pDC->LineTo((int) DSP_Point->x - 4, (int) DSP_Point->y - 4);
	pDC->MoveTo((int) DSP_Point->x + 4, (int) DSP_Point->y);
	pDC->LineTo((int) DSP_Point->x - 5, (int) DSP_Point->y);
	pDC->MoveTo((int) DSP_Point->x, (int) DSP_Point->y - 4);
	pDC->LineTo((int) DSP_Point->x, (int) DSP_Point->y + 4);
	// pDC->SetPixel(DSP_Point->x, DSP_Point->y+4, 255 );

	// pDC->Ellipse(DSP_Point->x+3,DSP_Point->y+3,DSP_Point->x-3,DSP_Point->y-3);
}

//
// // Draw Object line
// void CvPt_Object::Draw(CDC* pDC, int iDrawmode)
// {
// 	pDC->Ellipse((int)DSP_Point->x - 4, (int)DSP_Point->y - 4, (int)DSP_Point->x + 4, (int)DSP_Point->y + 4);
// }

void CvPt_Object::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

// void CvPt_Object::OglDrawW(int iDspFlgs, double dS1, double dS2)
// {
// 	char sLab[20];
// 	if ((iDspFlgs & DSP_POINTS) > 0)
// 	{
// 		Selectable = 1;
// 		glColor3fv(cols[GetCol()]);
// 		glPointSize(gPT_SIZE);
// 		glBegin(GL_POINTS);
// 		glVertex3f((float)Pt_Point->x, (float)Pt_Point->y, (float)Pt_Point->z);
// 		glEnd();
// 		if (bDrawLab == TRUE || gLBL_DSP)
// 		{
// 			sprintf_s(sLab, "Pt%i", iLabel);
// 			OglString(iDspFlgs, (float)Pt_Point->x, (float)Pt_Point->y, (float)Pt_Point->z, &sLab[0]);
// 		}
// 	}
// 	else
// 	{
// 		Selectable = 0;
// 	}
// }

void CvPt_Object::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	if ((iDspFlgs & DSP_POINTS) > 0) {
		Selectable = 1;
		glColor3fv(cols[GetCol()]);

		glPointSize(gPT_SIZE);
		glBegin(GL_POINTS);
		glVertex3f((float) Pt_Point->x, (float) Pt_Point->y, (float) Pt_Point->z);
		glEnd();

		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "Pt%i", iLabel);
			OglString(iDspFlgs, (float) Pt_Point->x, (float) Pt_Point->y, (float) Pt_Point->z, &sLab[0]);
		}
	} else {
		Selectable = 0;
	}
}

void CvPt_Object::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	C3dVector V;
	C3dVector R;
	G_Object::SetToScr(pModMat, pScrTran);

	R.x = Pt_Point->x;
	R.y = Pt_Point->y;
	R.z = Pt_Point->z;
	V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
	V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
	V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;

	R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
	R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
	R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;

	DSP_Point->x = R.x;
	DSP_Point->y = R.y;
	DSP_Point->z = 0;
}

void CvPt_Object::Move(C3dVector vM) {
	Pt_Point->x += vM.x;
	Pt_Point->y += vM.y;
	Pt_Point->z += vM.z;
}

void CvPt_Object::Transform(C3dMatrix TMAt) {
	C3dVector R;
	R.x = TMAt.m_00 * Pt_Point->x + TMAt.m_01 * Pt_Point->y + TMAt.m_02 * Pt_Point->z + TMAt.m_30;
	R.y = TMAt.m_10 * Pt_Point->x + TMAt.m_11 * Pt_Point->y + TMAt.m_12 * Pt_Point->z + TMAt.m_31;
	R.z = TMAt.m_20 * Pt_Point->x + TMAt.m_21 * Pt_Point->y + TMAt.m_22 * Pt_Point->z + TMAt.m_32;
	Pt_Point->x = R.x;
	Pt_Point->y = R.y;
	Pt_Point->z = R.z;
}

void CvPt_Object::Translate(C3dVector vIn) {
	Pt_Point->x += vIn.x;
	Pt_Point->y += vIn.y;
	Pt_Point->z += vIn.z;
}

void CvPt_Object::ScaleX(double d) {
	Pt_Point->x *= d;
}

void CvPt_Object::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	if ((DSP_Point->x > P1.x) &&
	    (DSP_Point->x < P2.x) &&
	    (DSP_Point->y > P1.y) &&
	    (DSP_Point->y < P2.y)) {
		pSel->Add(this);
	}
}

void CvPt_Object::SetTo(C3dVector cInVect) {
	Pt_Point->x = cInVect.x;
	Pt_Point->y = cInVect.y;
	Pt_Point->z = cInVect.z;
}

void CvPt_Object::ExportDXF(FILE* pFile) {
	// fprintf(pFile, "%8i", pVertex[0]->iLabel);
	int iL;
	iL = iFile;
	if (iL < 0)
		iL = 0;
	// Writing point entity
	fprintf(pFile, "POINT\n"); // write the LINE entity
	fprintf(pFile, "  8\n"); // write a line with value 8
	fprintf(pFile, "%s\n", "All"); // write the layer number
	fprintf(pFile, " 10\n"); // write a line with value 10
	fprintf(pFile, "%g\n", Pt_Point->x); // write the x-coordinate of the point
	fprintf(pFile, " 20\n"); // write a line with value 20
	fprintf(pFile, "%g\n", Pt_Point->y); // write the y-coordinate of the point
	fprintf(pFile, " 30\n"); // write a line with value 30
	fprintf(pFile, "%g\n", Pt_Point->z); // write the z-coordinate of the point
	fprintf(pFile, "  0\n");
}

CString CvPt_Object::GetName() {
	return ("Point");
}

int CvPt_Object::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "X";
	iNo++;
	sVar[iNo] = "Y";
	iNo++;
	sVar[iNo] = "Z";
	iNo++;
	sVar[iNo] = "Wt";
	iNo++;

	return (iNo);
}

int CvPt_Object::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%g", Pt_Point->x);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", Pt_Point->y);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", Pt_Point->z);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", w);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void CvPt_Object::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	Pt_Point->x = atof(sVar[0]);
	Pt_Point->y = atof(sVar[1]);
	Pt_Point->z = atof(sVar[2]);
	w = atof(sVar[3]);
}

IMPLEMENT_DYNAMIC(CvPt_ObjectW, CObject)

void CvPt_ObjectW::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	G_Object::SetToScr(pModMat, pScrTran);
	C3dVector V;
	C3dVector R;
	double x, y;
	NSurf* pS;
	pS = (NSurf*) this->pParent->pParent;
	if (pS != NULL) {
		x = Pt_Point->x;
		y = Pt_Point->y;
		w = w;
		R = pS->GetPt(x, y);
		V.x = pModMat->m_00 * R.x + pModMat->m_01 * R.y + pModMat->m_02 * R.z + pModMat->m_30;
		V.y = pModMat->m_10 * R.x + pModMat->m_11 * R.y + pModMat->m_12 * R.z + pModMat->m_31;
		V.z = pModMat->m_20 * R.x + pModMat->m_21 * R.y + pModMat->m_22 * R.z + pModMat->m_32;
		R.x = pScrTran->m_00 * V.x + pScrTran->m_01 * V.y + pScrTran->m_02 * V.z + pScrTran->m_30;
		R.y = pScrTran->m_10 * V.x + pScrTran->m_11 * V.y + pScrTran->m_12 * V.z + pScrTran->m_31;
		R.z = pScrTran->m_20 * V.x + pScrTran->m_21 * V.y + pScrTran->m_22 * V.z + pScrTran->m_32;
		DSP_Point->x = R.x;
		DSP_Point->y = R.y;
		DSP_Point->z = 0;
	}
}

C3dVector CvPt_ObjectW::Get_Centroid() {
	// FOR POINTS ON A SURFACE THAT NEED u,v COORDS CONVERTING TO XYZ
	C3dVector V;
	C3dVector R;
	double x, y;
	NSurf* pS;
	pS = (NSurf*) this->pParent->pParent;
	if (pS != NULL) {
		x = Pt_Point->x;
		y = Pt_Point->y;
		w = w;
		R = pS->GetPt(x, y);
	}
	return (R);
}

IMPLEMENT_DYNAMIC(NCurve, CObject)

NCurve::~NCurve() {
	int i;
	for (i = 0; i < iNoCPts; i++) {
		if (cPts[i] != NULL) {
			delete (cPts[i]);
			cPts[i] = NULL;
		}
	}
}

void NCurve::Clean() {
	int i;
	for (i = 0; i < iNoCPts; i++) {
		if (cPts[i] != NULL) {
			delete (cPts[i]);
			cPts[i] = NULL;
		}
	}
	iNoCPts = 0;
}

NCurve::NCurve() {
	iType = 1;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iLabel = -1;
	iObjType = 7;
	iNoCPts = 0;
	p = 3;
	ws = 0;
	we = 1;
	iLnThk = 4;
	iLnType = 1;
	DrawCPts = FALSE;
	DrawNoCvs = FALSE;
	pS = NULL;
	pE = NULL;
	iInc = -1;
	dLSize = 1;
}

// CvPt_Object* pVertex[20];
void NCurve::Create(int iLab, G_Object* Parrent) {
	Drawn = 0;
	iType = 1;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iLabel = iLab;
	iObjType = 7;
	iLnThk = 4;
	iNoCPts = 0;
	p = 3;
	ws = 0.0;
	we = 1.0;
	pParent = Parrent;
	DrawCPts = FALSE;
	DrawNoCvs = FALSE;
	pS = NULL;
	pE = NULL;
	iInc = -1;
	dLSize = 1;
}

void NCurve::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
}

CString NCurve::GetKnotString() {
	CString sK;
	int i;
	char S1[80];

	for (i = 0; i < iNoCPts + p + 1; i++) {
		sprintf_s(S1, "%g,", knots[i]);
		sK += S1;
	}
	return (sK);
}

void NCurve::Info() {
	int i;
	char S1[80];
	sprintf_s(S1, "%s", "CURVE OBJECT");
	outtext1(S1);
	G_Object::Info();
	sprintf_s(S1, "Curve Type: %i LAYER:: %i", iType, iFile);
	outtext1(S1);
	sprintf_s(S1, "%s%i", "Curve Mesh Increment : ", iInc);
	outtext1(S1);
	sprintf_s(S1, "Order: %i", p);
	outtext1(_T(S1));
	CString sO;
	for (i = 0; i < iNoCPts; i++) {
		sprintf_s(S1, "LAB: %i X: %f Y: %f Z: %f W: %f", iLabel, cPts[i]->Pt_Point->x, cPts[i]->Pt_Point->y,
		          cPts[i]->Pt_Point->z, cPts[i]->w);
		outtext1(_T(S1));
	}
	outtext1("Knot Sequence:-");
	for (i = 0; i < iNoCPts + p + 1; i++) {
		sprintf_s(S1, "%g,", knots[i]);
		sO += S1;
	}
	outtext1(sO);
}

C3dVector NCurve::Get_Centroid() {
	return (GetPt((ws + we) / 2));
}

void NCurve::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << dLSize;
		ar << iInc;
		ar << iLnThk;
		ar << iLnType;
		ar << iNoCPts;
		ar << p;
		ar << ws;
		ar << we;
		ar << DrawCPts;
		ar << vS.x;
		ar << vS.y;
		ar << vS.z;
		ar << vE.x;
		ar << vE.y;
		ar << vE.z;
		for (i = 0; i < iNoCPts; i++) {
			cPts[i]->Serialize(ar, iV);
		}
		for (i = 0; i < iNoCPts + p + 1; i++) {
			ar << knots[i];
		}
	} else {
		G_Object::Serialize(ar, iV);
		if (iV < -51) {
			ar >> dLSize;
			ar >> iInc;
		} else {
			iInc = -1;
		}
		ar >> iLnThk;
		ar >> iLnType;
		ar >> iNoCPts;
		ar >> p;
		ar >> ws;
		ar >> we;
		ar >> DrawCPts;
		if (iV <= -50) {
			ar >> vS.x;
			ar >> vS.y;
			ar >> vS.z;
			ar >> vE.x;
			ar >> vE.y;
			ar >> vE.z;
		}
		for (i = 0; i < iNoCPts; i++) {
			cPts[i] = new CvPt_Object();
			cPts[i]->Serialize(ar, iV);
			cPts[i]->pParent = this;
		}
		for (i = 0; i < iNoCPts + p + 1; i++) {
			ar >> knots[i];
		}
	}
}

G_Object* NCurve::Copy(G_Object* Parrent) {
	int i;
	NCurve* cPoly = new NCurve();
	cPoly->iType = iType;
	cPoly->Drawn = Drawn;
	cPoly->Selectable = Selectable;
	cPoly->Visable = Visable;
	cPoly->iColour = iColour;
	cPoly->iObjType = iObjType;
	cPoly->iLabel = iLabel;
	cPoly->iNoCPts = iNoCPts;
	cPoly->p = p;
	cPoly->ws = ws;
	cPoly->we = we;
	cPoly->iInc = iInc;
	cPoly->dLSize = dLSize;
	cPoly->pParent = Parrent;
	cPoly->iLnThk = iLnThk;
	cPoly->iLnType = iLnType;
	for (i = 0; i < iNoCPts; i++) {
		cPoly->cPts[i] = new CvPt_Object();
		cPoly->cPts[i] = (CvPt_Object*) cPts[i]->Copy(cPoly);
	}
	for (i = 0; i < iNoCPts + p + 1; i++) {
		cPoly->knots[i] = knots[i];
	}
	return (cPoly);
}

void NCurve::GetContolPts(Vec<C4dVector>& Cpts) {
	int i;
	double w;
	Cpts.Size(iNoCPts);

	for (i = 0; i < iNoCPts; i++) {
		w = cPts[i]->w;
		Cpts(i).xw = cPts[i]->Pt_Point->x * w;
		Cpts(i).yw = cPts[i]->Pt_Point->y * w;
		Cpts(i).zw = cPts[i]->Pt_Point->z * w;
		Cpts(i).w;
	}
}

void NCurve::GetcPts(Vec<C3dVector>& Cpts) {
	int i;

	Cpts.Size(iNoCPts);

	for (i = 0; i < iNoCPts; i++) {
		Cpts(i).x = cPts[i]->Pt_Point->x;
		Cpts(i).y = cPts[i]->Pt_Point->y;
		Cpts(i).z = cPts[i]->Pt_Point->z;
	}
}

void NCurve::GetKnotVec(Vec<double>& U) {
	int i;

	int iNoK = (iNoCPts) + p + 1;
	U.Size(iNoK);
	for (i = 0; i < iNoK; i++) {
		U(i) = knots[i];
	}
}

int NCurve::knotInsertion(double u, int r, int& kk, Vec<C4dVector>& ncP, Vec<double>& ncU) {
	// Compute k and s      u = [ u_k , u_k+1)  with u_k having multiplicity s
	int k = 0, s = 0;
	int i, j;
	int deg_ = p;
	Vec<C4dVector> P;
	GetContolPts(P);
	Vec<double> U;
	GetKnotVec(U);
	if (u < U[deg_] || u > U[P.n]) {
		// ERROR: out of range
	}
	for (i = 0; i < U.n; i++) {
		if (U[i] > u) {
			k = i - 1;
			break;
		}
	}
	if (u <= U[k]) {
		s = 1;
		for (i = k; i > deg_; i--) {
			if (U[i] <= U[i - 1])
				s++;
			else
				break;
		}
	} else {
		s = 0;
	}

	if ((r + s) > p + 1)
		r = p + 1 - s;

	if (r <= 0)
		return 0;

	ncU.Size(U.n + r);

	// Load new knot vector
	for (i = 0; i <= k; i++)
		ncU[i] = U[i];
	for (i = 1; i <= r; i++)
		ncU[k + i] = u;
	for (i = k + 1; i < U.n; i++)
		ncU[i + r] = U[i];

	// Save unaltered control points
	ncP.Size(P.n + r);
	Vec<C4dVector> R(p + 1);

	for (i = 0; i <= k - p; i++)
		ncP[i] = P[i];
	for (i = k - s; i < P.n; i++)
		ncP[i + r] = P[i];
	for (i = 0; i <= p - s; i++)
		R[i] = P[k - p + i];

	// Insert the knot r times
	int L = 0;
	double alpha;
	for (j = 1; j <= r; j++) {
		L = k - p + j;
		for (i = 0; i <= p - j - s; i++) {
			alpha = (u - U[L + i]) / (U[i + k + 1] - U[L + i]);
			R[i] = R[i + 1] * alpha + R[i] * (1.0 - alpha);
		}
		ncP[L] = R[0];
		if (p - j - s > 0)
			ncP[k + r - j - s] = R[p - j - s];
	}

	// Load remaining control points
	for (i = L + 1; i < k - s; i++) {
		ncP[i] = R[i - L];
	}
	P.DeleteAll();
	U.DeleteAll();
	R.DeleteAll();
	kk = k;
	return r;
}

void NCurve::refineKnotVector(Vec<double>& XVec, Vec<C4dVector>& P, Vec<double>& U) {
	int deg_ = p;
	Vec<C4dVector> cP;
	GetContolPts(cP);
	Vec<double> cU;
	GetKnotVec(cU);

	int n = cP.n - 1;
	int m = n + p + 1;
	int a, b;
	int r = XVec.n - 1;

	P.Size(r + 1 + n + 1);
	U.Size(r + 1 + n + 1 + p + 1);

	a = FindSpan(XVec[0]);
	b = FindSpan(XVec[r]);
	++b;
	int j;
	for (j = 0; j <= a - p; j++)
		P[j] = cP[j];
	for (j = b - 1; j <= n; j++)
		P[j + r + 1] = cP[j];
	for (j = 0; j <= a; j++)
		U[j] = cU[j];
	for (j = b + p; j <= m; j++)
		U[j + r + 1] = cU[j];
	int i = b + p - 1;
	int k = b + p + r;
	for (j = r; j >= 0; j--) {
		while (XVec[j] <= cU[i] && i > a) {
			P[k - p - 1] = cP[i - p - 1];
			U[k] = cU[i];
			--k;
			--i;
		}
		P[k - p - 1] = P[k - p];
		for (int l = 1; l <= p; l++) {
			int ind = k - p + l;
			double alpha = U[k + l] - XVec[j];
			if (alpha == 0.0)
				P[ind - 1] = P[ind];
			else
				alpha /= U[k + l] - cU[i - p + l];
			P[ind - 1] = P[ind - 1] * alpha + P[ind] * (1.0 - alpha);
		}
		U[k] = XVec[j];
		--k;
	}
}

double NCurve::chordLengthParam(const Vec<C3dVector>& Q, Vec<double>& ub) {
	int i;
	double d = 0;
	C3dVector T;
	ub.Size(Q.n);
	ub[0] = 0;
	for (i = 1; i < ub.n; i++) {
		T = Q[i];
		T -= Q[i - 1];
		d += T.Mag();
	}
	if (d > 0) {
		for (i = 1; i < ub.n - 1; ++i) {
			T = Q[i];
			T -= Q[i - 1];
			ub[i] = ub[i - 1] + T.Mag() / d;
		}
		ub[ub.n - 1] = 1.0; // In case there is some addition round-off
	}
	return d;
}

void NCurve::knotAveraging(const Vec<double>& uk, int deg, Vec<double>& U) {
	U.Size(uk.n + deg + 1);

	int j;
	for (j = 1; j < uk.n - deg; ++j) {
		U[j + deg] = 0.0;
		for (int i = j; i < j + deg; ++i)
			U[j + deg] += uk[i];
		U[j + deg] /= deg;
	}
	for (j = 0; j <= deg; ++j)
		U[j] = 0.0;
	for (j = U.n - deg - 1; j < U.n; ++j)
		U[j] = 1.0;
}

void NCurve::globalInterp(int d, Vec<C4dVector>& nP, Vec<double>& nU) {
	int i, j;
	Vec<C3dVector> Q;
	Vec<double> ub;
	p = d;
	GetcPts(Q);
	chordLengthParam(Q, ub);

	nP.Size(Q.n);
	nU.Size(Q.n + d + 1);

	Matrix<double> A(Q.n, Q.n);
	knotAveraging(ub, d, nU);

	// Initialize the basis matrix A
	double N[10];
	for (i = 0; i < A.m; i++) {
		for (j = 0; j < A.n; j++)
			A(i, j) = 0;
	}

	for (i = 1; i < Q.n - 1; i++) {
		int span = FindSpan2(d, nU, ub[i]);
		BasisFun2(d, span, ub[i], nU, N);
		for (j = 0; j <= d; j++)
			A(i, span - d + j) = N[j];
	}
	A(0, 0) = 1.0;
	A(Q.n - 1, Q.n - 1) = 1.0;

	//// Init matrix for LSE
	Matrix<double> qq(Q.n, 3);
	Matrix<double> xx;
	for (i = 0; i < Q.n; i++) {
		qq(i, 0) = Q[i].x;
		qq(i, 1) = Q[i].y;
		qq(i, 2) = Q[i].z;
	}
	double dd;
	for (i = 0; i < A.m; i++) {
		dd = A(i, 0);
	}
	A.Invert();
	for (i = 0; i < A.m; i++) {
		dd = A(i, 0);
	}

	A.Mult(qq, xx);
	for (i = 0; i < Q.n; i++) {
		nP[i].xw = xx(i, 0);
		nP[i].yw = xx(i, 1);
		nP[i].zw = xx(i, 2);
		nP[i].w = 1;
	}
	// clean up
	A.DeleteAll();
	qq.DeleteAll();
	ub.DeleteAll();
	Q.DeleteAll();
	xx.DeleteAll();

	// solve(A,qq,xx) ;

	//// Store the data
	// for(i=0;i<xx.rows();i++){
	//   for(j=0;j<D;j++)
	//     P[i].data[j] = (T)xx(i,j) ;
	//   P[i].w() = 1.0 ;
	// }
}

void NCurve::AddVert(C3dVector pInVertex1, double dWght) {
	if (iNoCPts < MAX_CVPTS) {
		cPts[iNoCPts] = new CvPt_Object();
		cPts[iNoCPts]->Create(pInVertex1, dWght, 0, 0, 0, 12, this);
		iNoCPts++;
	} else {
		outtext1("ERROR: Max No of Points Exceeded.");
	}
}

void NCurve::Generate(int inp) {
	p = inp;
	int i;
	int ind = 0;
	double span;
	span = 1.0 / (iNoCPts - p);

	for (i = 0; i < p; i++) {
		knots[ind] = 0;
		ind++;
	}
	for (i = 0; i < iNoCPts - p + 1; i++) {
		knots[ind] = span * i;
		ind++;
	}
	for (i = 0; i < p; i++) {
		knots[ind] = 1;
		ind++;
	}
}

void NCurve::GenerateExp(double Deg, Vec<C4dVector>& P, Vec<double>& U) {
	int i;
	C3dVector V;
	double W;
	Clean();
	p = (int) Deg;
	for (i = 0; i < P.n; i++) {
		if (iNoCPts < MAX_CVPTS) {
			W = P[i].w;
			V.x = P[i].xw;
			V.y = P[i].yw;
			V.z = P[i].zw;
			cPts[iNoCPts] = new CvPt_Object();
			cPts[iNoCPts]->Create(V, W, 0, 0, 0, 12, this);
			iNoCPts++;
		} else {
			outtext1("ERROR: Max No of Points Exceeded.");
		}
	}
	for (i = 0; i < U.n; i++) {
		knots[i] = U[i];
	}
}

int NCurve::FindSpan(double u) {
	int iRet;
	int low, mid, high;

	if (u == knots[iNoCPts]) {
		iRet = iNoCPts - 1;
	} else {
		low = p;
		high = iNoCPts;
		mid = (low + high) / 2;
		while ((u < knots[mid]) || (u >= knots[mid + 1])) {
			if (u < knots[mid]) {
				high = mid;
			} else {
				low = mid;
			}
			mid = (low + high) / 2;
		}
		iRet = mid;
	}
	return (iRet);
}

int NCurve::FindSpan2(double deg, const Vec<double>& U, double u) {
	int iRet;
	int low, mid, high;

	if (u == U[iNoCPts]) {
		iRet = iNoCPts - 1;
	} else {
		low = (int) deg;
		high = iNoCPts;
		mid = (low + high) / 2;
		while ((u < U[mid]) || (u >= U[mid + 1])) {
			if (u < U[mid]) {
				high = mid;
			} else {
				low = mid;
			}
			mid = (low + high) / 2;
		}
		iRet = mid;
	}
	return (iRet);
}

void NCurve::BasisFun(double deg, int i, double u, double N[10]) {
	int j;
	int r;
	double left[20];
	double right[20];
	double saved;
	double temp;
	N[0] = 1.0;
	for (j = 1; j <= deg; j++) {
		left[j] = u - knots[i + 1 - j];
		right[j] = knots[i + j] - u;
		saved = 0.0;
		for (r = 0; r < j; r++) {
			temp = N[r] / (right[r + 1] + left[j - r]);
			N[r] = saved + right[r + 1] * temp;
			saved = left[j - r] * temp;
		}
		N[j] = saved;
	}
}

void NCurve::BasisFun2(double deg, int i, double u, const Vec<double>& U, double N[10]) {
	int j;
	int r;
	double left[20];
	double right[20];
	double saved;
	double temp;
	N[0] = 1.0;
	for (j = 1; j <= deg; j++) {
		left[j] = u - U[i + 1 - j];
		right[j] = U[i + j] - u;
		saved = 0.0;
		for (r = 0; r < j; r++) {
			temp = N[r] / (right[r + 1] + left[j - r]);
			N[r] = saved + right[r + 1] * temp;
			saved = left[j - r] * temp;
		}
		N[j] = saved;
	}
}

void NCurve::binomialCoef(Mat* Bin) {
	int n, k;
	// Setup the first line
	*Bin->mn2(0, 0) = 1.0;
	for (k = Bin->n - 1; k > 0; --k) {
		*Bin->mn2(0, k) = 0.0;
	}
	// Setup the other lines
	for (n = 0; n < Bin->m - 1; n++) {
		*Bin->mn2(n + 1, 0) = 1.0;
		for (k = 1; k < Bin->n; k++) {
			if (n + 1 < k)
				*Bin->mn2(n, k) = 0.0;
			else
				*Bin->mn2(n + 1, k) = *Bin->mn2(n, k) + *Bin->mn2(n, k - 1);
		}
	}
}

void NCurve::deriveAt(double u, int d, C3dVector CK[10]) {
	C4dVector ders[10];
	int deg_ = p;
	int du;
	du = d;
	if (deg_ < d) {
		du = deg_;
	}
	int iSpan;
	Mat* derF;

	iSpan = FindSpan(u);
	derF = dersBasisFuns(du, u, iSpan);

	int k;
	for (k = du; k >= 0; --k) {
		ders[k].Clear();
		for (int j = deg_; j >= 0; --j) {
			ders[k].xw += *derF->mn2(k, j) * (cPts[iSpan - deg_ + j]->Pt_Point->x * cPts[iSpan - deg_ + j]->w);
			ders[k].yw += *derF->mn2(k, j) * (cPts[iSpan - deg_ + j]->Pt_Point->y * cPts[iSpan - deg_ + j]->w);
			ders[k].zw += *derF->mn2(k, j) * (cPts[iSpan - deg_ + j]->Pt_Point->z * cPts[iSpan - deg_ + j]->w);
			ders[k].w += *derF->mn2(k, j) * (cPts[iSpan - deg_ + j]->w);
		}
	}
	Mat* Bin = new Mat(d + 1, d + 1);
	binomialCoef(Bin);
	C3dVector v;
	int i;
	for (k = 0; k <= du; k++) {
		v.x = ders[k].xw;
		v.y = ders[k].yw;
		v.z = ders[k].zw;
		for (i = 1; i <= k; i++) {
			v.x = v.x - (*Bin->mn2(k, i)) * ders[i].w * CK[k - i].x;
			v.y = v.y - (*Bin->mn2(k, i)) * ders[i].w * CK[k - i].y;
			v.z = v.z - (*Bin->mn2(k, i)) * ders[i].w * CK[k - i].z;
		}
		CK[k].x = v.x / ders[0].w;
		CK[k].y = v.y / ders[0].w;
		CK[k].z = v.z / ders[0].w;
	}
	delete (derF);
	delete (Bin);
}

Mat* NCurve::dersBasisFuns(int n, double u, int span) {
	int deg_ = p;
	double* left = new double[2 * (deg_ + 1)];
	double* right = &left[deg_ + 1];

	Mat* ndu = new Mat(deg_ + 1, deg_ + 1);
	double saved, temp;
	int j, r;

	Mat* ders = new Mat(n + 1, deg_ + 1);

	*ndu->mn2(0, 0) = 1.0;
	for (j = 1; j <= deg_; j++) {
		left[j] = u - knots[span + 1 - j];
		right[j] = knots[span + j] - u;
		saved = 0.0;
		for (r = 0; r < j; r++) {
			// Lower triangle
			*ndu->mn2(j, r) = right[r + 1] + left[j - r];
			temp = *ndu->mn2(r, j - 1) / (*ndu->mn2(j, r));
			// Upper triangle
			*ndu->mn2(r, j) = saved + right[r + 1] * temp;
			saved = left[j - r] * temp;
		}

		*ndu->mn2(j, j) = saved;
	}

	for (j = deg_; j >= 0; --j)
		*ders->mn2(0, j) = *ndu->mn2(j, deg_);

	// Compute the derivatives
	Mat* a = new Mat(deg_ + 1, deg_ + 1);
	for (r = 0; r <= deg_; r++) {
		int s1, s2;
		s1 = 0;
		s2 = 1; // alternate rows in array a
		*a->mn2(0, 0) = 1.0;
		// Compute the kth derivative
		for (int k = 1; k <= n; k++) {
			double d;
			int rk, pk, j1, j2;
			d = 0.0;
			rk = r - k;
			pk = deg_ - k;

			if (r >= k) {
				*a->mn2(s2, 0) = (*a->mn2(s1, 0)) / (*ndu->mn2(pk + 1, rk));
				d = *a->mn2(s2, 0) * (*ndu->mn2(rk, pk));
			}

			if (rk >= -1) {
				j1 = 1;
			} else {
				j1 = -rk;
			}

			if (r - 1 <= pk) {
				j2 = k - 1;
			} else {
				j2 = deg_ - r;
			}

			for (j = j1; j <= j2; j++) {
				*a->mn2(s2, j) = (*a->mn2(s1, j) - *a->mn2(s1, j - 1)) / (*ndu->mn2(pk + 1, rk + j));
				d += *a->mn2(s2, j) * *ndu->mn2(rk + j, pk);
			}

			if (r <= pk) {
				*a->mn2(s2, k) = -(*a->mn2(s1, k - 1)) / (*ndu->mn2(pk + 1, r));
				d += *a->mn2(s2, k) * (*ndu->mn2(r, pk));
			}
			*ders->mn2(k, r) = d;
			j = s1;
			s1 = s2;
			s2 = j; // Switch rows
		}
	}

	// Multiply through by the correct factors
	r = deg_;
	for (int k = 1; k <= n; k++) {
		for (j = deg_; j >= 0; --j)
			*ders->mn2(k, j) *= r;
		r *= deg_ - k;
	}
	delete (a);
	delete (left);
	delete (ndu);
	return (ders);
}

void NCurve::CPolyRot(double dAng) {
	int i;
	C3dVector vT1, a, b;
	for (i = 0; i < iNoCPts; i++) {
		vT1.x = cPts[i]->Pt_Point->x;
		vT1.y = cPts[i]->Pt_Point->y;
		vT1.z = cPts[i]->Pt_Point->z;
		vT1.Rotate(a, b, dAng);
		cPts[i]->Pt_Point->x = vT1.x;
		cPts[i]->Pt_Point->y = vT1.y;
		cPts[i]->Pt_Point->z = vT1.z;
	}
}

void NCurve::Translate(C3dVector vIn) {
	int i;

	for (i = 0; i < iNoCPts; i++) {
		cPts[i]->Pt_Point->x += vIn.x;
		cPts[i]->Pt_Point->y += vIn.y;
		cPts[i]->Pt_Point->z += vIn.z;
	}
}

void NCurve::ScaleX(double d) {
	int i;

	for (i = 0; i < iNoCPts; i++) {
		cPts[i]->Pt_Point->x *= d;
	}
}

void NCurve::ScaleW(double dIn) {
	int i;
	for (i = 0; i < iNoCPts; i++) {
		cPts[i]->w *= dIn;
	}
}

int NCurve::GetOrder() {
	return (p);
}

C3dVector NCurve::MinPt(C3dVector inPt) {
	C3dVector vRet;
	const double dIncs = 36.0;
	int i;
	double dStp = 1 / dIncs;
	double dW = 0;
	double dMinW = 0;
	C3dVector cPt;
	C3dVector tPt;
	C3dVector cNextPt;
	double dWScl;
	double Dist;
	double minDist = 1e36;
	C3dVector v1;
	C3dVector v2;

	cPt = GetPt(dW);
	tPt = GetPt(dW + dStp);
	dWScl = cPt.Dist(tPt);
	for (i = 0; i < dIncs; i++) {
		dW = i * dStp;
		cPt = GetPt(dW);
		Dist = cPt.Dist(inPt);
		if (Dist < minDist) {
			minDist = Dist;
			dMinW = dW;
		}
	}
	// start of iteration
	dW = dMinW;
	double dWStp = dStp;
	double sw = 0.0000001; // delta w small increment for test direction or reducing dist
	C3dVector PtPlusW;
	C3dVector PtMinW;
	double dC;
	double dM;
	double dP;
	double dWp;
	double dWm;
	i = 0;
	C3dVector vT;
	do {
		cPt = GetPt(dW);
		dWp = dW + sw;
		dWm = dW - sw;
		// Out of parametric bounds conditions
		if (dWp > 1) {
			if (iType == 3)
				dWp -= 1;
			else
				dWp = 1;
		}
		if (dWm < 0) {
			if (iObjType == 3)
				dWm += 1;
			else
				dWm = 0;
		}
		PtPlusW = GetPt(dWp);
		PtMinW = GetPt(dWm);
		vT = inPt - cPt;
		dC = vT.Mag();
		vT = inPt - PtPlusW;
		dP = vT.Mag();
		vT = inPt - PtMinW;
		dM = vT.Mag();
		dWStp *= 0.5;
		if (dP < dC)
			dW += dWStp;
		if (dM < dC)
			dW -= dWStp;
		// Out of parametric bounds conditions
		if (iObjType == 3) {
			if (dW < 0)
				dW = dW + 1;
			if (dW > 1)
				dW = dW - 1;
		} else {
			if (dW < 0)
				dW = 0;
			if (dW > 1)
				dW = 1;
		}
		i++;
	} while ((dWStp > dTol) && (i < 100));
	vRet = GetPt(dW);
	// char S1[200];
	// CString OutT;
	// sprintf_s(S1, "MIN PT INT: ,%i %f", i, dWStp);
	// outtext1(S1);
	return (vRet);
}

double NCurve::MinWPt(C3dVector inPt) {
	C3dVector vRet;
	const double dIncs = 36;
	int i;
	double dStp = 1 / dIncs;
	double dlStp;
	double dW = 0;
	double dMinW = 0;
	C3dVector cPt;
	C3dVector tPt;
	C3dVector cNextPt;
	double dWScl;
	double Dist;
	double minDist = 1e36;
	C3dVector v1;
	C3dVector v2;
	double dM;
	double dDot;
	cPt = GetPt(dW);
	tPt = GetPt(dW + dStp);
	dWScl = cPt.Dist(tPt);
	for (i = 0; i < dIncs; i++) {
		dW = i * dStp;
		cPt = GetPt(dW);
		Dist = cPt.Dist(inPt);
		if (Dist < minDist) {
			minDist = Dist;
			dMinW = dW;
		}
	}
	// start of iteration
	dW = dMinW;
	dlStp = dStp;
	i = 0;
	do {
		cPt = GetPt(dW);
		// cNextPt=GetPt(dW+0.0000001);
		// v1=cNextPt;
		v1 = GetDir(dW);
		v2 = inPt;
		v2 -= cPt;
		dM = v2.Mag();
		v1.Normalize();
		v2.Normalize();
		dDot = v2.Dot(v1);
		dlStp = (dM * dDot / dWScl) * 1 * dStp;
		dW = dW + dlStp;
		if (dW < 0) {
			dW = 0;
		}
		if (dW > 1) {
			dW = 1;
		}
		i++;
	} while ((pow((dlStp * dlStp), 0.5) > dTol) & (i < 10000));
	vRet = GetPt(dW);
	return (dW);
}

//***********************************************************************
// This check for the ambiguity of projecting 0 & 1 paremetric
// values to a closed surface
//***********************************************************************
void NCurve::EndPtChk01(NSurf* pSurf,
                        double dS,
                        C3dVector* pSfS,
                        double dE,
                        C3dVector* pSfE) {
	C3dVector p3dC;
	C3dVector pTST;
	BOOL isClosedU = pSurf->isClosedinU();
	BOOL isClosedV = pSurf->isClosedinV();
	// Round of numerical errors
	if (abs(pSfS->x) < PARA_NEAR_ZERO)
		pSfS->x = 0;
	if (abs(pSfS->y) < PARA_NEAR_ZERO)
		pSfS->y = 0;
	if (abs(pSfS->x - 1) < PARA_NEAR_ZERO)
		pSfS->x = 1;
	if (abs(pSfS->y - 1) < PARA_NEAR_ZERO)
		pSfS->y = 1;
	if (abs(pSfE->x) < PARA_NEAR_ZERO)
		pSfE->x = 0;
	if (abs(pSfE->y) < PARA_NEAR_ZERO)
		pSfE->y = 0;
	if (abs(pSfE->x - 1) < PARA_NEAR_ZERO)
		pSfE->x = 1;
	if (abs(pSfE->y - 1) < PARA_NEAR_ZERO)
		pSfE->y = 1;
	//********************************************************
	if (isClosedU) {
		if ((pSfS->x == 0) || (pSfS->x == 1)) {
			p3dC = this->GetPt(0.1 * (ws + we));
			pTST = pSurf->MinPtW(p3dC);
			if (pTST.x > 0.5)
				pSfS->x = 1;
			else
				pSfS->x = 0;
		}
		if ((pSfE->x == 0) || (pSfE->x == 1)) {
			p3dC = this->GetPt(1 - 0.1 * (ws + we));
			pTST = pSurf->MinPtW(p3dC);
			if (pTST.x > 0.5)
				pSfE->x = 1;
			else
				pSfE->x = 0;
		}
	}
	if (isClosedV) {
		// Check Both End for 0-1 confussion
		if ((pSfS->y == 0) || (pSfS->y == 1)) {
			p3dC = this->GetPt(0.1 * (ws + we));
			pTST = pSurf->MinPtW(p3dC);
			if (pTST.y > 0.5)
				pSfS->y = 1;
			else
				pSfS->y = 0;
		}
		if ((pSfE->y == 0) || (pSfE->y == 1)) {
			p3dC = this->GetPt(1 - 0.1 * (ws + we));
			pTST = pSurf->MinPtW(p3dC);
			if (pTST.y > 0.5)
				pSfE->y = 1;
			else
				pSfE->y = 0;
		}
	}
}

CString NCurve::GetName() {
	return ("NCurve");
}

BOOL NCurve::IsClosed() {
	BOOL bRet = FALSE;
	double dDist = 0;
	C3dVector vS;
	C3dVector vE;
	vS = GetPt(ws);
	vE = GetPt(we);
	dDist = vS.Dist(vE);
	if (dDist < dTol)
		bRet = TRUE;
	return (bRet);
}

int NCurve::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "Layer";
	iNo++;
	sVar[iNo] = "KNOT Vector";
	iNo++;
	sVar[iNo] = "U Start";
	iNo++;
	sVar[iNo] = "U End";
	iNo++;
	return (iNo);
}

int NCurve::GetVarValues(CString sVar[]) {
	int i;
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	CString sKnots = "";
	for (i = 0; i < iNoCPts + p; i++) {
		sprintf_s(S1, "%g,", knots[i]);
		sKnots += S1;
	}
	sprintf_s(S1, "%g", knots[iNoCPts + p]);
	sKnots += S1;
	// CString str = str(3.1);
	sVar[iNo] = sKnots;
	iNo++;
	sprintf_s(S1, "%g", ws);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", we);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void NCurve::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	int i = 0;
	int index = 0;
	iFile = atoi(sVar[0]);
	CString line = _T(sVar[1]);
	CString field;
	CArray<CString, CString> v;
	while (AfxExtractSubString(field, line, index, _T(','))) {
		v.Add(field);
		++index;
	}
	if (index == iNoCPts + p + 1) {
		for (i = 0; i < iNoCPts + p + 1; i++) {
			knots[i] = atof(v[i]);
		}
	}
	double uS, uE;
	uS = atof(sVar[2]);
	uE = atof(sVar[3]);
	if ((uS >= 0.0) && (uS <= 1.0) && (uS < uE))
		ws = uS;
	if ((uE >= 0.0) && (uE <= 1.0) && (uE > uS))
		we = uE;
}

void NCurve::ExportDXF(FILE* pFile) {
	// Write the spline
	int iL;
	iL = iFile;
	if (iL < 0)
		iL = 0;

	// value 70 are bitwise flags defining the spline
	// 1 = Closed spline
	// 2 = Periodic spline
	// 4 = Rational spline
	// 8 = Planar
	// 16 = Linear (planar bit is also set)
	// 32.... 256 - knot param.
	// 32 = chord
	// 64 = sqrt. chord
	// 128 = uniform
	// 256 = custom
	// 512 =  CV frame visibility
	// 1024 = if present, the spline is defined by fit points. Otherwise, by control vertices.
	fprintf(pFile, "SPLINE\n");
	fprintf(pFile, "  8\n");
	fprintf(pFile, "%s\n", "All"); // Layer number
	fprintf(pFile, " 70\n");
	fprintf(pFile, "4\n"); // rational b spline
	fprintf(pFile, " 71\n");
	fprintf(pFile, "%i\n", p); // write the degree of the NURBS spline
	fprintf(pFile, " 72\n");
	fprintf(pFile, "%i\n", iNoCPts + p + 1); // no of knots
	fprintf(pFile, " 73\n");
	fprintf(pFile, "%i\n", iNoCPts); // no of control point
	// Write the knots
	for (int i = 0; i < iNoCPts + p + 1; ++i) {
		fprintf(pFile, " 40\n"); // write a line with value 10
		fprintf(pFile, "%g\n", knots[i]);
	}
	// Write the control points for the spline
	for (int i = 0; i < iNoCPts; ++i) {
		fprintf(pFile, " 10\n"); // write a line with value 10
		fprintf(pFile, "%g\n", cPts[i]->Pt_Point->x); // write the x-coordinate of the control point
		fprintf(pFile, " 20\n"); // write a line with value 20
		fprintf(pFile, "%g\n", cPts[i]->Pt_Point->y); // write the y-coordinate of the control point
		fprintf(pFile, " 30\n"); // write a line with value 30
		fprintf(pFile, "%g\n", cPts[i]->Pt_Point->z); // write the z-coordinate of the control point
		fprintf(pFile, " 41\n");
		fprintf(pFile, "%g\n", cPts[i]->w);
	}

	// Write the spline properties
	fprintf(pFile, "  0\n"); // write a line with value 0
}

NCurveOnSurf* NCurve::GetSurfaceCV(NSurf* pSurf) {
	int i;
	BOOL bPl;
	C3dVector pt;
	NCurveOnSurf* pS = new NCurveOnSurf();
	pS->Drawn = Drawn;
	pS->Selectable = Selectable;
	pS->Visable = Visable;
	pS->iColour = iColour;
	pS->iObjType = 13;
	pS->iLabel = iLabel;
	pS->iNoCPts = iNoCPts;
	pS->p = p;
	pS->ws = ws;
	pS->we = we;
	pS->pParent = pSurf;
	bPl = pSurf->isPlanar();
	for (i = 0; i < iNoCPts + p + 1; i++) {
		pS->knots[i] = knots[i];
	}

	for (i = 0; i < iNoCPts; i++) {
		pt = cPts[i]->Pt_Point;
		pt = pSurf->MinPtW(pt);
		pS->cPts[i] = new CvPt_ObjectW();
		pS->cPts[i]->Create(pt, cPts[i]->w, -1, 55, 1, 1, pS);
	}
	return (pS);
}

NCurveOnSurf* NCurve::GetSurfaceCV2(NSurf* pSurf) {
	int i;
	C3dVector pt;
	NCurveOnSurf* pS = new NCurveOnSurf();
	pS->Drawn = Drawn;
	pS->Selectable = Selectable;
	pS->Visable = Visable;
	pS->iColour = iColour;
	pS->iObjType = 13;
	pS->iLabel = iLabel;
	pS->iNoCPts = iNoCPts;
	pS->p = p;
	pS->ws = ws;
	pS->we = we;
	pS->pParent = pSurf;

	for (i = 0; i < iNoCPts + p + 1; i++) {
		pS->knots[i] = knots[i];
	}

	for (i = 0; i < iNoCPts; i++) {
		pt = cPts[i]->Pt_Point;
		pS->cPts[i] = new CvPt_ObjectW();
		pS->cPts[i]->Create(pt, cPts[i]->w, -1, 55, 1, 1, pS);
	}
	return (pS);
}

//***********************************************************************
// THIS PROJECTION CHECKS THE FOLLOWING
// CASE 1) If Its a planar curve in plane of a planar surface
// CASE 2) IF Its not a planar survce are the the curve to be pojected
//         actually isoline - then the segement on the surface is a
//         line 2 points (like cylinder trims)
// CASE 3) Must poject multiple point and fit curve 2nd order.
// ELSE Fail
//***********************************************************************

NCurveOnSurf* NCurve::GetSurfaceCV3(NSurf* pSurf) {
	const double dIncs = 10;
	double dStp;
	dStp = (we - ws) / dIncs;
	int j;
	double dCu;
	C3dVector pt;
	NCurveOnSurf* pS = NULL;
	BOOL bIsCv = FALSE;
	BOOL bPlainar = pSurf->isPlanar();
	C3dVector p3dC;
	C3dVector pSf;
	C3dVector pSfS;
	C3dVector pSfE;
	C3dVector pTST;
	double dCnstU;
	double dCnstV;
	BOOL bCnstU;
	BOOL bCnstV;

	if (bPlainar) {
		pS = GetSurfaceCV(pSurf);
	} else {
		// Test for isocurve
		// pick 10 points on curves if either u or v remain constant
		// it an iso curve
		p3dC = this->GetPt(ws);
		pSf = pSurf->MinPtW(p3dC);
		dCnstU = pSf.x;
		dCnstV = pSf.y;
		bCnstU = TRUE;
		bCnstV = TRUE;
		for (j = 1; j < dIncs; j++) {
			dCu = ws + j * dStp;
			p3dC = this->GetPt(dCu);
			pSf = pSurf->MinPtW(p3dC);
			if ((pSf.x < dCnstU - dTol) || (pSf.x > dCnstU + dTol))
				bCnstU = FALSE;
			if ((pSf.y < dCnstV - dTol) || (pSf.y > dCnstV + dTol))
				bCnstV = FALSE;
		}
		if (pSurf->iLabel == 25)
			pSurf->iLabel = 25;
		if ((bCnstU) || (bCnstV)) {
			// outtext1("Is Iso CUrve");
			pS = new NCurveOnSurf();
			pS->iLabel = iLabel;
			pS->p = 1;
			pS->ws = ws;
			pS->we = we;
			pS->pParent = pSurf;

			p3dC = this->GetPt(0);
			pSfS = pSurf->MinPtW(p3dC);
			p3dC = this->GetPt(1);
			pSfE = pSurf->MinPtW(p3dC);
			if (bCnstU) {
				// check v end pts
				if (pSfS.y == pSfE.y) // We have a problem
				{
					p3dC = this->GetPt(0 + 0.1);
					pTST = pSurf->MinPtW(p3dC);
					if (pTST.y > 0.5)
						pSfS.y = 1;
					p3dC = this->GetPt(1 - 0.1);
					pTST = pSurf->MinPtW(p3dC);
					if (pTST.y > 0.5)
						pSfE.y = 1;
				}
			}
			if (bCnstV) {
				if (pSfS.x == pSfE.x) // We have a problem
				{
					p3dC = this->GetPt(0 + 0.1);
					pTST = pSurf->MinPtW(p3dC);
					if (pTST.x > 0.5)
						pSfS.x = 1;
					p3dC = this->GetPt(1 - 0.1);
					pTST = pSurf->MinPtW(p3dC);
					if (pTST.x > 0.5)
						pSfE.x = 1;
				}
			}
			pS->AddVert(pSfS, 1);
			pS->AddVert(pSfE, 1);
			pS->knots[0] = 0.0;
			pS->knots[1] = 0.0;
			pS->knots[2] = 1.0;
			pS->knots[3] = 1.0;
		}
	}
	return (pS);
}

//******************************************************************
//      NON PLANAR SURF NOT ISOCURVE  ***GENERAL CASE***
//		CASE 3
//******************************************************************
NCurveOnSurf* NCurve::GetSurfaceCV4(NSurf* pSurf) {
	NCurveOnSurf* pS = NULL;
	C3dVector p3dC;
	C3dVector pSfS;
	C3dVector pSfE;
	C3dVector pTST;
	C3dVector pSfMid;
	p3dC = this->GetPt(this->ws);
	pSfS = pSurf->MinPtW(p3dC);
	p3dC = this->GetPt(0.5 * (this->ws + this->we));
	pSfMid = pSurf->MinPtW(p3dC);
	p3dC = this->GetPt(this->we);
	pSfE = pSurf->MinPtW(p3dC);
	this->EndPtChk01(pSurf, this->ws, &pSfS, this->we, &pSfE);

	pS = new NCurveOnSurf();
	pS->iLabel = iLabel;
	pS->p = 1;
	pS->ws = 0;
	pS->we = 1;
	pS->pParent = pSurf;

	pS->AddVert(pSfS, 1);
	pS->AddVert(pSfMid, 1);
	pS->AddVert(pSfE, 1);
	pS->knots[0] = 0.0;
	pS->knots[1] = 0.0;
	pS->knots[2] = 0.5;
	pS->knots[3] = 1.0;
	pS->knots[4] = 1.0;
	return (pS);
}

//************************************************************************************
// Test to see if this curve is an isocurve on pSurf
// retutns -1 not an iso-curve
// returns 1 for isocurve in u
// returns 2 for isocurve in v
//************************************************************************************
int NCurve::isIsoCurve(NSurf* pSurf) {
	int iret = -1;
	double dStp;
	dStp = (we - ws) / ISO_TEST_INC;
	int j;
	C3dVector p3dC;
	C3dVector pSf;
	C3dVector pSfS;
	C3dVector pSfE;
	C3dVector pTST;
	double dCnstU;
	double dCnstV;
	BOOL bCnstU;
	BOOL bCnstV;
	double dCu;

	// Test for isocurve
	// pick 10 points on curves if either u or v remain constant
	// it an iso curve
	p3dC = GetPt(ws);
	pSf = pSurf->MinPtW(p3dC);
	if ((abs(pSf.x) < PARA_NEAR_ZERO) || (abs(pSf.x - 1) < PARA_NEAR_ZERO))
		pSf.x = 0;
	dCnstU = pSf.x;
	if ((abs(pSf.y) < PARA_NEAR_ZERO) || (abs(pSf.y - 1) < PARA_NEAR_ZERO))
		pSf.y = 0;
	dCnstV = pSf.y;
	bCnstU = TRUE;
	bCnstV = TRUE;
	for (j = 1; j < ISO_TEST_INC; j++) {
		dCu = ws + j * dStp;
		p3dC = GetPt(dCu);
		pSf = pSurf->MinPtW(p3dC);
		if ((abs(pSf.x) < PARA_NEAR_ZERO) || (abs(pSf.x - 1) < PARA_NEAR_ZERO))
			pSf.x = 0;
		if ((abs(pSf.y) < PARA_NEAR_ZERO) || (abs(pSf.y - 1) < PARA_NEAR_ZERO))
			pSf.y = 0;
		if (abs(pSf.x - dCnstU) > PARA_NEAR_ZERO)
			bCnstU = FALSE;
		if (abs(pSf.y - dCnstV) > PARA_NEAR_ZERO)
			bCnstV = FALSE;
	}
	if (bCnstU)
		iret = 1;
	if (bCnstV)
		iret = 2;
	return (iret);
}

void NCurve::DrawCtrlPtsTog() {
	if (DrawCPts == TRUE) {
		DrawCPts = FALSE;
	} else {
		DrawCPts = TRUE;
	}
}

void NCurve::OglDraw(int iDspFlgs, double dS1, double dS2) {
	OglDrawW(iDspFlgs, dS1, dS2);
}

void NCurve::OglDrawCtrlPts() {
	int i;
	glColor3fv(cols[iColour]);
	glPointSize(15.0f);
	glBegin(GL_POINTS);
	for (i = 0; i < iNoCPts; i++) {
		glVertex3f((float) cPts[i]->Pt_Point->x, (float) cPts[i]->Pt_Point->y, (float) cPts[i]->Pt_Point->z);
	}
	glEnd();
}

void NCurve::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[80];
	int i = 0;
	double dt;
	if ((iDspFlgs & DSP_CURVES) > 0) {
		Selectable = 1;
		glColor3fv(cols[iColour]);
		if (DrawCPts || gDSP_CPTS) {
			OglDrawCtrlPts();
		}
		if (gDSP_CIRS) // put a s at start of circle helps woth trimming
		{
			sprintf_s(sLab, " S");
			OglString(iDspFlgs, cPts[0]->Pt_Point->x, cPts[0]->Pt_Point->y, cPts[0]->Pt_Point->z, &sLab[0]);
		}
		glColor3fv(cols[iColour]);
		C3dVector vPt;
		C3dVector vPt2;
		double dw = 0;
		double dSpan;
		double dInc = 0.005;
		int iNo;
		dSpan = we - ws;
		if (p > 0) {
			dt = dSpan / dInc;
			iNo = static_cast<int>(dt);
			dt = dSpan / iNo;
		}
		vPt = GetPt(ws);
		dw = ws;
		glLineWidth(iLnThk);
		// for dotted
		if (iLnType == 2) {
			glEnable(GL_LINE_STIPPLE);
			glLineStipple(1, 0x0101);
		} else if (iLnType == 3) {
			glEnable(GL_LINE_STIPPLE);
			glLineStipple(1, 0x00FF);
		}
		glBegin(GL_LINES);
		for (i = 0; i < iNo; i++) {
			dw += dt;
			if (dw > 1.0) {
				dw = 1;
			}
			vPt2 = GetPt(dw);
			glVertex3f((float) vPt.x, (float) vPt.y, (float) vPt.z);
			glVertex3f((float) vPt2.x, (float) vPt2.y, (float) vPt2.z);
			vPt = vPt2;
		}
		glEnd();
		glLineWidth(2.0);
		glDisable(GL_LINE_STIPPLE);
		C3dVector vCent;
		vCent = Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "C%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
	} else {
		Selectable = 0;
	}
}

double NCurve::CorrectW(double w) {
	return (w);
}

double NCurve::getLen() {
	int i;
	C3dVector p1;
	C3dVector p2;
	double dw = 0;
	double dLen = 0;
	for (i = 0; i < 99; i++) {
		p1 = GetPt(dw);
		p2 = GetPt(dw + 0.01);
		p1 -= p2;
		dLen += p1.Mag();
		dw += 0.01;
	}
	return (dLen);
}

void NCurve::Reverse() {
	int i;
	CvPt_Object* cPtsCp[MAX_CTPTS];
	// Note IMPORTANT for a non uniform knot seq
	// Need to reverse that to
	for (i = 0; i < iNoCPts; i++) {
		cPtsCp[i] = cPts[iNoCPts - i - 1];
	}
	for (i = 0; i < iNoCPts; i++) {
		cPts[i] = cPtsCp[i];
	}
}

void NCurve::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	int i;
	G_Object::SetToScr(pModMat, pScrTran);
	pModZ = pModMat;
	pScrZ = pScrTran;
	for (i = 0; i < iNoCPts; i++) {
		cPts[i]->SetToScr(pModMat, pScrTran);
	}
	// END POINTS
	C3dVector vT;
	if (pS == NULL) {
		pS = new CvPt_Object();
		pS->pParent = this;
	}
	vT = this->GetPt(ws);
	pS->Pt_Point->Set(vT.x, vT.y, vT.z);
	pS->SetToScr(pModMat, pScrTran);
	if (pE == NULL) {
		pE = new CvPt_Object();
		pE->pParent = this;
	}
	vT = this->GetPt(we);
	pE->Pt_Point->Set(vT.x, vT.y, vT.z);
	pE->SetToScr(pModMat, pScrTran);
}

void NCurve::Transform(C3dMatrix TMat) {
	int i;
	for (i = 0; i < iNoCPts; i++) {
		cPts[i]->Transform(TMat);
	}
}

void NCurve::HighLight(CDC* pDC) {
	double dw = 0;
	double dSpan;
	double dInc = 0.01;
	C3dVector vPt;
	int iNo;
	int i;

	dSpan = we - ws;
	double dt;
	dt = dSpan / dInc;
	iNo = (int) dt;
	dt = dSpan / iNo;
	dw = ws;
	vPt = GetPt(dw);
	Node* ThePoint = new Node;
	ThePoint->Create(vPt, 1, 0, 0, 11, 0, 0, NULL);
	ThePoint->SetToScr(pModZ, pScrZ);
	pDC->MoveTo((int) ThePoint->DSP_Point->x, (int) ThePoint->DSP_Point->y);
	for (i = 0; i < iNo; i++) {
		dw = dw + dt;
		vPt = GetPt(dw);
		ThePoint->Pt_Point->x = vPt.x;
		ThePoint->Pt_Point->y = vPt.y;
		ThePoint->Pt_Point->z = vPt.z;
		ThePoint->SetToScr(pModZ, pScrZ);
		pDC->LineTo((int) ThePoint->DSP_Point->x, (int) ThePoint->DSP_Point->y);
	}
	delete (ThePoint);
}

G_ObjectD NCurve::SelDist(CPoint InPT, Filter FIL) {
	G_ObjectD Ret;
	double MinDist = 1e36;
	double dDist = 0;
	double dw = 0;
	double dSpan;
	C3dVector vPt;
	C3dVector vPt2;
	int i;
	double dInc = 0.1;
	double dMinW = 0;
	double dMinPixDist;
	double dPixSpan;
	const int NO_PTS = 10;
	const int NO_PTS2 = 100;
	BOOL bIsPt = FALSE;
	Ret.pObj = NULL;
	//  IF POINTS ARE SELECTABLE
	if (FIL.isFilter(0)) {
		for (i = 0; i < iNoCPts; i++) {
			dDist = pow((cPts[i]->DSP_Point->x - InPT.x), 2) + pow((cPts[i]->DSP_Point->y - InPT.y), 2);
			if (dDist <= MinDist) {
				MinDist = dDist;
				if (dDist < 400) {
					bIsPt = TRUE;
					Ret.Dist = MinDist;
					Ret.pObj = cPts[i];
				}
			}
		}
		if (ws != 0) {
			dDist = pow((pS->DSP_Point->x - InPT.x), 2) + pow((pS->DSP_Point->y - InPT.y), 2);
			if (dDist <= MinDist) {
				MinDist = dDist;
				if (dDist < 400) {
					bIsPt = TRUE;
					Ret.Dist = MinDist;
					Ret.pObj = pS;
				}
			}
		}
		if (we != 1) {
			dDist = pow((pE->DSP_Point->x - InPT.x), 2) + pow((pE->DSP_Point->y - InPT.y), 2);
			if (dDist <= MinDist) {
				MinDist = dDist;
				if (dDist < 400) {
					bIsPt = TRUE;
					Ret.Dist = MinDist;
					Ret.pObj = pE;
				}
			}
		}
	}
	dMinPixDist = 10000;
	// IF CURVES ARE SELECTABLE
	if (!bIsPt) {
		if (FIL.isFilter(13) ||
		    FIL.isFilter(7)) {
			Node* ThePoint = new (Node);
			ThePoint->Create(vPt, 0, 0, 0, 11, 0, 0, NULL);
			// First pass selection
			dSpan = we - ws;
			dInc = dSpan / NO_PTS;
			// calculate pixels between w increments;
			vPt = GetPt(0);
			ThePoint->Pt_Point->Set(vPt.x, vPt.y, vPt.z);
			ThePoint->SetToScr(pModZ, pScrZ);
			vPt.Set(ThePoint->DSP_Point->x, ThePoint->DSP_Point->y, 0);
			vPt2 = GetPt(dInc);
			ThePoint->Pt_Point->Set(vPt2.x, vPt2.y, vPt2.z);
			ThePoint->SetToScr(pModZ, pScrZ);
			vPt2.Set(ThePoint->DSP_Point->x, ThePoint->DSP_Point->y, 0);
			vPt2 -= vPt;
			dPixSpan = vPt2.Mag();
			dw = ws + dInc;
			for (i = 0; i < NO_PTS - 1; i++) {
				vPt = GetPt(dw);
				ThePoint->Pt_Point->Set(vPt.x, vPt.y, vPt.z);
				ThePoint->SetToScr(pModZ, pScrZ);
				dDist = pow((ThePoint->DSP_Point->x - InPT.x), 2) + pow((ThePoint->DSP_Point->y - InPT.y), 2);
				double dTTTT;
				dTTTT = pow(dDist, 0.5);
				if (dTTTT < dMinPixDist) {
					dMinPixDist = dTTTT;
					dMinW = dw;
				}
				if (dDist < MinDist) {
					MinDist = dDist;
				}
				dw = dw + dInc;
			}
			// Refine if dMinPixDist<100
			if (dMinPixDist < dPixSpan) {
				double dds = 0;
				double dde = 0;
				dds = dMinW - dInc;
				dde = dMinW + dInc;
				if (dds < ws)
					dds = ws;
				if (dde > we)
					dde = we;
				dSpan = dde - dds;
				dInc = dSpan / NO_PTS2;
				dw = dds + dInc;
				for (i = 0; i < NO_PTS2 - 1; i++) {
					vPt = GetPt(dw);
					ThePoint->Pt_Point->Set(vPt.x, vPt.y, vPt.z);
					ThePoint->SetToScr(pModZ, pScrZ);
					dDist = pow((ThePoint->DSP_Point->x - InPT.x), 2) + pow((ThePoint->DSP_Point->y - InPT.y), 2);
					if (dDist < MinDist) {
						MinDist = dDist;
						dMinW = dw;
						dMinPixDist = pow(MinDist, 0.5);
					}
					dw = dw + dInc;
				}
			}
			delete (ThePoint);
		}
	}

	if (Ret.pObj == NULL) {
		Ret.Dist = MinDist;
		Ret.pObj = this;
	}
	return (Ret);
}

void NCurve::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	int i;

	if (DrawCPts || gDSP_CPTS) {
		for (i = 0; i < iNoCPts; i++) {
			cPts[i]->S_Box(P1, P2, pSel);
		}
	} else {
		G_Object::S_Box(P1, P2, pSel);
	}
}

C3dVector NCurve::GetPt(double w) {
	C4dVector Pt;
	C4dVector PtSum;
	C3dVector vR;
	int iSpan;
	int i;
	double N[20];
	if (w > 1)
		w = 1;
	// if (w<0)
	//   w=0;
	iSpan = FindSpan(w);
	BasisFun(p, iSpan, w, N);
	PtSum.Clear();
	for (i = 0; i <= p; i++) {
		Pt.xw = cPts[iSpan - p + i]->Pt_Point->x * cPts[iSpan - p + i]->w;
		Pt.yw = cPts[iSpan - p + i]->Pt_Point->y * cPts[iSpan - p + i]->w;
		Pt.zw = cPts[iSpan - p + i]->Pt_Point->z * cPts[iSpan - p + i]->w;
		Pt.w = cPts[iSpan - p + i]->w;
		PtSum = PtSum + Pt * N[i];
	}
	vR.x = PtSum.xw / PtSum.w;
	vR.y = PtSum.yw / PtSum.w;
	vR.z = PtSum.zw / PtSum.w;
	return (vR);
}

C3dVector NCurve::GetStartPt() {
	return (GetPt(ws));
}

C3dVector NCurve::GetEndPt() {
	return (GetPt(we));
}

C3dVector NCurve::GetDir(double w) {
	C3dVector DirA[10];
	deriveAt(w, 1, DirA);
	return (DirA[1]);
}

void NCurve::NullPointRef() {
	pS = NULL;
	pE = NULL;
}

IMPLEMENT_DYNAMIC(NCurveOnSurf, CObject)

// BlowsR
NCurveOnSurf::NCurveOnSurf() {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 75;
	iObjType = 13;
	iNoCPts = 0;
	p = 3;
	ws = 0.0;
	we = 1.0;
	DrawCPts = FALSE;
	DrawNoCvs = FALSE;
	iLnThk = 4;
	iLnType = 1;
	pSC = NULL;
	bOrient = TRUE; // Defualt agrees with space curve
}

void NCurveOnSurf::Create(int iLab, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 75;
	iLabel = iLab;
	iObjType = 13;
	iNoCPts = 0;
	p = 3;
	ws = 0.0;
	we = 1.0;
	pParent = Parrent;
	DrawCPts = FALSE;
	DrawNoCvs = FALSE;
	iLnThk = 4;
	iLnType = 1;
	pSC = NULL;
	bOrient = TRUE; // Defualt agrees with space curve
}

NCurve* NCurveOnSurf::GetSurfaceCVG(G_Object* pSurf) {
	int i;
	NSurf* pSS = (NSurf*) pSurf;

	C3dVector pt;
	NCurve* pS = new NCurve();
	pS->Drawn = Drawn;
	pS->Selectable = Selectable;
	pS->Visable = Visable;
	pS->iColour = iColour;
	pS->iObjType = 7;
	pS->iLabel = iLabel;
	pS->iNoCPts = iNoCPts;
	pS->p = p;
	pS->ws = ws;
	pS->we = we;
	pS->pParent = pSurf;

	for (i = 0; i < iNoCPts + p + 1; i++) {
		pS->knots[i] = knots[i];
	}
	C3dVector gPt;
	for (i = 0; i < iNoCPts; i++) {
		pt = cPts[i]->Pt_Point;
		gPt = pSS->GetPt(pt.x, pt.y);
		pS->cPts[i] = new CvPt_Object();
		pS->cPts[i]->Create(gPt, cPts[i]->w, -1, 55, 1, 1, pS);
	}
	return (pS);
}

C3dVector NCurveOnSurf::GetLastPt() {
	C3dVector vLast;
	vLast.x = cPts[iNoCPts - 1]->Pt_Point->x;
	vLast.y = cPts[iNoCPts - 1]->Pt_Point->y;
	vLast.z = cPts[iNoCPts - 1]->Pt_Point->z;
	return (vLast);
}

C3dVector NCurveOnSurf::Get_Centroid() {
	BOOL isCir;
	C3dVector v1;
	C3dVector v2;
	C3dVector vRet;
	isCir = isCircle();
	if (isCir == TRUE) {
		v1 = GetPt(0.0);
		v2 = GetPt(0.5);
		vRet = (v2 - v1);
		vRet *= 0.5;
		vRet += v1;
	} else {
		vRet = GetPt(0.5);
	}
	return (vRet);
}

BOOL NCurveOnSurf::isCircle() {
	// this need to be more of a verbose check
	// doing it quickly
	C3dVector v1;
	C3dVector v2;
	BOOL bRet;
	bRet = FALSE;
	double dMag;

	if (iNoCPts == 9) {
		v1 = cPts[0]->Pt_Point;
		v2 = cPts[8]->Pt_Point;
		v1 -= v2;
		dMag = v1.Mag();
		if (dMag < 0.000000001) {
			bRet = TRUE;
		}
	}
	return (bRet);
}

void NCurveOnSurf::AddVert(C3dVector pInVertex1, double dWght) {
	if (iNoCPts < MAX_CVPTS) {
		cPts[iNoCPts] = new CvPt_ObjectW();
		cPts[iNoCPts]->Create(pInVertex1, dWght, 0, 0, 0, 12, this);
		iNoCPts++;
	} else {
		outtext1("ERROR: Max No of Points Exceeded.");
	}
}

void NCurveOnSurf::OglDrawW(int iDspFlgs) {
	int i;
	double dw = 0;
	double dSpan;
	double dInc = 0.02;
	C3dVector vPt;
	C3dVector vPt2;
	double dt;
	int iNo;
	if (pParent != NULL) {
		if (DrawCPts || gDSP_CPTS) {
			OglDrawCtrlPts();
		}
		NSurf* pS = (NSurf*) pParent;
		glColor3fv(cols[iColour]);
		dSpan = we - ws;
		dt = dSpan / dInc;
		iNo = (int) dt;
		vPt = NCurve::GetPt(ws);
		vPt = pS->GetPt(vPt.x, vPt.y);
		dw = ws;
		glLineWidth(iLnThk);
		if (iLnType == 2) {
			glEnable(GL_LINE_STIPPLE);
			glLineStipple(1, 0x0101);
		} else if (iLnType == 3) {
			glEnable(GL_LINE_STIPPLE);
			glLineStipple(1, 0x00FF);
		} else if (iLnType == 4) {
			glEnable(GL_LINE_STIPPLE);
			glLineStipple(5, 0x0C0F);
		}
		glBegin(GL_LINES);
		for (i = 0; i < iNo; i++) {
			dw = dw + dInc;
			if (dw > 1.0) {
				dw = 1;
			}
			vPt2 = NCurve::GetPt(dw);
			vPt2 = pS->GetPt(vPt2.x, vPt2.y);
			glVertex3f((float) vPt.x, (float) vPt.y, (float) vPt.z);
			glVertex3f((float) vPt2.x, (float) vPt2.y, (float) vPt2.z);
			vPt = vPt2;
		}
		glEnd();
		glDisable(GL_LINE_STIPPLE);
	}
}

void NCurveOnSurf::OglDrawCtrlPts() {
	int i;
	C3dVector vP;
	glColor3fv(cols[iColour]);
	glPointSize(15.0f);
	glBegin(GL_POINTS);
	if (pParent != NULL) {
		for (i = 0; i < iNoCPts; i++) {
			vP = cPts[i]->Get_Centroid();
			glVertex3f((float) vP.x, (float) vP.y, (float) vP.z);
		}
	}
	glEnd();
}

// void NCurveOnSurf::SetToScr(C3dMatrix* pModMat,C3dMatrix* pScrTran)
//{
// int i;
// pModZ = pModMat;
// pScrZ = pScrTran;
// C3dVector V;
// C3dVector R;
// NSurf* pS;
// double x,y,w;
// pS=(NSurf*) this->pParent;
//
// for (i = 0; i < iNoCPts; i++)
//{
//   x=cPts[i]->Pt_Point->x;
//   y=cPts[i]->Pt_Point->y;
//   w=cPts[i]->w;
//   R=pS->GetPt(x/w,y/w);
//
//   V.x =  pModMat->m_00 * R.x +  pModMat->m_01 * R.y +  pModMat->m_02 * R.z +  pModMat->m_30;
//   V.y =  pModMat->m_10 * R.x +  pModMat->m_11 * R.y +  pModMat->m_12 * R.z +  pModMat->m_31;
//   V.z =  pModMat->m_20 * R.x +  pModMat->m_21 * R.y +  pModMat->m_22 * R.z +  pModMat->m_32;
//   R.x =  pScrTran->m_00 * V.x +  pScrTran->m_01 * V.y +  pScrTran->m_02 * V.z +  pScrTran->m_30;
//   R.y =  pScrTran->m_10 * V.x +  pScrTran->m_11 * V.y +  pScrTran->m_12 * V.z +  pScrTran->m_31;
//   R.z =  pScrTran->m_20 * V.x +  pScrTran->m_21 * V.y +  pScrTran->m_22 * V.z +  pScrTran->m_32;
//   cPts[i]->DSP_Point->x = R.x;
//   cPts[i]->DSP_Point->y = R.y;
//   cPts[i]->DSP_Point->z = 0;
// }
// }

void NCurveOnSurf::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	int i;
	G_Object::SetToScr(pModMat, pScrTran);
	pModZ = pModMat;
	pScrZ = pScrTran;
	for (i = 0; i < iNoCPts; i++) {
		cPts[i]->SetToScr(pModMat, pScrTran);
	}
	// END POINTS NOT CVPR W FOR PARAMETRIC CURVES ON SURFACE
	C3dVector vT;
	if (this->pParent != NULL) {
		if (pS == NULL) {
			pS = new CvPt_ObjectW();
			pS->pParent = this;
		}
		vT = this->GetParaPt(ws);
		pS->Pt_Point->Set(vT.x, vT.y, 0);
		pS->SetToScr(pModMat, pScrTran);
	}
	if (pE == NULL) {
		pE = new CvPt_ObjectW();
		pE->pParent = this;
	}
	vT = this->GetParaPt(we);
	pE->Pt_Point->Set(vT.x, vT.y, 0);
	pE->SetToScr(pModMat, pScrTran);
}

C3dVector NCurveOnSurf::GetPt(double w) {
	C3dVector Pt;
	if (pParent != NULL) {
		NSurf* pS = (NSurf*) pParent;
		Pt = NCurve::GetPt(w);
		Pt = pS->GetPt(Pt.x, Pt.y);
	}
	return (Pt);
}

double NCurveOnSurf::getLen() {
	int i;
	int iInc = 50;
	double dS;
	double dL = 0;
	double dInc;
	C3dVector v1;
	C3dVector v2;
	// if (iNoCPts == 2) //Straight Line
	//	iInc = 50;
	// else
	iInc = 50;
	dS = we - ws; // ws, we start and end w values
	dInc = dS / iInc;
	dS = ws;
	for (i = 0; i < iInc; i++) {
		v1 = GetPt(dS);
		dS += dInc;
		v2 = GetPt(dS);
		v2 -= v1;
		dL += v2.Mag();
	}

	return (dL);
}

C3dVector NCurveOnSurf::GetParaPt(double w) {
	C3dVector Pt;
	Pt = NCurve::GetPt(w);
	return (Pt);
}

void NCurveOnSurf::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << iLnThk;
		ar << iLnType;
		ar << iNoCPts;
		ar << p;
		ar << ws;
		ar << we;
		ar << DrawCPts;
		for (i = 0; i < iNoCPts; i++) {
			cPts[i]->Serialize(ar, iV);
		}
		for (i = 0; i < iNoCPts + p + 1; i++) {
			ar << knots[i];
		}
	} else {
		G_Object::Serialize(ar, iV);
		ar >> iLnThk;
		ar >> iLnType;
		ar >> iNoCPts;
		ar >> p;
		ar >> ws;
		ar >> we;
		ar >> DrawCPts;
		for (i = 0; i < iNoCPts; i++) {
			cPts[i] = new CvPt_ObjectW();
			cPts[i]->Serialize(ar, iV);
			cPts[i]->pParent = this;
		}
		for (i = 0; i < iNoCPts + p + 1; i++) {
			ar >> knots[i];
		}
	}
}

void NCurveOnSurf::HighLight(CDC* pDC) {
	double dw = 0;
	double dSpan;
	double dInc = 0.05;
	C3dVector vPt;
	int iNo;
	int i;
	double dt;
	Node* ThePoint = new Node;
	if (pParent != NULL) {
		NSurf* pS = (NSurf*) pParent;
		dSpan = we - ws;
		dt = dSpan / dInc;
		iNo = (int) dt;
		dw = ws;
		vPt = NCurve::GetPt(dw);
		vPt = pS->GetPt(vPt.x, vPt.y);
		ThePoint->Create(vPt, 1, 0, 0, 11, 0, 0, NULL);
		ThePoint->SetToScr(pModZ, pScrZ);
		pDC->MoveTo((int) ThePoint->DSP_Point->x, (int) ThePoint->DSP_Point->y);
		for (i = 0; i < iNo - 1; i++) {
			dw = dw + dInc;
			vPt = NCurve::GetPt(dw);
			vPt = pS->GetPt(vPt.x, vPt.y);
			ThePoint->Pt_Point->x = vPt.x;
			ThePoint->Pt_Point->y = vPt.y;
			ThePoint->Pt_Point->z = vPt.z;
			ThePoint->SetToScr(pModZ, pScrZ);
			pDC->LineTo((int) ThePoint->DSP_Point->x, (int) ThePoint->DSP_Point->y);
		}
	}
	delete (ThePoint);
}

void NCurveOnSurf::Translate(C3dVector vIn) {
}

void NCurveOnSurf::Transform(C3dMatrix TMat) {
}

C3dVector NCurveOnSurf::MinPt(C3dVector inPt) {
	C3dVector vRet;
	const double dIncs = 36;
	int i;
	double dStp = 1 / dIncs;
	double dlStp;
	double dW = 0;
	double dMinW = 0;
	C3dVector cPt;
	C3dVector tPt;
	C3dVector cNextPt;
	double dWScl;
	double Dist;
	double minDist = 1e36;
	C3dVector v1;
	C3dVector v2;
	double dM;
	double dDot;
	if (pParent != NULL) {
		NSurf* pS = (NSurf*) pParent;
		cPt = NCurve::GetPt(dW);
		cPt = pS->GetPt(cPt.x, cPt.y);
		tPt = NCurve::GetPt(dW + dStp);
		tPt = pS->GetPt(tPt.x, tPt.y);
		dWScl = cPt.Dist(tPt);
		for (i = 0; i < dIncs; i++) {
			dW = i * dStp;
			cPt = NCurve::GetPt(dW);
			cPt = pS->GetPt(cPt.x, cPt.y);
			Dist = cPt.Dist(inPt);
			if (Dist < minDist) {
				minDist = Dist;
				dMinW = dW;
			}
		}
		// start of iteration
		dW = dMinW;
		dlStp = dStp;
		i = 0;
		do {
			cPt = NCurve::GetPt(dW);
			cPt = pS->GetPt(cPt.x, cPt.y);
			cNextPt = NCurve::GetPt(dW + 0.000001);
			cNextPt = pS->GetPt(cNextPt.x, cNextPt.y);
			v1 = cNextPt;
			v1 -= cPt;
			v2 = inPt;
			v2 -= cPt;
			dM = v2.Mag();
			v1.Normalize();
			v2.Normalize();
			dDot = v2.Dot(v1);
			dlStp = (dM * dDot / dWScl) * 1 * dStp;
			dW = dW + dlStp;
			i++;
		} while ((pow((dlStp * dlStp), 0.5) > dTol) && (i < 100));
		vRet = NCurve::GetPt(dW);
		vRet = pS->GetPt(vRet.x, vRet.y);
	}
	return (vRet);
}

G_Object* NCurveOnSurf::Copy(G_Object* Parrent) {
	int i;
	C3dVector pt;
	NCurveOnSurf* pS = new NCurveOnSurf();
	pS->Drawn = Drawn;
	pS->Selectable = Selectable;
	pS->Visable = Visable;
	pS->iColour = iColour;
	pS->iObjType = 13;
	pS->iLabel = iLabel;
	pS->iNoCPts = iNoCPts;
	pS->p = p;
	pS->ws = ws;
	pS->we = we;
	pS->pParent = Parrent;

	for (i = 0; i < iNoCPts + p + 1; i++) {
		pS->knots[i] = knots[i];
	}

	for (i = 0; i < iNoCPts; i++) {
		pS->cPts[i] = new CvPt_Object();
		pS->cPts[i] = (CvPt_Object*) cPts[i]->Copy(Parrent);
	}
	return (pS);
}

void NCurveOnSurf::TrimOGL(GLUnurbsObj* pSurf) {
	int ku;
	int i;
	int iInd;
	GLfloat* ctrlpts;
	GLfloat* KnotsU;
	ku = iNoCPts + p + 1;
	KnotsU = (GLfloat*) malloc(ku * sizeof(GLfloat));
	for (i = 0; i < ku; i++) {
		KnotsU[i] = (GLfloat) knots[i];
	}
	ctrlpts = (GLfloat*) malloc(3 * iNoCPts * sizeof(GLfloat));
	iInd = 0;
	double w;
	for (i = 0; i < iNoCPts; i++) {
		w = cPts[i]->w;
		ctrlpts[iInd] = (GLfloat) (cPts[i]->Pt_Point->x * w);
		ctrlpts[iInd + 1] = (GLfloat) (cPts[i]->Pt_Point->y * w);
		ctrlpts[iInd + 2] = (GLfloat) w;
		iInd = iInd + 3;
	}
	gluNurbsCurve(pSurf, ku, KnotsU, 3, ctrlpts, p + 1, GLU_MAP1_TRIM_3);
	free(ctrlpts);
	free(KnotsU);
}

IMPLEMENT_DYNAMIC(NCircle, CObject)

NCircle::NCircle() {
	iType = 3;
	ws = 0;
	we = 1;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iLabel = -1;
	iLnThk = 4;
	iLnType = 1;
	iObjType = 7;
	dRadius = 0;
	pParent = NULL;
	iNoCPts = 0;
}

void NCircle::Create(C3dVector vN, C3dVector vC, double dRad, int iLab, G_Object* Parrent) {
	iType = 3;
	ws = 0;
	we = 1;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iLabel = iLab;
	iLnThk = 4;
	iLnType = 1;
	iObjType = 7;
	dRadius = dRad;
	if (dRadius == 0)
		dRadius = 0.00001;
	pParent = Parrent;
	iNoCPts = 0;
	p = 2;
	ws = 0.0;
	we = 1.0;
	vNorm = vN;
	// Note vCent gets set after the followin transformations
	// don't set it explicitly here
	vCent.Set(0, 0, 0);
	C3dVector vPt;

	double r2 = 0.70710678118654752440084436210485;

	vPt.x = dRadius;
	vPt.y = 0;
	vPt.z = 0;
	AddVert(vPt, 1);
	vPt.x = dRadius;
	vPt.y = dRadius;
	vPt.z = 0;
	AddVert(vPt, r2);
	vPt.x = 0;
	vPt.y = dRadius;
	vPt.z = 0;
	AddVert(vPt, 1);
	vPt.x = -dRadius;
	vPt.y = dRadius;
	vPt.z = 0;
	AddVert(vPt, r2);
	vPt.x = -dRadius;
	vPt.y = 0;
	vPt.z = 0;
	AddVert(vPt, 1);
	vPt.x = -dRadius;
	vPt.y = -dRadius;
	vPt.z = 0;
	AddVert(vPt, r2);
	vPt.x = 0;
	vPt.y = -dRadius;
	vPt.z = 0;
	AddVert(vPt, 1);
	vPt.x = dRadius;
	vPt.y = -dRadius;
	vPt.z = 0;
	AddVert(vPt, r2);
	vPt.x = dRadius;
	vPt.y = 0;
	vPt.z = 0;
	AddVert(vPt, 1);

	knots[0] = 0;
	knots[1] = 0;
	knots[2] = 0;

	knots[3] = 0.25;
	knots[4] = 0.25;

	knots[5] = 0.5;
	knots[6] = 0.5;

	knots[7] = 0.75;
	knots[8] = 0.75;

	knots[9] = 1.0;
	knots[10] = 1.0;
	knots[11] = 1.0;

	C3dMatrix RMat;
	RMat = RMat.CalcTran(vN);
	C3dMatrix TMat;
	RMat.Translate(vC.x, vC.y, vC.z);
	this->Transform(RMat);
	// TMat.Translate(vC.x,vC.y,vC.z);
	// this->Transform(TMat);
	vCent.Set(vC.x, vC.y, vC.z);
}

void NCircle::Create2(C3dVector vN, C3dVector vC, C3dVector vRD, double dRad, int iLab, G_Object* Parrent) {
	iType = 3;
	ws = 0;
	we = 1;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iLabel = iLab;
	iLnThk = 4;
	iLnType = 1;
	iObjType = 7;
	dRadius = dRad;
	pParent = Parrent;
	iNoCPts = 0;
	p = 2;
	ws = 0.0;
	we = 1.0;
	vNorm = vN;
	vCent = vC;
	vR = vRD;
	Build();
}

void NCircle::Build() {
	Clean();
	C3dVector vPt;
	// C3dVector vC;
	// vC = vCent;
	double r2 = 0.70710678118654752440084436210485;
	vPt.x = dRadius;
	vPt.y = 0;
	vPt.z = 0;
	AddVert(vPt, 1);
	vPt.x = dRadius;
	vPt.y = dRadius;
	vPt.z = 0;
	AddVert(vPt, r2);
	vPt.x = 0;
	vPt.y = dRadius;
	vPt.z = 0;
	AddVert(vPt, 1);
	vPt.x = -dRadius;
	vPt.y = dRadius;
	vPt.z = 0;
	AddVert(vPt, r2);
	vPt.x = -dRadius;
	vPt.y = 0;
	vPt.z = 0;
	AddVert(vPt, 1);
	vPt.x = -dRadius;
	vPt.y = -dRadius;
	vPt.z = 0;
	AddVert(vPt, r2);
	vPt.x = 0;
	vPt.y = -dRadius;
	vPt.z = 0;
	AddVert(vPt, 1);
	vPt.x = dRadius;
	vPt.y = -dRadius;
	vPt.z = 0;
	AddVert(vPt, r2);
	vPt.x = dRadius;
	vPt.y = 0;
	vPt.z = 0;
	AddVert(vPt, 1);

	knots[0] = 0;
	knots[1] = 0;
	knots[2] = 0;

	knots[3] = 0.25;
	knots[4] = 0.25;

	knots[5] = 0.5;
	knots[6] = 0.5;

	knots[7] = 0.75;
	knots[8] = 0.75;

	knots[9] = 1.0;
	knots[10] = 1.0;
	knots[11] = 1.0;

	C3dMatrix RMat;
	RMat.MakeUnit();
	C3dVector vX;
	C3dVector vY;
	C3dVector vZ;
	vZ = vNorm;
	vX = vR;
	vZ.Normalize();
	vX.Normalize();
	vY = vZ.Cross(vX);
	RMat.SetColVec(1, vX);
	RMat.SetColVec(2, vY);
	RMat.SetColVec(3, vZ);
	C3dMatrix TMat;
	RMat.Translate(vCent.x, vCent.y, vCent.z);
	this->Transform(RMat);
	// TMat.Translate(vC.x, vC.y, vC.z);
	// this->Transform(TMat);
}

void NCircle::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	// double r2 = 0.70710678118654752440084436210485;
	C3dVector a;
	a = vCent;
	a -= inPt;
	dRadius = a.Mag();
	Build();
	// cPts[0]->Pt_Point->Set(dRadius, 0, 0);
	// cPts[1]->Pt_Point->Set(dRadius,dRadius, 0);
	// cPts[2]->Pt_Point->Set(0,dRadius,0);
	/*cPts[3]->Pt_Point->Set(-dRadius,dRadius, 0);
	cPts[4]->Pt_Point->Set(-dRadius,0,0);
	cPts[5]->Pt_Point->Set(-dRadius,-dRadius,0);
	cPts[6]->Pt_Point->Set(0,-dRadius,0);
	cPts[7]->Pt_Point->Set(dRadius,-dRadius,0);
	cPts[8]->Pt_Point->Set(dRadius,0,0);

	C3dMatrix RMat;
	RMat = RMat.CalcTran(vNorm);

	C3dMatrix TMat;
	this->NCurve::Transform(RMat);
	TMat.Translate(vCent.x, vCent.y, vCent.z);
	this->NCurve::Transform(TMat);*/
}

void NCircle::Serialize(CArchive& ar, int iV) {
	NCurve::Serialize(ar, iV);
	if (ar.IsStoring()) {
		// TODO: add storing code here
		vNorm.Serialize(ar, iV);
		vCent.Serialize(ar, iV);
		vR.Serialize(ar, iV);
		ar << dRadius;
	} else {
		vNorm.Serialize(ar, iV);
		vCent.Serialize(ar, iV);
		if (iV <= -70)
			vR.Serialize(ar, iV);
		ar >> dRadius;
	}
}

C3dVector NCircle::Get_Centroid() {
	return (vCent);
}

G_Object* NCircle::OffSet(C3dVector vN, C3dVector vDir, double Dist) {
	C3dVector p1;
	C3dVector vR;
	p1 = this->GetPt(0);
	vR = p1 - vCent;
	double dRad;
	dRad = dRadius;
	NCircle* Cir2 = NULL;
	vDir -= vCent;
	if (vDir.Mag() > dRadius) {
		dRad += Dist;
		Cir2 = new NCircle;
		Cir2->Create2(vNorm, vCent, vR, dRad, 1, NULL);
		Cir2->we = we;
		Cir2->ws = ws;
	} else if (vDir.Mag() < dRadius) {
		dRad -= Dist;
		Cir2 = new NCircle;
		Cir2->Create2(vNorm, vCent, vR, dRad, 1, NULL);
		Cir2->we = we;
		Cir2->ws = ws;
	}

	return (Cir2);
}

double NCircle::CorrectW(double w) {
	C3dVector vX, vY, vA;
	double dX;
	vX = this->GetPt(0);
	vY = this->GetPt(0.25);
	vA = this->GetPt(w);
	dX = vA.Dot(vX);
	return (w);
}

void NCircle::RotateToUS(double U) {
	double dRad, dA1;
	int i;
	C3dMatrix mT;
	C3dVector vTmp;
	C3dVector vCent;
	C3dVector vCentN;
	C3dVector vX;
	C3dVector vY;
	C3dVector vN;
	C3dVector vS;
	C3dVector vE;
	C3dVector vNode;
	// Calculate circle cys and radius
	// calulating explicitly as circle may not have come from M3d
	vTmp.x = 0.5 * (cPts[4]->Pt_Point->x - cPts[0]->Pt_Point->x);
	vTmp.y = 0.5 * (cPts[4]->Pt_Point->y - cPts[0]->Pt_Point->y);
	vTmp.z = 0.5 * (cPts[4]->Pt_Point->z - cPts[0]->Pt_Point->z);
	dRad = vTmp.Mag();
	vCent.x = vTmp.x + cPts[0]->Pt_Point->x;
	vCent.y = vTmp.y + cPts[0]->Pt_Point->y;
	vCent.z = vTmp.z + cPts[0]->Pt_Point->z;
	vX.x = cPts[0]->Pt_Point->x - vCent.x;
	vX.y = cPts[0]->Pt_Point->y - vCent.y;
	vX.z = cPts[0]->Pt_Point->z - vCent.z;
	vY.x = cPts[2]->Pt_Point->x - vCent.x;
	vY.y = cPts[2]->Pt_Point->y - vCent.y;
	vY.z = cPts[2]->Pt_Point->z - vCent.z;
	vN = vX.Cross(vY);
	vX.Normalize();
	vY.Normalize();
	vN.Normalize();
	mT.MakeUnit();
	mT.SetColVec(1, vX);
	mT.SetColVec(2, vY);
	mT.SetColVec(3, vN);
	mT.Transpose();
	vCentN.x = -vCent.x;
	vCentN.y = -vCent.y;
	vCentN.z = -vCent.z;

	vS = GetPt(U);
	vS -= vCent;
	vS.Normalize();
	dA1 = vX.AngSigned(vS, vN);
	C3dMatrix mRot;
	mRot.Rotate(0, 0, dA1);

	// Transform ctrl point to XY then rotate and transform back
	vE = GetPt(we);
	for (i = 0; i < iNoCPts; i++) {
		cPts[i]->Translate(vCentN);
		cPts[i]->Transform(mT);
		cPts[i]->Transform(mRot);
	}
	// need to maintain this
	mT.Transpose();
	for (i = 0; i < iNoCPts; i++) {
		cPts[i]->Transform(mT);
		cPts[i]->Translate(vCent);
	}
	ws = 0;
	we = MinWPt(vE);
	if (we <= 0) {
		we = 1;
	}
}

void NCircle::ExportDXF(FILE* pFile) {
	C3dVector vTmp;
	double dRad;
	vTmp.x = 0.5 * (cPts[4]->Pt_Point->x - cPts[0]->Pt_Point->x);
	vTmp.y = 0.5 * (cPts[4]->Pt_Point->y - cPts[0]->Pt_Point->y);
	vTmp.z = 0.5 * (cPts[4]->Pt_Point->z - cPts[0]->Pt_Point->z);
	dRad = vTmp.Mag();
	vCent.x = vTmp.x + cPts[0]->Pt_Point->x;
	vCent.y = vTmp.y + cPts[0]->Pt_Point->y;
	vCent.z = vTmp.z + cPts[0]->Pt_Point->z;
	int iL;
	iL = iFile;
	if (iL < 0)
		iL = 0;
	double startAngle = 10;
	double endAngle = 90;
	double dTemp = 0;
	C3dVector vX, vS, vE, vN;
	if ((ws == 0) && (we == 1)) {
		fprintf(pFile, "CIRCLE\n");
		fprintf(pFile, "  8\n");
		fprintf(pFile, "%s\n", "All");
		fprintf(pFile, " 10\n");
		fprintf(pFile, "%g\n", vCent.x);
		fprintf(pFile, " 20\n");
		fprintf(pFile, "%g\n", vCent.y);
		fprintf(pFile, " 30\n");
		fprintf(pFile, "%g\n", vCent.z);
		fprintf(pFile, " 40\n");
		fprintf(pFile, "%g\n", dRad);
		fprintf(pFile, "  0\n");
	} else {
		// ARC Calc start ane end angle rel to x
		vN.Set(0, 0, 1);
		vX.Set(1, 0, 0);
		vS = GetPt(ws);
		vE = GetPt(we);
		vS -= vCent;
		vS.Normalize();
		vE -= vCent;
		vE.Normalize();
		// The arc - curve goes always from dxf.start_angle to dxf.end_angle
		// in counter - clockwise orientation around the dxf.extrusion vector,
		// which is(0, 0, 1) by defaultand the usual case for 2D arcs

		startAngle = vX.AngSigned(vS, vN);
		endAngle = vX.AngSigned(vE, vN);
		if (vNorm.Dot(vN) < 0) {
			dTemp = startAngle;
			startAngle = endAngle;
			endAngle = dTemp;
		}
		fprintf(pFile, "ARC\n");
		fprintf(pFile, "  8\n");
		fprintf(pFile, "%s\n", "All");
		fprintf(pFile, " 10\n");
		fprintf(pFile, "%g\n", vCent.x);
		fprintf(pFile, " 20\n");
		fprintf(pFile, "%g\n", vCent.y);
		fprintf(pFile, " 40\n");
		fprintf(pFile, "%g\n", dRad);
		fprintf(pFile, " 50\n");
		fprintf(pFile, "%g\n", startAngle);
		fprintf(pFile, " 51\n");
		fprintf(pFile, "%g\n", endAngle);
		fprintf(pFile, "  0\n");
	}
}

void NCircle::Reverse() {
	int i;
	C3dVector* p[9];
	double w[9];
	vNorm = -vNorm;

	for (i = 0; i < 9; i++) {
		p[i] = cPts[i]->Pt_Point;
		w[i] = cPts[i]->w;
	}
	for (i = 0; i < 9; i++) {
		cPts[i]->Pt_Point = p[8 - i];
		cPts[i]->w = w[8 - i];
	}

	ws = 1 - we;
	we = 1;
}

G_Object* NCircle::Copy(G_Object* Parrent) {
	NCircle* cPoly = new NCircle();
	int i;

	cPoly->Drawn = Drawn;
	cPoly->Selectable = Selectable;
	cPoly->Visable = Visable;
	cPoly->iColour = iColour;
	cPoly->iObjType = iObjType;
	cPoly->iLabel = iLabel;
	cPoly->iNoCPts = iNoCPts;
	cPoly->p = p;
	cPoly->ws = ws;
	cPoly->we = we;
	cPoly->pParent = Parrent;
	cPoly->iLnThk = iLnThk;
	cPoly->iLnType = iLnType;
	cPoly->dRadius = dRadius;
	for (i = 0; i < iNoCPts; i++) {
		cPoly->cPts[i] = new CvPt_Object();
		cPoly->cPts[i] = (CvPt_Object*) cPts[i]->Copy(cPoly);
	}
	for (i = 0; i < iNoCPts + p + 1; i++) {
		cPoly->knots[i] = knots[i];
	}

	cPoly->vCent = vCent;
	cPoly->vNorm = vNorm;
	return (cPoly);
}

void NCircle::Translate(C3dVector vIn) {
	NCurve::Translate(vIn);
	vCent += vIn;
}

void NCircle::Transform(C3dMatrix TMat) {
	NCurve::Transform(TMat);
	C3dVector vTmp;
	double dRad;
	vTmp.x = 0.5 * (cPts[4]->Pt_Point->x - cPts[0]->Pt_Point->x);
	vTmp.y = 0.5 * (cPts[4]->Pt_Point->y - cPts[0]->Pt_Point->y);
	vTmp.z = 0.5 * (cPts[4]->Pt_Point->z - cPts[0]->Pt_Point->z);
	dRad = vTmp.Mag();
	dRadius = dRad;
	vCent.x = vTmp.x + cPts[0]->Pt_Point->x;
	vCent.y = vTmp.y + cPts[0]->Pt_Point->y;
	vCent.z = vTmp.z + cPts[0]->Pt_Point->z;

	vR.x = (cPts[0]->Pt_Point->x - cPts[4]->Pt_Point->x);
	vR.y = (cPts[0]->Pt_Point->y - cPts[4]->Pt_Point->y);
	vR.z = (cPts[0]->Pt_Point->z - cPts[4]->Pt_Point->z);
	vR.Normalize();
	vTmp.x = (cPts[2]->Pt_Point->x - vCent.x);
	vTmp.y = (cPts[2]->Pt_Point->y - vCent.y);
	vTmp.z = (cPts[2]->Pt_Point->z - vCent.z);
	vTmp.Normalize();
	vNorm = vR.Cross(vTmp);
}

void NCircle::Info() {
	char S1[80];
	sprintf_s(S1, "%s", "CIRCLE OBJECT");
	outtext1(S1);
	G_Object::Info();
	sprintf_s(S1, "Curve Type: %i LAYER:: %i", iType, iFile);
	outtext1(S1);
	sprintf_s(S1, "%s%f", "Radius : ", dRadius);
	outtext1(S1);
	sprintf_s(S1, "%s%f%s%f%s%f", "Centre : ", vCent.x, ",", vCent.y, ",", vCent.z);
	outtext1(S1);
	sprintf_s(S1, "%s%f%s%f%s%f", "Normal : ", vNorm.x, ",", vNorm.y, ",", vNorm.z);
	outtext1(S1);
	outtext1("    ****");
}

int NCircle::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	sVar[iNo] = "Layer";
	iNo++;
	sVar[iNo] = "KNOT Vector";
	iNo++;
	sVar[iNo] = "U Start";
	iNo++;
	sVar[iNo] = "U End";
	iNo++;
	sVar[iNo] = "Radius";
	iNo++;
	return (iNo);
}

int NCircle::GetVarValues(CString sVar[]) {
	int i;
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", iFile);
	sVar[iNo] = S1;
	iNo++;
	CString sKnots = "";
	for (i = 0; i < iNoCPts + p; i++) {
		sprintf_s(S1, "%g,", knots[i]);
		sKnots += S1;
	}
	sprintf_s(S1, "%g", knots[iNoCPts + p]);
	sKnots += S1;
	// CString str = str(3.1);
	sVar[iNo] = sKnots;
	iNo++;
	sprintf_s(S1, "%g", ws);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", we);
	sVar[iNo] = S1;
	iNo++;
	sprintf_s(S1, "%g", dRadius);
	sVar[iNo] = S1;
	iNo++;
	return (iNo);
}

void NCircle::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	int i = 0;
	int index = 0;
	iFile = atoi(sVar[0]);
	CString line = _T(sVar[1]);
	CString field;
	CArray<CString, CString> v;

	while (AfxExtractSubString(field, line, index, _T(','))) {
		v.Add(field);
		++index;
	}
	if (index == iNoCPts + p + 1) {
		for (i = 0; i < iNoCPts + p + 1; i++) {
			knots[i] = atof(v[i]);
		}
	}
	double uS, uE;
	uS = atof(sVar[2]);
	uE = atof(sVar[3]);
	if ((uS >= 0.0) && (uS <= 1.0) && (uS < uE))
		ws = uS;
	if ((uE >= 0.0) && (uE <= 1.0) && (uE > uS))
		we = uE;
	dRadius = atof(sVar[4]);
	Build();
}

IMPLEMENT_DYNAMIC(NLine, CObject)

NLine::NLine() {
	iType = 2;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iLnThk = 4;
	iLnType = 1;
	iObjType = 7;
	pParent = NULL;
	iNoCPts = 0;
	p = 1;
	ws = 0.0;
	we = 1.0;
}

void NLine::Create(C3dVector vP1, C3dVector vP2, int iLab, G_Object* Parrent) {
	iType = 2;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 152;
	iLabel = iLab;
	iLnThk = 4;
	iLnType = 1;
	iObjType = 7;
	pParent = Parrent;
	iNoCPts = 0;
	p = 1;
	ws = 0.0;
	we = 1.0;

	AddVert(vP1, 1);
	AddVert(vP2, 1);

	knots[0] = 0.0;
	knots[1] = 0.0;
	knots[2] = 1.0;
	knots[3] = 1.0;
}

void NLine::DragUpdate(C3dVector inPt, C3dMatrix mWP) {
	C3dVector vD2, vD, vN, vX, vDir;
	double dR;
	double dAng;
	vX.Set(1, 0, 0);
	vN.Set(0, 0, 1);
	C3dVector p1;
	C3dVector p2;
	C3dVector vTrans;
	C3dMatrix mInv;
	vTrans.x = mWP.m_30;
	vTrans.y = mWP.m_31;
	vTrans.z = mWP.m_32;
	mWP.m_30 = 0;
	mWP.m_31 = 0;
	mWP.m_32 = 0;
	p1 = cPts[0]->Pt_Point;
	p2 = inPt;

	mInv = mWP.Inv();
	if (gORTHO) {
		// Pt to workplane
		p1 -= vTrans;
		p1 = mInv * p1;
		p2 -= vTrans;
		p2 = mInv * p2;
		p2.z = p1.z;
		vD = p2 - p1;
		vD2 = vD;
		dR = vD.Mag();
		vD.Normalize();
		dAng = vX.AngSigned(vD, vN);
		if ((dAng >= 345) && (dAng <= 15))
			dAng = 0;
		else if ((dAng >= 15) && (dAng <= 37.5))
			dAng = 30;
		else if ((dAng >= 37.5) && (dAng <= 52.5))
			dAng = 45;
		else if ((dAng >= 52.5) && (dAng <= 75))
			dAng = 60;
		else if ((dAng >= 75) && (dAng <= 105))
			dAng = 90;
		else if ((dAng >= 105) && (dAng <= 127.5))
			dAng = 120;
		else if ((dAng >= 127.5) && (dAng <= 142.5))
			dAng = 135;
		else if ((dAng >= 142.5) && (dAng <= 165))
			dAng = 150;
		else if ((dAng >= 165) && (dAng <= 195))
			dAng = 180;
		else if ((dAng >= 195) && (dAng <= 217.5))
			dAng = 210;
		else if ((dAng >= 217.5) && (dAng <= 232.5))
			dAng = 225;
		else if ((dAng >= 232.5) && (dAng <= 255))
			dAng = 240;
		else if ((dAng >= 255) && (dAng <= 285))
			dAng = 270;
		else if ((dAng >= 285) && (dAng <= 307.5))
			dAng = 300;
		else if ((dAng >= 307.5) && (dAng <= 322.5))
			dAng = 315;
		else if ((dAng >= 322.5) && (dAng <= 345))
			dAng = 330;
		else
			dAng = 0;

		vDir.x = cos(dAng * D2R);
		vDir.y = sin(dAng * D2R);
		vDir.z = p1.z;
		dR = vDir.Dot(vD2);
		p2.x = p1.x + dR * cos(dAng * D2R);
		p2.y = p1.y + dR * sin(dAng * D2R);
		p2.z = p1.z;
		p2 = mWP * p2;
		p2 += vTrans;
	}
	cPts[1]->Pt_Point->Set(p2.x, p2.y, p2.z);
}

void NLine::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	int i;
	char sLab[20];
	C3dVector vC;

	if ((iDspFlgs & DSP_CURVES) > 0) {
		if (DrawCPts || gDSP_CPTS) {
			OglDrawCtrlPts();
		}
		Selectable = 1;
		glColor3fv(cols[iColour]);
		C3dVector vPt1;
		C3dVector vPt2;
		vPt1 = GetPt(ws);
		vPt2 = GetPt(we);
		glLineWidth((float) iLnThk);
		if (iLnType == 2) {
			glEnable(GL_LINE_STIPPLE);
			glLineStipple(1, 0x0101);
		} else if (iLnType == 3) {
			glEnable(GL_LINE_STIPPLE);
			glLineStipple(1, 0x00FF);
		} else if (iLnType == 4) {
			glEnable(GL_LINE_STIPPLE);
			glLineStipple(5, 0x0C0F);
		}
		glBegin(GL_LINES);
		for (i = 0; i < iNoCPts - 1; i++) {
			glVertex3f((float) vPt1.x, (float) vPt1.y, (float) vPt1.z);
			glVertex3f((float) vPt2.x, (float) vPt2.y, (float) vPt2.z);
		}
		glEnd();
		glLineWidth(2.0);
		glDisable(GL_LINE_STIPPLE);
		vC = this->Get_Centroid();
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "Ln%i", iLabel);
			OglString(iDspFlgs, (float) vC.x, (float) vC.y, (float) vC.z, &sLab[0]);
		}
	} else {
		Selectable = 0;
	}
}

void NLine::HighLight(CDC* pDC) {
	double dw = 0;
	double dSpan;
	double dInc = 0.02;
	C3dVector vPt;
	int iNo;
	dSpan = we - ws;
	double dt;
	dt = dSpan / dInc;
	iNo = (int) dt;
	dw = ws;
	vPt = GetPt(ws);
	Node* ThePoint = new Node;
	ThePoint->Create(vPt, 1, 0, 0, 11, 0, 0, NULL);
	ThePoint->SetToScr(pModZ, pScrZ);
	pDC->MoveTo((int) ThePoint->DSP_Point->x, (int) ThePoint->DSP_Point->y);
	vPt = GetPt(we);
	ThePoint->Pt_Point->x = vPt.x;
	ThePoint->Pt_Point->y = vPt.y;
	ThePoint->Pt_Point->z = vPt.z;
	ThePoint->SetToScr(pModZ, pScrZ);
	pDC->LineTo((int) ThePoint->DSP_Point->x, (int) ThePoint->DSP_Point->y);

	delete (ThePoint);
}

C3dVector NLine::MinPt(C3dVector inPt) {
	C3dVector vRet;
	C3dVector v1;
	C3dVector v2;
	C3dVector P1;
	C3dVector P2;
	double dm;
	double dDot;
	P1.Set(cPts[0]->Pt_Point->x,
	       cPts[0]->Pt_Point->y,
	       cPts[0]->Pt_Point->z);
	P2.Set(cPts[1]->Pt_Point->x,
	       cPts[1]->Pt_Point->y,
	       cPts[1]->Pt_Point->z);
	v1 = P2;
	v1 -= P1;
	v2 = inPt;
	v2 -= P1;
	dm = v2.Mag();
	v1.Normalize();
	v2.Normalize();
	dDot = v2.Dot(v1);
	dm = dm * dDot;
	vRet = P1 + v1 * dm;
	return vRet;
}

void NLine::Info() {
	char S1[80];
	sprintf_s(S1, "%s", "LINE OBJECT");
	outtext1(S1);
	G_Object::Info();
	sprintf_s(S1, "Curve Type: %i LAYER:: %i", iType, iFile);
	outtext1(S1);
	// Set like this temporaly for generating symbols table
	sprintf_s(S1, "Pt1: %f %f %f", cPts[0]->Pt_Point->x, cPts[0]->Pt_Point->y, cPts[0]->Pt_Point->z);
	outtext1(S1);
	sprintf_s(S1, "Pt2: %f %f %f", cPts[1]->Pt_Point->x, cPts[1]->Pt_Point->y, cPts[1]->Pt_Point->z);
	outtext1(S1);
}

void NLine::ExportDXF(FILE* pFile) {
	// fprintf(pFile, "%8i", pVertex[0]->iLabel);
	C3dVector vS, vE;
	vS = GetPt(ws);
	vE = GetPt(we);
	int iL;
	iL = iFile;
	if (iL < 0)
		iL = 0;
	fprintf(pFile, "LINE\n"); // write the LINE entity
	fprintf(pFile, "  8\n"); // write a line with value 8
	fprintf(pFile, "%s\n", "All"); // write the layer number
	fprintf(pFile, " 10\n"); // write a line with value 10
	fprintf(pFile, "%g\n", vS.x); // write the x-coordinate of the first point
	fprintf(pFile, " 20\n"); // write a line with value 20
	fprintf(pFile, "%g\n", vS.y); // write the y-coordinate of the first point
	fprintf(pFile, " 30\n"); // write a line with value 30
	fprintf(pFile, "%g\n", vS.z); // write the z-coordinate of the first point
	fprintf(pFile, " 11\n"); // write a line with value 11
	fprintf(pFile, "%g\n", vE.x); // write the x-coordinate of the second point
	fprintf(pFile, " 21\n"); // write a line with value 21
	fprintf(pFile, "%g\n", vE.y); // write the y-coordinate of the second point
	fprintf(pFile, " 31\n"); // write a line with value 31
	fprintf(pFile, "%g\n", vE.z); // write the z-coordinate of the second point
	fprintf(pFile, "  0\n"); // write a line with value 0
}

G_Object* NLine::Copy(G_Object* Parrent) {
	int i;
	NLine* cPoly = new NLine();
	cPoly->iType = iType;
	cPoly->Drawn = Drawn;
	cPoly->Selectable = Selectable;
	cPoly->Visable = Visable;
	cPoly->iColour = iColour;
	cPoly->iObjType = iObjType;
	cPoly->iLabel = iLabel;
	cPoly->iNoCPts = iNoCPts;
	cPoly->p = p;
	cPoly->ws = ws;
	cPoly->we = we;
	cPoly->pParent = Parrent;
	cPoly->iLnThk = iLnThk;
	cPoly->iLnType = iLnType;
	for (i = 0; i < iNoCPts; i++) {
		cPoly->cPts[i] = new CvPt_Object();
		cPoly->cPts[i] = (CvPt_Object*) cPts[i]->Copy(cPoly);
	}
	for (i = 0; i < iNoCPts + p + 1; i++) {
		cPoly->knots[i] = knots[i];
	}
	return (cPoly);
}

double NLine::MinDist(C3dVector inPt) {
	C3dVector vRet;
	double dX, dY, dZ, dU;
	int iCnt1;
	double MinDist = 100000000000000.0;
	double dDist = 0;

	for (iCnt1 = 1; iCnt1 < 1000; iCnt1++) {
		dU = iCnt1 * 0.001;
		dX = (cPts[1]->Pt_Point->x - cPts[0]->Pt_Point->x) * dU;
		dY = (cPts[1]->Pt_Point->y - cPts[0]->Pt_Point->y) * dU;
		dZ = (cPts[1]->Pt_Point->z - cPts[0]->Pt_Point->z) * dU;
		vRet.x = cPts[0]->Pt_Point->x + dX;
		vRet.y = cPts[0]->Pt_Point->y + dY;
		vRet.z = cPts[0]->Pt_Point->z + dZ;
		dDist = pow((pow((vRet.x - inPt.x), 2) + pow((vRet.y - inPt.y), 2) + pow((vRet.z - inPt.z), 2)), 0.5);
		if (dDist < MinDist) {
			MinDist = dDist;
		}
	}
	return (MinDist);
}

double NLine::getLen() {
	C3dVector p1;
	C3dVector p2;
	p1 = GetPt(0);
	p2 = GetPt(1);
	p1 -= p2;
	return (p1.Mag());
}

G_Object* NLine::OffSet(C3dVector vN, C3dVector vDir, double Dist) {
	C3dVector p1;
	C3dVector p2;

	p1.Set(cPts[0]->Pt_Point->x,
	       cPts[0]->Pt_Point->y,
	       cPts[0]->Pt_Point->z);

	p2.Set(cPts[1]->Pt_Point->x,
	       cPts[1]->Pt_Point->y,
	       cPts[1]->Pt_Point->z);

	C3dVector v1;
	C3dVector v2;
	C3dVector v1o;
	v1 = p2;
	v1 -= p1;
	v2 = vDir;
	v2 -= p1;
	v2.Normalize();
	v1o = v1.Cross(vN);
	v1o.Normalize();
	v1o *= Dist;

	if (v1o.Dot(v2) < 0)
		v1o *= -1;

	NLine* Ln2 = new NLine;
	Ln2->Create(p1 + v1o, p2 + v1o, 1, NULL);
	Ln2->we = this->we;
	Ln2->ws = this->ws;
	return (Ln2);
}

IMPLEMENT_DYNAMIC(NSurf, CObject)

NSurf::~NSurf() {
	int i;
	for (i = 0; i < iNoCvs; i++) {
		delete (pCVsU[i]);
		pCVsU[i] = NULL;
	}

	if (pCVsV[0] != NULL) {
		// Note the control point have already been deleted above
		// dont delete again
		pCVsV[0]->iNoCPts = 0;
		delete (pCVsV[0]);
		pCVsV[0] = NULL;
	}
	if (pCVsV[1] != NULL) {
		// Note the control point have already been deleted above
		// dont delete again
		pCVsV[1]->iNoCPts = 0;
		delete (pCVsV[1]);
		pCVsV[1] = NULL;
	}
	for (i = 0; i < iNoTrimCvs; i++) {
		delete (pSurfCvs[i]);
		pSurfCvs[i] = NULL;
	}
	iNoTrimCvs = 0;
	iNoExtCvs = 0;
}

NSurf::NSurf() {
	iType = 1;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 151;
	iLabel = -1;
	iObjType = 15;
	iNoCvs = 0;
	DrawCPts = FALSE;
	pCVsV[0] = NULL;
	pCVsV[1] = NULL;
	iNoTrimCvs = 0;
	iNoExtCvs = 0;
	dSSize = -1;
}

// CvPt_Object* pVertex[20];
void NSurf::Create(int iLab, G_Object* Parrent) {
	iType = 1;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 151;
	iLabel = iLab;
	iObjType = 15;
	iNoCvs = 0;
	DrawCPts = FALSE;
	pParent = Parrent;
	pCVsV[0] = NULL;
	pCVsV[1] = NULL;
	iNoTrimCvs = 0;
	iNoExtCvs = 0;
	iNoIntLoops = 0;
	dSSize = -1;
}

G_Object* NSurf::Copy(G_Object* Parrent) {
	int i, j;
	NSurf* pSurf = new NSurf();
	pSurf->iType = iType;
	pSurf->Drawn = Drawn;
	pSurf->Selectable = Selectable;
	pSurf->Visable = Visable;
	pSurf->iColour = iColour;
	pSurf->iObjType = iObjType;
	pSurf->iLabel = iLabel;
	pSurf->iNoCvs = iNoCvs;
	pSurf->pU = pU;
	pSurf->pV = pV;
	pSurf->pParent = Parrent;
	pSurf->iNoTrimCvs = iNoTrimCvs;
	pSurf->dSSize = dSSize;

	for (i = 0; i < iNoCvs; i++) {
		pSurf->pCVsU[i] = (NCurve*) pCVsU[i]->Copy(pSurf);
	}
	for (i = 0; i < 2; i++) {
		pSurf->pCVsV[i] = (NCurve*) pCVsV[i]->Copy(pSurf);
	}
	for (i = 0; i < iNoTrimCvs; i++) {
		pSurf->pSurfCvs[i] = (NCurveOnSurf*) pSurfCvs[i]->Copy(pSurf);
	}
	pSurf->iNoTrimCvs = iNoTrimCvs;
	for (i = 0; i < iNoExtCvs; i++) {
		pSurf->pExtLoop[i] = (NCurveOnSurf*) pExtLoop[i]->Copy(pSurf);
	}
	pSurf->iNoExtCvs = iNoExtCvs;
	for (i = 0; i < iNoIntLoops; i++) {
		pSurf->iNoIntCvs[i] = iNoIntCvs[i];
	}
	pSurf->iNoIntLoops = iNoIntLoops;
	for (i = 0; i < iNoIntLoops; i++) {
		for (j = 0; j < iNoIntCvs[i]; j++) {
			pSurf->pIntLoop[i][j] = (NCurveOnSurf*) pIntLoop[i][j]->Copy(pSurf);
		}
	}
	return (pSurf);
}

void NSurf::Info() {
	char S1[80];
	sprintf_s(S1, "%s", "SURFACE OBJECT");
	outtext1(S1);
	G_Object::Info();
	sprintf_s(S1, "%s%i", "Surface Type : ", iType);
	outtext1(S1);
	sprintf_s(S1, "%s%f", "Surface Mesh Size : ", dSSize);
	outtext1(S1);
	int i;
	int j;
	for (i = 0; i < iNoExtCvs; i++)
		pExtLoop[i]->Info();
	outtext1("********** INTERNAL LOOPS**********");
	for (i = 0; i < iNoIntLoops; i++) {
		sprintf_s(S1, "%s%i", "LOOP : ", i);
		outtext1(S1);
		for (j = 0; j < iNoIntCvs[i]; j++) {
			pIntLoop[i][j]->Info();
		}
	}
}

void NSurf::Copy2(NSurf* pSurf) {
	int i, j;
	pSurf->iType = iType;
	pSurf->Drawn = Drawn;
	pSurf->Selectable = Selectable;
	pSurf->Visable = Visable;
	pSurf->iColour = iColour;
	pSurf->iObjType = iObjType;
	pSurf->iLabel = iLabel;
	pSurf->iNoCvs = iNoCvs;
	pSurf->pU = pU;
	pSurf->pV = pV;
	pSurf->pParent = NULL;
	pSurf->iNoTrimCvs = iNoTrimCvs;
	pSurf->dSSize = dSSize;
	for (i = 0; i < iNoCvs; i++) {
		pSurf->pCVsU[i] = (NCurve*) pCVsU[i]->Copy(pSurf);
	}
	for (i = 0; i < 2; i++) {
		pSurf->pCVsV[i] = (NCurve*) pCVsV[i]->Copy(pSurf);
	}
	for (i = 0; i < iNoTrimCvs; i++) {
		pSurf->pSurfCvs[i] = (NCurveOnSurf*) pSurfCvs[i]->Copy(pSurf);
	}
	pSurf->iNoTrimCvs = iNoTrimCvs;
	for (i = 0; i < iNoExtCvs; i++) {
		pSurf->pExtLoop[i] = pExtLoop[i];
	}
	pSurf->iNoExtCvs = iNoExtCvs;
	for (i = 0; i < iNoIntLoops; i++) {
		pSurf->iNoIntCvs[i] = iNoIntCvs[i];
	}
	pSurf->iNoIntLoops = iNoIntLoops;
	for (i = 0; i < iNoIntLoops; i++) {
		for (j = 0; j < iNoIntCvs[i]; j++) {
			pSurf->pIntLoop[i][j] = pIntLoop[i][j];
		}
	}
}

C3dVector NSurf::Get_Centroid() {
	return (GetPt(0.5, 0.5));
}

void NSurf::Serialize(CArchive& ar, int iV) {
	int i, j;
	int iObj;
	int iSObj;
	if (ar.IsStoring()) {
		// TODO: add storing code here
		G_Object::Serialize(ar, iV);
		ar << dSSize;
		ar << iNoCvs;
		ar << pU;
		ar << pV;
		ar << DrawCPts;
		ar << iNoTrimCvs;
		ar << iNoExtCvs;
		ar << iNoIntLoops;

		for (i = 0; i < iNoCvs; i++) {
			ar << pCVsU[i]->iObjType;
			ar << pCVsU[i]->iType;
			pCVsU[i]->Serialize(ar, iV);
		}
		for (i = 0; i < 2; i++) {
			ar << pCVsV[i]->iObjType;
			ar << pCVsV[i]->iType;
			pCVsV[i]->Serialize(ar, iV);
		}
		for (i = 0; i < iNoTrimCvs; i++) {
			ar << pSurfCvs[i]->iObjType;
			ar << pSurfCvs[i]->iType;
			pSurfCvs[i]->Serialize(ar, iV);
		}
		for (i = 0; i < iNoExtCvs; i++) {
			ar << pExtLoop[i]->iObjType;
			ar << pExtLoop[i]->iType;
			// Reattach space curves
			if (pExtLoop[i]->pSC != NULL)
				ar << pExtLoop[i]->pSC->iLabel;
			else
				ar << -1;

			pExtLoop[i]->Serialize(ar, iV);
			;
		}
		for (i = 0; i < iNoIntLoops; i++) {
			ar << iNoIntCvs[i];
		}
		for (i = 0; i < iNoIntLoops; i++) {
			for (j = 0; j < iNoIntCvs[i]; j++) {
				ar << pIntLoop[i][j]->iObjType;
				ar << pIntLoop[i][j]->iType;
				if (pIntLoop[i][j]->pSC != NULL)
					ar << pIntLoop[i][j]->pSC->iLabel;
				else
					ar << -1;
				pIntLoop[i][j]->Serialize(ar, iV);
				;
			}
		}
	} else {
		int iSC;
		G_Object::Serialize(ar, iV);
		ar >> dSSize;
		ar >> iNoCvs;
		ar >> pU;
		ar >> pV;
		ar >> DrawCPts;
		ar >> iNoTrimCvs;
		ar >> iNoExtCvs;
		ar >> iNoIntLoops;
		for (i = 0; i < iNoCvs; i++) {
			ar >> iObj;
			ar >> iSObj;
			if (iSObj == 1) {
				pCVsU[i] = new NCurve();
			} else if (iSObj == 3) {
				pCVsU[i] = new NCircle();
			} else if (iSObj == 2) {
				pCVsU[i] = new NLine();
			}
			pCVsU[i]->Serialize(ar, iV);
			pCVsU[i]->pParent = this;
		}
		for (i = 0; i < 2; i++) {
			ar >> iObj;
			ar >> iSObj;
			if (iSObj == 1) {
				pCVsV[i] = new NCurve();
			} else if (iSObj == 3) {
				pCVsV[i] = new NCircle();
			} else if (iSObj == 2) {
				pCVsV[i] = new NLine();
			}
			pCVsV[i]->Serialize(ar, iV);
			pCVsV[i]->pParent = this;
		}
		for (i = 0; i < iNoTrimCvs; i++) {
			ar >> iObj;
			ar >> iSObj;
			pSurfCvs[i] = new NCurveOnSurf();
			pSurfCvs[i]->Serialize(ar, iV);
			pSurfCvs[i]->pParent = this;
		}
		for (i = 0; i < iNoExtCvs; i++) {
			ar >> iObj;
			ar >> iSObj;
			ar >> iSC;
			pExtLoop[i] = new NCurveOnSurf();
			pExtLoop[i]->Serialize(ar, iV);
			pExtLoop[i]->pParent = this;
			pExtLoop[i]->pSC = NULL;
			if (iSC != -1) {
				if (this->pParent != NULL) {
					if (this->pParent->iObjType == 20) {
						Part* pPt = (Part*) this->pParent;
						pExtLoop[i]->pSC = (NCurve*) pPt->pPartC.Get(iSC);
					}
				}
			}
		}
		for (i = 0; i < iNoIntLoops; i++) {
			ar >> iNoIntCvs[i];
		}
		for (i = 0; i < iNoIntLoops; i++) {
			for (j = 0; j < iNoIntCvs[i]; j++) {
				ar >> iObj;
				ar >> iSObj;
				ar >> iSC;
				pIntLoop[i][j] = new NCurveOnSurf();
				pIntLoop[i][j]->Serialize(ar, iV);
				pIntLoop[i][j]->pParent = this;
				if (iSC != -1) {
					if (this->pParent != NULL) {
						if (this->pParent->iObjType == 20) {
							Part* pPt = (Part*) this->pParent;
							pIntLoop[i][j]->pSC = (NCurve*) pPt->pPartC.Get(iSC);
						}
					}
				}
			}
		}
	}
}

void NSurf::GetBoundingUV(double& MinU,
                          double& MinV,
                          double& SpanU,
                          double& SpanV) {
	int i;
	double MaxU;
	double MaxV;
	// initiatal values
	if (iNoExtCvs <= 1) // No user trim
	{
		MinU = 0;
		MinV = 0;
		SpanU = 1.0;
		SpanV = 1.0;
	} else {
		NCurveOnSurf* pC = (NCurveOnSurf*) pExtLoop[0];
		MinU = 1.0;
		MinV = 1.0;
		MaxU = 0;
		MaxV = 0;
		for (i = 0; i < iNoExtCvs; i++) {
			pC = (NCurveOnSurf*) pExtLoop[i];
			C3dVector pI = pC->GetParaPt(pC->ws);
			if (pI.x < MinU)
				MinU = pI.x;
			if (pI.y < MinV)
				MinV = pI.y;
			if (pI.x > MaxU)
				MaxU = pI.x;
			if (pI.y > MaxV)
				MaxV = pI.y;
		}
		SpanU = MaxU - MinU;
		SpanV = MaxV - MinV;
	}
}

void NSurf::AddCV(NCurve* inCV) {
	if (iNoCvs < MAX_CVS) {
		pCVsU[iNoCvs] = (NCurve*) inCV->Copy(this);
		iNoCvs++;
	} else {
		outtext1("ERROR: Max No of Curves in Surface Exceeded.");
	}
}

void NSurf::RelTo(G_Object* pThis, ObjList* pList, int iType) {
	int i;
	if (iType == 7) // Apace Curves
	{
		for (i = 0; i < iNoExtCvs; i++) {
			if (pExtLoop[i]->pSC != NULL)
				pList->AddEx(pExtLoop[i]->pSC);
		}
	}
}

void NSurf::OglDrawW(int iDspFlgs, double dS1, double dS2) {
	char sLab[20];
	double dUi;
	double dVi;
	double dSpanU;
	double dSpanV;
	C3dVector vCent;
	// UMarker direction Postition
	C3dVector vU;
	C3dVector vUDir;
	C3dVector vVDir;
	C3dVector vZDir;
	C3dVector vO;
	C3dVector vO1;

	if ((iDspFlgs & DSP_SURFACES) > 0) {
		int i;
		int j;
		Selectable = 1;

		vUDir = this->GetPt(0.25, 0.0);
		vCent = Get_Centroid();
		vO.Set(0, 0, 0);

		this->GetBoundingUV(dUi, dVi, dSpanU, dSpanV);
		vO = this->GetPt(dUi + dSpanU / 2, dVi + dSpanV / 2);
		vUDir = this->GetPt(dUi + dSpanU / 2 + 0.025, dVi + dSpanV / 2);
		vVDir = this->GetPt(dUi + dSpanU / 2, dVi + dSpanV / 2 + 0.025);
		// vUDir = this->GetPt(dUi + dSpanU / 2 + 0.25, dVi + dSpanV / 2);
		// vVDir = this->GetPt(dUi + dSpanU / 2, dVi + dSpanV / 2 + 0.25);
		vUDir -= vO;
		vVDir -= vO;
		vUDir.Normalize();
		vVDir.Normalize();
		vZDir = vUDir.Cross(vVDir);
		for (i = 0; i < iNoTrimCvs; i++) {
			if ((iDspFlgs & DSP_SURC) > 0) {
				pSurfCvs[i]->Selectable = 1;
				pSurfCvs[i]->OglDrawW(DSP_CURVES);
			} else {
				pSurfCvs[i]->Selectable = 0;
			}
		}
		// DRAW EXTERNAL TRIM LOOP
		if ((iDspFlgs & DSP_SURC) > 0) {
			for (i = 0; i < iNoExtCvs; i++) {
				pExtLoop[i]->OglDrawW(DSP_CURVES);
				pExtLoop[i]->Selectable = 1;
			}
			// DRAW INTERNAL TRIM LOOP
			if (this->iNoIntCvs > 0) {
				for (i = 0; i < iNoIntLoops; i++) {
					for (j = 0; j < iNoIntCvs[i]; j++) {
						pIntLoop[i][j]->OglDrawW(DSP_CURVES);
						pIntLoop[i][j]->Selectable = 1;
					}
				}
			}
		}

		//*********************************************************************************
		// Remove to just render lines
		// glLineWidth(2.0);
		// nu = pCVsU[0]->iNoCPts;
		// ku = nu + pU + 1;
		// nv = iNoCvs;
		// kv = nv + pV + 1;

		// KnotsU = (GLfloat*)malloc(ku*sizeof(GLfloat));
		// for (icu = 0; icu < ku; icu++)
		//{
		//   KnotsU[icu] = (float)pCVsU[0]->knots[icu];
		// }
		// KnotsV = (GLfloat*)malloc(kv*sizeof(GLfloat));
		// for (icu = 0; icu < kv; icu++)
		//{
		//   KnotsV[icu] = (float)pCVsV[0]->knots[icu];
		// }

		// int iInd = 0;

		// double dW;
		// ctrlpts = (GLfloat*)malloc(4 * nv*nu*sizeof(GLfloat));
		// for (i = 0; i<nv; i++)
		//{
		//   for (j = 0; j<nu; j++)
		//   {
		//     dW = pCVsU[i]->cPts[j]->w;
		//     ctrlpts[iInd] = (float)pCVsU[i]->cPts[j]->Pt_Point->x*(float)dW;
		//     ctrlpts[iInd + 1] = (float)pCVsU[i]->cPts[j]->Pt_Point->y*(float)dW;
		//     ctrlpts[iInd + 2] = (float)pCVsU[i]->cPts[j]->Pt_Point->z*(float)dW;
		//     ctrlpts[iInd + 3] = (float)dW;
		//     iInd = iInd + 4;
		//   }
		// }

		// GLUnurbsObj* pSurf;
		// pSurf = gluNewNurbsRenderer();
		// gluNurbsProperty(pSurf, GLU_SAMPLING_METHOD, GLU_PARAMETRIC_ERROR);
		// gluNurbsProperty(pSurf, GLU_PARAMETRIC_TOLERANCE, 0.05f);
		// gluNurbsProperty(pSurf, GLU_DISPLAY_MODE, GLU_OUTLINE_PATCH);
		// gluBeginSurface(pSurf);
		// gluNurbsSurface(pSurf,
		//   ku,
		//   KnotsU,
		//   kv,
		//   KnotsV,
		//   4,
		//   4 * nu,
		//   ctrlpts,
		//   pU + 1,
		//   pV + 1,
		//   GL_MAP2_VERTEX_4);

		// gluBeginTrim(pSurf);
		//   for (i = 0; i<iNoExtCvs; i++)
		//   {
		//     pExtLoop[i]->TrimOGL(pSurf);
		//   }
		// gluEndTrim(pSurf);
		// gluEndSurface(pSurf);
		// gluDeleteNurbsRenderer(pSurf);
		// free(ctrlpts);
		// free(KnotsU);
		// free(KnotsV);

		//*********************************************************************************

		// Draw the U marker
		if ((iDspFlgs & DSP_SURFU) == 0) {
			C3dVector p2;
			C3dVector p3;
			C3dVector p4;
			double X, Y, Z;
			p2 = vO;
			p2 += vUDir * dS1;
			p3 = vO;
			p3 += vVDir * dS1;
			p4 = vO;
			p4 += vZDir * dS1;
			glColor3fv(cols[iColour]);
			// FIRST ARROW
			C3dVector Pts[7];
			C3dMatrix mT;
			X = p2.x;
			Y = p2.y;
			Z = p2.z;
			mT = vUDir.GetTMat();
			for (i = 0; i < 7; i++) {
				Pts[i].Set(AHead[i][0], AHead[i][1], AHead[i][2]);
				// Pts[i] -= vOff;
				Pts[i] = mT.Mult(Pts[i]);
				Pts[i] *= 0.2 * dS1;
			}
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
			glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
			glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
			glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
			glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
			glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
			glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) vO.x, (float) vO.y, (float) vO.z);
			glVertex3f((float) p2.x, (float) p2.y, (float) p2.z);
			glEnd();
			glRasterPos3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPU);
			// END FIRST ARROW
			// SECOND ARROW
			X = p3.x;
			Y = p3.y;
			Z = p3.z;
			mT = vVDir.GetTMat();
			for (i = 0; i < 7; i++) {
				Pts[i].Set(AHead[i][0], AHead[i][1], AHead[i][2]);
				// Pts[i] -= vOff;
				Pts[i] = mT.Mult(Pts[i]);
				Pts[i] *= 0.2 * dS1;
			}
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
			glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
			glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
			glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
			glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
			glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
			glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) vO.x, (float) vO.y, (float) vO.z);
			glVertex3f((float) p3.x, (float) p3.y, (float) p3.z);
			glEnd();
			glRasterPos3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPV);
			// END SECOND ARROW
			// THIRD Z ARROW
			X = p4.x;
			Y = p4.y;
			Z = p4.z;
			mT = vZDir.GetTMat();
			for (i = 0; i < 7; i++) {
				Pts[i].Set(AHead[i][0], AHead[i][1], AHead[i][2]);
				// Pts[i] -= vOff;
				Pts[i] = mT.Mult(Pts[i]);
				Pts[i] *= 0.2 * dS1;
			}
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
			glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
			glVertex3f((float) Pts[2].x + X, (float) Pts[2].y + Y, (float) Pts[2].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
			glVertex3f((float) Pts[3].x + X, (float) Pts[3].y + Y, (float) Pts[3].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
			glVertex3f((float) Pts[4].x + X, (float) Pts[4].y + Y, (float) Pts[4].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
			glVertex3f((float) Pts[5].x + X, (float) Pts[5].y + Y, (float) Pts[5].z + Z);
			glEnd();
			glBegin(GL_POLYGON);
			glVertex3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glVertex3f((float) Pts[1].x + X, (float) Pts[1].y + Y, (float) Pts[1].z + Z);
			glVertex3f((float) Pts[6].x + X, (float) Pts[6].y + Y, (float) Pts[6].z + Z);
			glEnd();
			glBegin(GL_LINES);
			glVertex3f((float) vO.x, (float) vO.y, (float) vO.z);
			glVertex3f((float) p4.x, (float) p4.y, (float) p4.z);
			glEnd();
			glRasterPos3f((float) Pts[0].x + X, (float) Pts[0].y + Y, (float) Pts[0].z + Z);
			glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, BMPZ);
		}

		if (DrawCPts || gDSP_CPTS) {
			for (i = 0; i < iNoCvs; i++) {
				pCVsU[i]->OglDrawCtrlPts();
			}
		}
		// Esp_Mod_Labels_4_27_2025_Start: Added global label variable for label display
		if (gLBL_DSP_TRG)
			bDrawLab = FALSE;
		if (bDrawLab == TRUE)
		// Esp_Mod_Labels_4_27_2025_End
		{
			sprintf_s(sLab, "S%i", iLabel);
			OglString(iDspFlgs, vCent.x, vCent.y, vCent.z, &sLab[0]);
		}
	} else {
		Selectable = 0;
	}
}

void NSurf::OglDraw(int iDspFlgs, double dS1, double dS2) {
	// Below draw the curve using the open gl nurbs render

	// remove the statement and put some where where it only gets called once
	//*******************************************************************
	// CleanExternalTrim();

	if ((iDspFlgs & DSP_SURFACES) > 0) {
		Selectable = 1;
		GLfloat* ctrlpts;
		GLfloat* KnotsU;
		GLfloat* KnotsV;
		GLfloat knots[6] = {0.0, 0.0, 0.0, 1.0, 1.0, 1.0};
		GLfloat edgePt[5][2] = /* counter clockwise */
		    {
		        {0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}, {0.0, 1.0}, {0.0, 0.0}};

		int nu;
		int nv;
		int ku;
		int kv;
		int icu;

		glColor3fv(cols[iColour]); // Solid Colour
		if (pParent != NULL) {
			if (pParent->iObjType == 20) {
				Part* pPart = (Part*) pParent;
				float R = cols[pPart->iColour][0];
				float G = cols[pPart->iColour][1];
				float B = cols[pPart->iColour][2];
				float A = pPart->Alpha;
				glColor4f(R, G, B, A);
			}
		}

		nu = pCVsU[0]->iNoCPts;
		ku = nu + pU + 1;
		nv = iNoCvs;
		kv = nv + pV + 1;

		KnotsU = (GLfloat*) malloc(ku * sizeof(GLfloat));
		for (icu = 0; icu < ku; icu++) {
			KnotsU[icu] = (GLfloat) pCVsU[0]->knots[icu];
		}
		KnotsV = (GLfloat*) malloc(kv * sizeof(GLfloat));
		for (icu = 0; icu < kv; icu++) {
			KnotsV[icu] = (GLfloat) pCVsV[0]->knots[icu];
		}

		int iInd = 0;
		int j;
		int i;
		double dW;
		ctrlpts = (GLfloat*) malloc(4 * nv * nu * sizeof(GLfloat));
		for (i = 0; i < nv; i++) {
			for (j = 0; j < nu; j++) {
				dW = pCVsU[i]->cPts[j]->w;
				ctrlpts[iInd] = (GLfloat) pCVsU[i]->cPts[j]->Pt_Point->x * (GLfloat) dW;
				ctrlpts[iInd + 1] = (GLfloat) pCVsU[i]->cPts[j]->Pt_Point->y * (GLfloat) dW;
				ctrlpts[iInd + 2] = (GLfloat) pCVsU[i]->cPts[j]->Pt_Point->z * (GLfloat) dW;
				ctrlpts[iInd + 3] = (GLfloat) dW;
				iInd = iInd + 4;
			}
		}

		GLUnurbsObj* pSurf;
		pSurf = gluNewNurbsRenderer();
		// gluNurbsProperty(pSurf, GLU_SAMPLING_METHOD,GLU_PARAMETRIC_ERROR);
		gluNurbsProperty(pSurf, GLU_SAMPLING_METHOD, GLU_DOMAIN_DISTANCE);
		if (pU == 1)
			gluNurbsProperty(pSurf, GLU_U_STEP, 18);
		else
			gluNurbsProperty(pSurf, GLU_U_STEP, 18);
		if (pV == 1)
			gluNurbsProperty(pSurf, GLU_V_STEP, 18);
		else
			gluNurbsProperty(pSurf, GLU_V_STEP, 18);
		// gluNurbsProperty(pSurf, GLU_SAMPLING_METHOD, GLU_PATH_LENGTH);
		// gluNurbsProperty(pSurf, GLU_PARAMETRIC_TOLERANCE,0.01f);
		// gluNurbsProperty(pSurf, GLU_DISPLAY_MODE, GLU_OUTLINE_POLYGON); //GLU_FILL  GLU_OUTLINE_POLYGON

		gluNurbsProperty(pSurf, GLU_CULLING, GLU_FALSE);
		gluBeginSurface(pSurf);
		gluNurbsSurface(pSurf,
		                ku,
		                KnotsU,
		                kv,
		                KnotsV,
		                4,
		                4 * nu,
		                ctrlpts,
		                pU + 1,
		                pV + 1,
		                GL_MAP2_VERTEX_4);
		// gluBeginTrim (pSurf);
		//     gluPwlCurve (pSurf, 5, &edgePt[0][0], 2,
		//                  GLU_MAP1_TRIM_2);
		//  gluEndTrim (pSurf);

		gluBeginTrim(pSurf);
		for (i = 0; i < iNoExtCvs; i++) {
			////gluPwlCurve (pSurf, 5, &edgePt[0][0], 2, GLU_MAP1_TRIM_2);
			pExtLoop[i]->TrimOGL(pSurf);
		}
		gluEndTrim(pSurf);
		// internal loop
		if (iNoIntLoops > 0) {
			for (i = 0; i < iNoIntLoops; i++) {
				gluBeginTrim(pSurf);
				for (j = 0; j < iNoIntCvs[i]; j++) {
					pIntLoop[i][j]->TrimOGL(pSurf);
				}
				gluEndTrim(pSurf);
			}
		}
		gluEndSurface(pSurf);
		gluDeleteNurbsRenderer(pSurf);
		free(ctrlpts);
		free(KnotsU);
		free(KnotsV);
	} else {
		Selectable = 0;
	}
}

void NSurf::SetToScr(C3dMatrix* pModMat, C3dMatrix* pScrTran) {
	pModZ = pModMat;
	pScrZ = pScrTran;
	G_Object::SetToScr(pModMat, pScrTran);
	int i;
	int j;
	for (i = 0; i < iNoCvs; i++) {
		pCVsU[i]->SetToScr(pModMat, pScrTran);
	}
	pCVsV[0]->SetToScr(pModMat, pScrTran);
	pCVsV[1]->SetToScr(pModMat, pScrTran);

	for (i = 0; i < iNoTrimCvs; i++) {
		pSurfCvs[i]->SetToScr(pModMat, pScrTran);
	}
	for (i = 0; i < iNoExtCvs; i++) {
		// Here
		pExtLoop[i]->SetToScr(pModMat, pScrTran);
	}
	for (i = 0; i < iNoIntLoops; i++) {
		for (j = 0; j < iNoIntCvs[i]; j++) {
			// Here
			pIntLoop[i][j]->SetToScr(pModMat, pScrTran);
		}
	}
}

void NSurf::NullCurveRef() {
	int i;
	int j;
	for (i = 0; i < iNoExtCvs; i++) {
		pExtLoop[i]->pSC = NULL;
	}
	for (i = 0; i < iNoIntLoops; i++) {
		for (j = 0; j < iNoIntCvs[i]; j++) {
			pIntLoop[i][j]->pSC = NULL;
		}
	}
}

void NSurf::DrawCtrlPtsTog() {
	if (DrawCPts == FALSE) {
		DrawCPts = TRUE;
	} else {
		DrawCPts = FALSE;
	}
}

void NSurf::HighLight(CDC* pDC) {
	int i;
	if (iNoExtCvs > 0) {
		for (i = 0; i < iNoExtCvs; i++) {
			pExtLoop[i]->HighLight(pDC);
		}
	}
}

void NSurf::S_Box(CPoint P1, CPoint P2, ObjList* pSel) {
	int i;
	int j;
	// CALL SURFACE S_BOX METHOD
	G_Object::S_Box(P1, P2, pSel);

	if (DrawCPts || gDSP_CPTS) {
		for (i = 0; i < iNoCvs; i++) {
			pCVsU[i]->S_Box(P1, P2, pSel);
			for (j = 0; j < pCVsU[i]->iNoCPts; j++) {
				pCVsU[i]->cPts[j]->S_Box(P1, P2, pSel);
			}
		}
	}

	// CALL EXT TRIM CURVE S_BOX METHODS
	for (i = 0; i < this->iNoExtCvs; i++) {
		pExtLoop[i]->S_Box(P1, P2, pSel);
	}
	// CALL INTERNAL TRIM CURVE S_BOX METHODS
	for (i = 0; i < iNoIntLoops; i++) {
		for (j = 0; j < iNoIntCvs[i]; j++) {
			pIntLoop[i][j]->S_Box(P1, P2, pSel);
		}
	}
}

G_ObjectD NSurf::SelDist(CPoint InPT, Filter FIL) {
	G_ObjectD Ret;
	G_ObjectD vT;
	C3dVector vPt;
	C3dVector vPt2;
	int i, j;
	double dV;
	double dU;
	double dVi;
	double dUi;
	double dIncV;
	double dIncU;
	double dMinU;
	double dMinV;
	double dSpanV;
	double dSpanU;
	double dDist;
	double dMinPixDist;
	double dPixSpan;
	double ddsU;
	double ddeU;
	double ddsV;
	double ddeV;
	double MinDist = 1e36;
	double Z = 0;
	const int NO_PTS = 5;
	const int NO_PTS_RF = 50;
	Node* ThePoint = new (Node);
	ThePoint->Create(vPt, 0, 0, 0, 11, 0, 0, NULL);
	// check the surface
	this->GetBoundingUV(dUi, dVi, dSpanU, dSpanV);
	dIncU = dSpanU / NO_PTS;
	dIncV = dSpanV / NO_PTS;
	// calculate pixels between w increments;
	vPt = GetPt(0, 0);
	ThePoint->Pt_Point->Set(vPt.x, vPt.y, vPt.z);
	ThePoint->SetToScr(pModZ, pScrZ);
	vPt.Set(ThePoint->DSP_Point->x, ThePoint->DSP_Point->y, 0);
	vPt2 = GetPt(dIncU, dIncV);
	ThePoint->Pt_Point->Set(vPt2.x, vPt2.y, vPt2.z);
	ThePoint->SetToScr(pModZ, pScrZ);
	vPt2.Set(ThePoint->DSP_Point->x, ThePoint->DSP_Point->y, 0);
	vPt2 -= vPt;
	dPixSpan = vPt2.Mag();
	dU = dUi + dIncU;
	for (j = 0; j < NO_PTS - 1; j++) {
		dV = dVi + dIncV;
		for (i = 0; i < NO_PTS - 1; i++) {
			vPt = GetPt(dU, dV);
			ThePoint->Pt_Point->x = vPt.x;
			ThePoint->Pt_Point->y = vPt.y;
			ThePoint->Pt_Point->z = vPt.z;
			ThePoint->SetToScr(pModZ, pScrZ);
			dDist = pow((ThePoint->DSP_Point->x - InPT.x), 2) + pow((ThePoint->DSP_Point->y - InPT.y), 2);
			if (dDist < MinDist) {
				MinDist = dDist;
				Z = ThePoint->Pt_Point->z;
				dMinU = dU;
				dMinV = dV;
				dMinPixDist = pow(MinDist, 0.5);
			}
			dV += dIncV;
		}
		dU += dIncU;
	}
	// Refine if dMinPixDist<100
	if (dMinPixDist < dPixSpan) {
		ddsU = dMinU - dIncU;
		ddeU = dMinU + dIncU;
		if (ddsU < dUi)
			ddsU = dUi;
		if (ddeU > dUi + dSpanU)
			ddeU = dUi + dSpanU;
		ddsV = dMinV - dIncV;
		ddeV = dMinV + dIncV;
		if (ddsV < dVi)
			ddsV = dVi;
		if (ddeV > dVi + dSpanV)
			ddeV = dVi + dSpanV;
		dSpanV = ddeV - ddsV;
		dSpanU = ddeU - ddsU;
		// iNo = 100;
		// dw = dds;
		dIncU = dSpanU / NO_PTS_RF;
		dIncV = dSpanV / NO_PTS_RF;
		dU = ddsU + dIncU;
		for (j = 0; j < NO_PTS_RF - 1; j++) {
			dV = ddsV + dIncV;
			for (i = 0; i < NO_PTS_RF - 1; i++) {
				vPt = GetPt(dU, dV);
				ThePoint->Pt_Point->x = vPt.x;
				ThePoint->Pt_Point->y = vPt.y;
				ThePoint->Pt_Point->z = vPt.z;
				ThePoint->SetToScr(pModZ, pScrZ);
				dDist = pow((ThePoint->DSP_Point->x - InPT.x), 2) + pow((ThePoint->DSP_Point->y - InPT.y), 2);
				if (dDist < MinDist) {
					MinDist = dDist;
					Z = ThePoint->Pt_Point->z;
				}
				dV += dIncV;
			}
			dU += dIncU;
		}
	}
	delete (ThePoint);
	Ret.pObj = NULL;
	// Check Surface definition Curves
	if (iNoExtCvs == 0) {
		if ((FIL.isFilter(7)) ||
		    (FIL.isFilter(8)) ||
		    (FIL.isFilter(9))) {
			for (i = 0; i < iNoCvs; i++) {
				vT = pCVsU[i]->SelDist(InPT, FIL);
				if (vT.Dist < MinDist) {
					MinDist = vT.Dist;
					Ret.Dist = MinDist;
					Ret.pObj = vT.pObj;
				}
			}
			for (i = 0; i < 2; i++) {
				vT = pCVsV[i]->SelDist(InPT, FIL);
				if (vT.Dist < MinDist) {
					MinDist = vT.Dist;
					Ret.Dist = MinDist;
					Ret.pObj = vT.pObj;
				}
			}
		}
	}

	// Check the control points
	if (FIL.isFilter(0)) {
		if (DrawCPts || gDSP_CPTS) {
			for (i = 0; i < iNoCvs; i++) {
				for (j = 0; j < pCVsU[i]->iNoCPts; j++) {
					vT = pCVsU[i]->cPts[j]->SelDist(InPT, FIL);
					if (vT.Dist < MinDist) {
						MinDist = vT.Dist;
						Ret.Dist = MinDist;
						Ret.pObj = vT.pObj;
					}
				}
			}
		}
	}

	//******************************************************
	// Change to curve selection
	// Check active trim curves only not all trim curves
	// EXTERNAL TRIM LOOP FIRST
	//******************************************************
	if (this->iNoExtCvs > 0) {
		if (FIL.isFilter(13) || FIL.isFilter(0)) {
			for (i = 0; i < this->iNoExtCvs; i++) {
				vT = this->pExtLoop[i]->SelDist(InPT, FIL);
				if (vT.Dist < MinDist) {
					MinDist = vT.Dist;
					Ret.Dist = MinDist;
					Ret.pObj = vT.pObj;
				}
			}
		}
	}
	// INTERNAL TRIM LOOPS
	//******************************************************
	if (this->iNoIntCvs > 0) {
		if (FIL.isFilter(13) || FIL.isFilter(0)) {
			for (i = 0; i < iNoIntLoops; i++) {
				for (j = 0; j < iNoIntCvs[i]; j++) {
					// pIL[j]=pIntLoop[i][iNoIntCvs[i]-j];
					vT = this->pIntLoop[i][j]->SelDist(InPT, FIL);
					if (vT.Dist < MinDist) {
						MinDist = vT.Dist;
						Ret.Dist = MinDist;
						Ret.pObj = vT.pObj;
					}
				}
			}
		}
	}

	//******************************************************
	// Check all curves on surface if in trim curve or not??
	// Not sure best way to handle this

	if (FIL.isFilter(13)) {
		for (i = 0; i < iNoTrimCvs; i++) {
			vT = pSurfCvs[i]->SelDist(InPT, FIL);
			if (vT.Dist < MinDist) {
				MinDist = vT.Dist;
				Ret.Dist = MinDist;
				Ret.pObj = vT.pObj;
			}
		}
	}

	if (Ret.pObj == NULL) {
		Ret.Dist = MinDist;
		Ret.pObj = this;
		Ret.Z = Z;
	}

	return (Ret);
}

G_ObjectD NSurf::SelDistFace(CPoint InPT, Filter FIL) {
	G_ObjectD Ret;
	C3dVector vPt;
	C3dVector vPt2;
	int i, j;
	double dV;
	double dU;
	double dVi;
	double dUi;
	double dIncV;
	double dIncU;
	double dMinU;
	double dMinV;
	double dSpanV;
	double dSpanU;
	double dDist;
	double dMinPixDist;
	double dPixSpan;
	double ddsU;
	double ddeU;
	double ddsV;
	double ddeV;
	double MinDist = 1e36;
	double Z = 0;
	const int NO_PTS = 5;
	const int NO_PTS_RF = 50;
	Node* ThePoint = new (Node);
	ThePoint->Create(vPt, 0, 0, 0, 11, 0, 0, NULL);
	// check the surface
	this->GetBoundingUV(dUi, dVi, dSpanU, dSpanV);
	dIncU = dSpanU / NO_PTS;
	dIncV = dSpanV / NO_PTS;
	// calculate pixels between w increments;
	vPt = GetPt(0, 0);
	ThePoint->Pt_Point->Set(vPt.x, vPt.y, vPt.z);
	ThePoint->SetToScr(pModZ, pScrZ);
	vPt.Set(ThePoint->DSP_Point->x, ThePoint->DSP_Point->y, 0);
	vPt2 = GetPt(dIncU, dIncV);
	ThePoint->Pt_Point->Set(vPt2.x, vPt2.y, vPt2.z);
	ThePoint->SetToScr(pModZ, pScrZ);
	vPt2.Set(ThePoint->DSP_Point->x, ThePoint->DSP_Point->y, 0);
	vPt2 -= vPt;
	dPixSpan = vPt2.Mag();
	dU = dUi + dIncU;
	for (j = 0; j < NO_PTS - 1; j++) {
		dV = dVi + dIncV;
		for (i = 0; i < NO_PTS - 1; i++) {
			vPt = GetPt(dU, dV);
			ThePoint->Pt_Point->x = vPt.x;
			ThePoint->Pt_Point->y = vPt.y;
			ThePoint->Pt_Point->z = vPt.z;
			ThePoint->SetToScr(pModZ, pScrZ);
			dDist = pow((ThePoint->DSP_Point->x - InPT.x), 2) + pow((ThePoint->DSP_Point->y - InPT.y), 2);
			if (dDist < MinDist) {
				MinDist = dDist;
				Z = ThePoint->DSP_Point->z;
				dMinU = dU;
				dMinV = dV;
				dMinPixDist = pow(MinDist, 0.5);
			}
			dV += dIncV;
		}
		dU += dIncU;
	}
	// Refine if dMinPixDist<100
	if (dMinPixDist < dPixSpan) {
		ddsU = dMinU - dIncU;
		ddeU = dMinU + dIncU;
		if (ddsU < dUi)
			ddsU = dUi;
		if (ddeU > dUi + dSpanU)
			ddeU = dUi + dSpanU;
		ddsV = dMinV - dIncV;
		ddeV = dMinV + dIncV;
		if (ddsV < dVi)
			ddsV = dVi;
		if (ddeV > dVi + dSpanV)
			ddeV = dVi + dSpanV;
		dSpanV = ddeV - ddsV;
		dSpanU = ddeU - ddsU;
		// iNo = 100;
		// dw = dds;
		dIncU = dSpanU / NO_PTS_RF;
		dIncV = dSpanV / NO_PTS_RF;
		dU = ddsU + dIncU;
		for (j = 0; j < NO_PTS_RF - 1; j++) {
			dV = ddsV + dIncV;
			for (i = 0; i < NO_PTS_RF - 1; i++) {
				vPt = GetPt(dU, dV);
				ThePoint->Pt_Point->x = vPt.x;
				ThePoint->Pt_Point->y = vPt.y;
				ThePoint->Pt_Point->z = vPt.z;
				ThePoint->SetToScr(pModZ, pScrZ);
				dDist = pow((ThePoint->DSP_Point->x - InPT.x), 2) + pow((ThePoint->DSP_Point->y - InPT.y), 2);
				if (dDist < MinDist) {
					MinDist = dDist;
					Z = ThePoint->DSP_Point->z;
				}
				dV += dIncV;
			}
			dU += dIncU;
		}
	}
	delete (ThePoint);
	Ret.pObj = NULL;

	if (Ret.pObj == NULL) {
		Ret.Dist = MinDist;
		Ret.pObj = this;
		Ret.Z = Z;
	}
	return (Ret);
}

void NSurf::Translate(C3dVector vIn) {
	int i;
	for (i = 0; i < iNoCvs; i++) {
		pCVsU[i]->Translate(vIn);
	}
}

void NSurf::Transform(C3dMatrix TMat) {
	int i;
	for (i = 0; i < iNoCvs; i++) {
		pCVsU[i]->Transform(TMat);
	}
}

C3dVector NSurf::GetPt(double dU, double dV) {
	C3dVector vRet;
	int l, k;
	int uspan;
	int vspan;
	double W;
	double NU[20];
	double NV[20];
	C4dVector temp[20];
	C4dVector pt;
	C4dVector SW;
	if (dU < 0)
		dU = 0;
	else if (dU > 1)
		dU = 1;
	if (dV < 0)
		dV = 0;
	else if (dV > 1)
		dV = 1;

	uspan = pCVsU[0]->FindSpan(dU);
	pCVsU[0]->BasisFun(pCVsU[0]->p, uspan, dU, NU);
	vspan = pCVsV[0]->FindSpan(dV);
	pCVsV[0]->BasisFun(pCVsV[0]->p, vspan, dV, NV);
	for (l = 0; l <= pV; l++) {
		temp[l].Clear();
		for (k = 0; k <= pU; k++) {
			W = pCVsU[vspan - pV + l]->cPts[uspan - pU + k]->w;
			pt.xw = pCVsU[vspan - pV + l]->cPts[uspan - pU + k]->Pt_Point->x * W;
			pt.yw = pCVsU[vspan - pV + l]->cPts[uspan - pU + k]->Pt_Point->y * W;
			pt.zw = pCVsU[vspan - pV + l]->cPts[uspan - pU + k]->Pt_Point->z * W;
			pt.w = W;
			temp[l] = temp[l] + pt * NU[k];
		}
	}
	SW.Clear();
	for (l = 0; l <= pV; l++) {
		SW = SW + temp[l] * NV[l];
	}
	vRet.x = SW.xw / SW.w;
	vRet.y = SW.yw / SW.w;
	vRet.z = SW.zw / SW.w;
	return (vRet);
}

void NSurf::binomialCoef(Mat* Bin) {
	int n, k;
	// Setup the first line
	*Bin->mn2(0, 0) = 1.0;
	for (k = Bin->n - 1; k > 0; --k) {
		*Bin->mn2(0, k) = 0.0;
	}
	// Setup the other lines
	for (n = 0; n < Bin->m - 1; n++) {
		*Bin->mn2(n + 1, 0) = 1.0;
		for (k = 1; k < Bin->n; k++) {
			if (n + 1 < k)
				*Bin->mn2(n, k) = 0.0;
			else
				*Bin->mn2(n + 1, k) = *Bin->mn2(n, k) + *Bin->mn2(n, k - 1);
		}
	}
}

void NSurf::AddTrimCurveExp(NCurveOnSurf* pCurve) {
	if (pCurve != NULL) {
		if (iNoTrimCvs < MAX_LOOPCVS) {
			pSurfCvs[iNoTrimCvs] = pCurve;
			pSurfCvs[iNoTrimCvs]->pParent = this;
			pCurve->iLnType = 1;
			pCurve->iLnThk = 4;
			pCurve->iColour = 75;
			pCurve->SetToScr(pModZ, pScrZ);
			iNoTrimCvs++;
		}
	}
}

NCurveOnSurf* NSurf::AddTrimCurve(NCurve* pCurve) {
	NCurveOnSurf* pSCv = NULL;
	if (pCurve != NULL) {
		if (iNoTrimCvs < MAX_LOOPCVS) {
			pSCv = pCurve->GetSurfaceCV3(this);
			if (pSCv != NULL) {
				pSCv->pParent = this;
				pSCv->iLnType = 1;
				pSCv->iLnThk = 4;
				pSCv->iColour = 75;
				pSurfCvs[iNoTrimCvs] = pSCv;
				// pSurfCvs[iNoTrimCvs]->iColour=this->iColour;
				pSCv->SetToScr(pModZ, pScrZ);
				iNoTrimCvs++;
			}
		}
	}
	return (pSCv);
}

// This does onlt need calling once so remover from Opedgl draw shaded
void NSurf::CleanExternalTrim() {
	int i;
	NCurveOnSurf* c1;
	NCurveOnSurf* c2;
	if (iNoExtCvs > 0) {
		for (i = 0; i < iNoExtCvs - 1; i++) {
			c1 = pExtLoop[i];
			c2 = pExtLoop[i + 1];
			c1->cPts[c1->iNoCPts - 1]->Pt_Point->x = c2->cPts[0]->Pt_Point->x;
			c1->cPts[c1->iNoCPts - 1]->Pt_Point->y = c2->cPts[0]->Pt_Point->y;
		}
		c1 = pExtLoop[iNoExtCvs - 1];
		c2 = pExtLoop[0];
		c1->cPts[c1->iNoCPts - 1]->Pt_Point->x = c2->cPts[0]->Pt_Point->x;
		c1->cPts[c1->iNoCPts - 1]->Pt_Point->y = c2->cPts[0]->Pt_Point->y;
	}
}

C3dVector NSurf::Get_Normal(double dU, double dV) {
	C3dVector v1;
	C3dVector v2;
	C3dVector vN;
	Matrix<C3dVector> der;
	deriveAt(dU, dV, 1, der);
	v1 = der(1, 0);
	v2 = der(0, 1);
	der.DeleteAll();
	vN = v1.Cross(v2);
	return (vN);
}

BOOL NSurf::isPlanar() {
	bool brc = TRUE;
	C3dVector v1;
	C3dVector vt;
	double dDot;
	if ((pU == 1) && (pV == 1)) {
		v1 = Get_Normal(0.5, 0.5);
		v1.Normalize();
		vt = Get_Normal(0.1, 0.1);
		vt.Normalize();
		dDot = v1.Dot(vt);
		if ((dDot < 0.999999) || (dDot > 1.000001))
			return (FALSE);
		vt = Get_Normal(0.9, 0.1);
		vt.Normalize();
		dDot = v1.Dot(vt);
		if ((dDot < 0.999999) || (dDot > 1.000001))
			return (FALSE);
		vt = Get_Normal(0.9, 0.9);
		vt.Normalize();
		dDot = v1.Dot(vt);
		if ((dDot < 0.999999) || (dDot > 1.000001))
			return (FALSE);
	} else {
		brc = FALSE;
	}

	return (brc);
}

BOOL NSurf::isClosedinU() {
	BOOL brc;
	C3dVector s = this->GetPt(0, 1);
	C3dVector e = this->GetPt(1, 1);
	double dD;
	dD = s.Dist(e);
	if (dD < 0.0000001)
		brc = TRUE;
	else
		brc = FALSE;
	return (brc);
}

BOOL NSurf::isClosedinV() {
	BOOL brc;
	C3dVector s = this->GetPt(0, 0);
	C3dVector e = this->GetPt(0, 1);
	double dD;
	dD = s.Dist(e);
	if (dD < 0.0000001)
		brc = TRUE;
	else
		brc = FALSE;
	return (brc);
}

C3dVector NSurf::MinPt(C3dVector inPt) {
	C3dVector vRet;
	const double dIncs = 36;
	int i;
	int j;
	double dStp = 1 / dIncs;

	double dWu = 0;
	double dWv = 0;
	double dMinWu = 0;
	double dMinWv = 0;
	C3dVector cPt;
	C3dVector cNextPt;
	double Dist;
	double minDist = 1e36;
	C3dVector v1;
	C3dVector v2;

	double dDotU;
	double dDotV;
	cPt = GetPt(dWu, dWv);
	for (i = 0; i < dIncs; i++) {
		for (j = 0; j < dIncs; j++) {
			dWu = i * dStp;
			dWv = j * dStp;
			cPt = GetPt(dWu, dWv);
			Dist = cPt.Dist(inPt);
			if (Dist < minDist) {
				minDist = Dist;
				dMinWu = dWu;
				dMinWv = dWv;
			}
		}
	}

	// start of iteration
	dWu = dMinWu;
	dWv = dMinWv;

	i = 0;
	Matrix<C3dVector> der;
	C3dVector Vec;
	double dUscl;
	double dVscl;
	double dErr1 = 1e36;
	double dErr = 1e36;
	double absErr;
	do {
		der.DeleteAll();
		cPt = GetPt(dWu, dWv);
		Vec = inPt - cPt;
		dErr1 = dErr;
		dErr = Vec.Mag();
		absErr = abs(dErr - dErr1);
		deriveAt(dWu, dWv, 1, der);
		v1 = der(1, 0);
		v2 = der(0, 1);
		dUscl = v1.Mag();
		dVscl = v2.Mag();
		v1.Normalize();
		v2.Normalize();
		//  Vec.Normalize();
		dDotU = v1.Dot(Vec) / dUscl;
		dDotV = v2.Dot(Vec) / dVscl;
		dWu += dDotU;
		dWv += dDotV;
		if (dWu > 1) {
			dWu = 1;
		}
		if (dWv > 1) {
			dWv = 1;
		}
		if (dWu < 0) {
			dWu = 0;
		}
		if (dWv < 0) {
			dWv = 0;
		}
		i++;
	} while ((absErr > dTol) && (i < 100));
	vRet = GetPt(dWu, dWv);
	der.DeleteAll();
	return (vRet);
}

C3dVector NSurf::MinPtW(C3dVector inPt) {
	C3dVector vRet;
	const double dTol = 0.00000001;
	const double dIncs = 64;
	int i;
	int j;
	double dStp = 1 / dIncs;

	double dWu = 0;
	double dWv = 0;
	double dMinWu = 0;
	double dMinWv = 0;
	C3dVector cPt;
	C3dVector cPtN;
	C3dVector cNextPt;
	double Dist;
	double minDist = 1e36;
	C3dVector vD;
	C3dVector v1;
	C3dVector v2;

	double dDotU;
	double dDotV;
	cPt = GetPt(dWu, dWv);
	for (i = 0; i < dIncs; i++) {
		for (j = 0; j < dIncs; j++) {
			dWu = i * dStp;
			dWv = j * dStp;
			cPt = GetPt(dWu, dWv);
			cPtN = GetPt(dWu + 0.00001, dWv + 0.00001);
			cPtN -= cPt;
			cPtN.Normalize();
			vD = inPt;
			vD -= cPt;
			vD.Normalize();
			double dD;
			dD = cPtN.Dot(vD);

			Dist = cPt.Dist(inPt);
			if ((Dist < minDist) && (dD >= 0)) {
				minDist = Dist;
				dMinWu = dWu;
				dMinWv = dWv;
			}
		}
	}

	// start of iteration
	dWu = dMinWu;
	dWv = dMinWv;

	i = 0;
	Matrix<C3dVector> der;
	C3dVector Vec;
	double dUscl;
	double dVscl;
	double dErr1 = 1e36;
	double dErr = 1e36;
	double absErr;
	do {
		der.DeleteAll();
		cPt = GetPt(dWu, dWv);
		Vec = inPt - cPt;
		dErr1 = dErr;
		dErr = Vec.Mag();
		absErr = abs(dErr - dErr1);
		deriveAt(dWu, dWv, 1, der);
		v1 = der(1, 0);
		v2 = der(0, 1);
		dUscl = v1.Mag();
		dVscl = v2.Mag();
		v1.Normalize();
		v2.Normalize();
		//  Vec.Normalize();
		dDotU = v1.Dot(Vec) / dUscl;
		dDotV = v2.Dot(Vec) / dVscl;
		dWu += dDotU;
		dWv += dDotV;
		if (dWu > 1) {
			dWu = 1;
		}
		if (dWv > 1) {
			dWv = 1;
		}
		if (dWu < 0) {
			dWu = 0;
		}
		if (dWv < 0) {
			dWv = 0;
		}
		i++;
	} while ((absErr > dTol) && (i < 100));
	vRet.Set(dWu, dWv, 0);
	der.DeleteAll();
	return (vRet);
}

Mat* NSurf::Surfacederive(double u, double v, int d, Matrix<C4dVector>& skl) {
	int k, l, du, dv;
	// Mat* skl = new Mat(d+1,d+1);
	skl.Size(d + 1, d + 1);
	du = minimum(d, pU);
	for (k = pU + 1; k <= d; ++k) {
		for (l = 0; l <= d - k; ++l) {
			skl(k, l).Clear();
		}
	}
	dv = minimum(d, pV);
	for (l = pV + 1; l <= d; ++l) {
		for (k = 0; k <= d - l; ++k) {
			skl(k, l).Clear();
			C4dVector A = skl(k, l);
		}
	}
	int uspan = pCVsU[0]->FindSpan(u);
	int vspan = pCVsV[0]->FindSpan(v);
	Mat* Nu;
	Mat* Nv;
	Nu = pCVsU[0]->dersBasisFuns(du, u, uspan);
	Nv = pCVsV[0]->dersBasisFuns(dv, v, vspan);
	double W;
	C4dVector temp[10];
	int dd, r, s;
	C4dVector pt;
	for (k = 0; k <= du; ++k) {
		for (s = 0; s <= pV; ++s) {
			temp[s].Clear();
			for (r = 0; r <= pU; ++r) {
				// temp[s] += Nu(k,r)*pCVsU[uspan-degU+r]->cPts[vspan-degV+s] ;
				W = pCVsU[vspan - pV + s]->cPts[uspan - pU + r]->w;
				pt.xw = pCVsU[vspan - pV + s]->cPts[uspan - pU + r]->Pt_Point->x * W;
				pt.yw = pCVsU[vspan - pV + s]->cPts[uspan - pU + r]->Pt_Point->y * W;
				pt.zw = pCVsU[vspan - pV + s]->cPts[uspan - pU + r]->Pt_Point->z * W;
				pt.w = W;
				temp[s] = temp[s] + pt * *Nu->mn2(k, r);
			}
		}
		dd = minimum(d - k, dv);
		for (l = 0; l <= dd; ++l) {
			skl(k, l).Clear();
			for (s = 0; s <= pV; ++s) {
				skl(k, l).xw += temp[s].xw * *Nv->mn2(l, s);
				skl(k, l).yw += temp[s].yw * *Nv->mn2(l, s);
				skl(k, l).zw += temp[s].zw * *Nv->mn2(l, s);
				skl(k, l).w += temp[s].w * *Nv->mn2(l, s);
			}
		}
	}

	delete (Nu);
	delete (Nv);
	return (NULL);
}

void NSurf::deriveAt(double u, double v, int d, Matrix<C3dVector>& skl) {
	int i, j, k, l;
	C3dVector pv;
	C3dVector pv2;
	C3dVector a;
	Matrix<C4dVector> ders;
	Surfacederive(u, v, d, ders);
	skl.Size(d + 1, d + 1);
	Mat* Bin = new Mat(d + 1, d + 1);
	binomialCoef(Bin);

	for (k = 0; k <= d; ++k) {
		for (l = 0; l <= d - k; ++l) {
			pv.x = ders(k, l).xw;
			pv.y = ders(k, l).yw;
			pv.z = ders(k, l).zw;
			for (j = 1; j <= l; j++) {
				pv -= skl(k, l - j) * *Bin->mn2(l, j) * ders(0, j).w;
			}
			for (i = 1; i <= k; i++) {
				pv -= skl(k - i, l) * *Bin->mn2(k, i) * ders(i, 0).w;
				pv2.Set(0, 0, 0);
				for (j = 1; j <= l; j++) {
					pv2 += skl(k - i, l - j) * *Bin->mn2(l, j) * ders(i, j).w;
				}
				pv -= pv2 * *Bin->mn2(k, i);
			}
			skl(k, l) = pv;
			skl(k, l) /= ders(0, 0).w;
		}
	}

	delete (Bin);
	ders.DeleteAll();
}

BOOL NSurf::Generate(int pInV, double dvs, double dve) {
	BOOL bRet = FALSE;
	int i;

	// Check no pts and order in each U curve
	if (iNoCvs > 1) {
		for (i = 1; i < iNoCvs; i++) {
			if ((pCVsU[0]->p != pCVsU[i]->p) || (pCVsU[0]->iNoCPts != pCVsU[i]->iNoCPts)) {
				bRet = TRUE;
			}
		}
	} else {
		bRet = TRUE;
	}
	if (bRet == FALSE) {
		pU = pCVsU[0]->p;
		if (iNoCvs >= pInV + 1) {
			pV = pInV;
		} else {
			pV = iNoCvs - 1;
		}
		pCVsV[0] = new NCurve();
		pCVsV[1] = new NCurve();

		pCVsV[0]->Create(-1, this);
		pCVsV[1]->Create(-1, this);
		pCVsV[0]->iNoCPts = iNoCvs;
		pCVsV[1]->iNoCPts = iNoCvs;

		for (i = 0; i < iNoCvs; i++) {
			pCVsV[0]->cPts[i] = pCVsU[i]->cPts[0];
			pCVsV[1]->cPts[i] = pCVsU[i]->cPts[pCVsU[0]->iNoCPts - 1];
		}
		pCVsV[0]->Generate(pV);
		pCVsV[1]->Generate(pV);
	}
	pCVsV[0]->ws = dvs;
	pCVsV[1]->ws = dvs;
	pCVsV[0]->we = dve;
	pCVsV[1]->we = dve;
	DefualtTrim();
	return (bRet);
}

BOOL NSurf::GenerateFit(int pInV, double dvs, double dve) {
	BOOL bRet = FALSE;
	int i;
	int j;
	// Check no pts and order in each U curve
	if (iNoCvs > 1) {
		for (i = 1; i < iNoCvs; i++) {
			if ((pCVsU[0]->p != pCVsU[i]->p) || (pCVsU[0]->iNoCPts != pCVsU[i]->iNoCPts)) {
				bRet = TRUE;
			}
		}
	} else {
		bRet = TRUE;
	}
	Vec<C4dVector> P;
	Vec<double> U;
	if (bRet == FALSE) {
		// Interpolate the points in the V direction
		for (j = 0; j < pCVsU[0]->iNoCPts; j++) {
			NCurve* cPolyW = new NCurve();
			cPolyW->Create(0, NULL);
			for (i = 0; i < iNoCvs; i++) {
				C3dVector a = pCVsU[i]->cPts[j]->GetCoords();
				cPolyW->AddVert(pCVsU[i]->cPts[j]->GetCoords(), pCVsU[i]->cPts[j]->w);
			}
			cPolyW->globalInterp(pInV, P, U);
			cPolyW->GenerateExp(pInV, P, U);
			for (i = 0; i < iNoCvs; i++) {
				// pCVsU[i]->cPts[j]->w=cPolyW->cPts[i]->w;
				pCVsU[i]->cPts[j]->Pt_Point->x = cPolyW->cPts[i]->Pt_Point->x;
				pCVsU[i]->cPts[j]->Pt_Point->y = cPolyW->cPts[i]->Pt_Point->y;
				pCVsU[i]->cPts[j]->Pt_Point->z = cPolyW->cPts[i]->Pt_Point->z;
			}
			P.DeleteAll();
			U.DeleteAll();
			delete (cPolyW);
		}

		//
		pU = pCVsU[0]->p;
		if (iNoCvs >= pInV + 1) {
			pV = pInV;
		} else {
			pV = iNoCvs - 1;
		}
		pCVsV[0] = new NCurve();
		pCVsV[1] = new NCurve();

		pCVsV[0]->Create(-1, this);
		pCVsV[1]->Create(-1, this);
		pCVsV[0]->iNoCPts = iNoCvs;
		pCVsV[1]->iNoCPts = iNoCvs;

		for (i = 0; i < iNoCvs; i++) {
			pCVsV[0]->cPts[i] = pCVsU[i]->cPts[0];
			pCVsV[1]->cPts[i] = pCVsU[i]->cPts[pCVsU[0]->iNoCPts - 1];
		}
		pCVsV[0]->Generate(pV);
		pCVsV[1]->Generate(pV);
	}
	pCVsV[0]->ws = dvs;
	pCVsV[1]->ws = dvs;
	pCVsV[0]->we = dve;
	pCVsV[1]->we = dve;
	DefualtTrim();
	return (bRet);
}

BOOL NSurf::GenerateExp(C3dVector cPts[1000],
                        double wghts[1000],
                        double KnotsU[100],
                        double KnotsV[100],
                        int noU,
                        int noV,
                        int pInU,
                        int pInV) {
	BOOL bRet = FALSE;
	int i;
	int j;
	Create(-1, NULL);
	pU = pInU;
	pV = pInV;
	Vec<C4dVector> P;
	Vec<double> U;
	P.Size(noU);
	U.Size(noU + pInU + 1);
	NCurve* cPolyW;
	for (j = 0; j < noU + pInU + 1; j++) {
		U[j] = KnotsU[j];
	}
	for (i = 0; i < noV; i++) {
		cPolyW = new NCurve();
		for (j = 0; j < noU; j++) {
			P[j].xw = cPts[j + (i * noU)].x;
			P[j].yw = cPts[j + (i * noU)].y;
			P[j].zw = cPts[j + (i * noU)].z;
			P[j].w = wghts[j + (i * noU)];
		}

		cPolyW->GenerateExp(pU, P, U);
		this->AddCV(cPolyW);
	}
	P.clear();
	P.Size(iNoCvs);
	U.clear();
	U.Size(noV + pInV + 1);

	for (i = 0; i < iNoCvs; i++) {
		P[i].xw = pCVsU[i]->cPts[0]->Pt_Point->x;
		P[i].yw = pCVsU[i]->cPts[0]->Pt_Point->y;
		P[i].zw = pCVsU[i]->cPts[0]->Pt_Point->z;
		P[i].w = pCVsU[i]->cPts[0]->w;
	}
	for (j = 0; j < noV + pInV + 1; j++) {
		U[j] = KnotsV[j];
	}
	cPolyW = new NCurve();
	cPolyW->GenerateExp(pV, P, U);
	pCVsV[0] = cPolyW;

	for (i = 0; i < iNoCvs; i++) {
		P[i].xw = pCVsU[i]->cPts[pCVsU[0]->iNoCPts - 1]->Pt_Point->x;
		P[i].yw = pCVsU[i]->cPts[pCVsU[0]->iNoCPts - 1]->Pt_Point->y;
		P[i].zw = pCVsU[i]->cPts[pCVsU[0]->iNoCPts - 1]->Pt_Point->z;
		P[i].w = pCVsU[i]->cPts[pCVsU[0]->iNoCPts - 1]->w;
	}
	cPolyW = new NCurve();
	cPolyW->GenerateExp(pV, P, U);
	pCVsV[1] = cPolyW;

	// DefualtTrim();

	P.DeleteAll();

	////U.DeleteAll;
	// Check no pts and order in each U curve
	// if (iNoCvs>1)
	//{
	//   for (i=1;i<iNoCvs;i++)
	//   {
	//     if ((pCVsU[0]->p!=pCVsU[i]->p) || (pCVsU[0]->iNoCPts!=pCVsU[i]->iNoCPts))
	//     {
	//       bRet=TRUE;
	//     }
	//   }
	// }
	// else
	//{
	// bRet=TRUE;
	// }
	// if (bRet==FALSE)
	//{
	//   pU = pCVsU[0]->p;
	//   if (iNoCvs>=pInV+1)
	//   {
	//     pV = pInV;
	//   }
	//   else
	//   {
	//     pV = iNoCvs-1;
	//   }
	//   pCVsV[0]=new NCurve();
	//   pCVsV[1]=new NCurve();
	//   pCVsV[0]->Create(-1,this);
	//   pCVsV[1]->Create(-1,this);
	//   pCVsV[0]->iNoCPts = iNoCvs;
	//   pCVsV[1]->iNoCPts = iNoCvs;
	//
	//   for (i=0;i<iNoCvs;i++)
	//   {
	//     pCVsV[0]->cPts[i]=pCVsU[i]->cPts[0];
	//     pCVsV[1]->cPts[i]=pCVsU[i]->cPts[pCVsU[0]->iNoCPts-1];
	//   }
	//   pCVsV[0]->Generate(pV);
	//   pCVsV[1]->Generate(pV);
	// }
	// DefualtTrim();
	return (bRet);
}

// Remove the curve from list do not delete as may have been
// moved to a rtim loop
void NSurf::RemoveTrimCv(int ind) {
	int i;
	for (i = ind; i < iNoTrimCvs - 1; i++) {
		pSurfCvs[i] = pSurfCvs[i + 1];
	}
	iNoTrimCvs--;
}

int NSurf::GetTrimCvInd(G_Object* pCV) {
	int irc = -1;
	int i;
	for (i = 0; i < iNoTrimCvs; i++) {
		if (pSurfCvs[i] == pCV) {
			irc = i;
			break;
		}
	}
	return (irc);
}

void NSurf::InternalTrim(ObjList* pCvs) {
	int i;
	int irc;
	BOOL berr = FALSE;

	for (i = 0; i < pCvs->iNo; i++) {
		irc = GetTrimCvInd(pCvs->Objs[i]);
		pIntLoop[iNoIntLoops][i] = pSurfCvs[irc];
		RemoveTrimCv(irc);
	}
	iNoIntCvs[iNoIntLoops] = pCvs->iNo;
	iNoIntLoops++;
}

void NSurf::UserTrim(ObjList* pCvs) {
	int i;
	int irc;
	BOOL berr = FALSE;
	for (i = 0; i < iNoExtCvs; i++) {
		delete (pExtLoop[i]);
	}
	iNoExtCvs = 0;
	for (i = 0; i < pCvs->iNo; i++) {
		irc = GetTrimCvInd(pCvs->Objs[i]);
		pExtLoop[i] = pSurfCvs[irc];
		RemoveTrimCv(irc);
	}
	iNoExtCvs = pCvs->iNo;
}

void NSurf::DeleteExtTrimLoop() {
	// for debuging only at moment
	int i;

	for (i = 0; i < iNoExtCvs; i++) {
		pSurfCvs[iNoTrimCvs] = pExtLoop[i];
		iNoTrimCvs++;
	}
	iNoExtCvs = 0;
	this->DefualtTrim();
}

void NSurf::DeleteIntTrimLoop() {
	// for debuging only at moment
	int i;
	int j;

	for (i = 0; i < iNoIntLoops; i++) {
		for (j = 0; j < iNoIntCvs[i]; j++) {
			pSurfCvs[iNoTrimCvs] = pIntLoop[i][j];
			iNoTrimCvs++;
		}
	}
	iNoIntLoops = 0;
}

void NSurf::DefualtTrim() {
	double ut = pCVsU[0]->we;
	double vt = pCVsV[0]->we;
	;
	double us = pCVsU[0]->ws;
	double vs = pCVsV[0]->ws;
	;
	NCurveOnSurf* pTRM[4];
	pTRM[0] = new NCurveOnSurf();
	pTRM[0]->Create(-1, this);
	C3dVector Pt;
	Pt.Set(us, vs, 0);
	pTRM[0]->AddVert(Pt, 1);
	Pt.Set(ut, vs, 0);
	pTRM[0]->AddVert(Pt, 1);
	pTRM[0]->Generate(1);

	pTRM[1] = new NCurveOnSurf();
	pTRM[1]->Create(-1, this);
	Pt.Set(ut, vs, 0);
	pTRM[1]->AddVert(Pt, 1);
	Pt.Set(ut, vt, 0);
	pTRM[1]->AddVert(Pt, 1);
	pTRM[1]->Generate(1);

	pTRM[2] = new NCurveOnSurf();
	pTRM[2]->Create(-1, this);
	Pt.Set(ut, vt, 0);
	pTRM[2]->AddVert(Pt, 1);
	Pt.Set(us, vt, 0);
	pTRM[2]->AddVert(Pt, 1);
	pTRM[2]->Generate(1);

	pTRM[3] = new NCurveOnSurf();
	pTRM[3]->Create(-1, this);
	Pt.Set(us, vt, 0);
	pTRM[3]->AddVert(Pt, 1);
	Pt.Set(us, vs, 0);
	pTRM[3]->AddVert(Pt, 1);
	pTRM[3]->Generate(1);

	pExtLoop[0] = pTRM[0];
	iNoExtCvs++;
	pExtLoop[1] = pTRM[1];
	iNoExtCvs++;
	pExtLoop[2] = pTRM[2];
	iNoExtCvs++;
	pExtLoop[3] = pTRM[3];
	iNoExtCvs++;
}

// check the direction of the external trim loop if
// counterclockwise then ok for opengl render
BOOL NSurf::ChkExtLoopDir() {
	BOOL brc = FALSE;
	C3dVector vN;
	C3dVector v1;
	C3dVector v2;
	C3dVector vC;
	C3dVector vN2;
	int i;
	// vN= this->Get_Normal(0.5,0.5);
	// vN.Normalize();
	// get two non parrell vector from te trim loop
	// v1=pSurfCvs[pExtLoop[0]]->GetPt(1);
	// v1-=pSurfCvs[pExtLoop[0]]->GetPt(0);

	// v1.Normalize();
	for (i = 0; i < iNoExtCvs - 2; i++) {
		vC = pExtLoop[i]->GetPt(pExtLoop[i]->we);
		vN = vC;
		v1 = pExtLoop[i]->GetPt(pExtLoop[i]->we - 0.01);
		v2 = pExtLoop[i + 1]->GetPt(pExtLoop[i + 1]->ws + 0.01);
		v1 -= vC;
		v2 -= vC;
		v1.Normalize();
		v2.Normalize();
		vC = v2.Cross(v1);
		NCurveOnSurf* pC;

		if (vC.Mag() > 0.1) {
			vC.Normalize();
			pC = pExtLoop[i];
			vN = this->Get_Normal(pC->cPts[pC->iNoCPts - 1]->Pt_Point->x, pC->cPts[pC->iNoCPts - 1]->Pt_Point->y);
			vN.Normalize();
			if (vC.Dot(vN) > 0) {
				brc = TRUE;
				break;
			}
		}
	}

	return (brc);
}

void NSurf::ReverseExtTrimLoop() {
	int i;
	NCurveOnSurf* pEL[500];
	// change the order of the curve and reverse teir definition
	pEL[0] = pExtLoop[0];
	for (i = 1; i < iNoExtCvs; i++) {
		// gluPwlCurve (pSurf, 5, &edgePt[0][0], 2, GLU_MAP1_TRIM_2);
		pEL[i] = pExtLoop[iNoExtCvs - i];
	}
	pExtLoop[0]->Reverse();
	for (i = 1; i < iNoExtCvs; i++) {
		// gluPwlCurve (pSurf, 5, &edgePt[0][0], 2, GLU_MAP1_TRIM_2);
		pExtLoop[i] = pEL[i];
		pExtLoop[i]->Reverse();
	}
}

void NSurf::ReverseIntTrimLoops() {
	int i;
	int j;

	NCurveOnSurf* pIL[500];
	for (i = 0; i < iNoIntLoops; i++) {
		// change the order of the curve and reverse teir definition
		pIL[0] = pIntLoop[i][0];
		for (j = 1; j < iNoIntCvs[i]; j++) {
			// gluPwlCurve (pSurf, 5, &edgePt[0][0], 2, GLU_MAP1_TRIM_2);
			pIL[j] = pIntLoop[i][iNoIntCvs[i] - j];
		}
		for (j = 0; j < iNoIntCvs[i]; j++) {
			// gluPwlCurve (pSurf, 5, &edgePt[0][0], 2, GLU_MAP1_TRIM_2);
			pIntLoop[i][j] = pIL[j];
			pIntLoop[i][j]->Reverse();
		}
	}
}

void NSurf::TrimLoop(double us, double ue, double vs, double ve) {
	pSurfCvs[0] = new NCurveOnSurf();
	pSurfCvs[0]->Create(-1, this);
	C3dVector Pt;
	Pt.Set(us, vs, 0);
	pSurfCvs[0]->AddVert(Pt, 1);
	Pt.Set(ue, vs, 0);
	pSurfCvs[0]->AddVert(Pt, 1);
	pSurfCvs[0]->Generate(1);
	iNoTrimCvs++;
	pSurfCvs[1] = new NCurveOnSurf();
	pSurfCvs[1]->Create(-1, this);
	Pt.Set(ue, vs, 0);
	pSurfCvs[1]->AddVert(Pt, 1);
	Pt.Set(ue, ve, 0);
	pSurfCvs[1]->AddVert(Pt, 1);
	pSurfCvs[1]->Generate(1);
	iNoTrimCvs++;
	pSurfCvs[2] = new NCurveOnSurf();
	pSurfCvs[2]->Create(-1, this);
	Pt.Set(ue, ve, 0);
	pSurfCvs[2]->AddVert(Pt, 1);
	Pt.Set(us, ve, 0);
	pSurfCvs[2]->AddVert(Pt, 1);
	pSurfCvs[2]->Generate(1);
	iNoTrimCvs++;
	pSurfCvs[3] = new NCurveOnSurf();
	pSurfCvs[3]->Create(-1, this);
	Pt.Set(us, ve, 0);
	pSurfCvs[3]->AddVert(Pt, 1);
	Pt.Set(us, vs, 0);
	pSurfCvs[3]->AddVert(Pt, 1);
	pSurfCvs[3]->Generate(1);
	iNoTrimCvs++;
	pExtLoop[0] = pSurfCvs[0];
	iNoExtCvs++;
	pExtLoop[1] = pSurfCvs[1];
	;
	iNoExtCvs++;
	pExtLoop[2] = pSurfCvs[2];
	;
	iNoExtCvs++;
	pExtLoop[3] = pSurfCvs[3];
	;
	iNoExtCvs++;
	RemoveTrimCv(0);
	RemoveTrimCv(1);
	RemoveTrimCv(2);
	RemoveTrimCv(3);
}

CString NSurf::GetName() {
	return ("Surface");
}

IMPLEMENT_DYNAMIC(NSurfR, CObject)

NSurfR::NSurfR() {
	iType = 3;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 151;
	iLabel = -1;
	iObjType = 15;
	iNoCvs = 0;
	DrawCPts = FALSE;
	pCVsV[0] = NULL;
	pCVsV[1] = NULL;
	iNoTrimCvs = 0;
	iNoExtCvs = 0;
}

// CvPt_Object* pVertex[20];
void NSurfR::Create(NCurve* pCIn, C3dVector vN, C3dVector vC, int iLab, G_Object* Parrent, double dS) {
	iType = 3;
	C3dMatrix Glob;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 151;
	iLabel = iLab;
	iObjType = 15;
	iNoCvs = 0;
	DrawCPts = FALSE;
	pParent = Parrent;
	pCVsV[0] = NULL;
	pCVsV[1] = NULL;
	iNoTrimCvs = 0;
	iNoExtCvs = 0;
	iNoIntLoops = 0;
	vNorm = vN;
	vCent = vC;
	C3dVector vX, vY, vZ;
	vY = vN;
	vY.Normalize();
	vX = pCIn->Get_Centroid();
	vX -= vC;
	vX.Normalize();
	vZ = vX.Cross(vY);
	vZ.Normalize();
	vX = vY.Cross(vZ);

	Glob.SetColVec(1, vX);
	Glob.SetColVec(2, vY);
	Glob.SetColVec(3, vZ);
	Glob.m_30 = vC.x;
	Glob.m_31 = vC.y;
	Glob.m_32 = vC.z;

	C3dMatrix mRot;
	mRot.Rotate(0, R2D * dS, 0);
	double r2;
	r2 = 1.4142135623730950488016887242097;

	AddCV(pCIn);
	C3dVector v;
	C3dMatrix Glob2;
	Glob2 = Glob;
	Glob.m_30 = 0;
	Glob.m_31 = 0;
	Glob.m_32 = 0;
	v = -vC;

	Glob.Transpose();
	pCVsU[0]->Translate(v);
	pCVsU[0]->Transform(Glob);

	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->ScaleX(r2);
	pCVsU[iNoCvs - 1]->ScaleW(r2 / 2);
	pCVsU[iNoCvs - 1]->CPolyRot(45);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->CPolyRot(90);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->ScaleX(r2);
	pCVsU[iNoCvs - 1]->ScaleW(r2 / 2);
	pCVsU[iNoCvs - 1]->CPolyRot(135);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->CPolyRot(180);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->ScaleX(r2);
	pCVsU[iNoCvs - 1]->ScaleW(r2 / 2);
	pCVsU[iNoCvs - 1]->CPolyRot(225);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->CPolyRot(270);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->ScaleX(r2);
	pCVsU[iNoCvs - 1]->ScaleW(r2 / 2);
	pCVsU[iNoCvs - 1]->CPolyRot(315);
	AddCV(pCVsU[0]);

	int i;
	for (i = 0; i < iNoCvs; i++) {
		pCVsU[i]->Transform(mRot);
		pCVsU[i]->Transform(Glob2);
	}
}

void NSurfR::CreateRev(NCurve* pCIn, C3dVector vN, C3dVector vC, C3dVector vRef, int iLab, G_Object* Parrent) {
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 16;
	iLabel = iLab;
	iObjType = 16;
	iNoCvs = 0;
	DrawCPts = FALSE;
	pParent = Parrent;
	pCVsV[0] = NULL;
	pCVsV[1] = NULL;
	iNoTrimCvs = 0;
	iNoExtCvs = 0;
	iNoIntLoops = 0;
	vNorm = vN;
	vCent = vC;
	C3dMatrix Glob;
	C3dVector vX, vY, vZ;
	double r2;
	r2 = 1.4142135623730950488016887242097;

	AddCV(pCIn);
	C3dVector v;
	C3dMatrix Glob2;

	v = -vC;
	vX = vRef;
	vY = vN;
	vX.Normalize();
	vY.Normalize();
	vZ = vX.Cross(vY);
	Glob.SetColVec(1, vX);
	Glob.SetColVec(2, vY);
	Glob.SetColVec(3, vZ);
	Glob2 = Glob;
	Glob2.Translate(vC.x, vC.y, vC.z);
	Glob.Transpose();
	pCVsU[0]->Translate(v);
	pCVsU[0]->Transform(Glob);

	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->ScaleX(r2);
	pCVsU[iNoCvs - 1]->ScaleW(r2 / 2);
	pCVsU[iNoCvs - 1]->CPolyRot(45);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->CPolyRot(90);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->ScaleX(r2);
	pCVsU[iNoCvs - 1]->ScaleW(r2 / 2);
	pCVsU[iNoCvs - 1]->CPolyRot(135);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->CPolyRot(180);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->ScaleX(r2);
	pCVsU[iNoCvs - 1]->ScaleW(r2 / 2);
	pCVsU[iNoCvs - 1]->CPolyRot(225);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->CPolyRot(270);
	AddCV(pCVsU[0]);
	pCVsU[iNoCvs - 1]->ScaleX(r2);
	pCVsU[iNoCvs - 1]->ScaleW(r2 / 2);
	pCVsU[iNoCvs - 1]->CPolyRot(315);
	AddCV(pCVsU[0]);

	int i;
	for (i = 0; i < iNoCvs; i++) {
		pCVsU[i]->Transform(Glob2);
	}
}

BOOL NSurfR::Generate(int pInV, double dvs, double dve) {
	BOOL brc;
	brc = NSurf::Generate(2, dvs, dve);
	if (brc == FALSE) {
		pCVsV[0]->knots[0] = 0;
		pCVsV[0]->knots[1] = 0;
		pCVsV[0]->knots[2] = 0;
		pCVsV[0]->knots[3] = 0.25;
		pCVsV[0]->knots[4] = 0.25;
		pCVsV[0]->knots[5] = 0.5;
		pCVsV[0]->knots[6] = 0.5;
		pCVsV[0]->knots[7] = 0.75;
		pCVsV[0]->knots[8] = 0.75;
		pCVsV[0]->knots[9] = 1.0;
		pCVsV[0]->knots[10] = 1.0;
		pCVsV[0]->knots[11] = 1.0;

		pCVsV[1]->knots[0] = 0;
		pCVsV[1]->knots[1] = 0;
		pCVsV[1]->knots[2] = 0;
		pCVsV[1]->knots[3] = 0.25;
		pCVsV[1]->knots[4] = 0.25;
		pCVsV[1]->knots[5] = 0.5;
		pCVsV[1]->knots[6] = 0.5;
		pCVsV[1]->knots[7] = 0.75;
		pCVsV[1]->knots[8] = 0.75;
		pCVsV[1]->knots[9] = 1.0;
		pCVsV[1]->knots[10] = 1.0;
		pCVsV[1]->knots[11] = 1.0;
		this->dUs = pCVsU[0]->knots[0];
		this->dVs = pCVsV[0]->knots[0];
	}

	return (brc);
}

void NSurfR::Serialize(CArchive& ar, int iV) {
	NSurf::Serialize(ar, iV);
	vNorm.Serialize(ar, iV);
	vCent.Serialize(ar, iV);
}

G_Object* NSurfR::Copy(G_Object* Parrent) {
	NSurfR* pSurf = new NSurfR();
	NSurf::Copy2(pSurf);
	pSurf->pParent = Parrent;
	pSurf->vNorm = vNorm;
	pSurf->vCent = vCent;
	return (pSurf);
}

IMPLEMENT_DYNAMIC(NSurfE, CObject)

NSurfE::NSurfE() {
	iType = 2;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 151;
	iLabel = -1;
	iObjType = 15;
	iNoCvs = 0;
	DrawCPts = FALSE;
	pCVsV[0] = NULL;
	pCVsV[1] = NULL;
	iNoTrimCvs = 0;
	iNoExtCvs = 0;
}

// CvPt_Object* pVertex[20];
void NSurfE::Create(NCurve* pCIn1, NCurve* pCIn2, C3dVector vTr, int iLab, G_Object* Parrent) {
	iType = 2;
	Drawn = 0;
	Selectable = 1;
	Visable = 1;
	iColour = 151;
	iLabel = iLab;
	iObjType = 15;
	iNoCvs = 0;
	DrawCPts = FALSE;
	pParent = Parrent;
	pCVsV[0] = NULL;
	pCVsV[1] = NULL;
	vTran = vTr;
	iNoTrimCvs = 0;
	iNoExtCvs = 0;
	AddCV(pCIn1);
	AddCV(pCIn2);
	iNoIntLoops = 0;
}

BOOL NSurfE::Generate(int pInV, double dvs, double dve) {
	BOOL brc;
	brc = NSurf::Generate(1, dvs, dve);
	return (brc);
}

G_Object* NSurfE::Copy(G_Object* Parrent) {
	NSurfE* pSurf = new NSurfE();
	NSurf::Copy2(pSurf);
	pSurf->pParent = Parrent;
	pSurf->vTran = vTran;
	return (pSurf);
}

void NSurfE::Serialize(CArchive& ar, int iV) {
	NSurf::Serialize(ar, iV);
	vTran.Serialize(ar, iV);
}

IgesP::IgesP() {
	iNo = 0;
}

void IgesP::Add(CString inSt) {
	P[iNo] = inSt;
	iNo++;
}

CString IgesP::getPLine(int pInd, int iNo) {
	int i;
	int iC;
	CString sL = "";
	for (i = 0; i < iNo; i++) {
		sL += P[pInd - 1 + i];
		if (i == iNo - 1) {
			iC = sL.ReverseFind(';');
			sL = sL.Left(iC);
		} else {
			iC = sL.ReverseFind(',');
			sL = sL.Left(iC + 1);
		}
	}
	sL += ',';
	return (sL);
}

BEGIN_MESSAGE_MAP(CFilterDialog, CDialog)
ON_LBN_SELCHANGE(IDC_LIST1, &CFilterDialog::OnLbnSelchangeList1)
ON_LBN_DBLCLK(IDC_LIST1, &CFilterDialog::OnLbnDblclkList1)
ON_LBN_DBLCLK(IDC_LIST2, &CFilterDialog::OnLbnDblclkList2)
ON_BN_CLICKED(IDC_BUTTON1, &CFilterDialog::OnBnClickedButton1)
ON_BN_CLICKED(IDC_CLEAR_FIL, &CFilterDialog::OnBnClickedClearFil)
ON_BN_CLICKED(IDC_BUTTON2, &CFilterDialog::OnBnClickedButton2)
END_MESSAGE_MAP()

//*****************************************************************
// The filter dialog box
//*****************************************************************
CFilterDialog::CFilterDialog()
    : CDialog(CFilterDialog::IDD, NULL) {
}

void CFilterDialog::OnLbnSelchangeList1() {
	// TODO: Add your control notification handler code here
}

void CFilterDialog::ReSet() {
	int i;
	CListBox* pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST1);
	CListBox* pItemsNonSelectable = (CListBox*) GetDlgItem(IDC_LIST2);
	char OutT[80];

	for (i = 0; i < pFilt->iNoOfType; i++) {
		sprintf_s(OutT, "%i : %s", pFilt->iType[i], pFilt->sType[i]);
		if (pFilt->isFilter(pFilt->iType[i]) == TRUE) {
			pItemsNonSelectable->AddString(OutT);
		} else {
			pItemsSelectable->AddString(OutT);
		}
	}
}

BOOL CFilterDialog::OnInitDialog() {
	CDialog::OnInitDialog();

	// TODO:  Add extra initialization here
	ReSet();
	return TRUE; // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CFilterDialog::OnLbnDblclkList1() {
	// TODO: Add your control notification handler code here
	CListBox* pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST1);
	int ind = pItemsSelectable->GetCurSel();
	CString cT;
	pItemsSelectable->GetText(ind, cT);
	int i1;
	CString sR;
	i1 = cT.Find(":");
	sR = cT.Left(i1 - 1);
	ind = atoi(sR);
	pFilt->SetFilter(ind);
	pItemsSelectable->ResetContent();
	pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST2);
	pItemsSelectable->ResetContent();
	ReSet();
}

void CFilterDialog::OnLbnDblclkList2() {
	// TODO: Add your control notification handler code here
	CListBox* pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST2);
	int ind = pItemsSelectable->GetCurSel();
	CString cT;
	pItemsSelectable->GetText(ind, cT);
	int i1;
	CString sR;
	i1 = cT.Find(":");
	sR = cT.Left(i1 - 1);
	ind = atoi(sR);
	pFilt->RemFilter(ind);
	pItemsSelectable->ResetContent();
	pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST1);
	pItemsSelectable->ResetContent();
	ReSet();
}

void CFilterDialog::OnBnClickedButton1() {
	pFilt->SetAll();
	CListBox* pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST2);
	pItemsSelectable->ResetContent();
	pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST1);
	pItemsSelectable->ResetContent();
	ReSet();
}

void CFilterDialog::OnBnClickedClearFil() {
	// TODO: Add your control notification handler code here
	pFilt->Clear();
	CListBox* pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST2);
	pItemsSelectable->ResetContent();
	pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST1);
	pItemsSelectable->ResetContent();
	ReSet();
}

void CFilterDialog::OnBnClickedButton2() {
	// TODO: Add your control notification handler code here
	int ind;
	int ind2;
	int i1;
	CString cT;
	CString sR;
	CListBox* pItemsSelectable = (CListBox*) GetDlgItem(IDC_LIST2);
	CListBox* pItemsNonSelectable = (CListBox*) GetDlgItem(IDC_LIST1);
	ind = pItemsSelectable->GetCurSel();
	ind2 = pItemsNonSelectable->GetCurSel();
	if ((ind >= 0) || (ind2 >= 0)) {
		pFilt->Clear();
	}
	if (ind >= 0) {
		pItemsSelectable->GetText(ind, cT);
		i1 = cT.Find(":");
		sR = cT.Left(i1 - 1);
		ind = atoi(sR);
		pFilt->SetFilter(ind);
	}
	if (ind2 >= 0) {
		pItemsNonSelectable->GetText(ind2, cT);
		i1 = cT.Find(":");
		sR = cT.Left(i1 - 1);
		ind2 = atoi(sR);
		pFilt->SetFilter(ind2);
	}
	if ((ind >= 0) || (ind2 >= 0)) {
		pItemsSelectable->ResetContent();
		pItemsNonSelectable->ResetContent();
		ReSet();
	}
	OnOK();
}

CGroupDialog::CGroupDialog()
    : CDialog(CGroupDialog::IDD, NULL) {
	iNo = 0;
}

void CGroupDialog::AddGroup(CString sName) {
	Groups[iNo] = sName;
	iNo++;
}

void CGroupDialog::RefreshGPS() {
	int i;
	char OutT[80];
	CListBox* pGroups = (CListBox*) GetDlgItem(IDC_GROUP_SEL);
	pGroups->ResetContent();
	for (i = 0; i < iNo; i++) {
		sprintf_s(OutT, "%i : %s", i, Groups[i]);
		pGroups->AddString(OutT);
	}
	if (iGp != -1) {
		pGroups->SetCurSel(iGp);
	}
}

void CGroupDialog::DeleteGP(int iThisGp) {
	int i;
	if (iThisGp != -1) {
		for (i = iThisGp; i < iNo - 1; i++) {
			Groups[i] = Groups[i + 1];
		}
		iNo--;
		char sStr[10];
		_itoa(iGp, sStr, 10);
		outtextMSG2("GPDEL");
		outtextMSG2(sStr);
		if ((iThisGp > -1) && (iThisGp < iNo)) {
			iGp = iThisGp;
		} else {
			iGp = -1;
		}
		RefreshGPS();
	}
}

BOOL CGroupDialog::OnInitDialog() {
	CDialog::OnInitDialog();
	RefreshGPS();
	return (TRUE);
}

BEGIN_MESSAGE_MAP(CGroupDialog, CDialog)
ON_BN_CLICKED(IDOK, &CGroupDialog::OnBnClickedOk)
ON_BN_CLICKED(IDCANCEL, &CGroupDialog::OnBnClickedCancel)
ON_BN_CLICKED(IDC_GROUPADDGP, &CGroupDialog::OnBnClickedGroupaddgp)
ON_BN_CLICKED(IDC_GROUPREMGRP, &CGroupDialog::OnBnClickedGroupremgrp)
ON_BN_CLICKED(IDC_GROUPDSPCURRENT, &CGroupDialog::OnBnClickedGroupdspcurrent)
ON_BN_CLICKED(IDC_GROUPDSPALL, &CGroupDialog::OnBnClickedGroupdspall)
ON_BN_CLICKED(IDC_GROUPDELS, &CGroupDialog::OnBnClickedGroupdels)
END_MESSAGE_MAP()

void CGroupDialog::OnBnClickedOk() {
	// TODO: Add your control notification handler code here
	CListBox* pGroups = (CListBox*) GetDlgItem(IDC_GROUP_SEL);
	iGp = pGroups->GetCurSel();
	if (iGp != -1) {
		char sStr[10];
		_itoa(iGp, sStr, 10);
		outtextMSG2("GPSET");
		outtextMSG2(sStr);
	}
	// OnOK();
}

void CGroupDialog::OnBnClickedCancel() {
	// TODO: Add your control notification handler code here
	iGp = -1;
	OnCancel();
}

CRelToDialog::CRelToDialog()
    : CDialog(CRelToDialog::IDD, NULL) {
	iType = -1;
}

BOOL CRelToDialog::OnInitDialog() {
	CDialog::OnInitDialog();

	int i;
	CListBox* pTypes = (CListBox*) GetDlgItem(IDC_LIST_RELTO);
	char OutT[80];
	for (i = 0; i < pFilt->iNoOfType; i++) {
		sprintf_s(OutT, "%i : %s", pFilt->iType[i], pFilt->sType[i]);
		pTypes->AddString(OutT);
	}

	return TRUE; // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_MESSAGE_MAP(CRelToDialog, CDialog)
ON_LBN_DBLCLK(IDC_LIST_RELTO, &CRelToDialog::OnLbnDblclkListRelto)
END_MESSAGE_MAP()

void CRelToDialog::OnLbnDblclkListRelto() {
	int ind;
	int i1;
	CString sR;
	// TODO: Add your control notification handler code here
	CListBox* pTypes = (CListBox*) GetDlgItem(IDC_LIST_RELTO);
	iType = pTypes->GetCurSel();
	CString cT;
	pTypes->GetText(iType, cT);
	i1 = cT.Find(":");
	sR = cT.Left(i1 - 1);
	ind = atoi(sR);
	iType = ind;
	OnOK();
}

IMPLEMENT_DYNAMIC(BSec, CObject)

BSec::~BSec() {
	iLnCnt1 = 0;
	iLnCnt2 = 0;
}

void BSec::Clear() {
	iLnCnt1 = 0;
	iLnCnt2 = 0;
}

BSec::BSec() {
	int iLnCnt1 = 0;
	int iLnCnt2 = 0;
}

void BSec::Create() {
	int iLnCnt1 = 0;
	int iLnCnt2 = 0;
}

void BSec::CreateDefSec(double W, int iC) {
	Clear();
	int i;
	double Ang = 0;
	double AngInc;
	AngInc = (360.0 / (MAX_SECPTS - 1)) * D2R;
	for (i = 0; i < MAX_SECPTS - 1; i++) {
		AddOutPt(W * sin(Ang), W * cos(Ang));
		Ang += AngInc;
	}
	AddOutPt(W * sin(0.0), W * cos(0.0));
}

void BSec::CreateBox(double W, double H, double Wthk, double Hthk) {
	Clear();
	W /= 2;
	H /= 2;
	AddOutPt(-W, -H);
	AddOutPt(-W, +H);
	AddOutPt(+W, +H);
	AddOutPt(+W, -H);
	AddOutPt(-W, -H);
	W -= Wthk;
	H -= Hthk;
	AddInPt(-W, -H);
	AddInPt(-W, +H);
	AddInPt(+W, +H);
	AddInPt(+W, -H);
	AddInPt(-W, -H);
}

void BSec::CreateL(double W, double H, double Wthk, double Hthk, double yb, double zb) {
	Clear();
	AddOutPt(0, 0);
	AddOutPt(0, H);
	AddOutPt(Wthk, H);
	AddOutPt(Wthk, Hthk);
	AddOutPt(W, Hthk);
	AddOutPt(W, 0);
	AddOutPt(0, 0);
	MoveY(yb);
	MoveX(zb);
}

void BSec::CreateT2(double W, double H, double Wthk, double Hthk, double yb) {
	Clear();
	// For some reason the section is upside down need to check why
	W /= 2;

	AddOutPt(-W, 0);
	AddOutPt(-W, Wthk);
	AddOutPt(-Hthk / 2, Wthk);
	AddOutPt(-Hthk / 2, H);
	AddOutPt(Hthk / 2, H);
	AddOutPt(Hthk / 2, Wthk);
	AddOutPt(W, Wthk);
	AddOutPt(W, 0);
	AddOutPt(-W, 0);
	MoveY(yb);
}

void BSec::CreateCHAN2(double d1, double d2, double d3, double d4, double yb) {
	Clear();

	double dW = d4;
	double dH = d3;
	double dWt = d1;
	double dFt = d2;
	dW /= 2;
	AddOutPt(-dW, 0);
	AddOutPt(-dW, dH);
	AddOutPt(-dW + dWt, dH);
	AddOutPt(-dW + dWt, dFt);
	AddOutPt(dW - dWt, dFt);
	AddOutPt(dW - dWt, dH);
	AddOutPt(dW, dH);
	AddOutPt(dW, 0);
	AddOutPt(-dW, 0);
	MoveY(yb);
}

void BSec::CreateBar(double W, double H) {
	Clear();
	W /= 2;
	H /= 2;
	AddOutPt(-W, -H);
	AddOutPt(-W, +H);
	AddOutPt(+W, +H);
	AddOutPt(+W, -H);
	AddOutPt(-W, -H);
}

void BSec::CreateI2(double d1, double d2, double d3, double d4, double d5, double d6, double yb) {
	Clear();
	double dh = d1;
	double dw1 = d2;
	double dw2 = d3;
	double dwt = d4;
	double dft1 = d5;
	double dft2 = d6;
	dw1 /= 2;
	dw2 /= 2;
	AddOutPt(-dw1, 0);
	AddOutPt(-dw1, dft1);
	AddOutPt(-dwt / 2, dft1);
	AddOutPt(-dwt / 2, dh - dft2);
	AddOutPt(-dw2, dh - dft2);
	AddOutPt(-dw2, dh);
	AddOutPt(dw2, dh);
	AddOutPt(dw2, dh - dft2);
	AddOutPt(dwt / 2, dh - dft2);
	AddOutPt(dwt / 2, dft1);
	AddOutPt(dw1, dft1);
	AddOutPt(dw1, 0);
	AddOutPt(-dw1, 0);
	MoveY(yb);
}

void BSec::CreateRod(double R) {
	Clear();
	int i;
	double Ang = 0;
	double AngInc;
	AngInc = (360.0 / (MAX_SECPTS - 1)) * D2R;
	for (i = 0; i < MAX_SECPTS - 1; i++) {
		AddOutPt(R * sin(Ang), R * cos(Ang));
		Ang += AngInc;
	}
	AddOutPt(R * sin(0.0), R * cos(0.0));
}

void BSec::CreateTube(double R, double r) {
	Clear();
	int i;
	double Ang = 0;
	double AngInc;
	AngInc = (360.0 / (MAX_SECPTS - 1)) * D2R;
	for (i = 0; i < MAX_SECPTS - 1; i++) {
		AddOutPt(R * sin(Ang), R * cos(Ang));
		Ang += AngInc;
	}
	AddOutPt(R * sin(0.0), R * cos(0.0));
	Ang = 0;
	for (i = 0; i < MAX_SECPTS - 1; i++) {
		AddInPt(r * sin(Ang), r * cos(Ang));
		Ang += AngInc;
	}
	AddInPt(r * sin(0.0), r * cos(0.0));
}

void BSec::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		ar << iLnCnt1;
		ar << iLnCnt2;
		ar << inPt.x;
		ar << inPt.y;
		ar << inPt.z;
		ar << iLnCnt1;
		for (i = 0; i < iLnCnt1; i++) {
			ar << pLnLoop1[i].x;
			ar << pLnLoop1[i].y;
			ar << pLnLoop1[i].z;
		}
		ar << iLnCnt2;
		for (i = 0; i < iLnCnt2; i++) {
			ar << pLnLoop2[i].x;
			ar << pLnLoop2[i].y;
			ar << pLnLoop2[i].z;
		}
	} else {
		ar >> iLnCnt1;
		ar >> iLnCnt2;
		ar >> inPt.x;
		ar >> inPt.y;
		ar >> inPt.z;
		ar >> iLnCnt1;
		for (i = 0; i < iLnCnt1; i++) {
			ar >> pLnLoop1[i].x;
			ar >> pLnLoop1[i].y;
			ar >> pLnLoop1[i].z;
		}
		ar >> iLnCnt2;
		for (i = 0; i < iLnCnt2; i++) {
			ar >> pLnLoop2[i].x;
			ar >> pLnLoop2[i].y;
			ar >> pLnLoop2[i].z;
		}
	}
}

void BSec::OglDraw(int iDspFlgs, C3dMatrix TA, C3dMatrix TB, C3dVector d0, C3dVector d1, float C1, float C2, BOOL bD) {
	C3dVector p1;
	C3dVector p2;
	C3dVector p3;
	C3dVector p4;

	int j = 0;
	if (((iDspFlgs & DSP_CONT) > 0) || (bD == FALSE)) {
		if (iLnCnt1 > 1) {
			for (j = 0; j < iLnCnt1 - 1; j++) {
				p1 = TA * pLnLoop1[j + 1];
				p2 = TA * pLnLoop1[j];
				p3 = TB * pLnLoop1[j];
				p4 = TB * pLnLoop1[j + 1];
				glBegin(GL_POLYGON);
				glVertex3f((float) (p1.x + d0.x), (float) (p1.y + d0.y), (float) (p1.z + d0.z));
				glVertex3f((float) (p4.x + d1.x), (float) (p4.y + d1.y), (float) (p4.z + d1.z));
				glVertex3f((float) (p3.x + d1.x), (float) (p3.y + d1.y), (float) (p3.z + d1.z));
				glVertex3f((float) (p2.x + d0.x), (float) (p2.y + d0.y), (float) (p2.z + d0.z));
				glEnd();
			}
		}
		if (iLnCnt2 > 1) {
			for (j = 0; j < iLnCnt2 - 1; j++) {
				p1 = TA * pLnLoop2[j];
				p2 = TA * pLnLoop2[j + 1];
				p3 = TB * pLnLoop2[j + 1];
				p4 = TB * pLnLoop2[j];
				glBegin(GL_POLYGON);
				glVertex3f((float) (p1.x + d0.x), (float) (p1.y + d0.y), (float) (p1.z + d0.z));
				glVertex3f((float) (p4.x + d1.x), (float) (p4.y + d1.y), (float) (p4.z + d1.z));
				glVertex3f((float) (p3.x + d1.x), (float) (p3.y + d1.y), (float) (p3.z + d1.z));
				glVertex3f((float) (p2.x + d0.x), (float) (p2.y + d0.y), (float) (p2.z + d0.z));
				glEnd();
			}
		}
	} else {
		glColor3fv(cols[124]);
		glEnable(GL_TEXTURE_1D);
		if (iLnCnt1 > 1) {
			for (j = 0; j < iLnCnt1 - 1; j++) {
				p1 = TA * pLnLoop1[j + 1];
				p2 = TA * pLnLoop1[j];
				p3 = TB * pLnLoop1[j];
				p4 = TB * pLnLoop1[j + 1];
				glBegin(GL_POLYGON);
				glTexCoord1f(C1);
				glVertex3f((float) (p1.x + d0.x), (float) (p1.y + d0.y), (float) (p1.z + d0.z));
				glTexCoord1f(C2);
				glVertex3f((float) (p4.x + d1.x), (float) (p4.y + d1.y), (float) (p4.z + d1.z));
				glTexCoord1f(C2);
				glVertex3f((float) (p3.x + d1.x), (float) (p3.y + d1.y), (float) (p3.z + d1.z));
				glTexCoord1f(C1);
				glVertex3f((float) (p2.x + d0.x), (float) (p2.y + d0.y), (float) (p2.z + d0.z));

				glEnd();
			}
		}
		if (iLnCnt2 > 1) {
			for (j = 0; j < iLnCnt2 - 1; j++) {
				p1 = TA * pLnLoop2[j];
				p2 = TA * pLnLoop2[j + 1];
				p3 = TB * pLnLoop2[j + 1];
				p4 = TB * pLnLoop2[j];
				glBegin(GL_POLYGON);
				glVertex3f((float) (p1.x + d0.x), (float) (p1.y + d0.y), (float) (p1.z + d0.z));
				glVertex3f((float) (p4.x + d1.x), (float) (p4.y + d1.y), (float) (p4.z + d1.z));
				glVertex3f((float) (p3.x + d1.x), (float) (p3.y + d1.y), (float) (p3.z + d1.z));
				glVertex3f((float) (p2.x + d0.x), (float) (p2.y + d0.y), (float) (p2.z + d0.z));
				glEnd();
			}
		}
		glDisable(GL_TEXTURE_1D);
	}
}

void BSec::OglDrawW(int iDspFlgs, C3dMatrix TMat, C3dVector d0, C3dVector d1) {
	C3dVector p1;
	C3dVector p2;
	C3dVector vOf;
	vOf = d0;
	vOf += d1;
	vOf *= 0.5;
	int j = 0;
	glLineWidth(gBM_SIZE);
	if (iLnCnt1 > 1) {
		for (j = 0; j < iLnCnt1 - 1; j++) {
			p1 = TMat * pLnLoop1[j];
			p2 = TMat * pLnLoop1[j + 1];
			glBegin(GL_LINES);
			glVertex3f((float) (p1.x + vOf.x), (float) (p1.y + vOf.y), (float) (p1.z + vOf.z));
			glVertex3f((float) (p2.x + vOf.x), (float) (p2.y + vOf.y), (float) (p2.z + vOf.z));
			glEnd();
		}
	}
	if (iLnCnt2 > 1) {
		for (j = 0; j < iLnCnt2 - 1; j++) {
			p1 = TMat * pLnLoop2[j];
			p2 = TMat * pLnLoop2[j + 1];
			glBegin(GL_LINES);
			glVertex3f((float) (p1.x + vOf.x), (float) (p1.y + vOf.y), (float) (p1.z + vOf.z));
			glVertex3f((float) (p2.x + vOf.x), (float) (p2.y + vOf.y), (float) (p2.z + vOf.z));
			glEnd();
		}
	}
}

void BSec::AddOutPt(double X1, double Y1) {
	if (iLnCnt1 < MAX_SECPTS) {
		pLnLoop1[iLnCnt1].Set(X1, Y1, 0);
		iLnCnt1++;
	}
}

void BSec::AddInPt(double X1, double Y1) {
	if (iLnCnt2 < MAX_SECPTS) {
		pLnLoop2[iLnCnt2].Set(X1, Y1, 0);
		iLnCnt2++;
	}
}

void BSec::MoveY(double yBar) {
	int i;
	for (i = 0; i < iLnCnt1; i++) {
		pLnLoop1[i].y -= yBar;
	}
	for (i = 0; i < iLnCnt2; i++) {
		pLnLoop2[i].y -= yBar;
	}
}

void BSec::MoveX(double zBar) {
	int i;
	for (i = 0; i < iLnCnt1; i++) {
		pLnLoop1[i].x -= zBar;
	}
	for (i = 0; i < iLnCnt2; i++) {
		pLnLoop2[i].x -= zBar;
	}
}

IMPLEMENT_DYNAMIC(MatTable, CObject)

Material* MatTable::GetItem(int iID) {
	Material* pRet;
	pRet = (Material*) Table::GetItem(iID);
	return (pRet);
}

void MatTable::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		ar << iNo;
		for (i = 0; i < iNo; i++) {
			ar << pEnts[i]->iType;
			pEnts[i]->Serialize(ar, iV);
		}
	} else {
		int iE;
		ar >> iNo;
		for (i = 0; i < iNo; i++) {
			ar >> iE;
			switch (iE) {
				case 1:
					pEnts[i] = new MAT1;
					break;
				case 8:
					pEnts[i] = new MAT8;
					break;
			}
			pEnts[i]->Serialize(ar, iV);
		}
	}
}

IMPLEMENT_DYNAMIC(PropTable, CObject)

Property* PropTable::GetItem(int iID) {
	Property* pRet;
	pRet = (Property*) Table::GetItem(iID);
	return (pRet);
}

void PropTable::UpdateMats(NEList* newMats) {
	int i;
	Property* pRet;
	for (i = 0; i < iNo; i++) {
		pRet = (Property*) pEnts[i];
		pRet->UpdateMats(newMats);
	}
}

PBARL* PropTable::GetPBARL(CString sT, double W, double H, double dTHK, double dNSM, int iM) {
	int i;
	PBARL* pRet = NULL;
	PBARL* pB = NULL;
	for (i = 0; i < iNo; i++) {
		if (pEnts[i]->iType == 5) {
			pB = (PBARL*) pEnts[i];
			if ((pB->sSecType == sT) &&
			    (pB->dNSM == dNSM) &&
			    (pB->iMID == iM) &&
			    (pB->dDIMs[0] == W) &&
			    (pB->dDIMs[1] == H) &&
			    (pB->dDIMs[2] == dTHK)) {
				pRet = pB;
			}
		}
	}
	return (pRet);
}

PSHELL* PropTable::GetShell(double dTHK, double dNSM, int iM) {
	int i;
	PSHELL* pRet = NULL;
	PSHELL* pS = NULL;
	for (i = 0; i < iNo; i++) {
		if (pEnts[i]->iType == 1) {
			pS = (PSHELL*) pEnts[i];
			if ((pS->dT == dTHK) &&
			    (pS->iMID1 == iM) &&
			    (pS->dNSM == dNSM)) {
				pRet = pS;
			}
		}
	}

	return (pRet);
}

void PropTable::Serialize(CArchive& ar, int iV) {
	int i;
	if (ar.IsStoring()) {
		ar << iNo;
		for (i = 0; i < iNo; i++) {
			ar << pEnts[i]->iType;
			pEnts[i]->Serialize(ar, iV);
		}
	} else {
		int iE;
		ar >> iNo;
		for (i = 0; i < iNo; i++) {
			ar >> iE;
			switch (iE) {
				case 1:
					pEnts[i] = new PSHELL;
					break;
				case 2:
					pEnts[i] = new PCOMP;
					break;
				case 222:
					pEnts[i] = new PCOMPG;
					break;
				case 3:
					pEnts[i] = new PSOLID;
					break;
				case 4:
					pEnts[i] = new PBAR;
					break;
				case 5:
					pEnts[i] = new PBARL;
					break;
				case 6:
					pEnts[i] = new PBEAM;
					break;
				case 11:
					pEnts[i] = new PROD;
					break;
				case 136:
					pEnts[i] = new PSPRINGT;
					break;
				case 137:
					pEnts[i] = new PSPRINGR;
					break;
				case 138:
					pEnts[i] = new PBUSH();
					break;
				case 161:
					pEnts[i] = new PMASS;
					break;
			}
			pEnts[i]->Serialize(ar, iV);
			if (iE == 4) {
				PBAR* pbar = (PBAR*) pEnts[i];
				pbar->CreateSec();
			} else if (iE == 6) {
				PBEAM* pbar = (PBEAM*) pEnts[i];
				pbar->CreateSec();
			}
		}
	}
}

//****************************************************************
// PROPERTY TABLE
//****************************************************************
IMPLEMENT_DYNAMIC(Table, CObject)

Table::Table() {
	iNo = 0;
}

Table::~Table() {
	DeleteAll();
}

void Table::DeleteAll() {
	int i;
	for (i = 0; i < iNo; i++)
		delete (pEnts[i]);
	iNo = 0;
}

void Table::Delete(Entity* pO) {
	int i;
	for (i = 0; i < iNo; i++) {
		if (pEnts[i] == pO) {
			delete (pEnts[i]);
			pEnts[i] = pEnts[iNo - 1];
			iNo--;
		}
	}
}

void Table::AddItem(Entity* pIn) {
	BOOL bisIn = Exists(pIn->iID);
	if (bisIn == FALSE) {
		if (iNo < MAX_ENTS) {
			pEnts[iNo] = pIn;
			iNo++;
		} else {
			outtext1("ERROR: Max No in Table Exceeded.");
		}
	} else {
		char S1[80];
		sprintf_s(S1, "%s%i", "WARNING: Property Conflict. ", pIn->iID);
		outtext1(S1);
	}
}

BOOL Table::Exists(int iPID) {
	int i;
	BOOL bRet = FALSE;
	for (i = 0; i < iNo; i++) {
		if (pEnts[i]->iID == iPID) {
			bRet = TRUE;
			break;
		}
	}
	return (bRet);
}

Entity* Table::GetItem(int iID) {
	Entity* pRet = NULL;
	int i;
	for (i = 0; i < iNo; i++) {
		if (pEnts[i]->iID == iID) {
			pRet = pEnts[i];
			break;
		}
	}
	return (pRet);
}

void Table::ExportNAS(FILE* pF, int iFileNo) {
	int i;
	for (i = 0; i < iNo; i++) {
		if ((iFileNo == -1) || (pEnts[i]->iFile == iFileNo))
			pEnts[i]->ExportNAS(pF);
	}
}

void Table::ListAll() {
	int i;
	if (iNo > 0) {
		for (i = 0; i < iNo; i++) {
			// Saeed_Material_SaveBugV1_05_20_2025_Start
			/*
			//Saeed_Material_SaveBugV1_05_20_2025_End
			pEnts[i]->ListShort();
			//Saeed_Material_SaveBugV1_05_20_2025_Start
			*/
			pEnts[i]->ListShort(i + 1);
			// Saeed_Material_SaveBugV1_05_20_2025_End
		}
	} else {
		outtext1("None Defined.");
	}
}

int Table::NextID() {
	int i;
	int iRet = 0;
	if (iNo > 0) {
		for (i = 0; i < iNo; i++) {
			if (pEnts[i]->iID > iRet) {
				iRet = pEnts[i]->iID;
			}
		}
	}
	iRet++;
	return (iRet);
}

// Saeed_Material_SaveBugV1_05_20_2025_Start
int Table::OfferedID(int idIn, bool findNew, int newIdMode) { // newIdMode: 1>> Max of current list + 1 2>>Smallest empty room
	// fill check matrix:
	int i, idMaxInList;
	std::set<int> idSet;
	for (i = 0; i < iNo; i++) {
		idSet.insert(pEnts[i]->iID);
	}
	if (findNew && newIdMode == 1) { // if we need to find a new offered id in mode 1:
		idMaxInList = 0;
		for (i = 0; i < iNo; i++) {
			if (pEnts[i]->iID > idMaxInList) {
				idMaxInList = pEnts[i]->iID;
			}
		}
		return idMaxInList + 1;
	}
	if (findNew && newIdMode == 2) { // if we need to find a new offered id in mode 2:
		i = 1;
		while (i <= MAX_ENTS) {
			if (idSet.find(i) == idSet.end()) {
				// std::cout << "                              New ID: ";
				return i;
			}
			i++;
		}
		// show "Error: matrix is full."
		// std::cout << "######## Error: matrix is full. ########\n";
		return -1;
	} else { // if we need to find an offered id based on inputed user id (idIn):
		// if not exist in matrix:
		if (idSet.find(idIn) == idSet.end() && idIn >= 1 && idIn <= MAX_ENTS) {
			// std::cout << "                       True Place ID: ";
			return idIn;
		}
		// move down ID
		for (i = idIn; i >= 1; i--) {
			if (idSet.find(i) == idSet.end() && i <= MAX_ENTS) {
				// std::cout << "                       Moved Down ID: ";
				return i;
			}
		}
		// move up ID
		for (i = idIn; i <= MAX_ENTS; i++) {
			if (idSet.find(i) == idSet.end() && i >= 1) {
				// std::cout << "                         Moved Up ID: ";
				return i;
			}
		}
		// std::cout << "####### Error: can not update id. ######\n";
		return -1;
	}
}
// Saeed_Material_SaveBugV1_05_20_2025_End

void Table::Serialize(CArchive& ar, int iV) {
}

//****************************************************************************
//****************************************************************************
BEGIN_MESSAGE_MAP(CResSelDialog, CDialog)
ON_BN_CLICKED(IDOK, &CResSelDialog::OnBnClickedOk)
ON_LBN_SELCANCEL(IDC_LIST_RES, &CResSelDialog::OnLbnSelcancelListRes)
ON_LBN_SELCHANGE(IDC_LIST_RES, &CResSelDialog::OnLbnSelchangeListRes)
//  ON_STN_CLICKED(IDC_LCTEXT, &CResSelDialog::OnStnClickedLctext)
ON_LBN_SELCHANGE(IDC_LIST_VAL, &CResSelDialog::OnSelchangeListVal)
END_MESSAGE_MAP()

//*****************************************************************
// The Res dialog box
//*****************************************************************
CResSelDialog::CResSelDialog()
    : CDialog(CResSelDialog::IDD, NULL) {
	iNoRes = 0;
	iCurResSet = -1;
	iResVal = -1;
	iSecResID = -1;
	bIsVec = FALSE;
}

void CResSelDialog::SetData(BOOL isVec, ResSet* pInRes[], int iInNoRes, int iInCurResSet, int iInResVal, int inSecResID) {
	bIsVec = isVec;
	int i;
	iNoRes = iInNoRes;
	for (i = 0; i < iInNoRes; i++) {
		pRes[i] = pInRes[i];
	}
	iCurResSet = iInCurResSet;
	iResVal = iInResVal;
	iSecResID = inSecResID;
}

void CResSelDialog::Init() {
	int i;
	CListBox* pResList = (CListBox*) GetDlgItem(IDC_LIST_RES);
	char OutT[80];
	if (iNoRes > 0) {
		for (i = 0; i < iNoRes; i++) {
			sprintf_s(OutT, "%i: LC %i : %s", i, pRes[i]->LC, pRes[i]->sName.GetString());
			pResList->AddString(OutT);
		}
	}
}

void CResSelDialog::OnBnClickedOk() {
	CListBox* pResList = (CListBox*) GetDlgItem(IDC_LIST_RES);
	CListBox* pValList = (CListBox*) GetDlgItem(IDC_LIST_VAL);
	CListBox* pSecList = (CListBox*) GetDlgItem(IDC_LIST_VAL2);
	// TODO: Add your control notification handler code here
	OnOK();
	iCurResSet = pResList->GetCurSel();
	iResVal = pValList->GetCurSel();
	iSecResID = pSecList->GetCurSel();
	if (!bIsVec)
		iSecResID += 1;
}

BOOL CResSelDialog::OnInitDialog() {
	int i;
	int iMaxSec;
	CDialog::OnInitDialog();
	CListBox* pResList = (CListBox*) GetDlgItem(IDC_LIST_RES);
	CListBox* pValList = (CListBox*) GetDlgItem(IDC_LIST_VAL);
	CListBox* pSecList = (CListBox*) GetDlgItem(IDC_LIST_VAL2);
	Init();
	if (iCurResSet != -1)
		pResList->SetCurSel(iCurResSet);
	if (iResVal != -1) {
		char OutT[80];
		if (pRes[iCurResSet] != NULL) {
			if (bIsVec) // Is a vector plot find all valid vectors
			{
				for (i = 0; i < pRes[iCurResSet]->iNoResDef; i++) {
					sprintf_s(OutT, "%i : %s", i, pRes[iCurResSet]->ResDefintion[i]->sResType);
					pValList->AddString(OutT);
				}
			} else {
				for (i = 0; i < pRes[iCurResSet]->iNoV; i++) {
					sprintf_s(OutT, "%i : %s", i, pRes[iCurResSet]->lab[i]);
					pValList->AddString(OutT);
				}
			}
		}
		pValList->SetCurSel(iResVal);
		if (!bIsVec) {
			if (pRes[iCurResSet]->iSecondaryID != -1) {
				iMaxSec = pRes[iCurResSet]->getMaxSecondaryID();
				for (i = 0; i < iMaxSec; i++) {
					sprintf_s(OutT, "%s : %i", pRes[iCurResSet]->sOpName, i + 1);
					pSecList->AddString(OutT);
				}
				pSecList->SetCurSel(iSecResID - 1);
			}
		} else {
			if ((iResVal > -1) && (iCurResSet > -1)) {
				for (i = 0; i < pRes[iCurResSet]->ResDefintion[iResVal]->iCompNo; i++) {
					sprintf_s(OutT, "%i : %s", i, pRes[iCurResSet]->ResDefintion[iResVal]->Lab9[i]);
					pSecList->AddString(OutT);
				}
				pSecList->SetCurSel(iSecResID);
			}
		}
	}

	return TRUE; // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CResSelDialog::OnLbnSelcancelListRes() {
	// TODO: Add your control notification handler code here
}

void CResSelDialog::OnLbnSelchangeListRes() {
	// TODO: Add your control notification handler code here
	int i;
	CListBox* pResList = (CListBox*) GetDlgItem(IDC_LIST_RES);
	CListBox* pValList = (CListBox*) GetDlgItem(IDC_LIST_VAL);
	CListBox* pSecList = (CListBox*) GetDlgItem(IDC_LIST_VAL2);
	CStatic* pLCTitle = (CStatic*) GetDlgItem(IDC_LCTEXT);
	CStatic* pLCSubTitle = (CStatic*) GetDlgItem(IDC_SUBTITLE);
	int ind = pResList->GetCurSel();
	pValList->ResetContent();
	pSecList->ResetContent();
	pLCTitle->SetWindowText("TITLE:- " + pRes[ind]->sTitle);
	pLCSubTitle->SetWindowText("SUBTITLE:- " + pRes[ind]->sSubTitle);
	char OutT[80];
	if (bIsVec) {
		for (i = 0; i < pRes[ind]->iNoResDef; i++) {
			sprintf_s(OutT, "%i : %s", i, pRes[ind]->ResDefintion[i]->sResType);
			pValList->AddString(OutT);
		}
	} else {
		for (i = 0; i < pRes[ind]->iNoV; i++) {
			sprintf_s(OutT, "%i : %s", i, pRes[ind]->lab[i]);
			pValList->AddString(OutT);
		}
	}
	int iMaxSec;

	if (pRes[ind]->iSecondaryID != -1) {
		{
			iMaxSec = pRes[ind]->getMaxSecondaryID();
			for (i = 0; i < iMaxSec; i++) {
				sprintf_s(OutT, "%s : %i", pRes[ind]->sOpName, i + 1);
				pSecList->AddString(OutT);
			}
		}
	}
}

void CResSelDialog::OnSelchangeListVal() {
	char OutT[80];
	CListBox* pResList = (CListBox*) GetDlgItem(IDC_LIST_RES);
	CListBox* pValList = (CListBox*) GetDlgItem(IDC_LIST_VAL);
	CListBox* pSecList = (CListBox*) GetDlgItem(IDC_LIST_VAL2);
	CStatic* pLCTitle = (CStatic*) GetDlgItem(IDC_LCTEXT);
	CStatic* pLCSubTitle = (CStatic*) GetDlgItem(IDC_SUBTITLE);

	int i;
	int ind = pResList->GetCurSel();

	// TODO: Add your control notification handler code here
	if (bIsVec) {
		pSecList->ResetContent();
		int iV = pValList->GetCurSel();
		if (iV > -1) {
			for (i = 0; i < pRes[ind]->ResDefintion[iV]->iCompNo; i++) {
				sprintf_s(OutT, "%i : %s", i, pRes[ind]->ResDefintion[iV]->Lab9[i]);
				pSecList->AddString(OutT);
			}
		}
	}
}

//******************************************************************
// NASTRAN FIELD CLASS
//******************************************************************

// CString[MAX_FIELDS];

NasCard::NasCard() {
	iNo = 0;
	iLnCnt = 0;
}

void NasCard::Clear() {
	iNo = 0;
	iLnCnt = 0;
}

// Checks to see if string is empty or conatins
// only spaces (a blank nastran field)
// if its blank TRUE is returned else FALSE
BOOL isClear(CString S) {
	BOOL brc = TRUE;
	int i;
	int iL;

	iL = S.GetLength();
	for (i = 0; i < iL; i++) {
		if (S[i] != ' ') {
			brc = FALSE;
			break;
		}
	}
	return (brc);
};

BOOL NasCard::isVoid(int iField) {
	BOOL brc = TRUE;
	if (iField < iNo)
		brc = isClear(Fields[iField]);
	return (brc);
}

CString NasCard::GetField(int iField) {
	CString sRet = "NULL";
	if ((iField >= 0) && (iField < iNo))
		sRet = Fields[iField];
	return (sRet);
}

BOOL NasCard::AddLn(CString sStr) {
	CString sF1;
	CString sF10;

	BOOL brc = FALSE;
	int iField;
	int iNum;
	int i;
	int iStart;
	iStart = sStr.Find(",");
	if (iStart != -1) {
		iStart = iStart;
	}
	if (iStart == -1) {
		if (sStr.Find("*") > -1) {
			brc = TRUE;
			iField = 16;
			iNum = 4;
		} else {
			brc = FALSE;
			iField = 8;
			iNum = 8;
		}
		for (i = 0; i < iNum; i++) {
			Fields[iNo] = sStr.Mid(8 + i * iField, iField);
			iNo++;
		}
	} else {
		sStr = sStr.Right(sStr.GetLength() - iStart - 1);
		while (iStart != -1) {
			iStart = sStr.Find(",");
			sF1 = sStr.Left(iStart);
			sStr = sStr.Right(sStr.GetLength() - iStart - 1);
			if (iStart == -1)
				Fields[iNo] = sStr;
			else
				Fields[iNo] = sF1;

			iNo++;
		}
	}
	iLnCnt++;
	return (brc);
}

// Check for a continuation card
BOOL isCont(CString S1, CString S2) {
	BOOL brc;
	CString f10;
	CString F1;
	CString C1;

	brc = FALSE;
	// Check for a contination entre
	f10 = S1.Mid(72, 8);
	F1 = S2.Mid(0, 8);
	C1 = S2.Mid(0, 1);
	F1.Trim();
	// Not a comment or blank line
	if ((isClear(S2) == FALSE) && (S2.Find("$") == -1)) {
		if (f10.Find(F1) != -1)
			brc = TRUE;
		else if ((C1 == " ") || (C1 == "*") || (C1 == "+"))
			brc = TRUE;
	}

	return (brc);
}

void NasCard::Read(FILE* pFile, CString& sLine, CString& sLineN) {
	AddLn(sLine);
	BOOL bExit = FALSE;
	char s1[200];
	do {
		if (isCont(sLine, sLineN) == TRUE) {
			sLine = sLineN;
			AddLn(sLine);
			if (feof(pFile) == FALSE) {
				fgets(s1, 200, pFile);
				sLineN = s1;
			} else {
				sLine = "";
				sLineN = "";
				bExit = TRUE;
			}
		} else {
			bExit = TRUE;
		}
	} while (bExit == FALSE);
}

void CGroupDialog::OnBnClickedGroupaddgp() {
	CListBox* pGroups = (CListBox*) GetDlgItem(IDC_GROUP_SEL);
	iGp = pGroups->GetCurSel();
	if (iGp != -1) {
		char sStr[10];
		_itoa(iGp, sStr, 10);
		outtextMSG2("GPADDGP");
		outtextMSG2(sStr);
	}
}

void CGroupDialog::OnBnClickedGroupremgrp() {
	CListBox* pGroups = (CListBox*) GetDlgItem(IDC_GROUP_SEL);
	iGp = pGroups->GetCurSel();
	if (iGp != -1) {
		char sStr[10];
		_itoa(iGp, sStr, 10);
		outtextMSG2("GPREMGP");
		outtextMSG2(sStr);
	}
}

void CGroupDialog::OnBnClickedGroupdspcurrent() {
	// TODO: Add your control notification handler code here
	CListBox* pGroups = (CListBox*) GetDlgItem(IDC_GROUP_SEL);
	iGp = pGroups->GetCurSel();
	if (iGp != -1) {
		char sStr[10];
		_itoa(iGp, sStr, 10);
		outtextMSG2("GPSET");
		outtextMSG2(sStr);
		outtextMSG2("DSPGP");
	}
	// OnOK();
}

void CGroupDialog::OnBnClickedGroupdspall() {
	// TODO: Add your control notification handler code here
	outtextMSG2("DSPALL");
}

void CGroupDialog::OnBnClickedGroupdels() {
	int iThisGp = -1;
	CListBox* pGroups = (CListBox*) GetDlgItem(IDC_GROUP_SEL);
	iThisGp = pGroups->GetCurSel();
	DeleteGP(iThisGp);
}

// Colour pick dialog
CColourPickDialog::CColourPickDialog()
    : CDialog(CColourPickDialog::IDD, NULL) {
	iNoCols = 0;
	iSel = -1;
}

void CColourPickDialog::AddCol(int inR, int inG, int inB) {
	if (iNoCols < MAX_COL) {
		R[iNoCols] = inR;
		G[iNoCols] = inG;
		B[iNoCols] = inB;
		iNoCols++;
	}
}

BEGIN_MESSAGE_MAP(CColourPickDialog, CDialog)
ON_WM_PAINT()
ON_WM_LBUTTONDBLCLK()
ON_WM_LBUTTONUP()
ON_BN_CLICKED(IDCANCEL, &CColourPickDialog::OnBnClickedCancel)
END_MESSAGE_MAP()

void CColourPickDialog::OnPaint() {
	COLORREF col;
	;
	int iWH = 40; // Width and height of block
	int iX = 10;
	int iY = 0;
	int iNo = 0;
	// SIZE DIALOG BOX TO FIT COLOURS
	CRect oSize;
	this->GetWindowRect(&oSize);
	oSize.right = oSize.left + 21 * iWH;
	oSize.bottom = oSize.top + 12 * iWH;
	this->MoveWindow(oSize, 0);
	oSize.top = 9 * iWH + 15;
	oSize.left = 10; // 20 * iWH - 50;
	oSize.bottom = 9 * iWH + iWH + 15; // oSize.top + 25;
	oSize.right = 60; // oSize.left + 50;
	CButton* btnOK = (CButton*) this->GetDlgItem(IDOK);
	if (btnOK != NULL)
		btnOK->MoveWindow(oSize, 0);
	oSize.top = 9 * iWH + 15;
	oSize.left = 65; // 20 * iWH - 50;
	oSize.bottom = 9 * iWH + iWH + 15; // oSize.top + 25;
	oSize.right = 165; // oSize.left + 50;
	CButton* btnC = (CButton*) this->GetDlgItem(IDCANCEL);
	if (btnC != NULL)
		btnC->MoveWindow(oSize, 0);
	oSize.top = 9 * iWH + 7 + 15;
	oSize.left = 200; // 20 * iWH - 50;
	oSize.bottom = 9 * iWH + 45; // oSize.top + 25;
	oSize.right = 10 * iWH; // oSize.left + 50;
	CStatic* lbl = (CStatic*) this->GetDlgItem(IDC_STATIC_COL);
	if (lbl != NULL)
		lbl->MoveWindow(oSize, 0);
	// END SIZE DIALOG BOX TO FIT COLOURS
	int i;
	CPaintDC dc(this); // device context for painting
	for (i = 0; i < iNoCols; i++) {
		Rects[i].top = iY;
		Rects[i].left = iX;
		Rects[i].right = iX + iWH;
		Rects[i].bottom = iY + iWH;
		col = RGB(R[i], G[i], B[i]);
		CBrush Brush(col);
		if (iSel == i)
			Rects[i].InflateRect(-5, -5);
		dc.FillRect(&Rects[i], &Brush);
		iNo++;
		iX += iWH;
		if (iNo == 20) {
			iX = 10;
			iY = iY + iWH;
			iNo = 0;
		}
	}
}

void CColourPickDialog::OnLButtonDblClk(UINT nFlags, CPoint point) {
	// TODO: Add your message handler code here and/or call default

	CDialog::OnLButtonDblClk(nFlags, point);
}

void CColourPickDialog::OnLButtonUp(UINT nFlags, CPoint point) {
	// TODO: Add your message handler code here and/or call default

	CDialog::OnLButtonUp(nFlags, point);
	int i;

	for (i = 0; i < iNoCols; i++) {
		if ((point.x > Rects[i].left) && (point.x < Rects[i].right)) {
			if ((point.y > Rects[i].top) && (point.y < Rects[i].bottom)) {
				iSel = i;
				break;
			}
		}
	}
	// get the system to repaint dialog
	char S1[22];
	sprintf_s(S1, "%s%i", "Colour Index: ", iSel);
	CWnd* label = GetDlgItem(IDC_STATIC_COL);
	label->SetWindowText(S1);

	this->Invalidate();
	this->UpdateWindow();
}

void CColourPickDialog::OnBnClickedCancel() {
	// TODO: Add your control notification handler code here
	OnCancel();
	iSel = -1;
}

BEGIN_MESSAGE_MAP(CSETSDialog, CDialog)
ON_BN_CLICKED(IDCREATE, &CSETSDialog::OnBnClickedCreate)
ON_STN_CLICKED(IDC_SETLABEL, &CSETSDialog::OnStnClickedSetlabel)
ON_BN_CLICKED(IDCDELSET, &CSETSDialog::OnBnClickedCdelset)
ON_BN_CLICKED(IDCSETCUR, &CSETSDialog::OnBnClickedCsetcur)
ON_BN_CLICKED(IDCSETLIST, &CSETSDialog::OnBnClickedCsetlist)
ON_EN_CHANGE(IDC_SETID, &CSETSDialog::OnEnChangeSetid)
ON_BN_CLICKED(IDC_NONEACT, &CSETSDialog::OnBnClickedNoneact)
END_MESSAGE_MAP()
//****************************************************************************
//             BOUNDARY CONDITIONS GENERIC DIALOG BOX
//****************************************************************************
CSETSDialog::CSETSDialog()
    : CDialog(CSETSDialog::IDD, NULL) {
}

void CSETSDialog::AttachSets(int* iNo, int* iCur) {
	iNoS = iNo;
	iCurS = iCur;
}

void CSETSDialog::AddSet(int ind, CString sTit) {
	SETS[ind] = sTit;
}

void CSETSDialog::RemoveSet(int ind) {
	int i;
	if (ind < *iNoS - 1) {
		for (i = ind + 1; i < *iNoS; i++) {
			SETS[i - 1] = SETS[i];
		}
	}
}

void CSETSDialog::Refresh() {
	int i;

	CListBox* pSets = (CListBox*) GetDlgItem(IDC_LIST1);
	pSets->ResetContent();
	for (i = 0; i < *iNoS; i++) {
		pSets->AddString(SETS[i]);
	}
	CStatic* pSt = (CStatic*) GetDlgItem(IDC_CURSET);
	if (*iNoS > 0)
		pSt->SetWindowTextA(SETS[*iCurS]);
	else
		pSt->SetWindowTextA("ERROR: No Sets Defined.");
}

//****************************************************************************
void CSETSDialog::OnBnClickedCreate() {
	// TODO: Add your control notification handler code here
	CString cT;
	CString cI;
	int iID;
	CEdit* pTitle = (CEdit*) GetDlgItem(IDC_TITLE);
	CEdit* pSID = (CEdit*) GetDlgItem(IDC_SETID);

	pTitle->GetWindowText(cT);
	pSID->GetWindowText(cI);

	// CListBox* pSets=(CListBox*) GetDlgItem(IDC_LIST1);
	// pSets->AddString(cT);
	iID = atoi(cI);
	if (iID > 0) {
		int iNow = *iNoS - 1;
		outtextMSG2(sSET);
		outtextMSG2(cI);
		outtextMSG2(cT);
		char sNew[80];
		CListBox* pSets = (CListBox*) GetDlgItem(IDC_LIST1);
		sprintf_s(sNew, "%i : %s", iID, cT);
		if (iNow == *iNoS - 2) {
			AddSet(*iNoS - 1, sNew);
			pSets->AddString(sNew);
		}
	} else {
		outtext1("ERROR: Set ID Must be Greater than 0.");
	}
}

BOOL CSETSDialog::OnInitDialog() {
	CDialog::OnInitDialog();
	this->SetWindowTextA(sTitle);
	Refresh();
	return TRUE; // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CSETSDialog::OnStnClickedSetlabel() {
	// TODO: Add your control notification handler code here
}

void CSETSDialog::OnBnClickedCdelset() {
	// TODO: Add your control notification handler code here
	CListBox* pSets = (CListBox*) GetDlgItem(IDC_LIST1);
	int iSet = pSets->GetCurSel();
	char sStr[10];
	_itoa(iSet, sStr, 10);
	RemoveSet(iSet); // Must do this before its removed
	outtextMSG2(sDEL);
	outtextMSG2(sStr);
	Refresh();
}

void CSETSDialog::OnBnClickedCsetcur() {
	// TODO: Add your control notification handler code here
	CListBox* pSets = (CListBox*) GetDlgItem(IDC_LIST1);
	int iSet = pSets->GetCurSel();
	CString sL;
	CString sID;
	pSets->GetText(iSet, sL);
	int ipos = sL.Find(":");
	sID = sL.Left(ipos);
	sID.Trim(" ");
	// char sStr[10];
	// itoa (iSet,sStr,10);
	outtextMSG2(sACT);
	outtextMSG2(sID);
	Refresh();
}

void CSETSDialog::OnBnClickedNoneact() {
	// TODO: Add your control notification handler code here
	char sStr[10];
	_itoa(-1, sStr, 10);
	outtextMSG2(sACT);
	outtextMSG2(sStr);
	Refresh();
}

void CSETSDialog::OnBnClickedCsetlist() {
	// TODO: Add your control notification handler code here
	outtextMSG2(sLIST);
}

//****************************************************************************
//                        SOLUTION SEQUENCE DIALOG BOX
//****************************************************************************
CSOLDialog::CSOLDialog()
    : CDialog(CSOLDialog::IDD, NULL) {
}

void CSOLDialog::Refresh() {
	char OutT[80];
	CString ss;
	int i;
	CListBox* pSol = (CListBox*) GetDlgItem(IDC_SOL_LST);
	pSol->ResetContent();
	for (i = 0; i < pSOL->iNo; i++) {
		sprintf_s(OutT, "%i : %s", i, pSOL->pSols[i]->sTitle);
		pSol->AddString(OutT);
	}
	if (pSOL->iCur != -1) {
		sprintf_s(OutT, "%g", pSOL->pSols[pSOL->iCur]->dTol);
		pSol->SetCurSel(pSOL->iCur);
		CEdit* pTol = (CEdit*) GetDlgItem(IDC_TOL_TXT);
		pTol->SetWindowTextA(OutT);
		CComboBox* pType = (CComboBox*) GetDlgItem(IDC_TYPE_CBO);
		pType->SetCurSel(pSOL->pSols[pSOL->iCur]->iType);
		CEdit* pTit = (CEdit*) GetDlgItem(IDC_TITLE_TXT);
		pTit->SetWindowTextA(pSOL->pSols[pSOL->iCur]->sTitle);
		CStatic* pSt = (CStatic*) GetDlgItem(IDC_STATIC_SOL_ACT);
		sprintf_s(OutT, "%i : %s", pSOL->iCur, pSOL->pSols[pSOL->iCur]->sTitle);

		ss = pSOL->pSols[pSOL->iCur]->GetSolutionTitleString();
		pSt->SetWindowTextA(ss);
	} else {
		CEdit* pTit = (CEdit*) GetDlgItem(IDC_TITLE_TXT);
		pTit->SetWindowTextA("");
		CStatic* pSt = (CStatic*) GetDlgItem(IDC_STATIC_SOL_ACT);
		pSt->SetWindowTextA("No Solution Active.");
	}
}

BOOL CSOLDialog::OnInitDialog() {
	CDialog::OnInitDialog();
	this->SetWindowTextA(sTitle);
	CComboBox* pT = (CComboBox*) GetDlgItem(IDC_TYPE_CBO);
	pT->ResetContent();
	pT->AddString("0: Lin Static");
	pT->AddString("1: SS Heat");
	pT->AddString("2: Sparse");
	CEdit* pTol = (CEdit*) GetDlgItem(IDC_TOL_TXT);
	CString str;
	str.Format(_T("%g"), gDEF_SOL_TOL);
	pTol->SetWindowTextA(str);
	Refresh();

	return TRUE; // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_MESSAGE_MAP(CSOLDialog, CDialog)
ON_BN_CLICKED(ID_CR, &CSOLDialog::OnBnClickedCr)
ON_BN_CLICKED(ID_ACT, &CSOLDialog::OnBnClickedAct)
ON_BN_CLICKED(ID_DEL, &CSOLDialog::OnBnClickedDel)
ON_BN_CLICKED(IDOK, &CSOLDialog::OnBnClickedOk)
END_MESSAGE_MAP()

void CSOLDialog::OnBnClickedCr() {
	CString sTitle;
	CString sTol;
	char S1[20] = "";
	// TODO: Add your control notification handler code here
	CEdit* pTitle = (CEdit*) GetDlgItem(IDC_TITLE_TXT);
	// IDC_TYPE_CBO
	CComboBox* pCT = (CComboBox*) GetDlgItem(IDC_TYPE_CBO);
	int iT = pCT->GetCurSel();
	CEdit* pTol = (CEdit*) GetDlgItem(IDC_TOL_TXT);
	pTitle->GetWindowText(sTitle);
	pTol->GetWindowText(sTol);
	outtextMSG2("SOLCR");
	outtextMSG2(sTitle);
	sprintf_s(S1, "%i", iT);
	outtextMSG2(S1);
	outtextMSG2(sTol);
	Refresh();
}

void CSOLDialog::OnBnClickedAct() {
	// TODO: Add your control notification handler code here
	CListBox* pSol = (CListBox*) GetDlgItem(IDC_SOL_LST);
	int iSol = pSol->GetCurSel();
	char sStr[10];
	_itoa(iSol, sStr, 10);
	outtextMSG2("SOLACT");
	outtextMSG2(sStr);
	Refresh();
}

void CSOLDialog::OnBnClickedDel() {
	// TODO: Add your control notification handler code here
	int iDel;
	int i;
	CListBox* pSol = (CListBox*) GetDlgItem(IDC_SOL_LST);
	iDel = pSol->GetCurSel();
	if (pSOL->iNo > -1) {
		if (pSOL->iCur == iDel)
			pSOL->iCur = -1;
		else if (pSOL->iCur > iDel)
			pSOL->iCur--;
		delete (pSOL->pSols[iDel]);
		for (i = iDel; i < pSOL->iNo - 1; i++) {
			pSOL->pSols[i] = pSOL->pSols[i + 1];
		}
		pSOL->iNo--;
	}
	Refresh();
}

//****************************************************************************
//                        SOLUTION SETS DIALOG BOX
//****************************************************************************
CSTEPSDialog::CSTEPSDialog()
    : CDialog(CSTEPSDialog::IDD, NULL) {
	iNoLC = 0;
	iNoBC = 0;
	iNoTC = 0;
	int i;
	for (i = 0; i < 100; i++) {
		sTC[i] = "N/A";
		iTC[i] = -1;
		sBC[i] = "N/A";
		iBC[i] = -1;
		sLC[i] = "N/A";
		iLC[i] = -1;
	}
}

int CSTEPSDialog::GetLCInd(int ID) {
	int iRC = -1;
	int i;
	for (i = 0; i < iNoLC; i++) {
		if (iLC[i] == ID) {
			iRC = i;
			break;
		}
	}
	return (iRC);
}

int CSTEPSDialog::GetBCInd(int ID) {
	int iRC = -1;
	int i;
	for (i = 0; i < iNoBC; i++) {
		if (iBC[i] == ID) {
			iRC = i;
			break;
		}
	}
	return (iRC);
}

int CSTEPSDialog::GetTCInd(int ID) {
	int iRC = -1;
	int i;
	for (i = 0; i < iNoTC; i++) {
		if (iTC[i] == ID) {
			iRC = i;
			break;
		}
	}
	return (iRC);
}

void CSTEPSDialog::AddSet(int iID, CString sTXT, int iT) {
	if (iT == 0) {
		iLC[iNoLC] = iID;
		sLC[iNoLC] = sTXT;
		iNoLC++;
	} else if (iT == 1) {
		iBC[iNoBC] = iID;
		sBC[iNoBC] = sTXT;
		iNoBC++;
	} else if (iT == 2) {
		iTC[iNoTC] = iID;
		sTC[iNoTC] = sTXT;
		iNoTC++;
	}
}

void CSTEPSDialog::Refresh() {
	int i;

	CStatic* pSolTit = (CStatic*) GetDlgItem(IDC_CURSOL_TXT);
	CStatic* pSt = (CStatic*) GetDlgItem(IDC_STATIC_STEP_ACT);
	if (pSOL->iCur == -1) {
		pSolTit->SetWindowTextA("ERROR: No Active Solution Sequence!");
		pSt->SetWindowTextA("ERROR.");
	} else
		pSolTit->SetWindowTextA(pSOL->pSols[pSOL->iCur]->sTitle);
	CComboBox* pLC = (CComboBox*) GetDlgItem(IDC_LC_DD);
	pLC->ResetContent();
	for (i = 0; i < iNoLC; i++) {
		pLC->AddString(sLC[i]);
	}
	CComboBox* pBC = (CComboBox*) GetDlgItem(IDC_BC_DD);
	pBC->ResetContent();
	for (i = 0; i < iNoBC; i++) {
		pBC->AddString(sBC[i]);
	}
	CComboBox* pTC = (CComboBox*) GetDlgItem(IDC_TC_DD);
	pTC->ResetContent();
	for (i = 0; i < iNoTC; i++) {
		pTC->AddString(sTC[i]);
	}
	CComboBox* pRS = (CComboBox*) GetDlgItem(IDC_RS_DD);
	pRS->ResetContent();
	pRS->AddString("NO");
	pRS->AddString("YES");
	// Sol seq
	CListBox* pSol = (CListBox*) GetDlgItem(IDC_STEP_LBX);
	pSol->ResetContent();
	Solution* pS;
	char S1[200] = "";
	if (pSOL != NULL) {
		if (pSOL->iCur != -1) {
			pS = pSOL->pSols[pSOL->iCur];
			for (i = 0; i < pS->iNo; i++) {
				// sprintf_s(S1,"STEP: %i LC: %i BC: %i TSET: %i RS: %i %s",i,pS->LS[i],pS->BS[i],pS->TS[i],pS->RS[i],pS->sStepTitle[i]);
				pSol->AddString(pSOL->GetCurSolution()->GetStepTitleString(i));
			}
		}
	}

	if ((pSOL->iCur > -1) && (pSOL->iCur < pSOL->iNo)) {
		int iC;
		iC = pSOL->GetCurStep();
		if (iC > -1) {
			pSol->SetCurSel(iC);
			pSt->SetWindowTextA(pSOL->GetCurSolution()->GetStepTitleString(iC));
		} else {
			pSt->SetWindowTextA("ERROR: No Step Active.");
		}
	}
}

BOOL CSTEPSDialog::OnInitDialog() {
	CDialog::OnInitDialog();
	this->SetWindowTextA(sTitle);
	Refresh();
	return TRUE; // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

BEGIN_MESSAGE_MAP(CSTEPSDialog, CDialog)
ON_WM_CREATE()
ON_LBN_SELCHANGE(IDC_STEP_LBX, &CSTEPSDialog::OnLbnSelchangeStepLbx)
ON_BN_CLICKED(IDC_CREATE, &CSTEPSDialog::OnBnClickedCreate)
ON_BN_CLICKED(IDC_ACT_STEP, &CSTEPSDialog::OnBnClickedActStep)
ON_BN_CLICKED(IDOK, &CSTEPSDialog::OnBnClickedOk)
ON_BN_CLICKED(IDC_STEP_DEL, &CSTEPSDialog::OnBnClickedStepDel)
END_MESSAGE_MAP()

int CSTEPSDialog::OnCreate(LPCREATESTRUCT lpCreateStruct) {
	if (CDialog::OnCreate(lpCreateStruct) == -1)
		return -1;

	// TODO:  Add your specialized creation code here

	return 0;
}

void CSTEPSDialog::OnLbnSelchangeStepLbx() {
	// TODO: Add your control notification handler code here
	// int iStep;
	// int iI;
	// Solution* pS;
	// CListBox* pSets=(CListBox*) GetDlgItem(IDC_STEP_LBX);
	// iStep=pSets->GetCurSel();
	// if (pSOL!=NULL)
	//{
	//  pS=pSOL->pSols[iStep];
	//  iI=GetLCInd(pS->LS[iStep]);
	//  if (iI!=-1)
	//  {
	//     CComboBox* pLC=(CComboBox*) GetDlgItem(IDC_LC_DD);
	//     pLC->SetCurSel(iI);
	//  }
	//  iI=GetBCInd(pS->BS[iStep]);
	//  if (iI!=-1)
	//  {
	//     CComboBox* pBC=(CComboBox*) GetDlgItem(IDC_BC_DD);
	//     pBC->SetCurSel(iI);
	//  }
	//  iI=GetTCInd(pS->TS[iStep]);
	//  if (iI!=-1)
	//  {
	//     CComboBox* pTC=(CComboBox*) GetDlgItem(IDC_TC_DD);
	//     pTC->SetCurSel(iI);
	//  }
	//  CEdit* pST=(CEdit*) GetDlgItem(IDC_STPTIT_TB);
	//  pST->SetWindowTextA(pS->sStepTitle[iStep]);
	//}
	// CComboBox* pRS=(CComboBox*) GetDlgItem(IDC_RS_DD);
	// if(pS->RS[iStep]==0)
	//  pRS->SetCurSel(0);
	// else
	//  pRS->SetCurSel(1);
}

void CSTEPSDialog::OnBnClickedCreate() {
	// TODO: Add your control notification handler code here
	CString sTitle;
	int iRS;
	int iLSet;
	int iBSet;
	int iTSet;
	char S1[20] = "";

	CComboBox* pCB;
	// TODO: Add your control notification handler code here
	CEdit* pTitle = (CEdit*) GetDlgItem(IDC_STPTIT_TB);
	pTitle->GetWindowText(sTitle);
	pCB = (CComboBox*) GetDlgItem(IDC_LC_DD);
	iLSet = pCB->GetCurSel();
	pCB = (CComboBox*) GetDlgItem(IDC_BC_DD);
	iBSet = pCB->GetCurSel();
	pCB = (CComboBox*) GetDlgItem(IDC_TC_DD);
	iTSet = pCB->GetCurSel();
	pCB = (CComboBox*) GetDlgItem(IDC_RS_DD);
	iRS = pCB->GetCurSel();

	outtextMSG2("STEPCR");
	outtextMSG2(sTitle);
	sprintf_s(S1, "%i", iLC[iLSet]);
	outtextMSG2(S1);
	sprintf_s(S1, "%i", iBC[iBSet]);
	outtextMSG2(S1);
	if (iTSet != -1) {
		sprintf_s(S1, "%i", iTC[iTSet]);
		outtextMSG2(S1);
	} else {
		outtextMSG2("");
	}
	sprintf_s(S1, "%i", iRS);
	outtextMSG2(S1);
	Refresh();
}

void CSTEPSDialog::OnBnClickedActStep() {
	// TODO: Add your control notification handler code here
	CListBox* pStep = (CListBox*) GetDlgItem(IDC_STEP_LBX);
	int iStep = pStep->GetCurSel();
	char sStr[10];
	_itoa(iStep, sStr, 10);
	outtextMSG2("STEPACT");
	outtextMSG2(sStr);
	Refresh();
}

void CSTEPSDialog::OnBnClickedOk() {
	// TODO: Add your control notification handler code here
	OnOK();
}

void CSOLDialog::OnBnClickedOk() {
	// TODO: Add your control notification handler code here
	OnOK();
}

void CSTEPSDialog::OnBnClickedStepDel() {
	// TODO: Add your control notification handler code here
	int iDel;
	Solution* pS = NULL;

	CListBox* pSol = (CListBox*) GetDlgItem(IDC_STEP_LBX);
	iDel = pSol->GetCurSel();
	pS = pSOL->GetCurSolution();
	if (pS != NULL)
		pS->DelStep(iDel);

	Refresh();
}

void CSETSDialog::OnEnChangeSetid() {
	// TODO:  If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	// TODO:  Add your control notification handler code here
}

//*****************************************************************
// The Entity Editor dialog box
//*****************************************************************
const int MAX_VALS = 500;

CEntEditDialog::CEntEditDialog()
    : CDialog(CEntEditDialog::IDD, NULL) {
	pEnt = NULL;
	pO = NULL;
	PT = NULL;
	m_iItemBeingEdited = -1;
	eEdit = NULL;
	iNoLayers = 0;
	hdcOld = wglGetCurrentDC();
	hrcOld = wglGetCurrentContext();
	hrc = NULL;
	hdc = NULL;
	vMat.MakeUnit();
}

CEntEditDialog::~CEntEditDialog() {
	if (hrc != NULL) {
		wglMakeCurrent(NULL, NULL);
		wglDeleteContext(hrc);
	}

	if (pDrg != NULL)
		delete (pDrg);
	wglMakeCurrent(hdcOld, hrcOld);
}

BOOL CEntEditDialog::OnInitDialog() {
	int iW = 650;
	int iH = 650;
	int iBoff = 130;

	CDialog::OnInitDialog();
	this->SetWindowText("Entity Editor");
	eEdit = (CEdit*) GetDlgItem(IDC_EDIT_FLOAT);
	CRect oSize;
	CRect oSize2;
	this->GetWindowRect(&oSize);
	oSize.right = oSize.left + iW;
	oSize.bottom = oSize.top + iH;
	this->MoveWindow(oSize, 0);
	oSize2.top = 100;
	oSize2.left = 0;
	oSize2.bottom = iH - iBoff;
	oSize2.right = iW;
	CListBox* oLB = (CListBox*) this->GetDlgItem(IDC_LIST1);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	CButton* cBtn = (CButton*) this->GetDlgItem(IDC_ENTLIST);
	oSize2.top = iH - iBoff;
	oSize2.left = 0;
	oSize2.bottom = iH - iBoff + 50;
	oSize2.right = 100;
	cBtn->MoveWindow(oSize2, 0);
	cBtn = (CButton*) this->GetDlgItem(IDOK);
	oSize2.top = iH - iBoff;
	oSize2.left = 100;
	oSize2.bottom = iH - iBoff + 50;
	oSize2.right = 250;
	cBtn->MoveWindow(oSize2, 0);
	cBtn = (CButton*) this->GetDlgItem(IDCANCEL);
	oSize2.top = iH - iBoff;
	oSize2.left = 250;
	oSize2.bottom = iH - iBoff + 50;
	oSize2.right = 350;
	cBtn->MoveWindow(oSize2, 0);

	cBtn = (CButton*) this->GetDlgItem(IDCDELETE);
	oSize2.top = iH - iBoff;
	oSize2.left = iW - 120;
	oSize2.bottom = iH - iBoff + 50;
	oSize2.right = iW - 20;
	cBtn->MoveWindow(oSize2, 0);
	if (pEnt != NULL) {
		cBtn->EnableWindow(TRUE);
	} else {
		cBtn->EnableWindow(FALSE);
	}

	if (pEnt != NULL) {
		Populate2();
		BOOL pG = FALSE;
		if ((pEnt->iType == 2) || (pEnt->iType == 222)) {
			if (pEnt->iType == 222)
				pG = TRUE;
			oSize.right = oSize.left + iW + iW;
			oSize.bottom = oSize.top + iH;
			this->MoveWindow(oSize, 0);
			pDrg = new cWndOGL();
			pDrg->Create(_T("STATIC"), _T("Hi"), WS_CHILD | WS_VISIBLE | WS_THICKFRAME,
			             CRect(iW, 0, iW + iW, iH), this, 1234);
			InitOGL();
			Build(pG);
		}
	}
	if (pO != NULL) {
		CEdit* pI = (CEdit*) GetDlgItem(IDC_ENTID);
		pI->EnableWindow(TRUE);
		Populate1();
	}
	// Saeed_Material_SaveBugV1_05_20_2025_Start
	// Ed_ID.SetReadOnly(TRUE);
	// Saeed_Material_SaveBugV1_05_20_2025_End
	return TRUE; // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CEntEditDialog::Populate1() {
	CString sVName[MAX_VALS];
	CString sVVals[MAX_VALS];
	int nItem;
	int i;

	m_List.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP | LVS_OWNERDRAWFIXED);
	CRect oSize;
	m_List.GetWindowRect(oSize);
	int iW = oSize.Width();

	m_List.InsertColumn(0, "Variable Name", LVCFMT_LEFT, iW - 250);
	m_List.InsertColumn(1, "Value", LVCFMT_LEFT, 250);

	Ed_Title.SetWindowTextA(pO->GetName());
	char S1[80] = "";
	sprintf_s(S1, "%i", pO->iLabel);
	CString ss;
	ss = S1;
	Ed_ID.SetWindowTextA(ss);
	;

	iNo = pO->GetVarHeaders(sVName);
	iNo2 = pO->GetVarValues(sVVals);
	for (i = 0; i < iNo; i++) {
		nItem = m_List.InsertItem(i, sVName[i]);
		m_List.SetItemText(nItem, 1, sVVals[i]);
	}
}

void CEntEditDialog::Populate2() {
	CString sVName[MAX_VALS];
	CString sVVals[MAX_VALS];
	int nItem;
	int i;

	m_List.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP | LVS_OWNERDRAWFIXED);
	CRect oSize;
	m_List.GetWindowRect(oSize);
	int iW = oSize.Width();

	m_List.InsertColumn(0, "Variable Name", LVCFMT_LEFT, iW - 250);
	m_List.InsertColumn(1, "Value", LVCFMT_LEFT, 250);

	Ed_Title.SetWindowTextA(pEnt->sTitle);
	char S1[80] = "";
	sprintf_s(S1, "%i", pEnt->iID);
	CString ss;
	ss = S1;
	Ed_ID.SetWindowTextA(ss);
	;

	iNo = pEnt->GetVarHeaders(sVName);
	iNo2 = pEnt->GetVarValues(sVVals);
	for (i = 0; i < iNo; i++) {
		nItem = m_List.InsertItem(i, sVName[i]);
		m_List.SetItemText(nItem, 1, sVVals[i]);
	}
	if (pEnt->iType == 2) {
		for (i = 0; i < 100; i++) {
			nItem = m_List.InsertItem(iNo, "");
			iNo++;
		}
	}
}

void CEntEditDialog::Build(BOOL isPCOMPG) {
	int i;
	double dTheta;
	double dZ;
	double dT;
	double dS;
	int iM;
	if (isPCOMPG) {
		PCOMPG* pP = (PCOMPG*) pEnt;
		vMat.Rotate(-90, 0, 5);
		dS = 1.0 / pP->GetThk();
		dZ = pP->dZ0;
		dZ *= dS;
		dTheta = pP->Theta[0];
		iM = pP->MID[0];
		dZ += 0.5 * dS * pP->T[0];
		dT = dS * pP->T[0];
		AddVisLayer(dTheta, dZ, dT, iM);
		for (i = 1; i < pP->iNoLays; i++) {
			dTheta = pP->Theta[i];
			iM = pP->MID[i];
			dZ += 0.5 * dS * pP->T[i - 1];
			dZ += 0.5 * dS * pP->T[i];
			dT = dS * pP->T[i];
			AddVisLayer(dTheta, dZ, dT, iM);
		}
	} else {
		PCOMP* pP = (PCOMP*) pEnt;
		vMat.Rotate(-90, 0, 5);
		dS = 1.0 / pP->GetThk();
		dZ = pP->dZ0;
		dZ *= dS;
		dTheta = pP->Theta[0];
		iM = pP->MID[0];
		dZ += 0.5 * dS * pP->T[0];
		dT = dS * pP->T[0];
		AddVisLayer(dTheta, dZ, dT, iM);
		for (i = 1; i < pP->iNoLays; i++) {
			dTheta = pP->Theta[i];
			iM = pP->MID[i];
			dZ += 0.5 * dS * pP->T[i - 1];
			dZ += 0.5 * dS * pP->T[i];
			dT = dS * pP->T[i];
			AddVisLayer(dTheta, dZ, dT, iM);
		}
	}
}

void CEntEditDialog::Build2(BOOL isPCOMPG) {
	char S1[80];
	CString sTemp = "";
	int i = 0;
	double dTheta[100];
	double dZ;
	double dT[100];
	double dS;
	int iM[100];
	int iC = 10;
	int iLC = 0;
	double dThk = 0;
	// Reset layer to 0 and rebuild
	iNoLayers = 0;
	BOOL bExit = FALSE;
	do {
		sTemp = m_List.GetItemText(iC, 1);
		if (isPCOMPG) {
			iM[iLC] = atoi(ExtractSubString2(2, sTemp));
			dT[iLC] = atof(ExtractSubString2(3, sTemp));
			dTheta[iLC] = atof(ExtractSubString2(4, sTemp));
		} else {
			iM[iLC] = atoi(ExtractSubString2(1, sTemp));
			dT[iLC] = atof(ExtractSubString2(2, sTemp));
			dTheta[iLC] = atof(ExtractSubString2(3, sTemp));
		}
		if (iM[iLC] < 1) {
			bExit = TRUE;
		} else {
			iLC++;
			iC++;
		}
	} while (!bExit);
	// Caculate thickness
	dThk = 0;
	for (i = 0; i < iLC; i++) {
		dThk += dT[i];
	}
	sprintf_s(S1, "%i", iLC);
	sTemp = S1;
	m_List.SetItemText(8, 1, sTemp);
	sprintf_s(S1, "%g", dThk);
	sTemp = S1;
	m_List.SetItemText(9, 1, sTemp);
	sTemp = m_List.GetItemText(1, 1);
	dZ = atof(sTemp);
	// vMat.Rotate(-90, 0, 5);
	dS = 1.0 / dThk;

	dZ *= dS;
	dZ += 0.5 * dS * dT[0];
	AddVisLayer(dTheta[0], dZ, dS * dT[0], iM[0]);
	for (i = 1; i < iLC; i++) {
		//	dTheta = pP->Theta[i];
		//	iM = pP->MID[i];
		dZ += 0.5 * dS * dT[i - 1];
		dZ += 0.5 * dS * dT[i];
		//	dT = dS * pP->T[i];
		AddVisLayer(dTheta[i], dZ, dS * dT[i], iM[i]);
	}
}

void CEntEditDialog::InitOGL() {
	static PIXELFORMATDESCRIPTOR pfd =
	    {
	        sizeof(PIXELFORMATDESCRIPTOR), // size of this pfd
	        1, // version number
	        PFD_DRAW_TO_WINDOW | // support window
	            PFD_SUPPORT_OPENGL | // support OpenGL
	            // PFD_DOUBLEBUFFER,             // double buffered
	            PFD_TYPE_RGBA, // RGBA type
	        24, // 24-bit color depth
	        0, 0, 0, 0, 0, 0, // color bits ignored
	        0, // no alpha buffer
	        0, // shift bit ignored
	        0, // no accumulation buffer
	        0, 0, 0, 0, // accum bits ignored
	        32, // 32-bit z-buffer
	        0, // no stencil buffer
	        0, // no auxiliary buffer
	        PFD_MAIN_PLANE, // main layer
	        0, // reserved
	        0, 0, 0 // layer masks ignored
	    };

	// Get device context only once.
	hdc = pDrg->GetDC()->m_hDC;
	// Pixel format.
	m_nPixelFormat = ChoosePixelFormat(hdc, &pfd);
	SetPixelFormat(hdc, m_nPixelFormat, &pfd);

	// Create the OpenGL Rendering Context.
	hrc = wglCreateContext(hdc);
	wglMakeCurrent(hdc, hrc);

	// Send draw request
	// OnDraw(NULL);
}

void CEntEditDialog::OglDraw() {
	glClearColor(255.0f, 255.0f, 255.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glClearDepth(1.0f);
	CRect cR;
	pDrg->GetWindowRect(&cR);
	int iW = cR.Width();
	int iH = cR.Height();
	glViewport(0, 0, iW, iH);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	OglMat mOGLmat = vMat.GetOglMat();
	glMultMatrixf(mOGLmat.fMat);
	// gluPerspective(35.0f, (float)cx / (float)cy, 0.01f, 2000.0f);
	glMatrixMode(GL_MODELVIEW);
	glPointSize(10.0f);
	glColor3f((float) 0.0, (float) 0.0, (float) 0.9);
	glBegin(GL_POINTS);
	glVertex3f(20.0, 30.0, 10.0);
	glVertex3f(140.0, 30.0, 20.0);
	glVertex3f(50.0, 50.0, 30.0);
	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(0.5, 0.0, 0.0);
	glVertex3f(0.0, 0.5, 0.0);
	glEnd();
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	char sLab[20];

	int i;
	for (i = 0; i < iNoLayers; i++)
		Laminate[i].OglDraw();
	sprintf_s(sLab, "%s", "Z");
	OglString(1, 0.0, 0.0, 0.7, &sLab[0]);
	glBegin(GL_LINES);
	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f((float) 0.0, (float) 0.0, (float) 0.7);
	glEnd();
	sprintf_s(sLab, "%s", "1");
	OglString(1, 0.7, 0.0, 0.0, &sLab[0]);
	glBegin(GL_LINES);
	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f((float) 0.7, (float) 0.0, (float) 0.0);
	glEnd();

	glFinish();
	SwapBuffers(wglGetCurrentDC());
}

void CEntEditDialog::AddVisLayer(double dA, double dZ, double dT, int iM) {
	Laminate[iNoLayers].SetAng(dA);
	Laminate[iNoLayers].SetZ(dZ);
	Laminate[iNoLayers].SetThk(dT);
	Laminate[iNoLayers].SetMID(iM);
	iNoLayers++;
}

BEGIN_MESSAGE_MAP(CEntEditDialog, CDialog)
ON_WM_LBUTTONDOWN()
ON_BN_CLICKED(IDOK, &CEntEditDialog::OnBnClickedOk)
ON_BN_CLICKED(IDC_ENTLIST, &CEntEditDialog::OnBnClickedEntlist)
ON_NOTIFY(NM_DBLCLK, IDC_LIST1, &CEntEditDialog::OnDblclkList1)
ON_WM_PAINT()
ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST1, &CEntEditDialog::OnLvnItemchangedList1)
// ON_NOTIFY(LVN_ENDLABELEDIT, IDC_LIST1, &CEntEditDialog::OnLvnEndlabeleditList1)
ON_NOTIFY(LVN_ITEMCHANGING, IDC_LIST1, &CEntEditDialog::OnLvnItemchangingList1)
// ON_NOTIFY(NM_RETURN, IDC_LIST1, &CEntEditDialog::OnNMReturnList1)
// ON_NOTIFY(NM_RETURN, IDC_LIST1, &CEntEditDialog::OnNMReturnList1)
// ON_NOTIFY(LVN_ODCACHEHINT, IDC_LIST1, &CEntEditDialog::OnLvnOdcachehintList1)
// ON_NOTIFY(LVN_KEYDOWN, IDC_LIST1, &CEntEditDialog::OnLvnKeydownList1)
ON_NOTIFY(NM_RETURN, IDC_LIST1, &CEntEditDialog::OnNMReturnList1)
ON_WM_KEYDOWN()
ON_BN_CLICKED(IDCDELETE, &CEntEditDialog::OnBnClickedCdelete)
ON_BN_CLICKED(IDCANCEL, &CEntEditDialog::OnBnClickedCancel)
END_MESSAGE_MAP()

void CEntEditDialog::OnEnChangeEditFloat() {
	// TODO:  If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.

	// TODO:  Add your control notification handler code here
}

BOOL CEntEditDialog::PreTranslateMessage(MSG* pMsg) {
	// TODO: Add your specialized code here and/or call the base class
	if (pMsg->wParam == VK_ESCAPE) {
		eEdit->ShowWindow(SW_HIDE);
		m_iItemBeingEdited = -1;
		return TRUE;
	} else if ((pMsg->wParam == VK_RETURN) && (m_iItemBeingEdited != -1)) {
		CString sNew;
		eEdit->GetWindowText(sNew);
		eEdit->ShowWindow(SW_HIDE);
		m_List.SetItemText(m_iItemBeingEdited, 1, sNew);
		m_iItemBeingEdited = -1;
		if (pEnt != NULL) {
			if (pEnt->iType == 2) {
				Build2(FALSE);
				OglDraw();
			} else if (pEnt->iType == 222) {
				Build2(TRUE);
				OglDraw();
			}
		}
		return TRUE;
	} else {
		return CDialog::PreTranslateMessage(pMsg);
	}
}

void CEntEditDialog::OnLButtonDown(UINT nFlags, CPoint point) {
	// TODO: Add your message handler code here and/or call default

	CDialog::OnLButtonDown(nFlags, point);
}

void CEntEditDialog::OnBnClickedOk() {
	// TODO: Add your control notification handler code here
	int i;
	CString sVVals[500];
	CString sID;
	CEdit* pT = (CEdit*) GetDlgItem(IDC_PTITLE);
	CEdit* pI = (CEdit*) GetDlgItem(IDC_ENTID);
	if ((pEnt != NULL) || (pO != NULL)) {
		if (pEnt != NULL) {
			pT->GetWindowTextA(pEnt->sTitle);
			pI->GetWindowTextA(sID);

			// Saeed_Material_SaveBugV1_05_20_2025_Start
			/*
			//Saeed_Material_SaveBugV1_05_20_2025_End
			pEnt->iID = atoi(sID); //Need to check we can no id conflics
			//Saeed_Material_SaveBugV1_05_20_2025_Start
			*/
			if (atoi(sID) != pEnt->iID) {
				pEnt->iID = MatT->OfferedID(atoi(sID), false, 0);
				if (!MatT->isTemp) {
					outtextSprintf("\r\nMaterial ID changed to %i", pEnt->iID, 0.0, true, 1);
				}
				if (pEnt->iID != atoi(sID)) {
					sID = std::to_string(pEnt->iID).c_str();
					pI->SetWindowTextA(sID);
				}
			}
			// Saeed_Material_SaveBugV1_05_20_2025_End

		} else if (pO != NULL) {
			if (pO->iObjType == 12) // Coordsys
			{
				pI->GetWindowTextA(sID);
				pO->iLabel = atoi(sID);
			}
		}

		for (i = 0; i < iNo; i++) {
			sVVals[i] = m_List.GetItemText(i, 1);
			CString sS;
			sS = m_List.GetItemText(i, 1);
		}
		if (pEnt != NULL)
			pEnt->PutVarValues(iNo, sVVals);
		if (pO != NULL)
			pO->PutVarValues(PT, iNo, sVVals);

		// Saeed_Material_SaveBugV1_05_20_2025_Start
		if (MatT->isTemp == true) {
			outtextSprintf("\r\nMaterial ID %i Created.", MatT->pEnts[MatT->iNo - 1]->iID, 0.0, true, 1);
			MatT->isTemp = false;
		}
		// Saeed_Material_SaveBugV1_05_20_2025_End
	}
	// CDialog::OnOK();
}

void CEntEditDialog::OnBnClickedEntlist() {
	// TODO: Add your control notification handler code here
	int i;
	CString sTemp;
	outtext1("Entity Data Listing:-");
	CEdit* pT = (CEdit*) GetDlgItem(IDC_PTITLE);
	CEdit* pID = (CEdit*) GetDlgItem(IDC_ENTID);
	pT->GetWindowTextA(sTemp);
	outtext1(sTemp);
	pID->GetWindowTextA(sTemp);
	outtext1(sTemp);
	for (i = 0; i < iNo; i++) {
		sTemp = m_List.GetItemText(i, 0);
		outtext1(sTemp);
		sTemp = m_List.GetItemText(i, 1);
		outtext1(sTemp);
	}
}

void CEntEditDialog::OnDblclkList1(NMHDR* pNMHDR, LRESULT* pResult) {
	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	// TODO: Add your control notification handler code here
	POSITION iSeA = m_List.GetFirstSelectedItemPosition();
	int iRow = m_List.GetSelectionMark();
	m_iItemBeingEdited = iRow;
	*pResult = 0;
	CRect r;
	int iR = m_List.GetColumnWidth(0);
	int iL = m_List.GetColumnWidth(1);
	m_List.GetItemRect(iRow, &r, LVIR_BOUNDS);
	eEdit->SetParent(&m_List);
	eEdit->MoveWindow(iR, r.top - 2, iL, (r.bottom - r.top) + 4, 1);
	CString sS;
	sS = m_List.GetItemText(iRow, 1);

	eEdit->SetWindowText(sS);
	eEdit->SetSel(0, -1, TRUE);
	eEdit->ShowWindow(SW_SHOW);
	eEdit->SetFocus();
}

void CEntEditDialog::DoDataExchange(CDataExchange* pDX) {
	// TODO: Add your specialized code here and/or call the base class

	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_PTITLE, Ed_Title);
	DDX_Control(pDX, IDC_ENTID, Ed_ID);
	DDX_Control(pDX, IDC_LIST1, m_List);
}

// C:\Users\Roy\Documents\Visual Studio 2017\Projects\M3da\M3da\G_Object.cpp : implementation file
//

void CEntEditDialog::OnBnClickedMfclink2() {
	// TODO: Add your control notification handler code here
}

//***************************************************************
// Basic class for visulising lamina in latimate stack
//***************************************************************
Lamina::Lamina() {
	dZOFFS = 0;
	dThk = 0;
	dMAng = 0;
	pVertex[0].Set(-0.7, -0.5, 0);
	pVertex[1].Set(0.7, -0.5, 0);
	pVertex[2].Set(0.7, 0.5, 0);
	pVertex[3].Set(-0.7, 0.5, 0);
}

Lamina::~Lamina() {
}

void Lamina::SetZ(double dZ) {
	dZOFFS = dZ;
	pVertex[0].z = dZ;
	pVertex[1].z = dZ;
	pVertex[2].z = dZ;
	pVertex[3].z = dZ;
}

void Lamina::SetThk(double dT) {
	dThk = dT;
}

void Lamina::SetMID(int ID) {
	iMID = ID;
}

void Lamina::SetAng(double dA) {
	dMAng = dA;
}

void Lamina::OglDraw() {
	C3dMatrix R;
	char s1[8];
	R.MakeUnit();
	R.Rotate(0, 0, dMAng);
	C3dVector vTmp;
	C3dVector p1;
	C3dVector p2;
	C3dVector p3;
	C3dVector p4;
	vTmp = R * pVertex[0];

	glColor3fv(cols[144]);
	// glBegin(GL_POLYGON);
	//   vTmp = R*pVertex[0];
	//   glVertex3f((float)(vTmp.x), (float)(vTmp.y), (float)(vTmp.z ));
	//   vTmp = R*pVertex[1];
	//   glVertex3f((float)(vTmp.x), (float)(vTmp.y), (float)(vTmp.z ));
	//   vTmp = R*pVertex[2];
	//   glVertex3f((float)(vTmp.x), (float)(vTmp.y), (float)(vTmp.z ));
	//   vTmp = R*pVertex[3];
	//   glVertex3f((float)(vTmp.x), (float)(vTmp.y), (float)(vTmp.z ));
	// glEnd();
	p1.Set(-0.7, 0, dZOFFS - 0.5 * dThk);
	p2.Set(0.7, 0, dZOFFS - 0.5 * dThk);
	p3.Set(0.7, 0, dZOFFS + 0.5 * dThk);
	p4.Set(-0.7, 0, dZOFFS + 0.5 * dThk);
	p1 = R * p1;
	p2 = R * p2;
	p3 = R * p3;
	p4 = R * p4;
	glColor3fv(cols[4]);
	glBegin(GL_POLYGON);
	glVertex3f((float) (p1.x), (float) (p1.y), (float) (p1.z));
	glVertex3f((float) (p2.x), (float) (p2.y), (float) (p2.z));
	glVertex3f((float) (p3.x), (float) (p3.y), (float) (p3.z));
	glVertex3f((float) (p4.x), (float) (p4.y), (float) (p4.z));
	glEnd();
	glColor3fv(cols[0]);
	glLineWidth(gEL_SIZE);
	glBegin(GL_LINES);
	glVertex3f((float) (p1.x), (float) (p1.y), (float) (p1.z));
	glVertex3f((float) (p2.x), (float) (p2.y), (float) (p2.z));

	glVertex3f((float) (p2.x), (float) (p2.y), (float) (p2.z));
	glVertex3f((float) (p3.x), (float) (p3.y), (float) (p3.z));

	glVertex3f((float) (p3.x), (float) (p3.y), (float) (p3.z));
	glVertex3f((float) (p4.x), (float) (p4.y), (float) (p4.z));

	glVertex3f((float) (p4.x), (float) (p4.y), (float) (p4.z));
	glVertex3f((float) (p1.x), (float) (p1.y), (float) (p1.z));
	glEnd();
	glLineWidth(2.0);

	p1.Set(0.75, 0, dZOFFS);
	// p1 = R * p1;
	sprintf_s(s1, "%g", dMAng);
	OglString(0, p1.x, p1.y, p1.z, &s1[0]);
	p1.Set(-0.95, 0, dZOFFS);
	// p1 = R * p1;
	sprintf_s(s1, "%i", iMID);
	OglString(0, p1.x, p1.y, p1.z, &s1[0]);

	// Draw fibres
	double dWid;
	double dWidInc;
	int iInc = 2;
	C3dVector vS;
	C3dVector vE;
	int iC = 0;
	dWid = pVertex[3].y - pVertex[0].y;
	dWidInc = dWid / iInc;
	vS = pVertex[0];
	vE = pVertex[1];
	glColor3fv(cols[0]);

	// glBegin(GL_LINES);
	// for (iC =0; iC<iInc+1; iC++)
	//{
	//   vTmp = R*vS;
	//   glVertex3f((float)(vTmp.x), (float)(vTmp.y), (float)(vTmp.z));
	//   vTmp = R*vE;
	//   glVertex3f((float)(vTmp.x), (float)(vTmp.y), (float)(vTmp.z));
	//   vS.y += dWidInc;
	//   vE.y += dWidInc;
	// }
	// glEnd();
}

//**************************************************
//  T H E    P C O M P    E D I T O R
//**************************************************
CPcompEditor::CPcompEditor()
    : CDialog(IDD_PCOMPEDIT, NULL) {
	iNoLayers = 0;
	pEnt = NULL;
	hdcOld = wglGetCurrentDC();
	hrcOld = wglGetCurrentContext();
	hrc = NULL;
	hdc = NULL;
	vMat.MakeUnit();
}

void CPcompEditor::AddVisLayer(double dA, double dZ, double dT, int iM) {
	Laminate[iNoLayers].SetAng(dA);
	Laminate[iNoLayers].SetZ(dZ);
	Laminate[iNoLayers].SetThk(dT);
	Laminate[iNoLayers].SetMID(iM);
	iNoLayers++;
}

CPcompEditor::~CPcompEditor() {
	if (hrc != NULL) {
		wglMakeCurrent(NULL, NULL);
		wglDeleteContext(hrc);
	}

	if (pDrg != NULL)
		delete (pDrg);
	wglMakeCurrent(hdcOld, hrcOld);
}

void CPcompEditor::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CPcompEditor, CDialog)
ON_BN_CLICKED(IDOK, &CPcompEditor::OnBnClickedOk)
ON_BN_CLICKED(IDC_BUTTON1, &CPcompEditor::OnBnClickedButton1)
//  ON_WM_PAINT()
ON_WM_PAINT()
END_MESSAGE_MAP()

void CPcompEditor::OnBnClickedOk() {
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
}

BOOL CPcompEditor::OnInitDialog() {
	CDialog::OnInitDialog();
	// SIZE DIALOG BOX TO FIT COLOURS
	CRect oSize;
	this->SetWindowText("Laminate Stack Viewer");
	this->GetWindowRect(&oSize);
	oSize.right = oSize.left + 500;
	oSize.bottom = oSize.top + 600;
	this->MoveWindow(oSize, 0);

	// TODO:  Add extra initialization here
	pDrg = new CWnd;
	pDrg->Create(_T("STATIC"), _T("Hi"), WS_CHILD | WS_VISIBLE | WS_THICKFRAME,
	             CRect(0, 0, 500, 500), this, 1234);
	InitOGL();
	Build();
	return TRUE; // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CPcompEditor::Build() {
	int i;
	double dTheta;
	double dZ;
	double dT;
	double dS;
	int iM;
	PCOMP* pP = (PCOMP*) pEnt;
	vMat.Rotate(-90, 0, 5);
	dS = 1.0 / pP->GetThk();
	dZ = pP->dZ0;
	dZ *= dS;
	dTheta = pP->Theta[0];
	iM = pP->MID[0];
	dZ += 0.5 * dS * pP->T[0];
	dT = dS * pP->T[0];
	AddVisLayer(dTheta, dZ, dT, iM);
	for (i = 1; i < pP->iNoLays; i++) {
		dTheta = pP->Theta[i];
		iM = pP->MID[i];
		dZ += 0.5 * dS * pP->T[i - 1];
		dZ += 0.5 * dS * pP->T[i];
		dT = dS * pP->T[i];
		AddVisLayer(dTheta, dZ, dT, iM);
	}
}

void CPcompEditor::InitOGL() {
	static PIXELFORMATDESCRIPTOR pfd =
	    {
	        sizeof(PIXELFORMATDESCRIPTOR), // size of this pfd
	        1, // version number
	        PFD_DRAW_TO_WINDOW | // support window
	            PFD_SUPPORT_OPENGL | // support OpenGL
	            // PFD_DOUBLEBUFFER,             // double buffered
	            PFD_TYPE_RGBA, // RGBA type
	        24, // 24-bit color depth
	        0, 0, 0, 0, 0, 0, // color bits ignored
	        0, // no alpha buffer
	        0, // shift bit ignored
	        0, // no accumulation buffer
	        0, 0, 0, 0, // accum bits ignored
	        32, // 32-bit z-buffer
	        0, // no stencil buffer
	        0, // no auxiliary buffer
	        PFD_MAIN_PLANE, // main layer
	        0, // reserved
	        0, 0, 0 // layer masks ignored
	    };

	// Get device context only once.
	hdc = pDrg->GetDC()->m_hDC;
	// Pixel format.
	m_nPixelFormat = ChoosePixelFormat(hdc, &pfd);
	SetPixelFormat(hdc, m_nPixelFormat, &pfd);

	// Create the OpenGL Rendering Context.
	hrc = wglCreateContext(hdc);
	wglMakeCurrent(hdc, hrc);

	// Send draw request
	// OnDraw(NULL);
}

void CPcompEditor::OglDraw() {
	glClearColor(255.0f, 255.0f, 255.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glClearDepth(1.0f);
	CRect cR;
	pDrg->GetWindowRect(&cR);
	int iW = cR.Width();
	int iH = cR.Height();
	glViewport(0, 0, iW, iH);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	OglMat mOGLmat = vMat.GetOglMat();
	glMultMatrixf(mOGLmat.fMat);
	// gluPerspective(35.0f, (float)cx / (float)cy, 0.01f, 2000.0f);
	glMatrixMode(GL_MODELVIEW);
	glPointSize(10.0f);
	glColor3f((float) 0.0, (float) 0.0, (float) 0.9);
	glBegin(GL_POINTS);
	glVertex3f(20.0, 30.0, 10.0);
	glVertex3f(140.0, 30.0, 20.0);
	glVertex3f(50.0, 50.0, 30.0);
	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f(0.5, 0.0, 0.0);
	glVertex3f(0.0, 0.5, 0.0);
	glEnd();
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	char sLab[20];

	int i;
	for (i = 0; i < iNoLayers; i++)
		Laminate[i].OglDraw();
	sprintf_s(sLab, "%s", "Z");
	OglString(1, 0.0, 0.0, 0.7, &sLab[0]);
	glBegin(GL_LINES);
	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f((float) 0.0, (float) 0.0, (float) 0.7);
	glEnd();
	sprintf_s(sLab, "%s", "1");
	OglString(1, 0.7, 0.0, 0.0, &sLab[0]);
	glBegin(GL_LINES);
	glVertex3f(0.0, 0.0, 0.0);
	glVertex3f((float) 0.7, (float) 0.0, (float) 0.0);
	glEnd();

	glFinish();
	SwapBuffers(wglGetCurrentDC());
}

void CPcompEditor::OnBnClickedButton1() {
	// TODO: Add your control notification handler code here
	// OglDraw();
	Build();
}

void CPcompEditor::OnPaint() {
	// CPaintDC dc(this); // device context for painting
	OglDraw();
}

void CEntEditDialog::OnPaint() {
	CPaintDC dc(this); // device context for painting
	// TODO: Add your message handler code here
	// Do not call CDialog::OnPaint() for painting messages
	if (pDrg != NULL) {
		OglDraw();
	}
}

BEGIN_MESSAGE_MAP(cWndOGL, CWnd)
ON_WM_PAINT()
END_MESSAGE_MAP()

void cWndOGL::OnPaint() {
	// CPaintDC dc(this); // device context for painting
	//  TODO: Add your message handler code here
	//  Do not call CWnd::OnPaint() for painting messages
}

void CEntEditDialog::OnLvnItemchangedList1(NMHDR* pNMHDR, LRESULT* pResult) {
	LPNMLISTVIEW pNMLV = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);
	// TODO: Add your control notification handler code here
	*pResult = 0;
}

void CEntEditDialog::OnLvnItemchangingList1(NMHDR* pNMHDR, LRESULT* pResult) {
	LPNMLISTVIEW pNMLV = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);
	// TODO: Add your control notification handler code here
	*pResult = 0;
}

// void CEntEditDialog::OnLvnOdcachehintList1(NMHDR* pNMHDR, LRESULT* pResult)
//{
//	LPNMLVCACHEHINT pCacheHint = reinterpret_cast<LPNMLVCACHEHINT>(pNMHDR);
//	// TODO: Add your control notification handler code here
//	*pResult = 0;
// }

// void CEntEditDialog::OnLvnKeydownList1(NMHDR* pNMHDR, LRESULT* pResult)
//{
//	LPNMLVKEYDOWN pLVKeyDow = reinterpret_cast<LPNMLVKEYDOWN>(pNMHDR);
//	// TODO: Add your control notification handler code here
//	*pResult = 0;
// }

void CEntEditDialog::OnNMReturnList1(NMHDR* pNMHDR, LRESULT* pResult) {
	// TODO: Add your control notification handler code here
	*pResult = 0;
}

void CEntEditDialog::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) {
	// TODO: Add your message handler code here and/or call default

	CDialog::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CEntEditDialog::OnBnClickedCdelete() {
	// TODO: Add your control notification handler code here
	bDel = TRUE;
	CDialog::OnCancel();
}

void CEntEditDialog::OnBnClickedCancel() {
	// TODO: Add your control notification handler code here
	CDialog::OnCancel();
}

//****************************************************************
// RESPONSE GRAPH DIALOG
//****************************************************************
BEGIN_MESSAGE_MAP(CGraphDialog, CDialog)
ON_BN_CLICKED(IDOK, &CGraphDialog::OnBnClickedOk)
ON_WM_PAINT()
ON_LBN_SELCHANGE(IDC_RESPVEC, &CGraphDialog::OnLbnSelchangeRespvec)
ON_BN_CLICKED(IDC_PLOT, &CGraphDialog::OnBnClickedPlot)
//	ON_WM_MBUTTONDOWN()
ON_WM_LBUTTONUP()
ON_BN_CLICKED(IDCANCEL, &CGraphDialog::OnBnClickedCancel)
ON_BN_CLICKED(IDC_CLEAR, &CGraphDialog::OnBnClickedClear)
ON_LBN_SELCHANGE(IDC_PLOTS, &CGraphDialog::OnLbnSelchangePlots)
ON_BN_CLICKED(IDC_COLOUR, &CGraphDialog::OnBnClickedColour)
ON_BN_CLICKED(IDC_LIST, &CGraphDialog::OnBnClickedList)
ON_BN_CLICKED(IDC_REDRAW, &CGraphDialog::OnBnClickedRedraw)
ON_BN_CLICKED(IDC_LOG, &CGraphDialog::OnBnClickedLog)
END_MESSAGE_MAP()

CGraphDialog::CGraphDialog()
    : CDialog(CGraphDialog::IDD, NULL) {
	iNo = 0;
	pME = NULL;
	vMat.MakeUnit();
	int i;
	for (i = 0; i < MAX_GRAPHS; i++)
		pGs[i] = NULL;
}

CGraphDialog::~CGraphDialog() {
	int i;
	for (i = 0; i < iNo; i++)
		if (pGs[i] != NULL)
			delete (pGs[i]);
}

int CGraphDialog::GetColourID() {
	int irc;
	CColourPickDialog Dlg;
	int i;
	for (i = 0; i < 167; i++) {
		float R = cols[i][0];
		float G = cols[i][1];
		float B = cols[i][2];
		int iR = R * 255;
		int iG = G * 255;
		int iB = B * 255;
		Dlg.AddCol(iR, iG, iB);
	}
	Dlg.DoModal();
	irc = Dlg.iSel;
	return (irc);
}

void CGraphDialog::SetPen(CDC* pDC, int iC, int iS) {
	float R = cols[iC][0];
	float G = cols[iC][1];
	float B = cols[iC][2];
	int iR = R * 255;
	int iG = G * 255;
	int iB = B * 255;
	pDC->SelectStockObject(NULL_BRUSH);
	Pen = new CPen(PS_SOLID, iS, RGB(iR, iG, iB));
	oldPen = pDC->SelectObject(Pen);
}

void CGraphDialog::SetTextCol(HDC hdc, int iC) {
	float R = cols[iC][0];
	float G = cols[iC][1];
	float B = cols[iC][2];
	int iR = R * 255;
	int iG = G * 255;
	int iB = B * 255;
	SetTextColor(hdc, RGB(iR, iG, iB));
}

void CGraphDialog::RestorePen(CDC* pDC) {
	pDC->SelectObject(oldPen);
	int t = Pen->DeleteObject();
}

void CGraphDialog::ResetMaxMin() {
	minX = 0;
	maxX = 0;
	minY = 0;
	maxY = 0;
}

void CGraphDialog::DeleteAll() {
	int i;
	ResetMaxMin();
	for (i = 0; i < iNo; i++) {
		if (pGs[i] != NULL) {
			delete (pGs[i]);
			pGs[i] = NULL;
		}
	}
	iNo = 0;
}

// Calculate nice axis divisions
float CGraphDialog::AxisTickMarks(float fMaxV, int& itargetSteps) {
	int magMsd;
	float tempStep;
	float mag;
	float magPow;
	int i;
	// calculate an initial guess at step size
	tempStep = fMaxV / itargetSteps;
	// get the magnitude of the step size
	mag = floor(log10(tempStep));
	magPow = (float) pow(10, mag);
	// calculate most significant digit of the new step size
	magMsd = (int) (tempStep / magPow + 0.5);

	// promote the MSD to either 1, 2, or 5
	if (magMsd > 5)
		magMsd = 10;
	else if (magMsd > 2)
		magMsd = 5;
	else if (magMsd > 1)
		magMsd = 2;
	for (i = 0; i < 5; i++) {
		if (magMsd * magPow * itargetSteps < fMaxV)
			itargetSteps++;
		else
			break;
	}
	return (magMsd * magPow);
}

void CGraphDialog::GDIDraw() {
	BOOL bLOG = TRUE;
	CButton* oRB = (CButton*) this->GetDlgItem(IDC_LOG);

	if (oRB->GetCheck() == BST_CHECKED)
		bLOG = TRUE;
	else
		bLOG = FALSE;
	HFONT hFont, hTmp;
	int i;
	int j;
	int k;
	int iNoTicksX = 5;
	int iNoTicksY = 5;
	int iLegOffX = 800;
	int iLegOffY = 250;
	float fDivX = 0;
	float fDivY = 0;
	char sLab[20];
	BOOL bFirst = TRUE;
	HDC hDC;
	char buff[200];
	CDC* pDC = pDrg->GetDC();
	hDC = pDC->m_hDC;
	float X;
	float Y;
	CRect cR;
	fxoff = 80;
	fyoff = 50;
	fxspan = fW - fxoff - 50;
	fyspan = fH - fyoff - 50;
	Graph* pG = pGs[0];
	float MaxRealY = 0;
	// Calculate maximum axis value of all charts
	minX = 0;
	maxX = 0;
	minY = 0;
	maxY = 0;
	for (j = 0; j < iNo; j++) {
		pG = pGs[j];
		if (pG != NULL) {
			if (pG->GminX < minX)
				minX = pG->GminX;
			if (pG->GmaxX > maxX)
				maxX = pG->GmaxX;
			if (pG->GminY < minY)
				maxY = pG->GmaxY;
			if (pG->GmaxY > maxY)
				maxY = pG->GmaxY;
		}
	}
	fDivY = AxisTickMarks(maxY, iNoTicksY);
	if (bLOG) {
		iNoTicksX = log10(maxX);
		iNoTicksX = floor(iNoTicksX) + 1;
		fDivX = 1;
	} else {
		fDivX = AxisTickMarks(maxX, iNoTicksX);
	}
	if (fDivY * iNoTicksY > maxY)
		maxY = fDivY * iNoTicksY;
	if (bLOG) {
		maxX = iNoTicksX;
	} else {
		if (fDivX * iNoTicksX > maxX)
			maxX = fDivX * iNoTicksX;
	}
	// Axis and titles
	SetPen(pDC, 133, 3);
	for (i = 0; i <= iNoTicksX; i++) {
		X = fxoff + (fxspan) * (i * fDivX - minX) / (maxX - minX);
		pDC->MoveTo(X, fH - (fyoff - 5));
		pDC->LineTo(X, fH - (fyoff + fyspan));
		if (bLOG)
			sprintf_s(sLab, "%g", pow(10, i * fDivX));
		else
			sprintf_s(sLab, "%g", i * fDivX);
		TextOut(hDC, X, fH - (fyoff - 5), sLab, static_cast<int>(strlen(sLab)));
	}
	for (i = 0; i <= iNoTicksY; i++) {
		Y = fyoff + (fyspan) * (i * fDivY - minY) / (maxY - minY);
		pDC->MoveTo(fxoff - 5, fH - Y);
		pDC->LineTo(fxoff + fxspan, fH - Y);
		sprintf_s(sLab, "%g", i * fDivY);
		TextOut(hDC, fxoff - 40, fH - Y, sLab, static_cast<int>(strlen(sLab)));
	}
	RestorePen(pDC);
	SetPen(pDC, 133, 1);
	float fxLg = 0;
	float fBase = 0;
	if (bLOG) // Minor log grid lines
	{
		for (i = 0; i <= iNoTicksX; i++) {
			fBase = pow(10, i);
			for (k = 1; k < 10; k++) {
				fxLg = fBase * k;
				X = fxoff + (fxspan) *log10(fxLg) / (maxX - minX);
				pDC->MoveTo(X, fH - (fyoff - 5));
				pDC->LineTo(X, fH - (fyoff + fyspan));
			}
		}
	}
	RestorePen(pDC);
	CString sS;
	CEdit* oEdit = (CEdit*) this->GetDlgItem(IDC_XTITLE);
	oEdit->GetWindowTextA(sS);
	TextOut(hDC, fW / 2, fH - 40, sS, static_cast<int>(strlen(sS)));
	oEdit = (CEdit*) this->GetDlgItem(IDC_YTITLE);
	oEdit->GetWindowTextA(sS);
	TextOut(hDC, 5, fH / 2, sS, static_cast<int>(strlen(sS)));
	oEdit = (CEdit*) this->GetDlgItem(IDC_TITLE);
	oEdit->GetWindowTextA(sS);
	hFont = CreateFont(30, 0, 0, 0, FW_BOLD, 0, 0, 0, 0, 0, 0, 2, 0, "SYSTEM_FIXED_FONT");
	hTmp = (HFONT) SelectObject(hDC, hFont);
	TextOut(hDC, fxoff, 10, sS, static_cast<int>(strlen(sS)));
	DeleteObject(SelectObject(hDC, hTmp));
	// Draw All Charts
	for (j = 0; j < iNo; j++) {
		bFirst = TRUE;
		pG = pGs[j];
		if (pG != NULL) {
			if (j == iActPlot)
				SetPen(pDC, pG->iCol, 9);
			else
				SetPen(pDC, pG->iCol, 3);
			// Lengend
			SetTextCol(hDC, pG->iCol);
			sprintf_s(buff, "%s %s %s", pG->sResType, pG->sEntID, pG->sVar);
			TextOut(hDC, iLegOffX, fH - (iLegOffY + j * 20), buff, static_cast<int>(strlen(buff)));
			for (i = 0; i < pG->fx.size(); i++) {
				if (bLOG)
					X = fxoff + (fxspan) *log10(pG->fx[i] - minX) / (maxX - minX);
				else
					X = fxoff + (fxspan) * (pG->fx[i] - minX) / (maxX - minX);
				Y = fyoff + (fyspan) * (pG->fy[i] - minY) / (maxY - minY);
				if (bFirst) {
					pDC->MoveTo(X, fH - Y);
					bFirst = FALSE;
				} else {
					pDC->LineTo(X, fH - Y);
				}
			}
			RestorePen(pDC);
		}
	}

	this->ReleaseDC(pDC);
}

void CGraphDialog::popResVec() {
	int i;
	int iLC;
	int iTCode;
	char buff[200];
	NEList* LCGp = new NEList();
	NEList* oIDS = new NEList();
	CListBox* oLB;
	oLB = (CListBox*) this->GetDlgItem(IDC_RESPVEC);
	LCGp->iNo = 0;
	for (i = 0; i < pME->iNoRes; i++) {
		iLC = pME->ResultsSets[i]->LC;
		iTCode = pME->ResultsSets[i]->TCODE;
		// TCODE 1039 Node MPC
		if ((iTCode == 1039) && (!LCGp->IsIn(iLC))) {
			LCGp->Add(iLC, 1);
			sprintf_s(buff, "%i_%s_%i_%s", iTCode, "LC", iLC, "MPCF");
			oLB->AddString(buff);
			vTC.push_back(iTCode);
			vLC.push_back(iLC);
		}
	}
	LCGp->iNo = 0;
	for (i = 0; i < pME->iNoRes; i++) {
		iLC = pME->ResultsSets[i]->LC;
		iTCode = pME->ResultsSets[i]->TCODE;
		// TCODE 1011 Accel
		if ((iTCode == 1011) && (!LCGp->IsIn(iLC))) {
			LCGp->Add(iLC, 1);
			sprintf_s(buff, "%i	%s %i %s", iTCode, "LC", iLC, "ACCEL");
			oLB->AddString(buff);
			vTC.push_back(iTCode);
			vLC.push_back(iLC);
		}
	}

	LCGp->iNo = 0;
	for (i = 0; i < pME->iNoRes; i++) {
		iLC = pME->ResultsSets[i]->LC;
		iTCode = pME->ResultsSets[i]->TCODE;
		// TCODE 1004 El Force CBUSH
		if ((iTCode == 1004) && (!LCGp->IsIn(iLC))) {
			LCGp->Add(iLC, 1);
			sprintf_s(buff, "%i	%s %i %s", iTCode, "LC", iLC, "ELFORCE");
			oLB->AddString(buff);
			vTC.push_back(iTCode);
			vLC.push_back(iLC);
		}
	}

	delete (LCGp);
	delete (oIDS);
}

void CGraphDialog::popEnt(int inTC, int inLC) {
	int i;
	int j;
	int iLC;
	int iTCode;
	Res* pR = NULL;
	char buff[200];
	CListBox* oLB;
	CListBox* oLBE;
	vE.clear();
	oLB = (CListBox*) this->GetDlgItem(IDC_VAR);
	oLB->ResetContent();
	oLBE = (CListBox*) this->GetDlgItem(IDC_ENT);
	oLBE->ResetContent();
	for (i = 0; i < pME->iNoRes; i++) {
		iLC = pME->ResultsSets[i]->LC;
		iTCode = pME->ResultsSets[i]->TCODE;
		// TCODE 1039 Node MPC
		if ((iTCode == inTC) && (iLC = inLC)) {
			pR = pME->ResultsSets[i]->Head;
			for (j = 0; j < pME->ResultsSets[i]->iCnt; j++) {
				sprintf_s(buff, "%i", pR->ID);
				oLBE->AddString(buff);
				vE.push_back(pR->ID);
				pR = pR->next;
			}
			oLBE->RedrawWindow();
			oLBE->SetCurSel(0);
			for (j = 0; j < pME->ResultsSets[i]->iNoV; j++) {
				oLB->AddString(pME->ResultsSets[i]->lab[j]);
			}
			oLB->RedrawWindow();
			oLB->SetCurSel(0);
			break;
		}
	}
}

BOOL CGraphDialog::OnInitDialog() {
	CDialog::OnInitDialog();
	// SIZE DIALOG BOX TO FIT COLOURS
	CRect cR;
	CRect oSize;
	CRect oSize2;
	CRect oS;
	CListBox* oLB;
	vTC.clear();
	vLC.clear();
	this->SetWindowText("Graph");
	this->GetWindowRect(&oSize);

	oSize.right = oSize.left + 1500;
	oSize.bottom = oSize.top + 900;

	this->MoveWindow(oSize, 0);
	this->GetClientRect(oS);
	// TODO:  Add extra initialization here
	pDrg = new CWnd;
	pDrg->Create(_T("STATIC"), _T(""), WS_CHILD | WS_VISIBLE | WS_THICKFRAME,
	             CRect(oS.left, oS.top, oS.right, oS.bottom - 200), this, 1234);
	pDrg->GetWindowRect(&cR);
	fW = cR.Width();
	fH = cR.Height();
	// Size buttons and Listboxes
	oSize2.top = oS.bottom - 190;
	;
	oSize2.left = oS.left + 10;
	oSize2.bottom = oS.bottom - 10;
	oSize2.right = oS.left + 260;
	oLB = (CListBox*) this->GetDlgItem(IDC_RESPVEC);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	oLB->SetHorizontalExtent(300);
	oSize2.top = oS.bottom - 190;
	;
	oSize2.left = oS.left + 270;
	oSize2.bottom = oS.bottom - 10;
	oSize2.right = oS.left + 420;
	oLB = (CListBox*) this->GetDlgItem(IDC_ENT);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	oLB->SetHorizontalExtent(300);
	oSize2.top = oS.bottom - 190;
	;
	oSize2.left = oS.left + 430;
	oSize2.bottom = oS.bottom - 10;
	oSize2.right = oS.left + 580;
	oLB = (CListBox*) this->GetDlgItem(IDC_VAR);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	oLB->SetHorizontalExtent(300);
	oSize2.top = oS.bottom - 190;
	;
	oSize2.left = oS.left + 590;
	oSize2.bottom = oS.bottom - 10;
	oSize2.right = oS.left + 940;
	oLB = (CListBox*) this->GetDlgItem(IDC_PLOTS);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	oLB->SetHorizontalExtent(500);
	oSize2.top = oS.bottom - 190;
	;
	oSize2.left = oS.left + 950;
	oSize2.bottom = oS.bottom - 160;
	oSize2.right = oS.left + 1050;
	oLB = (CListBox*) this->GetDlgItem(IDC_PLOT);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	oSize2.top = oS.bottom - 160;
	;
	oSize2.left = oS.left + 950;
	oSize2.bottom = oS.bottom - 130;
	oSize2.right = oS.left + 1050;
	oLB = (CListBox*) this->GetDlgItem(IDC_REDRAW);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	oSize2.top = oS.bottom - 130;
	;
	oSize2.left = oS.left + 950;
	oSize2.bottom = oS.bottom - 100;
	oSize2.right = oS.left + 1050;
	oLB = (CListBox*) this->GetDlgItem(IDC_COLOUR);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);

	oSize2.top = oS.bottom - 100;
	;
	oSize2.left = oS.left + 950;
	oSize2.bottom = oS.bottom - 70;
	oSize2.right = oS.left + 1050;
	oLB = (CListBox*) this->GetDlgItem(IDC_LIST);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	oSize2.top = oS.bottom - 70;
	;
	oSize2.left = oS.left + 950;
	oSize2.bottom = oS.bottom - 40;
	oSize2.right = oS.left + 1050;
	oLB = (CListBox*) this->GetDlgItem(IDC_CLEAR);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	oSize2.top = oS.bottom - 40;
	;
	oSize2.left = oS.left + 950;
	oSize2.bottom = oS.bottom - 10;
	oSize2.right = oS.left + 1050;
	oLB = (CListBox*) this->GetDlgItem(IDCANCEL);
	if (oLB != NULL)
		oLB->MoveWindow(oSize2, 0);
	oSize2.top = oS.bottom - 190;
	oSize2.left = oS.left + 1100;
	oSize2.bottom = oS.bottom - 190 + 30;
	oSize2.right = oS.left + 1490;
	CEdit* oEdit = (CEdit*) this->GetDlgItem(IDC_TITLE);
	if (oEdit != NULL) {
		oEdit->MoveWindow(oSize2, 0);
		oEdit->SetWindowTextA("Graph Title");
	}
	oSize2.top = oS.bottom - 190 + 40;
	oSize2.left = oS.left + 1100;
	oSize2.bottom = oS.bottom - 190 + 70;
	oSize2.right = oS.left + 1490;
	oEdit = (CEdit*) this->GetDlgItem(IDC_XTITLE);
	if (oEdit != NULL) {
		oEdit->MoveWindow(oSize2, 0);
		oEdit->SetWindowTextA("Freq (Hz)");
	}
	oSize2.top = oS.bottom - 190 + 80;
	oSize2.left = oS.left + 1100;
	oSize2.bottom = oS.bottom - 190 + 110;
	oSize2.right = oS.left + 1490;
	oEdit = (CEdit*) this->GetDlgItem(IDC_YTITLE);
	if (oEdit != NULL) {
		oEdit->MoveWindow(oSize2, 0);
		oEdit->SetWindowTextA("Y Axis Title");
	}
	oSize2.top = oS.bottom - 190 + 120;
	oSize2.left = oS.left + 1100;
	oSize2.bottom = oS.bottom - 190 + 150;
	oSize2.right = oS.left + 1490;
	CButton* oRB = (CButton*) this->GetDlgItem(IDC_LOG);
	if (oRB != NULL) {
		oRB->MoveWindow(oSize2, 0);
	}

	popResVec();
	return TRUE; // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

void CGraphDialog::OnBnClickedOk() {
	// TODO: Add your control notification handler code here
	CDialog::OnOK();
}

void CGraphDialog::OnPaint() {
	CPaintDC dc(this); // device context for painting
	GDIDraw(); // TODO: Add your message handler code here
	// Do not call CDialog::OnPaint() for painting messages
}

void CGraphDialog::OnLbnSelchangeRespvec() {
	// TODO: Add your control notification handler code here
	int iI;
	int iTCode;
	int iLC;

	CListBox* oLB;
	oLB = (CListBox*) this->GetDlgItem(IDC_RESPVEC);
	iI = oLB->GetCurSel();
	iTCode = vTC.at(iI);
	iLC = vLC.at(iI);
	;
	popEnt(iTCode, iLC);
}

void CGraphDialog::OnBnClickedPlot() {
	// TODO: Add your control notification handler code here
	int iTC;
	int iE;
	int iLC;
	int iI;
	int iV;
	CString sRT;
	CString sID;
	CString sVar;

	CListBox* oLB;
	BOOL bIsGood = TRUE;
	oLB = (CListBox*) this->GetDlgItem(IDC_RESPVEC);
	iI = oLB->GetCurSel();
	oLB->GetText(iI, sRT);
	if (iI >= 0) {
		iTC = vTC.at(iI);
		iLC = vLC.at(iI);
	} else
		bIsGood = FALSE;
	oLB = (CListBox*) this->GetDlgItem(IDC_ENT);
	iI = oLB->GetCurSel();
	oLB->GetText(iI, sID);
	if (iI >= 0)
		iE = vE.at(iI);
	else
		bIsGood = FALSE;
	oLB = (CListBox*) this->GetDlgItem(IDC_VAR);
	iI = oLB->GetCurSel();
	oLB->GetText(iI, sVar);
	if (iI >= 0)
		iV = iI;
	else
		bIsGood = FALSE;
	// if bIsGood we have TCODE,LC,ENT and Var to plot
	if (bIsGood)
		GenGraph(sRT, sID, sVar, iTC, iLC, iE, iV);
}

void CGraphDialog::GenGraph(CString sRT, CString sID, CString sVar, int iTC, int iLC, int iEnt, int iVar) {
	char buff[200];
	int i;
	int j;
	ResSet* pRS;
	Res* pR;
	BOOL bFirst = TRUE;

	// Delete any previous graph data
	Graph* pG;
	pG = new Graph();
	if (iNo < MAX_GRAPHS) {
		pGs[iNo] = pG;
		iNo++;
		pG->sResType = sRT;
		pG->sEntID = sID;
		pG->sVar = sVar;
		CListBox* oLB = (CListBox*) this->GetDlgItem(IDC_PLOTS);
		sprintf_s(buff, "%s_%s_%s", sRT, sID, sVar);
		oLB->AddString(buff);
		for (i = 0; i < pME->iNoRes; i++) {
			if ((pME->ResultsSets[i]->LC == iLC) && (iTC == pME->ResultsSets[i]->TCODE)) {
				pRS = pME->ResultsSets[i];
				if (pRS->ACODE / 10 == 5) // Frequncy data
				{
					if (bFirst) {
						pG->sTitle = pRS->sTitle;
						pG->sSubTitle = pRS->sSubTitle;
						;
						bFirst = FALSE;
					}
					pR = pRS->Head;
					for (j = 0; j < pRS->iCnt; j++) {
						if (pR->ID == iEnt) {
							// sDL = pRS->ToStringDL(pR);
							pG->fx.push_back(*pR->GetAddress(0));
							pG->fy.push_back(*pR->GetAddress(iVar));

							// sprintf_s(buff, "%g	%g", *pR->GetAddress(0), *pR->GetAddress(iVar));
							// outtext1(buff);
							break;
						}
						pR = pR->next;
					}
				}
			}
		}
		pG->genMaxMin();
		// GDIDraw();
		CRect rc;
		pDrg->GetClientRect(&rc);
		pDrg->InvalidateRect(rc, 1);
		UpdateWindow();
		GDIDraw();
	}
}

// void CGraphDialog::OnMButtonDown(UINT nFlags, CPoint point)
//{
//	// TODO: Add your message handler code here and/or call default
//
//	CDialog::OnMButtonDown(nFlags, point);
//
// }

void CGraphDialog::OnLButtonUp(UINT nFlags, CPoint point) {
	// TODO: Add your message handler code here and/or call default
	// find closest point to clicked location
	int i;
	float fdist;
	float fdistMin;
	int ind = -1;
	float X;
	float Y;
	char s[20];
	BOOL bLOG;
	CButton* oRB = (CButton*) this->GetDlgItem(IDC_LOG);
	if (oRB->GetCheck() == BST_CHECKED)
		bLOG = TRUE;
	else
		bLOG = FALSE;
	point.x -= 5;
	Graph* pG = pGs[iActPlot];
	if (pG != NULL) {
		CDC* pDC = this->GetDC();
		X = fxoff + (fxspan) * (pG->fx[0] - minX) / (maxX - minX);
		fdistMin = abs(X - point.x);
		ind = 0;
		for (i = 0; i < pG->fx.size(); i++) {
			if (bLOG)
				X = fxoff + (fxspan) *log10(pG->fx[i] - minX) / (maxX - minX);
			else
				X = fxoff + (fxspan) * (pG->fx[i] - minX) / (maxX - minX);
			fdist = abs(X - point.x);
			if (fdist < fdistMin) {
				fdistMin = fdist;
				ind = i;
			}
		}
		if (bLOG)
			X = fxoff + (fxspan) *log10(pG->fx[ind] - minX) / (maxX - minX);
		else
			X = fxoff + (fxspan) * (pG->fx[ind] - minX) / (maxX - minX);
		Y = fyoff + (fyspan) * (pG->fy[ind] - minY) / (maxY - minY);
		sprintf(s, "%g", pG->fy[ind]);
		TextOut(pDC->m_hDC, X, fH - Y, s, static_cast<int>(strlen(s)));
		sprintf(s, "%g", pG->fx[ind]);
		TextOut(pDC->m_hDC, X, fH - (Y + 15), s, static_cast<int>(strlen(s)));
		this->ReleaseDC(pDC);
	}

	CDialog::OnLButtonUp(nFlags, point);
}

void CGraphDialog::OnBnClickedCancel() {
	// TODO: Add your control notification handler code here

	CDialog::OnCancel();
}

void CGraphDialog::OnBnClickedClear() {
	// TODO: Add your control notification handler code here
	CListBox* oLB = (CListBox*) this->GetDlgItem(IDC_PLOTS);
	oLB->ResetContent();
	CRect rc;
	pDrg->GetClientRect(&rc);
	pDrg->InvalidateRect(rc, 1);
	UpdateWindow();
	DeleteAll();
}

void CGraphDialog::OnLbnSelchangePlots() {
	// TODO: Add your control notification handler code here
	CListBox* oLB = (CListBox*) this->GetDlgItem(IDC_PLOTS);
	iActPlot = oLB->GetCurSel();
	CRect rc;
	pDrg->GetClientRect(&rc);
	pDrg->InvalidateRect(rc, 1);
	UpdateWindow();
	GDIDraw();
}

void CGraphDialog::OnBnClickedColour() {
	// TODO: Add your control notification handler code here
	int iC = GetColourID();
	CListBox* oLB = (CListBox*) this->GetDlgItem(IDC_PLOTS);

	// SetTextColor((HDC)wParam, RGB(255, 255, 255));
	int iActPlot = oLB->GetCurSel();
	if (iActPlot > -1) {
		if (pGs[iActPlot] != NULL)
			pGs[iActPlot]->iCol = iC;
	}
	CRect rc;
	pDrg->GetClientRect(&rc);
	pDrg->InvalidateRect(rc, 1);
	UpdateWindow();
	GDIDraw();
}

void CGraphDialog::OnBnClickedList() {
	// TODO: Add your control notification handler code here

	CListBox* oLB = (CListBox*) this->GetDlgItem(IDC_PLOTS);
	int iActPlot = oLB->GetCurSel();
	if (iActPlot > -1) {
		if (pGs[iActPlot] != NULL)
			pGs[iActPlot]->List();
	}
}

void CGraphDialog::OnBnClickedRedraw() {
	// TODO: Add your control notification handler code here

	CRect rc;
	pDrg->GetClientRect(&rc);
	pDrg->InvalidateRect(rc, 1);
	UpdateWindow();
	GDIDraw();
}

void CGraphDialog::OnBnClickedLog() {
	// TODO: Add your control notification handler code here
	CRect rc;
	pDrg->GetClientRect(&rc);
	pDrg->InvalidateRect(rc, 1);
	UpdateWindow();
	GDIDraw();
}

// Create Shade Representation of object

IMPLEMENT_DYNAMIC(G_ObjectDUM, CObject)

CString G_ObjectDUM::GetName() {
	return ("Variables");
}

int G_ObjectDUM::GetVarHeaders(CString sVar[]) {
	int iNo = 0;
	// gBACKGRD_COL
	sVar[iNo++] = "Background Colour - Tools/Colour To Find Value";

	// gZOOM_SCL
	sVar[iNo++] = "Zoom Scale Factor";

	// gPT_SIZE
	sVar[iNo++] = "Point Size";

	// gND_SIZE
	sVar[iNo++] = "Node Size";

	// gLM_SIZE
	sVar[iNo++] = "Lump Mass Size";

	// gEL_SIZE
	sVar[iNo++] = "Element Edge Size";

	// gED_SIZE
	sVar[iNo++] = "Free Edge Size";

	// gFC_SIZE
	sVar[iNo++] = "Free Face Size";

	// gWP_SIZE
	sVar[iNo++] = "Workplane Line Weight";

	// gBM_SIZE
	sVar[iNo++] = "Beam Section Size";

	// gTXT_SIZE
	sVar[iNo++] = "Text Size";

	// gDIM_SCALE
	sVar[iNo++] = "Drawing Scale for DIMS (ie 0.5 is 2:1)";

	// gDIM_FILSZ
	sVar[iNo++] = "Fillet Size";

	// gDIM_OFFSZ
	sVar[iNo++] = "Line Offset";

	// gTXT_HEIGHT
	sVar[iNo++] = "Text Height";

	// gDIM_RADSZ
	sVar[iNo++] = "Circle Radius for CIRCR";

	// gDIM_CVORD
	sVar[iNo++] = "Spline Order";

	// gDIM_PREC
	sVar[iNo++] = "Dimension Precision";

	// gDIM_SIZE
	sVar[iNo++] = "Dimension Size";

	// gCUR_RES
	sVar[iNo++] = "Trim Curve on Surface Resolution";

	// gDRILL_KS
	sVar[iNo++] = "Shell Drilling K Value";

	// gRIGID_MULTIPLIER
	sVar[iNo++] = "Stiffness Multplier for M3D Dummy Rigid";

	// gVSTIFF_KS
	sVar[iNo++] = "K for Restraints";

	// gDEF_E
	sVar[iNo++] = "Defualt Material E";

	// gDEF_V
	sVar[iNo++] = "Defualt Material v";

	// gDEF_DEN
	sVar[iNo++] = "Defualt Material Density";

	// gDEF_COND
	sVar[iNo++] = "Defualt Material Thermal Condutivity";

	// gSTIFF_BDIA
	sVar[iNo++] = "Defualt Stiff Beam Diameter";

	// gDEF_CTE
	sVar[iNo++] = "Defualt Material CTE";

	// gDEF_THERM_LNK
	sVar[iNo++] = "Defualt Thermal Link Coef";

	// gDEF_SOL_TOL
	sVar[iNo++] = "Defualt Iterative Solver Tolerence";
	return (iNo);
}

int G_ObjectDUM::GetVarValues(CString sVar[]) {
	int iNo = 0;
	char S1[80] = "";
	sprintf_s(S1, "%i", gBACKGRD_COL);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gZOOM_SCL);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gPT_SIZE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gND_SIZE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gLM_SIZE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gEL_SIZE);
	sVar[iNo++] = S1;
	;
	sprintf_s(S1, "%g", gED_SIZE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gFC_SIZE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gWP_SIZE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gBM_SIZE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gTXT_SIZE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDIM_SCALE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDIM_FILSZ);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDIM_OFFSZ);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gTXT_HEIGHT);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDIM_RADSZ);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDIM_CVORD);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%i", gDIM_PREC);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDIM_SIZE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%i", gCUR_RES);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDRILL_KS);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gRIGID_MULTIPLIER);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gVSTIFF_KS);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDEF_E);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDEF_V);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDEF_DEN);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDEF_COND);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gSTIFF_BDIA);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDEF_CTE);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDEF_THERM_LNK);
	sVar[iNo++] = S1;
	sprintf_s(S1, "%g", gDEF_SOL_TOL);
	sVar[iNo++] = S1;

	return (iNo);
}

void G_ObjectDUM::PutVarValues(PropTable* PT, int iNo, CString sVar[]) {
	int iC = 0;
	gBACKGRD_COL = atoi(sVar[iC++]);
	if ((gBACKGRD_COL < 0) || (gBACKGRD_COL > 166))
		gBACKGRD_COL = 0;
	gZOOM_SCL = atof(sVar[iC++]);
	gPT_SIZE = atof(sVar[iC++]);
	gND_SIZE = atof(sVar[iC++]);
	gLM_SIZE = atof(sVar[iC++]);
	gEL_SIZE = atof(sVar[iC++]);
	gED_SIZE = atof(sVar[iC++]);
	gFC_SIZE = atof(sVar[iC++]);
	gWP_SIZE = atof(sVar[iC++]);
	gBM_SIZE = atof(sVar[iC++]);
	gTXT_SIZE = atof(sVar[iC++]);
	gDIM_SCALE = atof(sVar[iC++]);
	gDIM_FILSZ = atof(sVar[iC++]);
	gDIM_OFFSZ = atof(sVar[iC++]);
	gTXT_HEIGHT = atof(sVar[iC++]);
	gDIM_RADSZ = atof(sVar[iC++]);
	gDIM_CVORD = atof(sVar[iC++]);
	gDIM_PREC = atoi(sVar[iC++]);
	gDIM_SIZE = atof(sVar[iC++]);
	gCUR_RES = atoi(sVar[iC++]);
	gDRILL_KS = atof(sVar[iC++]);
	gRIGID_MULTIPLIER = atof(sVar[iC++]);
	gVSTIFF_KS = atof(sVar[iC++]);
	gDEF_E = atof(sVar[iC++]);
	gDEF_V = atof(sVar[iC++]);
	gDEF_DEN = atof(sVar[iC++]);
	gDEF_COND = atof(sVar[iC++]);
	gSTIFF_BDIA = atof(sVar[iC++]);
	gDEF_CTE = atof(sVar[iC++]);
	gDEF_THERM_LNK = atof(sVar[iC++]);
	gDEF_SOL_TOL = atof(sVar[iC++]);
}

IDispatch* ME_Object::API_CreateNode2(DOUBLE x, DOUBLE y, DOUBLE z) {
	AFX_MANAGE_STATE(AfxGetAppModuleState());
	G_Object* pN = nullptr;
	C3dVector vPt;
	vPt.Set(x, y, z);

	pN = this->AddNode(vPt, iNodeLab, -1, -1, 50, -1, -1);
	this->iNodeLab++;
	if (pN != nullptr) // Ensure valid index and object
	{
		return pN->GetIDispatch(TRUE);
		;
	} else {
		outtext1("Error: API_CreateNode2 returning NULL");
		return nullptr;
	}
	// TODO: Add your dispatch handler code here

	return nullptr;
}
